
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model accounts
 * 
 */
export type accounts = $Result.DefaultSelection<Prisma.$accountsPayload>
/**
 * Model alliance_gradenames
 * 
 */
export type alliance_gradenames = $Result.DefaultSelection<Prisma.$alliance_gradenamesPayload>
/**
 * Model alliances
 * 
 */
export type alliances = $Result.DefaultSelection<Prisma.$alliancesPayload>
/**
 * Model auction_histories
 * 
 */
export type auction_histories = $Result.DefaultSelection<Prisma.$auction_historiesPayload>
/**
 * Model auction_items
 * 
 */
export type auction_items = $Result.DefaultSelection<Prisma.$auction_itemsPayload>
/**
 * Model avatardata
 * 
 */
export type avatardata = $Result.DefaultSelection<Prisma.$avatardataPayload>
/**
 * Model avatarlook
 * 
 */
export type avatarlook = $Result.DefaultSelection<Prisma.$avatarlookPayload>
/**
 * Model bbs_records
 * 
 */
export type bbs_records = $Result.DefaultSelection<Prisma.$bbs_recordsPayload>
/**
 * Model bbs_replies
 * 
 */
export type bbs_replies = $Result.DefaultSelection<Prisma.$bbs_repliesPayload>
/**
 * Model beautydata
 * 
 */
export type beautydata = $Result.DefaultSelection<Prisma.$beautydataPayload>
/**
 * Model bosslog
 * 
 */
export type bosslog = $Result.DefaultSelection<Prisma.$bosslogPayload>
/**
 * Model cashiteminfos
 * 
 */
export type cashiteminfos = $Result.DefaultSelection<Prisma.$cashiteminfosPayload>
/**
 * Model characterpotentials
 * 
 */
export type characterpotentials = $Result.DefaultSelection<Prisma.$characterpotentialsPayload>
/**
 * Model characters
 * 
 */
export type characters = $Result.DefaultSelection<Prisma.$charactersPayload>
/**
 * Model characterstats
 * 
 */
export type characterstats = $Result.DefaultSelection<Prisma.$characterstatsPayload>
/**
 * Model chosenskills
 * 
 */
export type chosenskills = $Result.DefaultSelection<Prisma.$chosenskillsPayload>
/**
 * Model cms_votes
 * 
 */
export type cms_votes = $Result.DefaultSelection<Prisma.$cms_votesPayload>
/**
 * Model cooldowns
 * 
 */
export type cooldowns = $Result.DefaultSelection<Prisma.$cooldownsPayload>
/**
 * Model cores
 * 
 */
export type cores = $Result.DefaultSelection<Prisma.$coresPayload>
/**
 * Model cs_categories
 * 
 */
export type cs_categories = $Result.DefaultSelection<Prisma.$cs_categoriesPayload>
/**
 * Model cs_items
 * 
 */
export type cs_items = $Result.DefaultSelection<Prisma.$cs_itemsPayload>
/**
 * Model damageskins
 * 
 */
export type damageskins = $Result.DefaultSelection<Prisma.$damageskinsPayload>
/**
 * Model employeetrunk
 * 
 */
export type employeetrunk = $Result.DefaultSelection<Prisma.$employeetrunkPayload>
/**
 * Model equips
 * 
 */
export type equips = $Result.DefaultSelection<Prisma.$equipsPayload>
/**
 * Model eventnametag
 * 
 */
export type eventnametag = $Result.DefaultSelection<Prisma.$eventnametagPayload>
/**
 * Model extendsp
 * 
 */
export type extendsp = $Result.DefaultSelection<Prisma.$extendspPayload>
/**
 * Model familiars
 * 
 */
export type familiars = $Result.DefaultSelection<Prisma.$familiarsPayload>
/**
 * Model friends
 * 
 */
export type friends = $Result.DefaultSelection<Prisma.$friendsPayload>
/**
 * Model funckeymap
 * 
 */
export type funckeymap = $Result.DefaultSelection<Prisma.$funckeymapPayload>
/**
 * Model gradenames
 * 
 */
export type gradenames = $Result.DefaultSelection<Prisma.$gradenamesPayload>
/**
 * Model guildmembers
 * 
 */
export type guildmembers = $Result.DefaultSelection<Prisma.$guildmembersPayload>
/**
 * Model guildrequestors
 * 
 */
export type guildrequestors = $Result.DefaultSelection<Prisma.$guildrequestorsPayload>
/**
 * Model guilds
 * 
 */
export type guilds = $Result.DefaultSelection<Prisma.$guildsPayload>
/**
 * Model guildskill
 * 
 */
export type guildskill = $Result.DefaultSelection<Prisma.$guildskillPayload>
/**
 * Model guildskills
 * 
 */
export type guildskills = $Result.DefaultSelection<Prisma.$guildskillsPayload>
/**
 * Model hairequips
 * 
 */
export type hairequips = $Result.DefaultSelection<Prisma.$hairequipsPayload>
/**
 * Model hyperrockfields
 * 
 */
export type hyperrockfields = $Result.DefaultSelection<Prisma.$hyperrockfieldsPayload>
/**
 * Model inventories
 * 
 */
export type inventories = $Result.DefaultSelection<Prisma.$inventoriesPayload>
/**
 * Model items
 * 
 */
export type items = $Result.DefaultSelection<Prisma.$itemsPayload>
/**
 * Model itemsbuylimit
 * 
 */
export type itemsbuylimit = $Result.DefaultSelection<Prisma.$itemsbuylimitPayload>
/**
 * Model keymaps
 * 
 */
export type keymaps = $Result.DefaultSelection<Prisma.$keymapsPayload>
/**
 * Model linkskills
 * 
 */
export type linkskills = $Result.DefaultSelection<Prisma.$linkskillsPayload>
/**
 * Model macros
 * 
 */
export type macros = $Result.DefaultSelection<Prisma.$macrosPayload>
/**
 * Model macroskills
 * 
 */
export type macroskills = $Result.DefaultSelection<Prisma.$macroskillsPayload>
/**
 * Model matrixskill
 * 
 */
export type matrixskill = $Result.DefaultSelection<Prisma.$matrixskillPayload>
/**
 * Model medals
 * 
 */
export type medals = $Result.DefaultSelection<Prisma.$medalsPayload>
/**
 * Model mob_drops
 * 
 */
export type mob_drops = $Result.DefaultSelection<Prisma.$mob_dropsPayload>
/**
 * Model monster_collection
 * 
 */
export type monster_collection = $Result.DefaultSelection<Prisma.$monster_collectionPayload>
/**
 * Model monster_collection_explorations
 * 
 */
export type monster_collection_explorations = $Result.DefaultSelection<Prisma.$monster_collection_explorationsPayload>
/**
 * Model monster_collection_group_rewards
 * 
 */
export type monster_collection_group_rewards = $Result.DefaultSelection<Prisma.$monster_collection_group_rewardsPayload>
/**
 * Model monster_collection_mobs
 * 
 */
export type monster_collection_mobs = $Result.DefaultSelection<Prisma.$monster_collection_mobsPayload>
/**
 * Model monster_collection_rewards
 * 
 */
export type monster_collection_rewards = $Result.DefaultSelection<Prisma.$monster_collection_rewardsPayload>
/**
 * Model monster_collection_session_rewards
 * 
 */
export type monster_collection_session_rewards = $Result.DefaultSelection<Prisma.$monster_collection_session_rewardsPayload>
/**
 * Model monster_collections
 * 
 */
export type monster_collections = $Result.DefaultSelection<Prisma.$monster_collectionsPayload>
/**
 * Model monsterbookcards
 * 
 */
export type monsterbookcards = $Result.DefaultSelection<Prisma.$monsterbookcardsPayload>
/**
 * Model monsterbookinfos
 * 
 */
export type monsterbookinfos = $Result.DefaultSelection<Prisma.$monsterbookinfosPayload>
/**
 * Model noncombatstatdaylimit
 * 
 */
export type noncombatstatdaylimit = $Result.DefaultSelection<Prisma.$noncombatstatdaylimitPayload>
/**
 * Model npc
 * 
 */
export type npc = $Result.DefaultSelection<Prisma.$npcPayload>
/**
 * Model offense_managers
 * 
 */
export type offense_managers = $Result.DefaultSelection<Prisma.$offense_managersPayload>
/**
 * Model offenses
 * 
 */
export type offenses = $Result.DefaultSelection<Prisma.$offensesPayload>
/**
 * Model party
 * 
 */
export type party = $Result.DefaultSelection<Prisma.$partyPayload>
/**
 * Model partyboss
 * 
 */
export type partyboss = $Result.DefaultSelection<Prisma.$partybossPayload>
/**
 * Model partymembers
 * 
 */
export type partymembers = $Result.DefaultSelection<Prisma.$partymembersPayload>
/**
 * Model petids
 * 
 */
export type petids = $Result.DefaultSelection<Prisma.$petidsPayload>
/**
 * Model petitems
 * 
 */
export type petitems = $Result.DefaultSelection<Prisma.$petitemsPayload>
/**
 * Model questlists
 * 
 */
export type questlists = $Result.DefaultSelection<Prisma.$questlistsPayload>
/**
 * Model questmanagers
 * 
 */
export type questmanagers = $Result.DefaultSelection<Prisma.$questmanagersPayload>
/**
 * Model questprogressrequirements
 * 
 */
export type questprogressrequirements = $Result.DefaultSelection<Prisma.$questprogressrequirementsPayload>
/**
 * Model quests
 * 
 */
export type quests = $Result.DefaultSelection<Prisma.$questsPayload>
/**
 * Model rewardinfo
 * 
 */
export type rewardinfo = $Result.DefaultSelection<Prisma.$rewardinfoPayload>
/**
 * Model shopitems
 * 
 */
export type shopitems = $Result.DefaultSelection<Prisma.$shopitemsPayload>
/**
 * Model skillcooltimes
 * 
 */
export type skillcooltimes = $Result.DefaultSelection<Prisma.$skillcooltimesPayload>
/**
 * Model skills
 * 
 */
export type skills = $Result.DefaultSelection<Prisma.$skillsPayload>
/**
 * Model spset
 * 
 */
export type spset = $Result.DefaultSelection<Prisma.$spsetPayload>
/**
 * Model stolenskills
 * 
 */
export type stolenskills = $Result.DefaultSelection<Prisma.$stolenskillsPayload>
/**
 * Model systemtimes
 * 
 */
export type systemtimes = $Result.DefaultSelection<Prisma.$systemtimesPayload>
/**
 * Model totems
 * 
 */
export type totems = $Result.DefaultSelection<Prisma.$totemsPayload>
/**
 * Model trunks
 * 
 */
export type trunks = $Result.DefaultSelection<Prisma.$trunksPayload>
/**
 * Model unseenequips
 * 
 */
export type unseenequips = $Result.DefaultSelection<Prisma.$unseenequipsPayload>
/**
 * Model users
 * 
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Accounts
 * const accounts = await prisma.accounts.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Accounts
   * const accounts = await prisma.accounts.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.accounts`: Exposes CRUD operations for the **accounts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.accounts.findMany()
    * ```
    */
  get accounts(): Prisma.accountsDelegate<ExtArgs>;

  /**
   * `prisma.alliance_gradenames`: Exposes CRUD operations for the **alliance_gradenames** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Alliance_gradenames
    * const alliance_gradenames = await prisma.alliance_gradenames.findMany()
    * ```
    */
  get alliance_gradenames(): Prisma.alliance_gradenamesDelegate<ExtArgs>;

  /**
   * `prisma.alliances`: Exposes CRUD operations for the **alliances** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Alliances
    * const alliances = await prisma.alliances.findMany()
    * ```
    */
  get alliances(): Prisma.alliancesDelegate<ExtArgs>;

  /**
   * `prisma.auction_histories`: Exposes CRUD operations for the **auction_histories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Auction_histories
    * const auction_histories = await prisma.auction_histories.findMany()
    * ```
    */
  get auction_histories(): Prisma.auction_historiesDelegate<ExtArgs>;

  /**
   * `prisma.auction_items`: Exposes CRUD operations for the **auction_items** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Auction_items
    * const auction_items = await prisma.auction_items.findMany()
    * ```
    */
  get auction_items(): Prisma.auction_itemsDelegate<ExtArgs>;

  /**
   * `prisma.avatardata`: Exposes CRUD operations for the **avatardata** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Avatardata
    * const avatardata = await prisma.avatardata.findMany()
    * ```
    */
  get avatardata(): Prisma.avatardataDelegate<ExtArgs>;

  /**
   * `prisma.avatarlook`: Exposes CRUD operations for the **avatarlook** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Avatarlooks
    * const avatarlooks = await prisma.avatarlook.findMany()
    * ```
    */
  get avatarlook(): Prisma.avatarlookDelegate<ExtArgs>;

  /**
   * `prisma.bbs_records`: Exposes CRUD operations for the **bbs_records** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bbs_records
    * const bbs_records = await prisma.bbs_records.findMany()
    * ```
    */
  get bbs_records(): Prisma.bbs_recordsDelegate<ExtArgs>;

  /**
   * `prisma.bbs_replies`: Exposes CRUD operations for the **bbs_replies** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bbs_replies
    * const bbs_replies = await prisma.bbs_replies.findMany()
    * ```
    */
  get bbs_replies(): Prisma.bbs_repliesDelegate<ExtArgs>;

  /**
   * `prisma.beautydata`: Exposes CRUD operations for the **beautydata** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Beautydata
    * const beautydata = await prisma.beautydata.findMany()
    * ```
    */
  get beautydata(): Prisma.beautydataDelegate<ExtArgs>;

  /**
   * `prisma.bosslog`: Exposes CRUD operations for the **bosslog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bosslogs
    * const bosslogs = await prisma.bosslog.findMany()
    * ```
    */
  get bosslog(): Prisma.bosslogDelegate<ExtArgs>;

  /**
   * `prisma.cashiteminfos`: Exposes CRUD operations for the **cashiteminfos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cashiteminfos
    * const cashiteminfos = await prisma.cashiteminfos.findMany()
    * ```
    */
  get cashiteminfos(): Prisma.cashiteminfosDelegate<ExtArgs>;

  /**
   * `prisma.characterpotentials`: Exposes CRUD operations for the **characterpotentials** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Characterpotentials
    * const characterpotentials = await prisma.characterpotentials.findMany()
    * ```
    */
  get characterpotentials(): Prisma.characterpotentialsDelegate<ExtArgs>;

  /**
   * `prisma.characters`: Exposes CRUD operations for the **characters** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Characters
    * const characters = await prisma.characters.findMany()
    * ```
    */
  get characters(): Prisma.charactersDelegate<ExtArgs>;

  /**
   * `prisma.characterstats`: Exposes CRUD operations for the **characterstats** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Characterstats
    * const characterstats = await prisma.characterstats.findMany()
    * ```
    */
  get characterstats(): Prisma.characterstatsDelegate<ExtArgs>;

  /**
   * `prisma.chosenskills`: Exposes CRUD operations for the **chosenskills** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chosenskills
    * const chosenskills = await prisma.chosenskills.findMany()
    * ```
    */
  get chosenskills(): Prisma.chosenskillsDelegate<ExtArgs>;

  /**
   * `prisma.cms_votes`: Exposes CRUD operations for the **cms_votes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cms_votes
    * const cms_votes = await prisma.cms_votes.findMany()
    * ```
    */
  get cms_votes(): Prisma.cms_votesDelegate<ExtArgs>;

  /**
   * `prisma.cooldowns`: Exposes CRUD operations for the **cooldowns** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cooldowns
    * const cooldowns = await prisma.cooldowns.findMany()
    * ```
    */
  get cooldowns(): Prisma.cooldownsDelegate<ExtArgs>;

  /**
   * `prisma.cores`: Exposes CRUD operations for the **cores** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cores
    * const cores = await prisma.cores.findMany()
    * ```
    */
  get cores(): Prisma.coresDelegate<ExtArgs>;

  /**
   * `prisma.cs_categories`: Exposes CRUD operations for the **cs_categories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cs_categories
    * const cs_categories = await prisma.cs_categories.findMany()
    * ```
    */
  get cs_categories(): Prisma.cs_categoriesDelegate<ExtArgs>;

  /**
   * `prisma.cs_items`: Exposes CRUD operations for the **cs_items** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cs_items
    * const cs_items = await prisma.cs_items.findMany()
    * ```
    */
  get cs_items(): Prisma.cs_itemsDelegate<ExtArgs>;

  /**
   * `prisma.damageskins`: Exposes CRUD operations for the **damageskins** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Damageskins
    * const damageskins = await prisma.damageskins.findMany()
    * ```
    */
  get damageskins(): Prisma.damageskinsDelegate<ExtArgs>;

  /**
   * `prisma.employeetrunk`: Exposes CRUD operations for the **employeetrunk** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employeetrunks
    * const employeetrunks = await prisma.employeetrunk.findMany()
    * ```
    */
  get employeetrunk(): Prisma.employeetrunkDelegate<ExtArgs>;

  /**
   * `prisma.equips`: Exposes CRUD operations for the **equips** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Equips
    * const equips = await prisma.equips.findMany()
    * ```
    */
  get equips(): Prisma.equipsDelegate<ExtArgs>;

  /**
   * `prisma.eventnametag`: Exposes CRUD operations for the **eventnametag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Eventnametags
    * const eventnametags = await prisma.eventnametag.findMany()
    * ```
    */
  get eventnametag(): Prisma.eventnametagDelegate<ExtArgs>;

  /**
   * `prisma.extendsp`: Exposes CRUD operations for the **extendsp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Extendsps
    * const extendsps = await prisma.extendsp.findMany()
    * ```
    */
  get extendsp(): Prisma.extendspDelegate<ExtArgs>;

  /**
   * `prisma.familiars`: Exposes CRUD operations for the **familiars** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Familiars
    * const familiars = await prisma.familiars.findMany()
    * ```
    */
  get familiars(): Prisma.familiarsDelegate<ExtArgs>;

  /**
   * `prisma.friends`: Exposes CRUD operations for the **friends** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Friends
    * const friends = await prisma.friends.findMany()
    * ```
    */
  get friends(): Prisma.friendsDelegate<ExtArgs>;

  /**
   * `prisma.funckeymap`: Exposes CRUD operations for the **funckeymap** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Funckeymaps
    * const funckeymaps = await prisma.funckeymap.findMany()
    * ```
    */
  get funckeymap(): Prisma.funckeymapDelegate<ExtArgs>;

  /**
   * `prisma.gradenames`: Exposes CRUD operations for the **gradenames** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Gradenames
    * const gradenames = await prisma.gradenames.findMany()
    * ```
    */
  get gradenames(): Prisma.gradenamesDelegate<ExtArgs>;

  /**
   * `prisma.guildmembers`: Exposes CRUD operations for the **guildmembers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Guildmembers
    * const guildmembers = await prisma.guildmembers.findMany()
    * ```
    */
  get guildmembers(): Prisma.guildmembersDelegate<ExtArgs>;

  /**
   * `prisma.guildrequestors`: Exposes CRUD operations for the **guildrequestors** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Guildrequestors
    * const guildrequestors = await prisma.guildrequestors.findMany()
    * ```
    */
  get guildrequestors(): Prisma.guildrequestorsDelegate<ExtArgs>;

  /**
   * `prisma.guilds`: Exposes CRUD operations for the **guilds** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Guilds
    * const guilds = await prisma.guilds.findMany()
    * ```
    */
  get guilds(): Prisma.guildsDelegate<ExtArgs>;

  /**
   * `prisma.guildskill`: Exposes CRUD operations for the **guildskill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Guildskills
    * const guildskills = await prisma.guildskill.findMany()
    * ```
    */
  get guildskill(): Prisma.guildskillDelegate<ExtArgs>;

  /**
   * `prisma.guildskills`: Exposes CRUD operations for the **guildskills** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Guildskills
    * const guildskills = await prisma.guildskills.findMany()
    * ```
    */
  get guildskills(): Prisma.guildskillsDelegate<ExtArgs>;

  /**
   * `prisma.hairequips`: Exposes CRUD operations for the **hairequips** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Hairequips
    * const hairequips = await prisma.hairequips.findMany()
    * ```
    */
  get hairequips(): Prisma.hairequipsDelegate<ExtArgs>;

  /**
   * `prisma.hyperrockfields`: Exposes CRUD operations for the **hyperrockfields** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Hyperrockfields
    * const hyperrockfields = await prisma.hyperrockfields.findMany()
    * ```
    */
  get hyperrockfields(): Prisma.hyperrockfieldsDelegate<ExtArgs>;

  /**
   * `prisma.inventories`: Exposes CRUD operations for the **inventories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inventories
    * const inventories = await prisma.inventories.findMany()
    * ```
    */
  get inventories(): Prisma.inventoriesDelegate<ExtArgs>;

  /**
   * `prisma.items`: Exposes CRUD operations for the **items** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Items
    * const items = await prisma.items.findMany()
    * ```
    */
  get items(): Prisma.itemsDelegate<ExtArgs>;

  /**
   * `prisma.itemsbuylimit`: Exposes CRUD operations for the **itemsbuylimit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Itemsbuylimits
    * const itemsbuylimits = await prisma.itemsbuylimit.findMany()
    * ```
    */
  get itemsbuylimit(): Prisma.itemsbuylimitDelegate<ExtArgs>;

  /**
   * `prisma.keymaps`: Exposes CRUD operations for the **keymaps** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Keymaps
    * const keymaps = await prisma.keymaps.findMany()
    * ```
    */
  get keymaps(): Prisma.keymapsDelegate<ExtArgs>;

  /**
   * `prisma.linkskills`: Exposes CRUD operations for the **linkskills** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Linkskills
    * const linkskills = await prisma.linkskills.findMany()
    * ```
    */
  get linkskills(): Prisma.linkskillsDelegate<ExtArgs>;

  /**
   * `prisma.macros`: Exposes CRUD operations for the **macros** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Macros
    * const macros = await prisma.macros.findMany()
    * ```
    */
  get macros(): Prisma.macrosDelegate<ExtArgs>;

  /**
   * `prisma.macroskills`: Exposes CRUD operations for the **macroskills** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Macroskills
    * const macroskills = await prisma.macroskills.findMany()
    * ```
    */
  get macroskills(): Prisma.macroskillsDelegate<ExtArgs>;

  /**
   * `prisma.matrixskill`: Exposes CRUD operations for the **matrixskill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Matrixskills
    * const matrixskills = await prisma.matrixskill.findMany()
    * ```
    */
  get matrixskill(): Prisma.matrixskillDelegate<ExtArgs>;

  /**
   * `prisma.medals`: Exposes CRUD operations for the **medals** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Medals
    * const medals = await prisma.medals.findMany()
    * ```
    */
  get medals(): Prisma.medalsDelegate<ExtArgs>;

  /**
   * `prisma.mob_drops`: Exposes CRUD operations for the **mob_drops** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mob_drops
    * const mob_drops = await prisma.mob_drops.findMany()
    * ```
    */
  get mob_drops(): Prisma.mob_dropsDelegate<ExtArgs>;

  /**
   * `prisma.monster_collection`: Exposes CRUD operations for the **monster_collection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Monster_collections
    * const monster_collections = await prisma.monster_collection.findMany()
    * ```
    */
  get monster_collection(): Prisma.monster_collectionDelegate<ExtArgs>;

  /**
   * `prisma.monster_collection_explorations`: Exposes CRUD operations for the **monster_collection_explorations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Monster_collection_explorations
    * const monster_collection_explorations = await prisma.monster_collection_explorations.findMany()
    * ```
    */
  get monster_collection_explorations(): Prisma.monster_collection_explorationsDelegate<ExtArgs>;

  /**
   * `prisma.monster_collection_group_rewards`: Exposes CRUD operations for the **monster_collection_group_rewards** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Monster_collection_group_rewards
    * const monster_collection_group_rewards = await prisma.monster_collection_group_rewards.findMany()
    * ```
    */
  get monster_collection_group_rewards(): Prisma.monster_collection_group_rewardsDelegate<ExtArgs>;

  /**
   * `prisma.monster_collection_mobs`: Exposes CRUD operations for the **monster_collection_mobs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Monster_collection_mobs
    * const monster_collection_mobs = await prisma.monster_collection_mobs.findMany()
    * ```
    */
  get monster_collection_mobs(): Prisma.monster_collection_mobsDelegate<ExtArgs>;

  /**
   * `prisma.monster_collection_rewards`: Exposes CRUD operations for the **monster_collection_rewards** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Monster_collection_rewards
    * const monster_collection_rewards = await prisma.monster_collection_rewards.findMany()
    * ```
    */
  get monster_collection_rewards(): Prisma.monster_collection_rewardsDelegate<ExtArgs>;

  /**
   * `prisma.monster_collection_session_rewards`: Exposes CRUD operations for the **monster_collection_session_rewards** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Monster_collection_session_rewards
    * const monster_collection_session_rewards = await prisma.monster_collection_session_rewards.findMany()
    * ```
    */
  get monster_collection_session_rewards(): Prisma.monster_collection_session_rewardsDelegate<ExtArgs>;

  /**
   * `prisma.monster_collections`: Exposes CRUD operations for the **monster_collections** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Monster_collections
    * const monster_collections = await prisma.monster_collections.findMany()
    * ```
    */
  get monster_collections(): Prisma.monster_collectionsDelegate<ExtArgs>;

  /**
   * `prisma.monsterbookcards`: Exposes CRUD operations for the **monsterbookcards** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Monsterbookcards
    * const monsterbookcards = await prisma.monsterbookcards.findMany()
    * ```
    */
  get monsterbookcards(): Prisma.monsterbookcardsDelegate<ExtArgs>;

  /**
   * `prisma.monsterbookinfos`: Exposes CRUD operations for the **monsterbookinfos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Monsterbookinfos
    * const monsterbookinfos = await prisma.monsterbookinfos.findMany()
    * ```
    */
  get monsterbookinfos(): Prisma.monsterbookinfosDelegate<ExtArgs>;

  /**
   * `prisma.noncombatstatdaylimit`: Exposes CRUD operations for the **noncombatstatdaylimit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Noncombatstatdaylimits
    * const noncombatstatdaylimits = await prisma.noncombatstatdaylimit.findMany()
    * ```
    */
  get noncombatstatdaylimit(): Prisma.noncombatstatdaylimitDelegate<ExtArgs>;

  /**
   * `prisma.npc`: Exposes CRUD operations for the **npc** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Npcs
    * const npcs = await prisma.npc.findMany()
    * ```
    */
  get npc(): Prisma.npcDelegate<ExtArgs>;

  /**
   * `prisma.offense_managers`: Exposes CRUD operations for the **offense_managers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Offense_managers
    * const offense_managers = await prisma.offense_managers.findMany()
    * ```
    */
  get offense_managers(): Prisma.offense_managersDelegate<ExtArgs>;

  /**
   * `prisma.offenses`: Exposes CRUD operations for the **offenses** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Offenses
    * const offenses = await prisma.offenses.findMany()
    * ```
    */
  get offenses(): Prisma.offensesDelegate<ExtArgs>;

  /**
   * `prisma.party`: Exposes CRUD operations for the **party** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Parties
    * const parties = await prisma.party.findMany()
    * ```
    */
  get party(): Prisma.partyDelegate<ExtArgs>;

  /**
   * `prisma.partyboss`: Exposes CRUD operations for the **partyboss** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Partybosses
    * const partybosses = await prisma.partyboss.findMany()
    * ```
    */
  get partyboss(): Prisma.partybossDelegate<ExtArgs>;

  /**
   * `prisma.partymembers`: Exposes CRUD operations for the **partymembers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Partymembers
    * const partymembers = await prisma.partymembers.findMany()
    * ```
    */
  get partymembers(): Prisma.partymembersDelegate<ExtArgs>;

  /**
   * `prisma.petids`: Exposes CRUD operations for the **petids** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Petids
    * const petids = await prisma.petids.findMany()
    * ```
    */
  get petids(): Prisma.petidsDelegate<ExtArgs>;

  /**
   * `prisma.petitems`: Exposes CRUD operations for the **petitems** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Petitems
    * const petitems = await prisma.petitems.findMany()
    * ```
    */
  get petitems(): Prisma.petitemsDelegate<ExtArgs>;

  /**
   * `prisma.questlists`: Exposes CRUD operations for the **questlists** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Questlists
    * const questlists = await prisma.questlists.findMany()
    * ```
    */
  get questlists(): Prisma.questlistsDelegate<ExtArgs>;

  /**
   * `prisma.questmanagers`: Exposes CRUD operations for the **questmanagers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Questmanagers
    * const questmanagers = await prisma.questmanagers.findMany()
    * ```
    */
  get questmanagers(): Prisma.questmanagersDelegate<ExtArgs>;

  /**
   * `prisma.questprogressrequirements`: Exposes CRUD operations for the **questprogressrequirements** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Questprogressrequirements
    * const questprogressrequirements = await prisma.questprogressrequirements.findMany()
    * ```
    */
  get questprogressrequirements(): Prisma.questprogressrequirementsDelegate<ExtArgs>;

  /**
   * `prisma.quests`: Exposes CRUD operations for the **quests** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Quests
    * const quests = await prisma.quests.findMany()
    * ```
    */
  get quests(): Prisma.questsDelegate<ExtArgs>;

  /**
   * `prisma.rewardinfo`: Exposes CRUD operations for the **rewardinfo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rewardinfos
    * const rewardinfos = await prisma.rewardinfo.findMany()
    * ```
    */
  get rewardinfo(): Prisma.rewardinfoDelegate<ExtArgs>;

  /**
   * `prisma.shopitems`: Exposes CRUD operations for the **shopitems** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Shopitems
    * const shopitems = await prisma.shopitems.findMany()
    * ```
    */
  get shopitems(): Prisma.shopitemsDelegate<ExtArgs>;

  /**
   * `prisma.skillcooltimes`: Exposes CRUD operations for the **skillcooltimes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Skillcooltimes
    * const skillcooltimes = await prisma.skillcooltimes.findMany()
    * ```
    */
  get skillcooltimes(): Prisma.skillcooltimesDelegate<ExtArgs>;

  /**
   * `prisma.skills`: Exposes CRUD operations for the **skills** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Skills
    * const skills = await prisma.skills.findMany()
    * ```
    */
  get skills(): Prisma.skillsDelegate<ExtArgs>;

  /**
   * `prisma.spset`: Exposes CRUD operations for the **spset** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Spsets
    * const spsets = await prisma.spset.findMany()
    * ```
    */
  get spset(): Prisma.spsetDelegate<ExtArgs>;

  /**
   * `prisma.stolenskills`: Exposes CRUD operations for the **stolenskills** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stolenskills
    * const stolenskills = await prisma.stolenskills.findMany()
    * ```
    */
  get stolenskills(): Prisma.stolenskillsDelegate<ExtArgs>;

  /**
   * `prisma.systemtimes`: Exposes CRUD operations for the **systemtimes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Systemtimes
    * const systemtimes = await prisma.systemtimes.findMany()
    * ```
    */
  get systemtimes(): Prisma.systemtimesDelegate<ExtArgs>;

  /**
   * `prisma.totems`: Exposes CRUD operations for the **totems** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Totems
    * const totems = await prisma.totems.findMany()
    * ```
    */
  get totems(): Prisma.totemsDelegate<ExtArgs>;

  /**
   * `prisma.trunks`: Exposes CRUD operations for the **trunks** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Trunks
    * const trunks = await prisma.trunks.findMany()
    * ```
    */
  get trunks(): Prisma.trunksDelegate<ExtArgs>;

  /**
   * `prisma.unseenequips`: Exposes CRUD operations for the **unseenequips** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Unseenequips
    * const unseenequips = await prisma.unseenequips.findMany()
    * ```
    */
  get unseenequips(): Prisma.unseenequipsDelegate<ExtArgs>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.18.0
   * Query Engine version: 4c784e32044a8a016d99474bd02a3b6123742169
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    accounts: 'accounts',
    alliance_gradenames: 'alliance_gradenames',
    alliances: 'alliances',
    auction_histories: 'auction_histories',
    auction_items: 'auction_items',
    avatardata: 'avatardata',
    avatarlook: 'avatarlook',
    bbs_records: 'bbs_records',
    bbs_replies: 'bbs_replies',
    beautydata: 'beautydata',
    bosslog: 'bosslog',
    cashiteminfos: 'cashiteminfos',
    characterpotentials: 'characterpotentials',
    characters: 'characters',
    characterstats: 'characterstats',
    chosenskills: 'chosenskills',
    cms_votes: 'cms_votes',
    cooldowns: 'cooldowns',
    cores: 'cores',
    cs_categories: 'cs_categories',
    cs_items: 'cs_items',
    damageskins: 'damageskins',
    employeetrunk: 'employeetrunk',
    equips: 'equips',
    eventnametag: 'eventnametag',
    extendsp: 'extendsp',
    familiars: 'familiars',
    friends: 'friends',
    funckeymap: 'funckeymap',
    gradenames: 'gradenames',
    guildmembers: 'guildmembers',
    guildrequestors: 'guildrequestors',
    guilds: 'guilds',
    guildskill: 'guildskill',
    guildskills: 'guildskills',
    hairequips: 'hairequips',
    hyperrockfields: 'hyperrockfields',
    inventories: 'inventories',
    items: 'items',
    itemsbuylimit: 'itemsbuylimit',
    keymaps: 'keymaps',
    linkskills: 'linkskills',
    macros: 'macros',
    macroskills: 'macroskills',
    matrixskill: 'matrixskill',
    medals: 'medals',
    mob_drops: 'mob_drops',
    monster_collection: 'monster_collection',
    monster_collection_explorations: 'monster_collection_explorations',
    monster_collection_group_rewards: 'monster_collection_group_rewards',
    monster_collection_mobs: 'monster_collection_mobs',
    monster_collection_rewards: 'monster_collection_rewards',
    monster_collection_session_rewards: 'monster_collection_session_rewards',
    monster_collections: 'monster_collections',
    monsterbookcards: 'monsterbookcards',
    monsterbookinfos: 'monsterbookinfos',
    noncombatstatdaylimit: 'noncombatstatdaylimit',
    npc: 'npc',
    offense_managers: 'offense_managers',
    offenses: 'offenses',
    party: 'party',
    partyboss: 'partyboss',
    partymembers: 'partymembers',
    petids: 'petids',
    petitems: 'petitems',
    questlists: 'questlists',
    questmanagers: 'questmanagers',
    questprogressrequirements: 'questprogressrequirements',
    quests: 'quests',
    rewardinfo: 'rewardinfo',
    shopitems: 'shopitems',
    skillcooltimes: 'skillcooltimes',
    skills: 'skills',
    spset: 'spset',
    stolenskills: 'stolenskills',
    systemtimes: 'systemtimes',
    totems: 'totems',
    trunks: 'trunks',
    unseenequips: 'unseenequips',
    users: 'users'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "accounts" | "alliance_gradenames" | "alliances" | "auction_histories" | "auction_items" | "avatardata" | "avatarlook" | "bbs_records" | "bbs_replies" | "beautydata" | "bosslog" | "cashiteminfos" | "characterpotentials" | "characters" | "characterstats" | "chosenskills" | "cms_votes" | "cooldowns" | "cores" | "cs_categories" | "cs_items" | "damageskins" | "employeetrunk" | "equips" | "eventnametag" | "extendsp" | "familiars" | "friends" | "funckeymap" | "gradenames" | "guildmembers" | "guildrequestors" | "guilds" | "guildskill" | "guildskills" | "hairequips" | "hyperrockfields" | "inventories" | "items" | "itemsbuylimit" | "keymaps" | "linkskills" | "macros" | "macroskills" | "matrixskill" | "medals" | "mob_drops" | "monster_collection" | "monster_collection_explorations" | "monster_collection_group_rewards" | "monster_collection_mobs" | "monster_collection_rewards" | "monster_collection_session_rewards" | "monster_collections" | "monsterbookcards" | "monsterbookinfos" | "noncombatstatdaylimit" | "npc" | "offense_managers" | "offenses" | "party" | "partyboss" | "partymembers" | "petids" | "petitems" | "questlists" | "questmanagers" | "questprogressrequirements" | "quests" | "rewardinfo" | "shopitems" | "skillcooltimes" | "skills" | "spset" | "stolenskills" | "systemtimes" | "totems" | "trunks" | "unseenequips" | "users"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      accounts: {
        payload: Prisma.$accountsPayload<ExtArgs>
        fields: Prisma.accountsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.accountsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.accountsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountsPayload>
          }
          findFirst: {
            args: Prisma.accountsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.accountsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountsPayload>
          }
          findMany: {
            args: Prisma.accountsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountsPayload>[]
          }
          create: {
            args: Prisma.accountsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountsPayload>
          }
          createMany: {
            args: Prisma.accountsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.accountsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountsPayload>
          }
          update: {
            args: Prisma.accountsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountsPayload>
          }
          deleteMany: {
            args: Prisma.accountsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.accountsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.accountsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountsPayload>
          }
          aggregate: {
            args: Prisma.AccountsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccounts>
          }
          groupBy: {
            args: Prisma.accountsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountsGroupByOutputType>[]
          }
          count: {
            args: Prisma.accountsCountArgs<ExtArgs>
            result: $Utils.Optional<AccountsCountAggregateOutputType> | number
          }
        }
      }
      alliance_gradenames: {
        payload: Prisma.$alliance_gradenamesPayload<ExtArgs>
        fields: Prisma.alliance_gradenamesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.alliance_gradenamesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alliance_gradenamesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.alliance_gradenamesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alliance_gradenamesPayload>
          }
          findFirst: {
            args: Prisma.alliance_gradenamesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alliance_gradenamesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.alliance_gradenamesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alliance_gradenamesPayload>
          }
          findMany: {
            args: Prisma.alliance_gradenamesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alliance_gradenamesPayload>[]
          }
          create: {
            args: Prisma.alliance_gradenamesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alliance_gradenamesPayload>
          }
          createMany: {
            args: Prisma.alliance_gradenamesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.alliance_gradenamesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alliance_gradenamesPayload>
          }
          update: {
            args: Prisma.alliance_gradenamesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alliance_gradenamesPayload>
          }
          deleteMany: {
            args: Prisma.alliance_gradenamesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.alliance_gradenamesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.alliance_gradenamesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alliance_gradenamesPayload>
          }
          aggregate: {
            args: Prisma.Alliance_gradenamesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAlliance_gradenames>
          }
          groupBy: {
            args: Prisma.alliance_gradenamesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Alliance_gradenamesGroupByOutputType>[]
          }
          count: {
            args: Prisma.alliance_gradenamesCountArgs<ExtArgs>
            result: $Utils.Optional<Alliance_gradenamesCountAggregateOutputType> | number
          }
        }
      }
      alliances: {
        payload: Prisma.$alliancesPayload<ExtArgs>
        fields: Prisma.alliancesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.alliancesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alliancesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.alliancesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alliancesPayload>
          }
          findFirst: {
            args: Prisma.alliancesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alliancesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.alliancesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alliancesPayload>
          }
          findMany: {
            args: Prisma.alliancesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alliancesPayload>[]
          }
          create: {
            args: Prisma.alliancesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alliancesPayload>
          }
          createMany: {
            args: Prisma.alliancesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.alliancesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alliancesPayload>
          }
          update: {
            args: Prisma.alliancesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alliancesPayload>
          }
          deleteMany: {
            args: Prisma.alliancesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.alliancesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.alliancesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alliancesPayload>
          }
          aggregate: {
            args: Prisma.AlliancesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAlliances>
          }
          groupBy: {
            args: Prisma.alliancesGroupByArgs<ExtArgs>
            result: $Utils.Optional<AlliancesGroupByOutputType>[]
          }
          count: {
            args: Prisma.alliancesCountArgs<ExtArgs>
            result: $Utils.Optional<AlliancesCountAggregateOutputType> | number
          }
        }
      }
      auction_histories: {
        payload: Prisma.$auction_historiesPayload<ExtArgs>
        fields: Prisma.auction_historiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.auction_historiesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auction_historiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.auction_historiesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auction_historiesPayload>
          }
          findFirst: {
            args: Prisma.auction_historiesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auction_historiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.auction_historiesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auction_historiesPayload>
          }
          findMany: {
            args: Prisma.auction_historiesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auction_historiesPayload>[]
          }
          create: {
            args: Prisma.auction_historiesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auction_historiesPayload>
          }
          createMany: {
            args: Prisma.auction_historiesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.auction_historiesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auction_historiesPayload>
          }
          update: {
            args: Prisma.auction_historiesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auction_historiesPayload>
          }
          deleteMany: {
            args: Prisma.auction_historiesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.auction_historiesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.auction_historiesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auction_historiesPayload>
          }
          aggregate: {
            args: Prisma.Auction_historiesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuction_histories>
          }
          groupBy: {
            args: Prisma.auction_historiesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Auction_historiesGroupByOutputType>[]
          }
          count: {
            args: Prisma.auction_historiesCountArgs<ExtArgs>
            result: $Utils.Optional<Auction_historiesCountAggregateOutputType> | number
          }
        }
      }
      auction_items: {
        payload: Prisma.$auction_itemsPayload<ExtArgs>
        fields: Prisma.auction_itemsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.auction_itemsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auction_itemsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.auction_itemsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auction_itemsPayload>
          }
          findFirst: {
            args: Prisma.auction_itemsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auction_itemsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.auction_itemsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auction_itemsPayload>
          }
          findMany: {
            args: Prisma.auction_itemsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auction_itemsPayload>[]
          }
          create: {
            args: Prisma.auction_itemsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auction_itemsPayload>
          }
          createMany: {
            args: Prisma.auction_itemsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.auction_itemsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auction_itemsPayload>
          }
          update: {
            args: Prisma.auction_itemsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auction_itemsPayload>
          }
          deleteMany: {
            args: Prisma.auction_itemsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.auction_itemsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.auction_itemsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auction_itemsPayload>
          }
          aggregate: {
            args: Prisma.Auction_itemsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuction_items>
          }
          groupBy: {
            args: Prisma.auction_itemsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Auction_itemsGroupByOutputType>[]
          }
          count: {
            args: Prisma.auction_itemsCountArgs<ExtArgs>
            result: $Utils.Optional<Auction_itemsCountAggregateOutputType> | number
          }
        }
      }
      avatardata: {
        payload: Prisma.$avatardataPayload<ExtArgs>
        fields: Prisma.avatardataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.avatardataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$avatardataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.avatardataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$avatardataPayload>
          }
          findFirst: {
            args: Prisma.avatardataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$avatardataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.avatardataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$avatardataPayload>
          }
          findMany: {
            args: Prisma.avatardataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$avatardataPayload>[]
          }
          create: {
            args: Prisma.avatardataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$avatardataPayload>
          }
          createMany: {
            args: Prisma.avatardataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.avatardataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$avatardataPayload>
          }
          update: {
            args: Prisma.avatardataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$avatardataPayload>
          }
          deleteMany: {
            args: Prisma.avatardataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.avatardataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.avatardataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$avatardataPayload>
          }
          aggregate: {
            args: Prisma.AvatardataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAvatardata>
          }
          groupBy: {
            args: Prisma.avatardataGroupByArgs<ExtArgs>
            result: $Utils.Optional<AvatardataGroupByOutputType>[]
          }
          count: {
            args: Prisma.avatardataCountArgs<ExtArgs>
            result: $Utils.Optional<AvatardataCountAggregateOutputType> | number
          }
        }
      }
      avatarlook: {
        payload: Prisma.$avatarlookPayload<ExtArgs>
        fields: Prisma.avatarlookFieldRefs
        operations: {
          findUnique: {
            args: Prisma.avatarlookFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$avatarlookPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.avatarlookFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$avatarlookPayload>
          }
          findFirst: {
            args: Prisma.avatarlookFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$avatarlookPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.avatarlookFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$avatarlookPayload>
          }
          findMany: {
            args: Prisma.avatarlookFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$avatarlookPayload>[]
          }
          create: {
            args: Prisma.avatarlookCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$avatarlookPayload>
          }
          createMany: {
            args: Prisma.avatarlookCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.avatarlookDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$avatarlookPayload>
          }
          update: {
            args: Prisma.avatarlookUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$avatarlookPayload>
          }
          deleteMany: {
            args: Prisma.avatarlookDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.avatarlookUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.avatarlookUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$avatarlookPayload>
          }
          aggregate: {
            args: Prisma.AvatarlookAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAvatarlook>
          }
          groupBy: {
            args: Prisma.avatarlookGroupByArgs<ExtArgs>
            result: $Utils.Optional<AvatarlookGroupByOutputType>[]
          }
          count: {
            args: Prisma.avatarlookCountArgs<ExtArgs>
            result: $Utils.Optional<AvatarlookCountAggregateOutputType> | number
          }
        }
      }
      bbs_records: {
        payload: Prisma.$bbs_recordsPayload<ExtArgs>
        fields: Prisma.bbs_recordsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.bbs_recordsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bbs_recordsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.bbs_recordsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bbs_recordsPayload>
          }
          findFirst: {
            args: Prisma.bbs_recordsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bbs_recordsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.bbs_recordsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bbs_recordsPayload>
          }
          findMany: {
            args: Prisma.bbs_recordsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bbs_recordsPayload>[]
          }
          create: {
            args: Prisma.bbs_recordsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bbs_recordsPayload>
          }
          createMany: {
            args: Prisma.bbs_recordsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.bbs_recordsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bbs_recordsPayload>
          }
          update: {
            args: Prisma.bbs_recordsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bbs_recordsPayload>
          }
          deleteMany: {
            args: Prisma.bbs_recordsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.bbs_recordsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.bbs_recordsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bbs_recordsPayload>
          }
          aggregate: {
            args: Prisma.Bbs_recordsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBbs_records>
          }
          groupBy: {
            args: Prisma.bbs_recordsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Bbs_recordsGroupByOutputType>[]
          }
          count: {
            args: Prisma.bbs_recordsCountArgs<ExtArgs>
            result: $Utils.Optional<Bbs_recordsCountAggregateOutputType> | number
          }
        }
      }
      bbs_replies: {
        payload: Prisma.$bbs_repliesPayload<ExtArgs>
        fields: Prisma.bbs_repliesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.bbs_repliesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bbs_repliesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.bbs_repliesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bbs_repliesPayload>
          }
          findFirst: {
            args: Prisma.bbs_repliesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bbs_repliesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.bbs_repliesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bbs_repliesPayload>
          }
          findMany: {
            args: Prisma.bbs_repliesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bbs_repliesPayload>[]
          }
          create: {
            args: Prisma.bbs_repliesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bbs_repliesPayload>
          }
          createMany: {
            args: Prisma.bbs_repliesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.bbs_repliesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bbs_repliesPayload>
          }
          update: {
            args: Prisma.bbs_repliesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bbs_repliesPayload>
          }
          deleteMany: {
            args: Prisma.bbs_repliesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.bbs_repliesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.bbs_repliesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bbs_repliesPayload>
          }
          aggregate: {
            args: Prisma.Bbs_repliesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBbs_replies>
          }
          groupBy: {
            args: Prisma.bbs_repliesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Bbs_repliesGroupByOutputType>[]
          }
          count: {
            args: Prisma.bbs_repliesCountArgs<ExtArgs>
            result: $Utils.Optional<Bbs_repliesCountAggregateOutputType> | number
          }
        }
      }
      beautydata: {
        payload: Prisma.$beautydataPayload<ExtArgs>
        fields: Prisma.beautydataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.beautydataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$beautydataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.beautydataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$beautydataPayload>
          }
          findFirst: {
            args: Prisma.beautydataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$beautydataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.beautydataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$beautydataPayload>
          }
          findMany: {
            args: Prisma.beautydataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$beautydataPayload>[]
          }
          create: {
            args: Prisma.beautydataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$beautydataPayload>
          }
          createMany: {
            args: Prisma.beautydataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.beautydataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$beautydataPayload>
          }
          update: {
            args: Prisma.beautydataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$beautydataPayload>
          }
          deleteMany: {
            args: Prisma.beautydataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.beautydataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.beautydataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$beautydataPayload>
          }
          aggregate: {
            args: Prisma.BeautydataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBeautydata>
          }
          groupBy: {
            args: Prisma.beautydataGroupByArgs<ExtArgs>
            result: $Utils.Optional<BeautydataGroupByOutputType>[]
          }
          count: {
            args: Prisma.beautydataCountArgs<ExtArgs>
            result: $Utils.Optional<BeautydataCountAggregateOutputType> | number
          }
        }
      }
      bosslog: {
        payload: Prisma.$bosslogPayload<ExtArgs>
        fields: Prisma.bosslogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.bosslogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bosslogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.bosslogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bosslogPayload>
          }
          findFirst: {
            args: Prisma.bosslogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bosslogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.bosslogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bosslogPayload>
          }
          findMany: {
            args: Prisma.bosslogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bosslogPayload>[]
          }
          create: {
            args: Prisma.bosslogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bosslogPayload>
          }
          createMany: {
            args: Prisma.bosslogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.bosslogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bosslogPayload>
          }
          update: {
            args: Prisma.bosslogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bosslogPayload>
          }
          deleteMany: {
            args: Prisma.bosslogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.bosslogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.bosslogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bosslogPayload>
          }
          aggregate: {
            args: Prisma.BosslogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBosslog>
          }
          groupBy: {
            args: Prisma.bosslogGroupByArgs<ExtArgs>
            result: $Utils.Optional<BosslogGroupByOutputType>[]
          }
          count: {
            args: Prisma.bosslogCountArgs<ExtArgs>
            result: $Utils.Optional<BosslogCountAggregateOutputType> | number
          }
        }
      }
      cashiteminfos: {
        payload: Prisma.$cashiteminfosPayload<ExtArgs>
        fields: Prisma.cashiteminfosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.cashiteminfosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cashiteminfosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.cashiteminfosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cashiteminfosPayload>
          }
          findFirst: {
            args: Prisma.cashiteminfosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cashiteminfosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.cashiteminfosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cashiteminfosPayload>
          }
          findMany: {
            args: Prisma.cashiteminfosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cashiteminfosPayload>[]
          }
          create: {
            args: Prisma.cashiteminfosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cashiteminfosPayload>
          }
          createMany: {
            args: Prisma.cashiteminfosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.cashiteminfosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cashiteminfosPayload>
          }
          update: {
            args: Prisma.cashiteminfosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cashiteminfosPayload>
          }
          deleteMany: {
            args: Prisma.cashiteminfosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.cashiteminfosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.cashiteminfosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cashiteminfosPayload>
          }
          aggregate: {
            args: Prisma.CashiteminfosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCashiteminfos>
          }
          groupBy: {
            args: Prisma.cashiteminfosGroupByArgs<ExtArgs>
            result: $Utils.Optional<CashiteminfosGroupByOutputType>[]
          }
          count: {
            args: Prisma.cashiteminfosCountArgs<ExtArgs>
            result: $Utils.Optional<CashiteminfosCountAggregateOutputType> | number
          }
        }
      }
      characterpotentials: {
        payload: Prisma.$characterpotentialsPayload<ExtArgs>
        fields: Prisma.characterpotentialsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.characterpotentialsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$characterpotentialsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.characterpotentialsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$characterpotentialsPayload>
          }
          findFirst: {
            args: Prisma.characterpotentialsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$characterpotentialsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.characterpotentialsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$characterpotentialsPayload>
          }
          findMany: {
            args: Prisma.characterpotentialsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$characterpotentialsPayload>[]
          }
          create: {
            args: Prisma.characterpotentialsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$characterpotentialsPayload>
          }
          createMany: {
            args: Prisma.characterpotentialsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.characterpotentialsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$characterpotentialsPayload>
          }
          update: {
            args: Prisma.characterpotentialsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$characterpotentialsPayload>
          }
          deleteMany: {
            args: Prisma.characterpotentialsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.characterpotentialsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.characterpotentialsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$characterpotentialsPayload>
          }
          aggregate: {
            args: Prisma.CharacterpotentialsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCharacterpotentials>
          }
          groupBy: {
            args: Prisma.characterpotentialsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CharacterpotentialsGroupByOutputType>[]
          }
          count: {
            args: Prisma.characterpotentialsCountArgs<ExtArgs>
            result: $Utils.Optional<CharacterpotentialsCountAggregateOutputType> | number
          }
        }
      }
      characters: {
        payload: Prisma.$charactersPayload<ExtArgs>
        fields: Prisma.charactersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.charactersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$charactersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.charactersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$charactersPayload>
          }
          findFirst: {
            args: Prisma.charactersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$charactersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.charactersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$charactersPayload>
          }
          findMany: {
            args: Prisma.charactersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$charactersPayload>[]
          }
          create: {
            args: Prisma.charactersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$charactersPayload>
          }
          createMany: {
            args: Prisma.charactersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.charactersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$charactersPayload>
          }
          update: {
            args: Prisma.charactersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$charactersPayload>
          }
          deleteMany: {
            args: Prisma.charactersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.charactersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.charactersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$charactersPayload>
          }
          aggregate: {
            args: Prisma.CharactersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCharacters>
          }
          groupBy: {
            args: Prisma.charactersGroupByArgs<ExtArgs>
            result: $Utils.Optional<CharactersGroupByOutputType>[]
          }
          count: {
            args: Prisma.charactersCountArgs<ExtArgs>
            result: $Utils.Optional<CharactersCountAggregateOutputType> | number
          }
        }
      }
      characterstats: {
        payload: Prisma.$characterstatsPayload<ExtArgs>
        fields: Prisma.characterstatsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.characterstatsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$characterstatsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.characterstatsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$characterstatsPayload>
          }
          findFirst: {
            args: Prisma.characterstatsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$characterstatsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.characterstatsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$characterstatsPayload>
          }
          findMany: {
            args: Prisma.characterstatsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$characterstatsPayload>[]
          }
          create: {
            args: Prisma.characterstatsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$characterstatsPayload>
          }
          createMany: {
            args: Prisma.characterstatsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.characterstatsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$characterstatsPayload>
          }
          update: {
            args: Prisma.characterstatsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$characterstatsPayload>
          }
          deleteMany: {
            args: Prisma.characterstatsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.characterstatsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.characterstatsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$characterstatsPayload>
          }
          aggregate: {
            args: Prisma.CharacterstatsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCharacterstats>
          }
          groupBy: {
            args: Prisma.characterstatsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CharacterstatsGroupByOutputType>[]
          }
          count: {
            args: Prisma.characterstatsCountArgs<ExtArgs>
            result: $Utils.Optional<CharacterstatsCountAggregateOutputType> | number
          }
        }
      }
      chosenskills: {
        payload: Prisma.$chosenskillsPayload<ExtArgs>
        fields: Prisma.chosenskillsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.chosenskillsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chosenskillsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.chosenskillsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chosenskillsPayload>
          }
          findFirst: {
            args: Prisma.chosenskillsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chosenskillsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.chosenskillsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chosenskillsPayload>
          }
          findMany: {
            args: Prisma.chosenskillsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chosenskillsPayload>[]
          }
          create: {
            args: Prisma.chosenskillsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chosenskillsPayload>
          }
          createMany: {
            args: Prisma.chosenskillsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.chosenskillsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chosenskillsPayload>
          }
          update: {
            args: Prisma.chosenskillsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chosenskillsPayload>
          }
          deleteMany: {
            args: Prisma.chosenskillsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.chosenskillsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.chosenskillsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chosenskillsPayload>
          }
          aggregate: {
            args: Prisma.ChosenskillsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChosenskills>
          }
          groupBy: {
            args: Prisma.chosenskillsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChosenskillsGroupByOutputType>[]
          }
          count: {
            args: Prisma.chosenskillsCountArgs<ExtArgs>
            result: $Utils.Optional<ChosenskillsCountAggregateOutputType> | number
          }
        }
      }
      cms_votes: {
        payload: Prisma.$cms_votesPayload<ExtArgs>
        fields: Prisma.cms_votesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.cms_votesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cms_votesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.cms_votesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cms_votesPayload>
          }
          findFirst: {
            args: Prisma.cms_votesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cms_votesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.cms_votesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cms_votesPayload>
          }
          findMany: {
            args: Prisma.cms_votesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cms_votesPayload>[]
          }
          create: {
            args: Prisma.cms_votesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cms_votesPayload>
          }
          createMany: {
            args: Prisma.cms_votesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.cms_votesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cms_votesPayload>
          }
          update: {
            args: Prisma.cms_votesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cms_votesPayload>
          }
          deleteMany: {
            args: Prisma.cms_votesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.cms_votesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.cms_votesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cms_votesPayload>
          }
          aggregate: {
            args: Prisma.Cms_votesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCms_votes>
          }
          groupBy: {
            args: Prisma.cms_votesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Cms_votesGroupByOutputType>[]
          }
          count: {
            args: Prisma.cms_votesCountArgs<ExtArgs>
            result: $Utils.Optional<Cms_votesCountAggregateOutputType> | number
          }
        }
      }
      cooldowns: {
        payload: Prisma.$cooldownsPayload<ExtArgs>
        fields: Prisma.cooldownsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.cooldownsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cooldownsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.cooldownsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cooldownsPayload>
          }
          findFirst: {
            args: Prisma.cooldownsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cooldownsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.cooldownsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cooldownsPayload>
          }
          findMany: {
            args: Prisma.cooldownsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cooldownsPayload>[]
          }
          create: {
            args: Prisma.cooldownsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cooldownsPayload>
          }
          createMany: {
            args: Prisma.cooldownsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.cooldownsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cooldownsPayload>
          }
          update: {
            args: Prisma.cooldownsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cooldownsPayload>
          }
          deleteMany: {
            args: Prisma.cooldownsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.cooldownsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.cooldownsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cooldownsPayload>
          }
          aggregate: {
            args: Prisma.CooldownsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCooldowns>
          }
          groupBy: {
            args: Prisma.cooldownsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CooldownsGroupByOutputType>[]
          }
          count: {
            args: Prisma.cooldownsCountArgs<ExtArgs>
            result: $Utils.Optional<CooldownsCountAggregateOutputType> | number
          }
        }
      }
      cores: {
        payload: Prisma.$coresPayload<ExtArgs>
        fields: Prisma.coresFieldRefs
        operations: {
          findUnique: {
            args: Prisma.coresFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coresPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.coresFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coresPayload>
          }
          findFirst: {
            args: Prisma.coresFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coresPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.coresFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coresPayload>
          }
          findMany: {
            args: Prisma.coresFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coresPayload>[]
          }
          create: {
            args: Prisma.coresCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coresPayload>
          }
          createMany: {
            args: Prisma.coresCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.coresDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coresPayload>
          }
          update: {
            args: Prisma.coresUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coresPayload>
          }
          deleteMany: {
            args: Prisma.coresDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.coresUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.coresUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coresPayload>
          }
          aggregate: {
            args: Prisma.CoresAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCores>
          }
          groupBy: {
            args: Prisma.coresGroupByArgs<ExtArgs>
            result: $Utils.Optional<CoresGroupByOutputType>[]
          }
          count: {
            args: Prisma.coresCountArgs<ExtArgs>
            result: $Utils.Optional<CoresCountAggregateOutputType> | number
          }
        }
      }
      cs_categories: {
        payload: Prisma.$cs_categoriesPayload<ExtArgs>
        fields: Prisma.cs_categoriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.cs_categoriesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cs_categoriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.cs_categoriesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cs_categoriesPayload>
          }
          findFirst: {
            args: Prisma.cs_categoriesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cs_categoriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.cs_categoriesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cs_categoriesPayload>
          }
          findMany: {
            args: Prisma.cs_categoriesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cs_categoriesPayload>[]
          }
          create: {
            args: Prisma.cs_categoriesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cs_categoriesPayload>
          }
          createMany: {
            args: Prisma.cs_categoriesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.cs_categoriesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cs_categoriesPayload>
          }
          update: {
            args: Prisma.cs_categoriesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cs_categoriesPayload>
          }
          deleteMany: {
            args: Prisma.cs_categoriesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.cs_categoriesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.cs_categoriesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cs_categoriesPayload>
          }
          aggregate: {
            args: Prisma.Cs_categoriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCs_categories>
          }
          groupBy: {
            args: Prisma.cs_categoriesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Cs_categoriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.cs_categoriesCountArgs<ExtArgs>
            result: $Utils.Optional<Cs_categoriesCountAggregateOutputType> | number
          }
        }
      }
      cs_items: {
        payload: Prisma.$cs_itemsPayload<ExtArgs>
        fields: Prisma.cs_itemsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.cs_itemsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cs_itemsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.cs_itemsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cs_itemsPayload>
          }
          findFirst: {
            args: Prisma.cs_itemsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cs_itemsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.cs_itemsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cs_itemsPayload>
          }
          findMany: {
            args: Prisma.cs_itemsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cs_itemsPayload>[]
          }
          create: {
            args: Prisma.cs_itemsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cs_itemsPayload>
          }
          createMany: {
            args: Prisma.cs_itemsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.cs_itemsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cs_itemsPayload>
          }
          update: {
            args: Prisma.cs_itemsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cs_itemsPayload>
          }
          deleteMany: {
            args: Prisma.cs_itemsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.cs_itemsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.cs_itemsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cs_itemsPayload>
          }
          aggregate: {
            args: Prisma.Cs_itemsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCs_items>
          }
          groupBy: {
            args: Prisma.cs_itemsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Cs_itemsGroupByOutputType>[]
          }
          count: {
            args: Prisma.cs_itemsCountArgs<ExtArgs>
            result: $Utils.Optional<Cs_itemsCountAggregateOutputType> | number
          }
        }
      }
      damageskins: {
        payload: Prisma.$damageskinsPayload<ExtArgs>
        fields: Prisma.damageskinsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.damageskinsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$damageskinsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.damageskinsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$damageskinsPayload>
          }
          findFirst: {
            args: Prisma.damageskinsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$damageskinsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.damageskinsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$damageskinsPayload>
          }
          findMany: {
            args: Prisma.damageskinsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$damageskinsPayload>[]
          }
          create: {
            args: Prisma.damageskinsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$damageskinsPayload>
          }
          createMany: {
            args: Prisma.damageskinsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.damageskinsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$damageskinsPayload>
          }
          update: {
            args: Prisma.damageskinsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$damageskinsPayload>
          }
          deleteMany: {
            args: Prisma.damageskinsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.damageskinsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.damageskinsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$damageskinsPayload>
          }
          aggregate: {
            args: Prisma.DamageskinsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDamageskins>
          }
          groupBy: {
            args: Prisma.damageskinsGroupByArgs<ExtArgs>
            result: $Utils.Optional<DamageskinsGroupByOutputType>[]
          }
          count: {
            args: Prisma.damageskinsCountArgs<ExtArgs>
            result: $Utils.Optional<DamageskinsCountAggregateOutputType> | number
          }
        }
      }
      employeetrunk: {
        payload: Prisma.$employeetrunkPayload<ExtArgs>
        fields: Prisma.employeetrunkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.employeetrunkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeetrunkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.employeetrunkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeetrunkPayload>
          }
          findFirst: {
            args: Prisma.employeetrunkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeetrunkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.employeetrunkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeetrunkPayload>
          }
          findMany: {
            args: Prisma.employeetrunkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeetrunkPayload>[]
          }
          create: {
            args: Prisma.employeetrunkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeetrunkPayload>
          }
          createMany: {
            args: Prisma.employeetrunkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.employeetrunkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeetrunkPayload>
          }
          update: {
            args: Prisma.employeetrunkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeetrunkPayload>
          }
          deleteMany: {
            args: Prisma.employeetrunkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.employeetrunkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.employeetrunkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeetrunkPayload>
          }
          aggregate: {
            args: Prisma.EmployeetrunkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployeetrunk>
          }
          groupBy: {
            args: Prisma.employeetrunkGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeetrunkGroupByOutputType>[]
          }
          count: {
            args: Prisma.employeetrunkCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeetrunkCountAggregateOutputType> | number
          }
        }
      }
      equips: {
        payload: Prisma.$equipsPayload<ExtArgs>
        fields: Prisma.equipsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.equipsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$equipsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.equipsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$equipsPayload>
          }
          findFirst: {
            args: Prisma.equipsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$equipsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.equipsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$equipsPayload>
          }
          findMany: {
            args: Prisma.equipsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$equipsPayload>[]
          }
          create: {
            args: Prisma.equipsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$equipsPayload>
          }
          createMany: {
            args: Prisma.equipsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.equipsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$equipsPayload>
          }
          update: {
            args: Prisma.equipsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$equipsPayload>
          }
          deleteMany: {
            args: Prisma.equipsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.equipsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.equipsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$equipsPayload>
          }
          aggregate: {
            args: Prisma.EquipsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEquips>
          }
          groupBy: {
            args: Prisma.equipsGroupByArgs<ExtArgs>
            result: $Utils.Optional<EquipsGroupByOutputType>[]
          }
          count: {
            args: Prisma.equipsCountArgs<ExtArgs>
            result: $Utils.Optional<EquipsCountAggregateOutputType> | number
          }
        }
      }
      eventnametag: {
        payload: Prisma.$eventnametagPayload<ExtArgs>
        fields: Prisma.eventnametagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.eventnametagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventnametagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.eventnametagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventnametagPayload>
          }
          findFirst: {
            args: Prisma.eventnametagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventnametagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.eventnametagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventnametagPayload>
          }
          findMany: {
            args: Prisma.eventnametagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventnametagPayload>[]
          }
          create: {
            args: Prisma.eventnametagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventnametagPayload>
          }
          createMany: {
            args: Prisma.eventnametagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.eventnametagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventnametagPayload>
          }
          update: {
            args: Prisma.eventnametagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventnametagPayload>
          }
          deleteMany: {
            args: Prisma.eventnametagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.eventnametagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.eventnametagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventnametagPayload>
          }
          aggregate: {
            args: Prisma.EventnametagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEventnametag>
          }
          groupBy: {
            args: Prisma.eventnametagGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventnametagGroupByOutputType>[]
          }
          count: {
            args: Prisma.eventnametagCountArgs<ExtArgs>
            result: $Utils.Optional<EventnametagCountAggregateOutputType> | number
          }
        }
      }
      extendsp: {
        payload: Prisma.$extendspPayload<ExtArgs>
        fields: Prisma.extendspFieldRefs
        operations: {
          findUnique: {
            args: Prisma.extendspFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$extendspPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.extendspFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$extendspPayload>
          }
          findFirst: {
            args: Prisma.extendspFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$extendspPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.extendspFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$extendspPayload>
          }
          findMany: {
            args: Prisma.extendspFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$extendspPayload>[]
          }
          create: {
            args: Prisma.extendspCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$extendspPayload>
          }
          createMany: {
            args: Prisma.extendspCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.extendspDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$extendspPayload>
          }
          update: {
            args: Prisma.extendspUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$extendspPayload>
          }
          deleteMany: {
            args: Prisma.extendspDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.extendspUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.extendspUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$extendspPayload>
          }
          aggregate: {
            args: Prisma.ExtendspAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExtendsp>
          }
          groupBy: {
            args: Prisma.extendspGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExtendspGroupByOutputType>[]
          }
          count: {
            args: Prisma.extendspCountArgs<ExtArgs>
            result: $Utils.Optional<ExtendspCountAggregateOutputType> | number
          }
        }
      }
      familiars: {
        payload: Prisma.$familiarsPayload<ExtArgs>
        fields: Prisma.familiarsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.familiarsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$familiarsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.familiarsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$familiarsPayload>
          }
          findFirst: {
            args: Prisma.familiarsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$familiarsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.familiarsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$familiarsPayload>
          }
          findMany: {
            args: Prisma.familiarsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$familiarsPayload>[]
          }
          create: {
            args: Prisma.familiarsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$familiarsPayload>
          }
          createMany: {
            args: Prisma.familiarsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.familiarsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$familiarsPayload>
          }
          update: {
            args: Prisma.familiarsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$familiarsPayload>
          }
          deleteMany: {
            args: Prisma.familiarsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.familiarsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.familiarsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$familiarsPayload>
          }
          aggregate: {
            args: Prisma.FamiliarsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFamiliars>
          }
          groupBy: {
            args: Prisma.familiarsGroupByArgs<ExtArgs>
            result: $Utils.Optional<FamiliarsGroupByOutputType>[]
          }
          count: {
            args: Prisma.familiarsCountArgs<ExtArgs>
            result: $Utils.Optional<FamiliarsCountAggregateOutputType> | number
          }
        }
      }
      friends: {
        payload: Prisma.$friendsPayload<ExtArgs>
        fields: Prisma.friendsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.friendsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$friendsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.friendsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$friendsPayload>
          }
          findFirst: {
            args: Prisma.friendsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$friendsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.friendsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$friendsPayload>
          }
          findMany: {
            args: Prisma.friendsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$friendsPayload>[]
          }
          create: {
            args: Prisma.friendsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$friendsPayload>
          }
          createMany: {
            args: Prisma.friendsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.friendsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$friendsPayload>
          }
          update: {
            args: Prisma.friendsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$friendsPayload>
          }
          deleteMany: {
            args: Prisma.friendsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.friendsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.friendsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$friendsPayload>
          }
          aggregate: {
            args: Prisma.FriendsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFriends>
          }
          groupBy: {
            args: Prisma.friendsGroupByArgs<ExtArgs>
            result: $Utils.Optional<FriendsGroupByOutputType>[]
          }
          count: {
            args: Prisma.friendsCountArgs<ExtArgs>
            result: $Utils.Optional<FriendsCountAggregateOutputType> | number
          }
        }
      }
      funckeymap: {
        payload: Prisma.$funckeymapPayload<ExtArgs>
        fields: Prisma.funckeymapFieldRefs
        operations: {
          findUnique: {
            args: Prisma.funckeymapFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$funckeymapPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.funckeymapFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$funckeymapPayload>
          }
          findFirst: {
            args: Prisma.funckeymapFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$funckeymapPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.funckeymapFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$funckeymapPayload>
          }
          findMany: {
            args: Prisma.funckeymapFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$funckeymapPayload>[]
          }
          create: {
            args: Prisma.funckeymapCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$funckeymapPayload>
          }
          createMany: {
            args: Prisma.funckeymapCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.funckeymapDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$funckeymapPayload>
          }
          update: {
            args: Prisma.funckeymapUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$funckeymapPayload>
          }
          deleteMany: {
            args: Prisma.funckeymapDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.funckeymapUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.funckeymapUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$funckeymapPayload>
          }
          aggregate: {
            args: Prisma.FunckeymapAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFunckeymap>
          }
          groupBy: {
            args: Prisma.funckeymapGroupByArgs<ExtArgs>
            result: $Utils.Optional<FunckeymapGroupByOutputType>[]
          }
          count: {
            args: Prisma.funckeymapCountArgs<ExtArgs>
            result: $Utils.Optional<FunckeymapCountAggregateOutputType> | number
          }
        }
      }
      gradenames: {
        payload: Prisma.$gradenamesPayload<ExtArgs>
        fields: Prisma.gradenamesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.gradenamesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gradenamesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.gradenamesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gradenamesPayload>
          }
          findFirst: {
            args: Prisma.gradenamesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gradenamesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.gradenamesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gradenamesPayload>
          }
          findMany: {
            args: Prisma.gradenamesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gradenamesPayload>[]
          }
          create: {
            args: Prisma.gradenamesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gradenamesPayload>
          }
          createMany: {
            args: Prisma.gradenamesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.gradenamesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gradenamesPayload>
          }
          update: {
            args: Prisma.gradenamesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gradenamesPayload>
          }
          deleteMany: {
            args: Prisma.gradenamesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.gradenamesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.gradenamesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gradenamesPayload>
          }
          aggregate: {
            args: Prisma.GradenamesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGradenames>
          }
          groupBy: {
            args: Prisma.gradenamesGroupByArgs<ExtArgs>
            result: $Utils.Optional<GradenamesGroupByOutputType>[]
          }
          count: {
            args: Prisma.gradenamesCountArgs<ExtArgs>
            result: $Utils.Optional<GradenamesCountAggregateOutputType> | number
          }
        }
      }
      guildmembers: {
        payload: Prisma.$guildmembersPayload<ExtArgs>
        fields: Prisma.guildmembersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.guildmembersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guildmembersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.guildmembersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guildmembersPayload>
          }
          findFirst: {
            args: Prisma.guildmembersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guildmembersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.guildmembersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guildmembersPayload>
          }
          findMany: {
            args: Prisma.guildmembersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guildmembersPayload>[]
          }
          create: {
            args: Prisma.guildmembersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guildmembersPayload>
          }
          createMany: {
            args: Prisma.guildmembersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.guildmembersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guildmembersPayload>
          }
          update: {
            args: Prisma.guildmembersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guildmembersPayload>
          }
          deleteMany: {
            args: Prisma.guildmembersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.guildmembersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.guildmembersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guildmembersPayload>
          }
          aggregate: {
            args: Prisma.GuildmembersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGuildmembers>
          }
          groupBy: {
            args: Prisma.guildmembersGroupByArgs<ExtArgs>
            result: $Utils.Optional<GuildmembersGroupByOutputType>[]
          }
          count: {
            args: Prisma.guildmembersCountArgs<ExtArgs>
            result: $Utils.Optional<GuildmembersCountAggregateOutputType> | number
          }
        }
      }
      guildrequestors: {
        payload: Prisma.$guildrequestorsPayload<ExtArgs>
        fields: Prisma.guildrequestorsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.guildrequestorsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guildrequestorsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.guildrequestorsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guildrequestorsPayload>
          }
          findFirst: {
            args: Prisma.guildrequestorsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guildrequestorsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.guildrequestorsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guildrequestorsPayload>
          }
          findMany: {
            args: Prisma.guildrequestorsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guildrequestorsPayload>[]
          }
          create: {
            args: Prisma.guildrequestorsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guildrequestorsPayload>
          }
          createMany: {
            args: Prisma.guildrequestorsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.guildrequestorsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guildrequestorsPayload>
          }
          update: {
            args: Prisma.guildrequestorsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guildrequestorsPayload>
          }
          deleteMany: {
            args: Prisma.guildrequestorsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.guildrequestorsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.guildrequestorsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guildrequestorsPayload>
          }
          aggregate: {
            args: Prisma.GuildrequestorsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGuildrequestors>
          }
          groupBy: {
            args: Prisma.guildrequestorsGroupByArgs<ExtArgs>
            result: $Utils.Optional<GuildrequestorsGroupByOutputType>[]
          }
          count: {
            args: Prisma.guildrequestorsCountArgs<ExtArgs>
            result: $Utils.Optional<GuildrequestorsCountAggregateOutputType> | number
          }
        }
      }
      guilds: {
        payload: Prisma.$guildsPayload<ExtArgs>
        fields: Prisma.guildsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.guildsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guildsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.guildsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guildsPayload>
          }
          findFirst: {
            args: Prisma.guildsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guildsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.guildsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guildsPayload>
          }
          findMany: {
            args: Prisma.guildsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guildsPayload>[]
          }
          create: {
            args: Prisma.guildsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guildsPayload>
          }
          createMany: {
            args: Prisma.guildsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.guildsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guildsPayload>
          }
          update: {
            args: Prisma.guildsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guildsPayload>
          }
          deleteMany: {
            args: Prisma.guildsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.guildsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.guildsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guildsPayload>
          }
          aggregate: {
            args: Prisma.GuildsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGuilds>
          }
          groupBy: {
            args: Prisma.guildsGroupByArgs<ExtArgs>
            result: $Utils.Optional<GuildsGroupByOutputType>[]
          }
          count: {
            args: Prisma.guildsCountArgs<ExtArgs>
            result: $Utils.Optional<GuildsCountAggregateOutputType> | number
          }
        }
      }
      guildskill: {
        payload: Prisma.$guildskillPayload<ExtArgs>
        fields: Prisma.guildskillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.guildskillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guildskillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.guildskillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guildskillPayload>
          }
          findFirst: {
            args: Prisma.guildskillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guildskillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.guildskillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guildskillPayload>
          }
          findMany: {
            args: Prisma.guildskillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guildskillPayload>[]
          }
          create: {
            args: Prisma.guildskillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guildskillPayload>
          }
          createMany: {
            args: Prisma.guildskillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.guildskillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guildskillPayload>
          }
          update: {
            args: Prisma.guildskillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guildskillPayload>
          }
          deleteMany: {
            args: Prisma.guildskillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.guildskillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.guildskillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guildskillPayload>
          }
          aggregate: {
            args: Prisma.GuildskillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGuildskill>
          }
          groupBy: {
            args: Prisma.guildskillGroupByArgs<ExtArgs>
            result: $Utils.Optional<GuildskillGroupByOutputType>[]
          }
          count: {
            args: Prisma.guildskillCountArgs<ExtArgs>
            result: $Utils.Optional<GuildskillCountAggregateOutputType> | number
          }
        }
      }
      guildskills: {
        payload: Prisma.$guildskillsPayload<ExtArgs>
        fields: Prisma.guildskillsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.guildskillsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guildskillsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.guildskillsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guildskillsPayload>
          }
          findFirst: {
            args: Prisma.guildskillsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guildskillsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.guildskillsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guildskillsPayload>
          }
          findMany: {
            args: Prisma.guildskillsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guildskillsPayload>[]
          }
          create: {
            args: Prisma.guildskillsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guildskillsPayload>
          }
          createMany: {
            args: Prisma.guildskillsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.guildskillsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guildskillsPayload>
          }
          update: {
            args: Prisma.guildskillsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guildskillsPayload>
          }
          deleteMany: {
            args: Prisma.guildskillsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.guildskillsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.guildskillsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guildskillsPayload>
          }
          aggregate: {
            args: Prisma.GuildskillsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGuildskills>
          }
          groupBy: {
            args: Prisma.guildskillsGroupByArgs<ExtArgs>
            result: $Utils.Optional<GuildskillsGroupByOutputType>[]
          }
          count: {
            args: Prisma.guildskillsCountArgs<ExtArgs>
            result: $Utils.Optional<GuildskillsCountAggregateOutputType> | number
          }
        }
      }
      hairequips: {
        payload: Prisma.$hairequipsPayload<ExtArgs>
        fields: Prisma.hairequipsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.hairequipsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hairequipsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.hairequipsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hairequipsPayload>
          }
          findFirst: {
            args: Prisma.hairequipsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hairequipsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.hairequipsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hairequipsPayload>
          }
          findMany: {
            args: Prisma.hairequipsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hairequipsPayload>[]
          }
          create: {
            args: Prisma.hairequipsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hairequipsPayload>
          }
          createMany: {
            args: Prisma.hairequipsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.hairequipsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hairequipsPayload>
          }
          update: {
            args: Prisma.hairequipsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hairequipsPayload>
          }
          deleteMany: {
            args: Prisma.hairequipsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.hairequipsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.hairequipsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hairequipsPayload>
          }
          aggregate: {
            args: Prisma.HairequipsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHairequips>
          }
          groupBy: {
            args: Prisma.hairequipsGroupByArgs<ExtArgs>
            result: $Utils.Optional<HairequipsGroupByOutputType>[]
          }
          count: {
            args: Prisma.hairequipsCountArgs<ExtArgs>
            result: $Utils.Optional<HairequipsCountAggregateOutputType> | number
          }
        }
      }
      hyperrockfields: {
        payload: Prisma.$hyperrockfieldsPayload<ExtArgs>
        fields: Prisma.hyperrockfieldsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.hyperrockfieldsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hyperrockfieldsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.hyperrockfieldsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hyperrockfieldsPayload>
          }
          findFirst: {
            args: Prisma.hyperrockfieldsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hyperrockfieldsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.hyperrockfieldsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hyperrockfieldsPayload>
          }
          findMany: {
            args: Prisma.hyperrockfieldsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hyperrockfieldsPayload>[]
          }
          create: {
            args: Prisma.hyperrockfieldsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hyperrockfieldsPayload>
          }
          createMany: {
            args: Prisma.hyperrockfieldsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.hyperrockfieldsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hyperrockfieldsPayload>
          }
          update: {
            args: Prisma.hyperrockfieldsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hyperrockfieldsPayload>
          }
          deleteMany: {
            args: Prisma.hyperrockfieldsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.hyperrockfieldsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.hyperrockfieldsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hyperrockfieldsPayload>
          }
          aggregate: {
            args: Prisma.HyperrockfieldsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHyperrockfields>
          }
          groupBy: {
            args: Prisma.hyperrockfieldsGroupByArgs<ExtArgs>
            result: $Utils.Optional<HyperrockfieldsGroupByOutputType>[]
          }
          count: {
            args: Prisma.hyperrockfieldsCountArgs<ExtArgs>
            result: $Utils.Optional<HyperrockfieldsCountAggregateOutputType> | number
          }
        }
      }
      inventories: {
        payload: Prisma.$inventoriesPayload<ExtArgs>
        fields: Prisma.inventoriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inventoriesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventoriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inventoriesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventoriesPayload>
          }
          findFirst: {
            args: Prisma.inventoriesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventoriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inventoriesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventoriesPayload>
          }
          findMany: {
            args: Prisma.inventoriesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventoriesPayload>[]
          }
          create: {
            args: Prisma.inventoriesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventoriesPayload>
          }
          createMany: {
            args: Prisma.inventoriesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.inventoriesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventoriesPayload>
          }
          update: {
            args: Prisma.inventoriesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventoriesPayload>
          }
          deleteMany: {
            args: Prisma.inventoriesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.inventoriesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.inventoriesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventoriesPayload>
          }
          aggregate: {
            args: Prisma.InventoriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventories>
          }
          groupBy: {
            args: Prisma.inventoriesGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.inventoriesCountArgs<ExtArgs>
            result: $Utils.Optional<InventoriesCountAggregateOutputType> | number
          }
        }
      }
      items: {
        payload: Prisma.$itemsPayload<ExtArgs>
        fields: Prisma.itemsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.itemsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.itemsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemsPayload>
          }
          findFirst: {
            args: Prisma.itemsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.itemsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemsPayload>
          }
          findMany: {
            args: Prisma.itemsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemsPayload>[]
          }
          create: {
            args: Prisma.itemsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemsPayload>
          }
          createMany: {
            args: Prisma.itemsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.itemsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemsPayload>
          }
          update: {
            args: Prisma.itemsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemsPayload>
          }
          deleteMany: {
            args: Prisma.itemsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.itemsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.itemsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemsPayload>
          }
          aggregate: {
            args: Prisma.ItemsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItems>
          }
          groupBy: {
            args: Prisma.itemsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItemsGroupByOutputType>[]
          }
          count: {
            args: Prisma.itemsCountArgs<ExtArgs>
            result: $Utils.Optional<ItemsCountAggregateOutputType> | number
          }
        }
      }
      itemsbuylimit: {
        payload: Prisma.$itemsbuylimitPayload<ExtArgs>
        fields: Prisma.itemsbuylimitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.itemsbuylimitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemsbuylimitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.itemsbuylimitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemsbuylimitPayload>
          }
          findFirst: {
            args: Prisma.itemsbuylimitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemsbuylimitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.itemsbuylimitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemsbuylimitPayload>
          }
          findMany: {
            args: Prisma.itemsbuylimitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemsbuylimitPayload>[]
          }
          create: {
            args: Prisma.itemsbuylimitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemsbuylimitPayload>
          }
          createMany: {
            args: Prisma.itemsbuylimitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.itemsbuylimitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemsbuylimitPayload>
          }
          update: {
            args: Prisma.itemsbuylimitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemsbuylimitPayload>
          }
          deleteMany: {
            args: Prisma.itemsbuylimitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.itemsbuylimitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.itemsbuylimitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemsbuylimitPayload>
          }
          aggregate: {
            args: Prisma.ItemsbuylimitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItemsbuylimit>
          }
          groupBy: {
            args: Prisma.itemsbuylimitGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItemsbuylimitGroupByOutputType>[]
          }
          count: {
            args: Prisma.itemsbuylimitCountArgs<ExtArgs>
            result: $Utils.Optional<ItemsbuylimitCountAggregateOutputType> | number
          }
        }
      }
      keymaps: {
        payload: Prisma.$keymapsPayload<ExtArgs>
        fields: Prisma.keymapsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.keymapsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$keymapsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.keymapsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$keymapsPayload>
          }
          findFirst: {
            args: Prisma.keymapsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$keymapsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.keymapsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$keymapsPayload>
          }
          findMany: {
            args: Prisma.keymapsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$keymapsPayload>[]
          }
          create: {
            args: Prisma.keymapsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$keymapsPayload>
          }
          createMany: {
            args: Prisma.keymapsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.keymapsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$keymapsPayload>
          }
          update: {
            args: Prisma.keymapsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$keymapsPayload>
          }
          deleteMany: {
            args: Prisma.keymapsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.keymapsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.keymapsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$keymapsPayload>
          }
          aggregate: {
            args: Prisma.KeymapsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKeymaps>
          }
          groupBy: {
            args: Prisma.keymapsGroupByArgs<ExtArgs>
            result: $Utils.Optional<KeymapsGroupByOutputType>[]
          }
          count: {
            args: Prisma.keymapsCountArgs<ExtArgs>
            result: $Utils.Optional<KeymapsCountAggregateOutputType> | number
          }
        }
      }
      linkskills: {
        payload: Prisma.$linkskillsPayload<ExtArgs>
        fields: Prisma.linkskillsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.linkskillsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$linkskillsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.linkskillsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$linkskillsPayload>
          }
          findFirst: {
            args: Prisma.linkskillsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$linkskillsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.linkskillsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$linkskillsPayload>
          }
          findMany: {
            args: Prisma.linkskillsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$linkskillsPayload>[]
          }
          create: {
            args: Prisma.linkskillsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$linkskillsPayload>
          }
          createMany: {
            args: Prisma.linkskillsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.linkskillsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$linkskillsPayload>
          }
          update: {
            args: Prisma.linkskillsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$linkskillsPayload>
          }
          deleteMany: {
            args: Prisma.linkskillsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.linkskillsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.linkskillsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$linkskillsPayload>
          }
          aggregate: {
            args: Prisma.LinkskillsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLinkskills>
          }
          groupBy: {
            args: Prisma.linkskillsGroupByArgs<ExtArgs>
            result: $Utils.Optional<LinkskillsGroupByOutputType>[]
          }
          count: {
            args: Prisma.linkskillsCountArgs<ExtArgs>
            result: $Utils.Optional<LinkskillsCountAggregateOutputType> | number
          }
        }
      }
      macros: {
        payload: Prisma.$macrosPayload<ExtArgs>
        fields: Prisma.macrosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.macrosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$macrosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.macrosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$macrosPayload>
          }
          findFirst: {
            args: Prisma.macrosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$macrosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.macrosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$macrosPayload>
          }
          findMany: {
            args: Prisma.macrosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$macrosPayload>[]
          }
          create: {
            args: Prisma.macrosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$macrosPayload>
          }
          createMany: {
            args: Prisma.macrosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.macrosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$macrosPayload>
          }
          update: {
            args: Prisma.macrosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$macrosPayload>
          }
          deleteMany: {
            args: Prisma.macrosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.macrosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.macrosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$macrosPayload>
          }
          aggregate: {
            args: Prisma.MacrosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMacros>
          }
          groupBy: {
            args: Prisma.macrosGroupByArgs<ExtArgs>
            result: $Utils.Optional<MacrosGroupByOutputType>[]
          }
          count: {
            args: Prisma.macrosCountArgs<ExtArgs>
            result: $Utils.Optional<MacrosCountAggregateOutputType> | number
          }
        }
      }
      macroskills: {
        payload: Prisma.$macroskillsPayload<ExtArgs>
        fields: Prisma.macroskillsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.macroskillsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$macroskillsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.macroskillsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$macroskillsPayload>
          }
          findFirst: {
            args: Prisma.macroskillsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$macroskillsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.macroskillsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$macroskillsPayload>
          }
          findMany: {
            args: Prisma.macroskillsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$macroskillsPayload>[]
          }
          create: {
            args: Prisma.macroskillsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$macroskillsPayload>
          }
          createMany: {
            args: Prisma.macroskillsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.macroskillsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$macroskillsPayload>
          }
          update: {
            args: Prisma.macroskillsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$macroskillsPayload>
          }
          deleteMany: {
            args: Prisma.macroskillsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.macroskillsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.macroskillsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$macroskillsPayload>
          }
          aggregate: {
            args: Prisma.MacroskillsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMacroskills>
          }
          groupBy: {
            args: Prisma.macroskillsGroupByArgs<ExtArgs>
            result: $Utils.Optional<MacroskillsGroupByOutputType>[]
          }
          count: {
            args: Prisma.macroskillsCountArgs<ExtArgs>
            result: $Utils.Optional<MacroskillsCountAggregateOutputType> | number
          }
        }
      }
      matrixskill: {
        payload: Prisma.$matrixskillPayload<ExtArgs>
        fields: Prisma.matrixskillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.matrixskillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$matrixskillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.matrixskillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$matrixskillPayload>
          }
          findFirst: {
            args: Prisma.matrixskillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$matrixskillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.matrixskillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$matrixskillPayload>
          }
          findMany: {
            args: Prisma.matrixskillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$matrixskillPayload>[]
          }
          create: {
            args: Prisma.matrixskillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$matrixskillPayload>
          }
          createMany: {
            args: Prisma.matrixskillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.matrixskillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$matrixskillPayload>
          }
          update: {
            args: Prisma.matrixskillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$matrixskillPayload>
          }
          deleteMany: {
            args: Prisma.matrixskillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.matrixskillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.matrixskillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$matrixskillPayload>
          }
          aggregate: {
            args: Prisma.MatrixskillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMatrixskill>
          }
          groupBy: {
            args: Prisma.matrixskillGroupByArgs<ExtArgs>
            result: $Utils.Optional<MatrixskillGroupByOutputType>[]
          }
          count: {
            args: Prisma.matrixskillCountArgs<ExtArgs>
            result: $Utils.Optional<MatrixskillCountAggregateOutputType> | number
          }
        }
      }
      medals: {
        payload: Prisma.$medalsPayload<ExtArgs>
        fields: Prisma.medalsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.medalsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medalsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.medalsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medalsPayload>
          }
          findFirst: {
            args: Prisma.medalsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medalsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.medalsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medalsPayload>
          }
          findMany: {
            args: Prisma.medalsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medalsPayload>[]
          }
          create: {
            args: Prisma.medalsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medalsPayload>
          }
          createMany: {
            args: Prisma.medalsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.medalsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medalsPayload>
          }
          update: {
            args: Prisma.medalsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medalsPayload>
          }
          deleteMany: {
            args: Prisma.medalsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.medalsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.medalsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medalsPayload>
          }
          aggregate: {
            args: Prisma.MedalsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedals>
          }
          groupBy: {
            args: Prisma.medalsGroupByArgs<ExtArgs>
            result: $Utils.Optional<MedalsGroupByOutputType>[]
          }
          count: {
            args: Prisma.medalsCountArgs<ExtArgs>
            result: $Utils.Optional<MedalsCountAggregateOutputType> | number
          }
        }
      }
      mob_drops: {
        payload: Prisma.$mob_dropsPayload<ExtArgs>
        fields: Prisma.mob_dropsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.mob_dropsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mob_dropsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.mob_dropsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mob_dropsPayload>
          }
          findFirst: {
            args: Prisma.mob_dropsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mob_dropsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.mob_dropsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mob_dropsPayload>
          }
          findMany: {
            args: Prisma.mob_dropsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mob_dropsPayload>[]
          }
          create: {
            args: Prisma.mob_dropsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mob_dropsPayload>
          }
          createMany: {
            args: Prisma.mob_dropsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.mob_dropsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mob_dropsPayload>
          }
          update: {
            args: Prisma.mob_dropsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mob_dropsPayload>
          }
          deleteMany: {
            args: Prisma.mob_dropsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.mob_dropsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.mob_dropsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mob_dropsPayload>
          }
          aggregate: {
            args: Prisma.Mob_dropsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMob_drops>
          }
          groupBy: {
            args: Prisma.mob_dropsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Mob_dropsGroupByOutputType>[]
          }
          count: {
            args: Prisma.mob_dropsCountArgs<ExtArgs>
            result: $Utils.Optional<Mob_dropsCountAggregateOutputType> | number
          }
        }
      }
      monster_collection: {
        payload: Prisma.$monster_collectionPayload<ExtArgs>
        fields: Prisma.monster_collectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.monster_collectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monster_collectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.monster_collectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monster_collectionPayload>
          }
          findFirst: {
            args: Prisma.monster_collectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monster_collectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.monster_collectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monster_collectionPayload>
          }
          findMany: {
            args: Prisma.monster_collectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monster_collectionPayload>[]
          }
          create: {
            args: Prisma.monster_collectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monster_collectionPayload>
          }
          createMany: {
            args: Prisma.monster_collectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.monster_collectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monster_collectionPayload>
          }
          update: {
            args: Prisma.monster_collectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monster_collectionPayload>
          }
          deleteMany: {
            args: Prisma.monster_collectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.monster_collectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.monster_collectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monster_collectionPayload>
          }
          aggregate: {
            args: Prisma.Monster_collectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMonster_collection>
          }
          groupBy: {
            args: Prisma.monster_collectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<Monster_collectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.monster_collectionCountArgs<ExtArgs>
            result: $Utils.Optional<Monster_collectionCountAggregateOutputType> | number
          }
        }
      }
      monster_collection_explorations: {
        payload: Prisma.$monster_collection_explorationsPayload<ExtArgs>
        fields: Prisma.monster_collection_explorationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.monster_collection_explorationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monster_collection_explorationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.monster_collection_explorationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monster_collection_explorationsPayload>
          }
          findFirst: {
            args: Prisma.monster_collection_explorationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monster_collection_explorationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.monster_collection_explorationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monster_collection_explorationsPayload>
          }
          findMany: {
            args: Prisma.monster_collection_explorationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monster_collection_explorationsPayload>[]
          }
          create: {
            args: Prisma.monster_collection_explorationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monster_collection_explorationsPayload>
          }
          createMany: {
            args: Prisma.monster_collection_explorationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.monster_collection_explorationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monster_collection_explorationsPayload>
          }
          update: {
            args: Prisma.monster_collection_explorationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monster_collection_explorationsPayload>
          }
          deleteMany: {
            args: Prisma.monster_collection_explorationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.monster_collection_explorationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.monster_collection_explorationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monster_collection_explorationsPayload>
          }
          aggregate: {
            args: Prisma.Monster_collection_explorationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMonster_collection_explorations>
          }
          groupBy: {
            args: Prisma.monster_collection_explorationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Monster_collection_explorationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.monster_collection_explorationsCountArgs<ExtArgs>
            result: $Utils.Optional<Monster_collection_explorationsCountAggregateOutputType> | number
          }
        }
      }
      monster_collection_group_rewards: {
        payload: Prisma.$monster_collection_group_rewardsPayload<ExtArgs>
        fields: Prisma.monster_collection_group_rewardsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.monster_collection_group_rewardsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monster_collection_group_rewardsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.monster_collection_group_rewardsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monster_collection_group_rewardsPayload>
          }
          findFirst: {
            args: Prisma.monster_collection_group_rewardsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monster_collection_group_rewardsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.monster_collection_group_rewardsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monster_collection_group_rewardsPayload>
          }
          findMany: {
            args: Prisma.monster_collection_group_rewardsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monster_collection_group_rewardsPayload>[]
          }
          create: {
            args: Prisma.monster_collection_group_rewardsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monster_collection_group_rewardsPayload>
          }
          createMany: {
            args: Prisma.monster_collection_group_rewardsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.monster_collection_group_rewardsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monster_collection_group_rewardsPayload>
          }
          update: {
            args: Prisma.monster_collection_group_rewardsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monster_collection_group_rewardsPayload>
          }
          deleteMany: {
            args: Prisma.monster_collection_group_rewardsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.monster_collection_group_rewardsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.monster_collection_group_rewardsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monster_collection_group_rewardsPayload>
          }
          aggregate: {
            args: Prisma.Monster_collection_group_rewardsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMonster_collection_group_rewards>
          }
          groupBy: {
            args: Prisma.monster_collection_group_rewardsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Monster_collection_group_rewardsGroupByOutputType>[]
          }
          count: {
            args: Prisma.monster_collection_group_rewardsCountArgs<ExtArgs>
            result: $Utils.Optional<Monster_collection_group_rewardsCountAggregateOutputType> | number
          }
        }
      }
      monster_collection_mobs: {
        payload: Prisma.$monster_collection_mobsPayload<ExtArgs>
        fields: Prisma.monster_collection_mobsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.monster_collection_mobsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monster_collection_mobsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.monster_collection_mobsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monster_collection_mobsPayload>
          }
          findFirst: {
            args: Prisma.monster_collection_mobsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monster_collection_mobsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.monster_collection_mobsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monster_collection_mobsPayload>
          }
          findMany: {
            args: Prisma.monster_collection_mobsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monster_collection_mobsPayload>[]
          }
          create: {
            args: Prisma.monster_collection_mobsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monster_collection_mobsPayload>
          }
          createMany: {
            args: Prisma.monster_collection_mobsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.monster_collection_mobsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monster_collection_mobsPayload>
          }
          update: {
            args: Prisma.monster_collection_mobsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monster_collection_mobsPayload>
          }
          deleteMany: {
            args: Prisma.monster_collection_mobsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.monster_collection_mobsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.monster_collection_mobsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monster_collection_mobsPayload>
          }
          aggregate: {
            args: Prisma.Monster_collection_mobsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMonster_collection_mobs>
          }
          groupBy: {
            args: Prisma.monster_collection_mobsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Monster_collection_mobsGroupByOutputType>[]
          }
          count: {
            args: Prisma.monster_collection_mobsCountArgs<ExtArgs>
            result: $Utils.Optional<Monster_collection_mobsCountAggregateOutputType> | number
          }
        }
      }
      monster_collection_rewards: {
        payload: Prisma.$monster_collection_rewardsPayload<ExtArgs>
        fields: Prisma.monster_collection_rewardsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.monster_collection_rewardsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monster_collection_rewardsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.monster_collection_rewardsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monster_collection_rewardsPayload>
          }
          findFirst: {
            args: Prisma.monster_collection_rewardsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monster_collection_rewardsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.monster_collection_rewardsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monster_collection_rewardsPayload>
          }
          findMany: {
            args: Prisma.monster_collection_rewardsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monster_collection_rewardsPayload>[]
          }
          create: {
            args: Prisma.monster_collection_rewardsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monster_collection_rewardsPayload>
          }
          createMany: {
            args: Prisma.monster_collection_rewardsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.monster_collection_rewardsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monster_collection_rewardsPayload>
          }
          update: {
            args: Prisma.monster_collection_rewardsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monster_collection_rewardsPayload>
          }
          deleteMany: {
            args: Prisma.monster_collection_rewardsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.monster_collection_rewardsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.monster_collection_rewardsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monster_collection_rewardsPayload>
          }
          aggregate: {
            args: Prisma.Monster_collection_rewardsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMonster_collection_rewards>
          }
          groupBy: {
            args: Prisma.monster_collection_rewardsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Monster_collection_rewardsGroupByOutputType>[]
          }
          count: {
            args: Prisma.monster_collection_rewardsCountArgs<ExtArgs>
            result: $Utils.Optional<Monster_collection_rewardsCountAggregateOutputType> | number
          }
        }
      }
      monster_collection_session_rewards: {
        payload: Prisma.$monster_collection_session_rewardsPayload<ExtArgs>
        fields: Prisma.monster_collection_session_rewardsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.monster_collection_session_rewardsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monster_collection_session_rewardsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.monster_collection_session_rewardsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monster_collection_session_rewardsPayload>
          }
          findFirst: {
            args: Prisma.monster_collection_session_rewardsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monster_collection_session_rewardsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.monster_collection_session_rewardsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monster_collection_session_rewardsPayload>
          }
          findMany: {
            args: Prisma.monster_collection_session_rewardsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monster_collection_session_rewardsPayload>[]
          }
          create: {
            args: Prisma.monster_collection_session_rewardsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monster_collection_session_rewardsPayload>
          }
          createMany: {
            args: Prisma.monster_collection_session_rewardsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.monster_collection_session_rewardsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monster_collection_session_rewardsPayload>
          }
          update: {
            args: Prisma.monster_collection_session_rewardsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monster_collection_session_rewardsPayload>
          }
          deleteMany: {
            args: Prisma.monster_collection_session_rewardsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.monster_collection_session_rewardsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.monster_collection_session_rewardsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monster_collection_session_rewardsPayload>
          }
          aggregate: {
            args: Prisma.Monster_collection_session_rewardsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMonster_collection_session_rewards>
          }
          groupBy: {
            args: Prisma.monster_collection_session_rewardsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Monster_collection_session_rewardsGroupByOutputType>[]
          }
          count: {
            args: Prisma.monster_collection_session_rewardsCountArgs<ExtArgs>
            result: $Utils.Optional<Monster_collection_session_rewardsCountAggregateOutputType> | number
          }
        }
      }
      monster_collections: {
        payload: Prisma.$monster_collectionsPayload<ExtArgs>
        fields: Prisma.monster_collectionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.monster_collectionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monster_collectionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.monster_collectionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monster_collectionsPayload>
          }
          findFirst: {
            args: Prisma.monster_collectionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monster_collectionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.monster_collectionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monster_collectionsPayload>
          }
          findMany: {
            args: Prisma.monster_collectionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monster_collectionsPayload>[]
          }
          create: {
            args: Prisma.monster_collectionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monster_collectionsPayload>
          }
          createMany: {
            args: Prisma.monster_collectionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.monster_collectionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monster_collectionsPayload>
          }
          update: {
            args: Prisma.monster_collectionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monster_collectionsPayload>
          }
          deleteMany: {
            args: Prisma.monster_collectionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.monster_collectionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.monster_collectionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monster_collectionsPayload>
          }
          aggregate: {
            args: Prisma.Monster_collectionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMonster_collections>
          }
          groupBy: {
            args: Prisma.monster_collectionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Monster_collectionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.monster_collectionsCountArgs<ExtArgs>
            result: $Utils.Optional<Monster_collectionsCountAggregateOutputType> | number
          }
        }
      }
      monsterbookcards: {
        payload: Prisma.$monsterbookcardsPayload<ExtArgs>
        fields: Prisma.monsterbookcardsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.monsterbookcardsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monsterbookcardsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.monsterbookcardsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monsterbookcardsPayload>
          }
          findFirst: {
            args: Prisma.monsterbookcardsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monsterbookcardsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.monsterbookcardsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monsterbookcardsPayload>
          }
          findMany: {
            args: Prisma.monsterbookcardsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monsterbookcardsPayload>[]
          }
          create: {
            args: Prisma.monsterbookcardsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monsterbookcardsPayload>
          }
          createMany: {
            args: Prisma.monsterbookcardsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.monsterbookcardsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monsterbookcardsPayload>
          }
          update: {
            args: Prisma.monsterbookcardsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monsterbookcardsPayload>
          }
          deleteMany: {
            args: Prisma.monsterbookcardsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.monsterbookcardsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.monsterbookcardsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monsterbookcardsPayload>
          }
          aggregate: {
            args: Prisma.MonsterbookcardsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMonsterbookcards>
          }
          groupBy: {
            args: Prisma.monsterbookcardsGroupByArgs<ExtArgs>
            result: $Utils.Optional<MonsterbookcardsGroupByOutputType>[]
          }
          count: {
            args: Prisma.monsterbookcardsCountArgs<ExtArgs>
            result: $Utils.Optional<MonsterbookcardsCountAggregateOutputType> | number
          }
        }
      }
      monsterbookinfos: {
        payload: Prisma.$monsterbookinfosPayload<ExtArgs>
        fields: Prisma.monsterbookinfosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.monsterbookinfosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monsterbookinfosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.monsterbookinfosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monsterbookinfosPayload>
          }
          findFirst: {
            args: Prisma.monsterbookinfosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monsterbookinfosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.monsterbookinfosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monsterbookinfosPayload>
          }
          findMany: {
            args: Prisma.monsterbookinfosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monsterbookinfosPayload>[]
          }
          create: {
            args: Prisma.monsterbookinfosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monsterbookinfosPayload>
          }
          createMany: {
            args: Prisma.monsterbookinfosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.monsterbookinfosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monsterbookinfosPayload>
          }
          update: {
            args: Prisma.monsterbookinfosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monsterbookinfosPayload>
          }
          deleteMany: {
            args: Prisma.monsterbookinfosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.monsterbookinfosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.monsterbookinfosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monsterbookinfosPayload>
          }
          aggregate: {
            args: Prisma.MonsterbookinfosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMonsterbookinfos>
          }
          groupBy: {
            args: Prisma.monsterbookinfosGroupByArgs<ExtArgs>
            result: $Utils.Optional<MonsterbookinfosGroupByOutputType>[]
          }
          count: {
            args: Prisma.monsterbookinfosCountArgs<ExtArgs>
            result: $Utils.Optional<MonsterbookinfosCountAggregateOutputType> | number
          }
        }
      }
      noncombatstatdaylimit: {
        payload: Prisma.$noncombatstatdaylimitPayload<ExtArgs>
        fields: Prisma.noncombatstatdaylimitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.noncombatstatdaylimitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$noncombatstatdaylimitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.noncombatstatdaylimitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$noncombatstatdaylimitPayload>
          }
          findFirst: {
            args: Prisma.noncombatstatdaylimitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$noncombatstatdaylimitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.noncombatstatdaylimitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$noncombatstatdaylimitPayload>
          }
          findMany: {
            args: Prisma.noncombatstatdaylimitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$noncombatstatdaylimitPayload>[]
          }
          create: {
            args: Prisma.noncombatstatdaylimitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$noncombatstatdaylimitPayload>
          }
          createMany: {
            args: Prisma.noncombatstatdaylimitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.noncombatstatdaylimitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$noncombatstatdaylimitPayload>
          }
          update: {
            args: Prisma.noncombatstatdaylimitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$noncombatstatdaylimitPayload>
          }
          deleteMany: {
            args: Prisma.noncombatstatdaylimitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.noncombatstatdaylimitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.noncombatstatdaylimitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$noncombatstatdaylimitPayload>
          }
          aggregate: {
            args: Prisma.NoncombatstatdaylimitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNoncombatstatdaylimit>
          }
          groupBy: {
            args: Prisma.noncombatstatdaylimitGroupByArgs<ExtArgs>
            result: $Utils.Optional<NoncombatstatdaylimitGroupByOutputType>[]
          }
          count: {
            args: Prisma.noncombatstatdaylimitCountArgs<ExtArgs>
            result: $Utils.Optional<NoncombatstatdaylimitCountAggregateOutputType> | number
          }
        }
      }
      npc: {
        payload: Prisma.$npcPayload<ExtArgs>
        fields: Prisma.npcFieldRefs
        operations: {
          findUnique: {
            args: Prisma.npcFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$npcPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.npcFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$npcPayload>
          }
          findFirst: {
            args: Prisma.npcFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$npcPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.npcFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$npcPayload>
          }
          findMany: {
            args: Prisma.npcFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$npcPayload>[]
          }
          create: {
            args: Prisma.npcCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$npcPayload>
          }
          createMany: {
            args: Prisma.npcCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.npcDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$npcPayload>
          }
          update: {
            args: Prisma.npcUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$npcPayload>
          }
          deleteMany: {
            args: Prisma.npcDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.npcUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.npcUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$npcPayload>
          }
          aggregate: {
            args: Prisma.NpcAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNpc>
          }
          groupBy: {
            args: Prisma.npcGroupByArgs<ExtArgs>
            result: $Utils.Optional<NpcGroupByOutputType>[]
          }
          count: {
            args: Prisma.npcCountArgs<ExtArgs>
            result: $Utils.Optional<NpcCountAggregateOutputType> | number
          }
        }
      }
      offense_managers: {
        payload: Prisma.$offense_managersPayload<ExtArgs>
        fields: Prisma.offense_managersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.offense_managersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$offense_managersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.offense_managersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$offense_managersPayload>
          }
          findFirst: {
            args: Prisma.offense_managersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$offense_managersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.offense_managersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$offense_managersPayload>
          }
          findMany: {
            args: Prisma.offense_managersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$offense_managersPayload>[]
          }
          create: {
            args: Prisma.offense_managersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$offense_managersPayload>
          }
          createMany: {
            args: Prisma.offense_managersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.offense_managersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$offense_managersPayload>
          }
          update: {
            args: Prisma.offense_managersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$offense_managersPayload>
          }
          deleteMany: {
            args: Prisma.offense_managersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.offense_managersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.offense_managersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$offense_managersPayload>
          }
          aggregate: {
            args: Prisma.Offense_managersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOffense_managers>
          }
          groupBy: {
            args: Prisma.offense_managersGroupByArgs<ExtArgs>
            result: $Utils.Optional<Offense_managersGroupByOutputType>[]
          }
          count: {
            args: Prisma.offense_managersCountArgs<ExtArgs>
            result: $Utils.Optional<Offense_managersCountAggregateOutputType> | number
          }
        }
      }
      offenses: {
        payload: Prisma.$offensesPayload<ExtArgs>
        fields: Prisma.offensesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.offensesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$offensesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.offensesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$offensesPayload>
          }
          findFirst: {
            args: Prisma.offensesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$offensesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.offensesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$offensesPayload>
          }
          findMany: {
            args: Prisma.offensesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$offensesPayload>[]
          }
          create: {
            args: Prisma.offensesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$offensesPayload>
          }
          createMany: {
            args: Prisma.offensesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.offensesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$offensesPayload>
          }
          update: {
            args: Prisma.offensesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$offensesPayload>
          }
          deleteMany: {
            args: Prisma.offensesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.offensesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.offensesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$offensesPayload>
          }
          aggregate: {
            args: Prisma.OffensesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOffenses>
          }
          groupBy: {
            args: Prisma.offensesGroupByArgs<ExtArgs>
            result: $Utils.Optional<OffensesGroupByOutputType>[]
          }
          count: {
            args: Prisma.offensesCountArgs<ExtArgs>
            result: $Utils.Optional<OffensesCountAggregateOutputType> | number
          }
        }
      }
      party: {
        payload: Prisma.$partyPayload<ExtArgs>
        fields: Prisma.partyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.partyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$partyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.partyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$partyPayload>
          }
          findFirst: {
            args: Prisma.partyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$partyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.partyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$partyPayload>
          }
          findMany: {
            args: Prisma.partyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$partyPayload>[]
          }
          create: {
            args: Prisma.partyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$partyPayload>
          }
          createMany: {
            args: Prisma.partyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.partyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$partyPayload>
          }
          update: {
            args: Prisma.partyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$partyPayload>
          }
          deleteMany: {
            args: Prisma.partyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.partyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.partyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$partyPayload>
          }
          aggregate: {
            args: Prisma.PartyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParty>
          }
          groupBy: {
            args: Prisma.partyGroupByArgs<ExtArgs>
            result: $Utils.Optional<PartyGroupByOutputType>[]
          }
          count: {
            args: Prisma.partyCountArgs<ExtArgs>
            result: $Utils.Optional<PartyCountAggregateOutputType> | number
          }
        }
      }
      partyboss: {
        payload: Prisma.$partybossPayload<ExtArgs>
        fields: Prisma.partybossFieldRefs
        operations: {
          findUnique: {
            args: Prisma.partybossFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$partybossPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.partybossFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$partybossPayload>
          }
          findFirst: {
            args: Prisma.partybossFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$partybossPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.partybossFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$partybossPayload>
          }
          findMany: {
            args: Prisma.partybossFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$partybossPayload>[]
          }
          create: {
            args: Prisma.partybossCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$partybossPayload>
          }
          createMany: {
            args: Prisma.partybossCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.partybossDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$partybossPayload>
          }
          update: {
            args: Prisma.partybossUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$partybossPayload>
          }
          deleteMany: {
            args: Prisma.partybossDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.partybossUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.partybossUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$partybossPayload>
          }
          aggregate: {
            args: Prisma.PartybossAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePartyboss>
          }
          groupBy: {
            args: Prisma.partybossGroupByArgs<ExtArgs>
            result: $Utils.Optional<PartybossGroupByOutputType>[]
          }
          count: {
            args: Prisma.partybossCountArgs<ExtArgs>
            result: $Utils.Optional<PartybossCountAggregateOutputType> | number
          }
        }
      }
      partymembers: {
        payload: Prisma.$partymembersPayload<ExtArgs>
        fields: Prisma.partymembersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.partymembersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$partymembersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.partymembersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$partymembersPayload>
          }
          findFirst: {
            args: Prisma.partymembersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$partymembersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.partymembersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$partymembersPayload>
          }
          findMany: {
            args: Prisma.partymembersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$partymembersPayload>[]
          }
          create: {
            args: Prisma.partymembersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$partymembersPayload>
          }
          createMany: {
            args: Prisma.partymembersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.partymembersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$partymembersPayload>
          }
          update: {
            args: Prisma.partymembersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$partymembersPayload>
          }
          deleteMany: {
            args: Prisma.partymembersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.partymembersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.partymembersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$partymembersPayload>
          }
          aggregate: {
            args: Prisma.PartymembersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePartymembers>
          }
          groupBy: {
            args: Prisma.partymembersGroupByArgs<ExtArgs>
            result: $Utils.Optional<PartymembersGroupByOutputType>[]
          }
          count: {
            args: Prisma.partymembersCountArgs<ExtArgs>
            result: $Utils.Optional<PartymembersCountAggregateOutputType> | number
          }
        }
      }
      petids: {
        payload: Prisma.$petidsPayload<ExtArgs>
        fields: Prisma.petidsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.petidsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$petidsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.petidsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$petidsPayload>
          }
          findFirst: {
            args: Prisma.petidsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$petidsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.petidsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$petidsPayload>
          }
          findMany: {
            args: Prisma.petidsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$petidsPayload>[]
          }
          create: {
            args: Prisma.petidsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$petidsPayload>
          }
          createMany: {
            args: Prisma.petidsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.petidsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$petidsPayload>
          }
          update: {
            args: Prisma.petidsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$petidsPayload>
          }
          deleteMany: {
            args: Prisma.petidsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.petidsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.petidsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$petidsPayload>
          }
          aggregate: {
            args: Prisma.PetidsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePetids>
          }
          groupBy: {
            args: Prisma.petidsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PetidsGroupByOutputType>[]
          }
          count: {
            args: Prisma.petidsCountArgs<ExtArgs>
            result: $Utils.Optional<PetidsCountAggregateOutputType> | number
          }
        }
      }
      petitems: {
        payload: Prisma.$petitemsPayload<ExtArgs>
        fields: Prisma.petitemsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.petitemsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$petitemsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.petitemsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$petitemsPayload>
          }
          findFirst: {
            args: Prisma.petitemsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$petitemsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.petitemsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$petitemsPayload>
          }
          findMany: {
            args: Prisma.petitemsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$petitemsPayload>[]
          }
          create: {
            args: Prisma.petitemsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$petitemsPayload>
          }
          createMany: {
            args: Prisma.petitemsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.petitemsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$petitemsPayload>
          }
          update: {
            args: Prisma.petitemsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$petitemsPayload>
          }
          deleteMany: {
            args: Prisma.petitemsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.petitemsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.petitemsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$petitemsPayload>
          }
          aggregate: {
            args: Prisma.PetitemsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePetitems>
          }
          groupBy: {
            args: Prisma.petitemsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PetitemsGroupByOutputType>[]
          }
          count: {
            args: Prisma.petitemsCountArgs<ExtArgs>
            result: $Utils.Optional<PetitemsCountAggregateOutputType> | number
          }
        }
      }
      questlists: {
        payload: Prisma.$questlistsPayload<ExtArgs>
        fields: Prisma.questlistsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.questlistsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questlistsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.questlistsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questlistsPayload>
          }
          findFirst: {
            args: Prisma.questlistsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questlistsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.questlistsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questlistsPayload>
          }
          findMany: {
            args: Prisma.questlistsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questlistsPayload>[]
          }
          create: {
            args: Prisma.questlistsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questlistsPayload>
          }
          createMany: {
            args: Prisma.questlistsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.questlistsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questlistsPayload>
          }
          update: {
            args: Prisma.questlistsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questlistsPayload>
          }
          deleteMany: {
            args: Prisma.questlistsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.questlistsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.questlistsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questlistsPayload>
          }
          aggregate: {
            args: Prisma.QuestlistsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestlists>
          }
          groupBy: {
            args: Prisma.questlistsGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestlistsGroupByOutputType>[]
          }
          count: {
            args: Prisma.questlistsCountArgs<ExtArgs>
            result: $Utils.Optional<QuestlistsCountAggregateOutputType> | number
          }
        }
      }
      questmanagers: {
        payload: Prisma.$questmanagersPayload<ExtArgs>
        fields: Prisma.questmanagersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.questmanagersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questmanagersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.questmanagersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questmanagersPayload>
          }
          findFirst: {
            args: Prisma.questmanagersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questmanagersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.questmanagersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questmanagersPayload>
          }
          findMany: {
            args: Prisma.questmanagersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questmanagersPayload>[]
          }
          create: {
            args: Prisma.questmanagersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questmanagersPayload>
          }
          createMany: {
            args: Prisma.questmanagersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.questmanagersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questmanagersPayload>
          }
          update: {
            args: Prisma.questmanagersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questmanagersPayload>
          }
          deleteMany: {
            args: Prisma.questmanagersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.questmanagersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.questmanagersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questmanagersPayload>
          }
          aggregate: {
            args: Prisma.QuestmanagersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestmanagers>
          }
          groupBy: {
            args: Prisma.questmanagersGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestmanagersGroupByOutputType>[]
          }
          count: {
            args: Prisma.questmanagersCountArgs<ExtArgs>
            result: $Utils.Optional<QuestmanagersCountAggregateOutputType> | number
          }
        }
      }
      questprogressrequirements: {
        payload: Prisma.$questprogressrequirementsPayload<ExtArgs>
        fields: Prisma.questprogressrequirementsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.questprogressrequirementsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questprogressrequirementsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.questprogressrequirementsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questprogressrequirementsPayload>
          }
          findFirst: {
            args: Prisma.questprogressrequirementsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questprogressrequirementsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.questprogressrequirementsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questprogressrequirementsPayload>
          }
          findMany: {
            args: Prisma.questprogressrequirementsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questprogressrequirementsPayload>[]
          }
          create: {
            args: Prisma.questprogressrequirementsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questprogressrequirementsPayload>
          }
          createMany: {
            args: Prisma.questprogressrequirementsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.questprogressrequirementsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questprogressrequirementsPayload>
          }
          update: {
            args: Prisma.questprogressrequirementsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questprogressrequirementsPayload>
          }
          deleteMany: {
            args: Prisma.questprogressrequirementsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.questprogressrequirementsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.questprogressrequirementsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questprogressrequirementsPayload>
          }
          aggregate: {
            args: Prisma.QuestprogressrequirementsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestprogressrequirements>
          }
          groupBy: {
            args: Prisma.questprogressrequirementsGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestprogressrequirementsGroupByOutputType>[]
          }
          count: {
            args: Prisma.questprogressrequirementsCountArgs<ExtArgs>
            result: $Utils.Optional<QuestprogressrequirementsCountAggregateOutputType> | number
          }
        }
      }
      quests: {
        payload: Prisma.$questsPayload<ExtArgs>
        fields: Prisma.questsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.questsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.questsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questsPayload>
          }
          findFirst: {
            args: Prisma.questsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.questsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questsPayload>
          }
          findMany: {
            args: Prisma.questsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questsPayload>[]
          }
          create: {
            args: Prisma.questsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questsPayload>
          }
          createMany: {
            args: Prisma.questsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.questsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questsPayload>
          }
          update: {
            args: Prisma.questsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questsPayload>
          }
          deleteMany: {
            args: Prisma.questsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.questsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.questsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questsPayload>
          }
          aggregate: {
            args: Prisma.QuestsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuests>
          }
          groupBy: {
            args: Prisma.questsGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestsGroupByOutputType>[]
          }
          count: {
            args: Prisma.questsCountArgs<ExtArgs>
            result: $Utils.Optional<QuestsCountAggregateOutputType> | number
          }
        }
      }
      rewardinfo: {
        payload: Prisma.$rewardinfoPayload<ExtArgs>
        fields: Prisma.rewardinfoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.rewardinfoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rewardinfoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.rewardinfoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rewardinfoPayload>
          }
          findFirst: {
            args: Prisma.rewardinfoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rewardinfoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.rewardinfoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rewardinfoPayload>
          }
          findMany: {
            args: Prisma.rewardinfoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rewardinfoPayload>[]
          }
          create: {
            args: Prisma.rewardinfoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rewardinfoPayload>
          }
          createMany: {
            args: Prisma.rewardinfoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.rewardinfoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rewardinfoPayload>
          }
          update: {
            args: Prisma.rewardinfoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rewardinfoPayload>
          }
          deleteMany: {
            args: Prisma.rewardinfoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.rewardinfoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.rewardinfoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rewardinfoPayload>
          }
          aggregate: {
            args: Prisma.RewardinfoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRewardinfo>
          }
          groupBy: {
            args: Prisma.rewardinfoGroupByArgs<ExtArgs>
            result: $Utils.Optional<RewardinfoGroupByOutputType>[]
          }
          count: {
            args: Prisma.rewardinfoCountArgs<ExtArgs>
            result: $Utils.Optional<RewardinfoCountAggregateOutputType> | number
          }
        }
      }
      shopitems: {
        payload: Prisma.$shopitemsPayload<ExtArgs>
        fields: Prisma.shopitemsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.shopitemsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shopitemsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.shopitemsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shopitemsPayload>
          }
          findFirst: {
            args: Prisma.shopitemsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shopitemsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.shopitemsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shopitemsPayload>
          }
          findMany: {
            args: Prisma.shopitemsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shopitemsPayload>[]
          }
          create: {
            args: Prisma.shopitemsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shopitemsPayload>
          }
          createMany: {
            args: Prisma.shopitemsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.shopitemsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shopitemsPayload>
          }
          update: {
            args: Prisma.shopitemsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shopitemsPayload>
          }
          deleteMany: {
            args: Prisma.shopitemsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.shopitemsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.shopitemsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shopitemsPayload>
          }
          aggregate: {
            args: Prisma.ShopitemsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShopitems>
          }
          groupBy: {
            args: Prisma.shopitemsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShopitemsGroupByOutputType>[]
          }
          count: {
            args: Prisma.shopitemsCountArgs<ExtArgs>
            result: $Utils.Optional<ShopitemsCountAggregateOutputType> | number
          }
        }
      }
      skillcooltimes: {
        payload: Prisma.$skillcooltimesPayload<ExtArgs>
        fields: Prisma.skillcooltimesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.skillcooltimesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillcooltimesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.skillcooltimesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillcooltimesPayload>
          }
          findFirst: {
            args: Prisma.skillcooltimesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillcooltimesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.skillcooltimesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillcooltimesPayload>
          }
          findMany: {
            args: Prisma.skillcooltimesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillcooltimesPayload>[]
          }
          create: {
            args: Prisma.skillcooltimesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillcooltimesPayload>
          }
          createMany: {
            args: Prisma.skillcooltimesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.skillcooltimesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillcooltimesPayload>
          }
          update: {
            args: Prisma.skillcooltimesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillcooltimesPayload>
          }
          deleteMany: {
            args: Prisma.skillcooltimesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.skillcooltimesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.skillcooltimesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillcooltimesPayload>
          }
          aggregate: {
            args: Prisma.SkillcooltimesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSkillcooltimes>
          }
          groupBy: {
            args: Prisma.skillcooltimesGroupByArgs<ExtArgs>
            result: $Utils.Optional<SkillcooltimesGroupByOutputType>[]
          }
          count: {
            args: Prisma.skillcooltimesCountArgs<ExtArgs>
            result: $Utils.Optional<SkillcooltimesCountAggregateOutputType> | number
          }
        }
      }
      skills: {
        payload: Prisma.$skillsPayload<ExtArgs>
        fields: Prisma.skillsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.skillsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.skillsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillsPayload>
          }
          findFirst: {
            args: Prisma.skillsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.skillsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillsPayload>
          }
          findMany: {
            args: Prisma.skillsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillsPayload>[]
          }
          create: {
            args: Prisma.skillsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillsPayload>
          }
          createMany: {
            args: Prisma.skillsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.skillsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillsPayload>
          }
          update: {
            args: Prisma.skillsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillsPayload>
          }
          deleteMany: {
            args: Prisma.skillsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.skillsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.skillsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillsPayload>
          }
          aggregate: {
            args: Prisma.SkillsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSkills>
          }
          groupBy: {
            args: Prisma.skillsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SkillsGroupByOutputType>[]
          }
          count: {
            args: Prisma.skillsCountArgs<ExtArgs>
            result: $Utils.Optional<SkillsCountAggregateOutputType> | number
          }
        }
      }
      spset: {
        payload: Prisma.$spsetPayload<ExtArgs>
        fields: Prisma.spsetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.spsetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$spsetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.spsetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$spsetPayload>
          }
          findFirst: {
            args: Prisma.spsetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$spsetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.spsetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$spsetPayload>
          }
          findMany: {
            args: Prisma.spsetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$spsetPayload>[]
          }
          create: {
            args: Prisma.spsetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$spsetPayload>
          }
          createMany: {
            args: Prisma.spsetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.spsetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$spsetPayload>
          }
          update: {
            args: Prisma.spsetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$spsetPayload>
          }
          deleteMany: {
            args: Prisma.spsetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.spsetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.spsetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$spsetPayload>
          }
          aggregate: {
            args: Prisma.SpsetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpset>
          }
          groupBy: {
            args: Prisma.spsetGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpsetGroupByOutputType>[]
          }
          count: {
            args: Prisma.spsetCountArgs<ExtArgs>
            result: $Utils.Optional<SpsetCountAggregateOutputType> | number
          }
        }
      }
      stolenskills: {
        payload: Prisma.$stolenskillsPayload<ExtArgs>
        fields: Prisma.stolenskillsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.stolenskillsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stolenskillsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.stolenskillsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stolenskillsPayload>
          }
          findFirst: {
            args: Prisma.stolenskillsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stolenskillsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.stolenskillsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stolenskillsPayload>
          }
          findMany: {
            args: Prisma.stolenskillsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stolenskillsPayload>[]
          }
          create: {
            args: Prisma.stolenskillsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stolenskillsPayload>
          }
          createMany: {
            args: Prisma.stolenskillsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.stolenskillsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stolenskillsPayload>
          }
          update: {
            args: Prisma.stolenskillsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stolenskillsPayload>
          }
          deleteMany: {
            args: Prisma.stolenskillsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.stolenskillsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.stolenskillsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stolenskillsPayload>
          }
          aggregate: {
            args: Prisma.StolenskillsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStolenskills>
          }
          groupBy: {
            args: Prisma.stolenskillsGroupByArgs<ExtArgs>
            result: $Utils.Optional<StolenskillsGroupByOutputType>[]
          }
          count: {
            args: Prisma.stolenskillsCountArgs<ExtArgs>
            result: $Utils.Optional<StolenskillsCountAggregateOutputType> | number
          }
        }
      }
      systemtimes: {
        payload: Prisma.$systemtimesPayload<ExtArgs>
        fields: Prisma.systemtimesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.systemtimesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$systemtimesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.systemtimesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$systemtimesPayload>
          }
          findFirst: {
            args: Prisma.systemtimesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$systemtimesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.systemtimesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$systemtimesPayload>
          }
          findMany: {
            args: Prisma.systemtimesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$systemtimesPayload>[]
          }
          create: {
            args: Prisma.systemtimesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$systemtimesPayload>
          }
          createMany: {
            args: Prisma.systemtimesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.systemtimesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$systemtimesPayload>
          }
          update: {
            args: Prisma.systemtimesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$systemtimesPayload>
          }
          deleteMany: {
            args: Prisma.systemtimesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.systemtimesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.systemtimesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$systemtimesPayload>
          }
          aggregate: {
            args: Prisma.SystemtimesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemtimes>
          }
          groupBy: {
            args: Prisma.systemtimesGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemtimesGroupByOutputType>[]
          }
          count: {
            args: Prisma.systemtimesCountArgs<ExtArgs>
            result: $Utils.Optional<SystemtimesCountAggregateOutputType> | number
          }
        }
      }
      totems: {
        payload: Prisma.$totemsPayload<ExtArgs>
        fields: Prisma.totemsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.totemsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$totemsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.totemsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$totemsPayload>
          }
          findFirst: {
            args: Prisma.totemsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$totemsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.totemsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$totemsPayload>
          }
          findMany: {
            args: Prisma.totemsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$totemsPayload>[]
          }
          create: {
            args: Prisma.totemsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$totemsPayload>
          }
          createMany: {
            args: Prisma.totemsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.totemsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$totemsPayload>
          }
          update: {
            args: Prisma.totemsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$totemsPayload>
          }
          deleteMany: {
            args: Prisma.totemsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.totemsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.totemsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$totemsPayload>
          }
          aggregate: {
            args: Prisma.TotemsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTotems>
          }
          groupBy: {
            args: Prisma.totemsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TotemsGroupByOutputType>[]
          }
          count: {
            args: Prisma.totemsCountArgs<ExtArgs>
            result: $Utils.Optional<TotemsCountAggregateOutputType> | number
          }
        }
      }
      trunks: {
        payload: Prisma.$trunksPayload<ExtArgs>
        fields: Prisma.trunksFieldRefs
        operations: {
          findUnique: {
            args: Prisma.trunksFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trunksPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.trunksFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trunksPayload>
          }
          findFirst: {
            args: Prisma.trunksFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trunksPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.trunksFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trunksPayload>
          }
          findMany: {
            args: Prisma.trunksFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trunksPayload>[]
          }
          create: {
            args: Prisma.trunksCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trunksPayload>
          }
          createMany: {
            args: Prisma.trunksCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.trunksDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trunksPayload>
          }
          update: {
            args: Prisma.trunksUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trunksPayload>
          }
          deleteMany: {
            args: Prisma.trunksDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.trunksUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.trunksUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trunksPayload>
          }
          aggregate: {
            args: Prisma.TrunksAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrunks>
          }
          groupBy: {
            args: Prisma.trunksGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrunksGroupByOutputType>[]
          }
          count: {
            args: Prisma.trunksCountArgs<ExtArgs>
            result: $Utils.Optional<TrunksCountAggregateOutputType> | number
          }
        }
      }
      unseenequips: {
        payload: Prisma.$unseenequipsPayload<ExtArgs>
        fields: Prisma.unseenequipsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.unseenequipsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$unseenequipsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.unseenequipsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$unseenequipsPayload>
          }
          findFirst: {
            args: Prisma.unseenequipsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$unseenequipsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.unseenequipsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$unseenequipsPayload>
          }
          findMany: {
            args: Prisma.unseenequipsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$unseenequipsPayload>[]
          }
          create: {
            args: Prisma.unseenequipsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$unseenequipsPayload>
          }
          createMany: {
            args: Prisma.unseenequipsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.unseenequipsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$unseenequipsPayload>
          }
          update: {
            args: Prisma.unseenequipsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$unseenequipsPayload>
          }
          deleteMany: {
            args: Prisma.unseenequipsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.unseenequipsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.unseenequipsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$unseenequipsPayload>
          }
          aggregate: {
            args: Prisma.UnseenequipsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnseenequips>
          }
          groupBy: {
            args: Prisma.unseenequipsGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnseenequipsGroupByOutputType>[]
          }
          count: {
            args: Prisma.unseenequipsCountArgs<ExtArgs>
            result: $Utils.Optional<UnseenequipsCountAggregateOutputType> | number
          }
        }
      }
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */



  /**
   * Models
   */

  /**
   * Model accounts
   */

  export type AggregateAccounts = {
    _count: AccountsCountAggregateOutputType | null
    _avg: AccountsAvgAggregateOutputType | null
    _sum: AccountsSumAggregateOutputType | null
    _min: AccountsMinAggregateOutputType | null
    _max: AccountsMaxAggregateOutputType | null
  }

  export type AccountsAvgAggregateOutputType = {
    id: number | null
    worldid: number | null
    userid: number | null
    trunkid: number | null
    nxCredit: number | null
    monstercollectionid: number | null
    employeetrunkid: number | null
  }

  export type AccountsSumAggregateOutputType = {
    id: number | null
    worldid: number | null
    userid: number | null
    trunkid: number | null
    nxCredit: number | null
    monstercollectionid: number | null
    employeetrunkid: number | null
  }

  export type AccountsMinAggregateOutputType = {
    id: number | null
    worldid: number | null
    userid: number | null
    trunkid: number | null
    nxCredit: number | null
    monstercollectionid: number | null
    employeetrunkid: number | null
  }

  export type AccountsMaxAggregateOutputType = {
    id: number | null
    worldid: number | null
    userid: number | null
    trunkid: number | null
    nxCredit: number | null
    monstercollectionid: number | null
    employeetrunkid: number | null
  }

  export type AccountsCountAggregateOutputType = {
    id: number
    worldid: number
    userid: number
    trunkid: number
    nxCredit: number
    monstercollectionid: number
    employeetrunkid: number
    _all: number
  }


  export type AccountsAvgAggregateInputType = {
    id?: true
    worldid?: true
    userid?: true
    trunkid?: true
    nxCredit?: true
    monstercollectionid?: true
    employeetrunkid?: true
  }

  export type AccountsSumAggregateInputType = {
    id?: true
    worldid?: true
    userid?: true
    trunkid?: true
    nxCredit?: true
    monstercollectionid?: true
    employeetrunkid?: true
  }

  export type AccountsMinAggregateInputType = {
    id?: true
    worldid?: true
    userid?: true
    trunkid?: true
    nxCredit?: true
    monstercollectionid?: true
    employeetrunkid?: true
  }

  export type AccountsMaxAggregateInputType = {
    id?: true
    worldid?: true
    userid?: true
    trunkid?: true
    nxCredit?: true
    monstercollectionid?: true
    employeetrunkid?: true
  }

  export type AccountsCountAggregateInputType = {
    id?: true
    worldid?: true
    userid?: true
    trunkid?: true
    nxCredit?: true
    monstercollectionid?: true
    employeetrunkid?: true
    _all?: true
  }

  export type AccountsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which accounts to aggregate.
     */
    where?: accountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accounts to fetch.
     */
    orderBy?: accountsOrderByWithRelationInput | accountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: accountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned accounts
    **/
    _count?: true | AccountsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountsMaxAggregateInputType
  }

  export type GetAccountsAggregateType<T extends AccountsAggregateArgs> = {
        [P in keyof T & keyof AggregateAccounts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccounts[P]>
      : GetScalarType<T[P], AggregateAccounts[P]>
  }




  export type accountsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: accountsWhereInput
    orderBy?: accountsOrderByWithAggregationInput | accountsOrderByWithAggregationInput[]
    by: AccountsScalarFieldEnum[] | AccountsScalarFieldEnum
    having?: accountsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountsCountAggregateInputType | true
    _avg?: AccountsAvgAggregateInputType
    _sum?: AccountsSumAggregateInputType
    _min?: AccountsMinAggregateInputType
    _max?: AccountsMaxAggregateInputType
  }

  export type AccountsGroupByOutputType = {
    id: number
    worldid: number | null
    userid: number | null
    trunkid: number | null
    nxCredit: number | null
    monstercollectionid: number | null
    employeetrunkid: number | null
    _count: AccountsCountAggregateOutputType | null
    _avg: AccountsAvgAggregateOutputType | null
    _sum: AccountsSumAggregateOutputType | null
    _min: AccountsMinAggregateOutputType | null
    _max: AccountsMaxAggregateOutputType | null
  }

  type GetAccountsGroupByPayload<T extends accountsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountsGroupByOutputType[P]>
            : GetScalarType<T[P], AccountsGroupByOutputType[P]>
        }
      >
    >


  export type accountsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    worldid?: boolean
    userid?: boolean
    trunkid?: boolean
    nxCredit?: boolean
    monstercollectionid?: boolean
    employeetrunkid?: boolean
  }, ExtArgs["result"]["accounts"]>


  export type accountsSelectScalar = {
    id?: boolean
    worldid?: boolean
    userid?: boolean
    trunkid?: boolean
    nxCredit?: boolean
    monstercollectionid?: boolean
    employeetrunkid?: boolean
  }


  export type $accountsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "accounts"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      worldid: number | null
      userid: number | null
      trunkid: number | null
      nxCredit: number | null
      monstercollectionid: number | null
      employeetrunkid: number | null
    }, ExtArgs["result"]["accounts"]>
    composites: {}
  }

  type accountsGetPayload<S extends boolean | null | undefined | accountsDefaultArgs> = $Result.GetResult<Prisma.$accountsPayload, S>

  type accountsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<accountsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AccountsCountAggregateInputType | true
    }

  export interface accountsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['accounts'], meta: { name: 'accounts' } }
    /**
     * Find zero or one Accounts that matches the filter.
     * @param {accountsFindUniqueArgs} args - Arguments to find a Accounts
     * @example
     * // Get one Accounts
     * const accounts = await prisma.accounts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends accountsFindUniqueArgs>(args: SelectSubset<T, accountsFindUniqueArgs<ExtArgs>>): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Accounts that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {accountsFindUniqueOrThrowArgs} args - Arguments to find a Accounts
     * @example
     * // Get one Accounts
     * const accounts = await prisma.accounts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends accountsFindUniqueOrThrowArgs>(args: SelectSubset<T, accountsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountsFindFirstArgs} args - Arguments to find a Accounts
     * @example
     * // Get one Accounts
     * const accounts = await prisma.accounts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends accountsFindFirstArgs>(args?: SelectSubset<T, accountsFindFirstArgs<ExtArgs>>): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Accounts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountsFindFirstOrThrowArgs} args - Arguments to find a Accounts
     * @example
     * // Get one Accounts
     * const accounts = await prisma.accounts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends accountsFindFirstOrThrowArgs>(args?: SelectSubset<T, accountsFindFirstOrThrowArgs<ExtArgs>>): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.accounts.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.accounts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountsWithIdOnly = await prisma.accounts.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends accountsFindManyArgs>(args?: SelectSubset<T, accountsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Accounts.
     * @param {accountsCreateArgs} args - Arguments to create a Accounts.
     * @example
     * // Create one Accounts
     * const Accounts = await prisma.accounts.create({
     *   data: {
     *     // ... data to create a Accounts
     *   }
     * })
     * 
     */
    create<T extends accountsCreateArgs>(args: SelectSubset<T, accountsCreateArgs<ExtArgs>>): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Accounts.
     * @param {accountsCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const accounts = await prisma.accounts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends accountsCreateManyArgs>(args?: SelectSubset<T, accountsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Accounts.
     * @param {accountsDeleteArgs} args - Arguments to delete one Accounts.
     * @example
     * // Delete one Accounts
     * const Accounts = await prisma.accounts.delete({
     *   where: {
     *     // ... filter to delete one Accounts
     *   }
     * })
     * 
     */
    delete<T extends accountsDeleteArgs>(args: SelectSubset<T, accountsDeleteArgs<ExtArgs>>): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Accounts.
     * @param {accountsUpdateArgs} args - Arguments to update one Accounts.
     * @example
     * // Update one Accounts
     * const accounts = await prisma.accounts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends accountsUpdateArgs>(args: SelectSubset<T, accountsUpdateArgs<ExtArgs>>): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Accounts.
     * @param {accountsDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.accounts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends accountsDeleteManyArgs>(args?: SelectSubset<T, accountsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const accounts = await prisma.accounts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends accountsUpdateManyArgs>(args: SelectSubset<T, accountsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Accounts.
     * @param {accountsUpsertArgs} args - Arguments to update or create a Accounts.
     * @example
     * // Update or create a Accounts
     * const accounts = await prisma.accounts.upsert({
     *   create: {
     *     // ... data to create a Accounts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Accounts we want to update
     *   }
     * })
     */
    upsert<T extends accountsUpsertArgs>(args: SelectSubset<T, accountsUpsertArgs<ExtArgs>>): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountsCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.accounts.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends accountsCountArgs>(
      args?: Subset<T, accountsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountsAggregateArgs>(args: Subset<T, AccountsAggregateArgs>): Prisma.PrismaPromise<GetAccountsAggregateType<T>>

    /**
     * Group by Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends accountsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: accountsGroupByArgs['orderBy'] }
        : { orderBy?: accountsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, accountsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the accounts model
   */
  readonly fields: accountsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for accounts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__accountsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the accounts model
   */ 
  interface accountsFieldRefs {
    readonly id: FieldRef<"accounts", 'Int'>
    readonly worldid: FieldRef<"accounts", 'Int'>
    readonly userid: FieldRef<"accounts", 'Int'>
    readonly trunkid: FieldRef<"accounts", 'Int'>
    readonly nxCredit: FieldRef<"accounts", 'Int'>
    readonly monstercollectionid: FieldRef<"accounts", 'Int'>
    readonly employeetrunkid: FieldRef<"accounts", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * accounts findUnique
   */
  export type accountsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Filter, which accounts to fetch.
     */
    where: accountsWhereUniqueInput
  }

  /**
   * accounts findUniqueOrThrow
   */
  export type accountsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Filter, which accounts to fetch.
     */
    where: accountsWhereUniqueInput
  }

  /**
   * accounts findFirst
   */
  export type accountsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Filter, which accounts to fetch.
     */
    where?: accountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accounts to fetch.
     */
    orderBy?: accountsOrderByWithRelationInput | accountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for accounts.
     */
    cursor?: accountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of accounts.
     */
    distinct?: AccountsScalarFieldEnum | AccountsScalarFieldEnum[]
  }

  /**
   * accounts findFirstOrThrow
   */
  export type accountsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Filter, which accounts to fetch.
     */
    where?: accountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accounts to fetch.
     */
    orderBy?: accountsOrderByWithRelationInput | accountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for accounts.
     */
    cursor?: accountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of accounts.
     */
    distinct?: AccountsScalarFieldEnum | AccountsScalarFieldEnum[]
  }

  /**
   * accounts findMany
   */
  export type accountsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Filter, which accounts to fetch.
     */
    where?: accountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accounts to fetch.
     */
    orderBy?: accountsOrderByWithRelationInput | accountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing accounts.
     */
    cursor?: accountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accounts.
     */
    skip?: number
    distinct?: AccountsScalarFieldEnum | AccountsScalarFieldEnum[]
  }

  /**
   * accounts create
   */
  export type accountsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * The data needed to create a accounts.
     */
    data?: XOR<accountsCreateInput, accountsUncheckedCreateInput>
  }

  /**
   * accounts createMany
   */
  export type accountsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many accounts.
     */
    data: accountsCreateManyInput | accountsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * accounts update
   */
  export type accountsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * The data needed to update a accounts.
     */
    data: XOR<accountsUpdateInput, accountsUncheckedUpdateInput>
    /**
     * Choose, which accounts to update.
     */
    where: accountsWhereUniqueInput
  }

  /**
   * accounts updateMany
   */
  export type accountsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update accounts.
     */
    data: XOR<accountsUpdateManyMutationInput, accountsUncheckedUpdateManyInput>
    /**
     * Filter which accounts to update
     */
    where?: accountsWhereInput
  }

  /**
   * accounts upsert
   */
  export type accountsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * The filter to search for the accounts to update in case it exists.
     */
    where: accountsWhereUniqueInput
    /**
     * In case the accounts found by the `where` argument doesn't exist, create a new accounts with this data.
     */
    create: XOR<accountsCreateInput, accountsUncheckedCreateInput>
    /**
     * In case the accounts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<accountsUpdateInput, accountsUncheckedUpdateInput>
  }

  /**
   * accounts delete
   */
  export type accountsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Filter which accounts to delete.
     */
    where: accountsWhereUniqueInput
  }

  /**
   * accounts deleteMany
   */
  export type accountsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which accounts to delete
     */
    where?: accountsWhereInput
  }

  /**
   * accounts without action
   */
  export type accountsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
  }


  /**
   * Model alliance_gradenames
   */

  export type AggregateAlliance_gradenames = {
    _count: Alliance_gradenamesCountAggregateOutputType | null
    _avg: Alliance_gradenamesAvgAggregateOutputType | null
    _sum: Alliance_gradenamesSumAggregateOutputType | null
    _min: Alliance_gradenamesMinAggregateOutputType | null
    _max: Alliance_gradenamesMaxAggregateOutputType | null
  }

  export type Alliance_gradenamesAvgAggregateOutputType = {
    id: number | null
    allianceid: number | null
  }

  export type Alliance_gradenamesSumAggregateOutputType = {
    id: number | null
    allianceid: number | null
  }

  export type Alliance_gradenamesMinAggregateOutputType = {
    id: number | null
    gradename: string | null
    allianceid: number | null
  }

  export type Alliance_gradenamesMaxAggregateOutputType = {
    id: number | null
    gradename: string | null
    allianceid: number | null
  }

  export type Alliance_gradenamesCountAggregateOutputType = {
    id: number
    gradename: number
    allianceid: number
    _all: number
  }


  export type Alliance_gradenamesAvgAggregateInputType = {
    id?: true
    allianceid?: true
  }

  export type Alliance_gradenamesSumAggregateInputType = {
    id?: true
    allianceid?: true
  }

  export type Alliance_gradenamesMinAggregateInputType = {
    id?: true
    gradename?: true
    allianceid?: true
  }

  export type Alliance_gradenamesMaxAggregateInputType = {
    id?: true
    gradename?: true
    allianceid?: true
  }

  export type Alliance_gradenamesCountAggregateInputType = {
    id?: true
    gradename?: true
    allianceid?: true
    _all?: true
  }

  export type Alliance_gradenamesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which alliance_gradenames to aggregate.
     */
    where?: alliance_gradenamesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of alliance_gradenames to fetch.
     */
    orderBy?: alliance_gradenamesOrderByWithRelationInput | alliance_gradenamesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: alliance_gradenamesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` alliance_gradenames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` alliance_gradenames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned alliance_gradenames
    **/
    _count?: true | Alliance_gradenamesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Alliance_gradenamesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Alliance_gradenamesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Alliance_gradenamesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Alliance_gradenamesMaxAggregateInputType
  }

  export type GetAlliance_gradenamesAggregateType<T extends Alliance_gradenamesAggregateArgs> = {
        [P in keyof T & keyof AggregateAlliance_gradenames]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlliance_gradenames[P]>
      : GetScalarType<T[P], AggregateAlliance_gradenames[P]>
  }




  export type alliance_gradenamesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: alliance_gradenamesWhereInput
    orderBy?: alliance_gradenamesOrderByWithAggregationInput | alliance_gradenamesOrderByWithAggregationInput[]
    by: Alliance_gradenamesScalarFieldEnum[] | Alliance_gradenamesScalarFieldEnum
    having?: alliance_gradenamesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Alliance_gradenamesCountAggregateInputType | true
    _avg?: Alliance_gradenamesAvgAggregateInputType
    _sum?: Alliance_gradenamesSumAggregateInputType
    _min?: Alliance_gradenamesMinAggregateInputType
    _max?: Alliance_gradenamesMaxAggregateInputType
  }

  export type Alliance_gradenamesGroupByOutputType = {
    id: number
    gradename: string | null
    allianceid: number | null
    _count: Alliance_gradenamesCountAggregateOutputType | null
    _avg: Alliance_gradenamesAvgAggregateOutputType | null
    _sum: Alliance_gradenamesSumAggregateOutputType | null
    _min: Alliance_gradenamesMinAggregateOutputType | null
    _max: Alliance_gradenamesMaxAggregateOutputType | null
  }

  type GetAlliance_gradenamesGroupByPayload<T extends alliance_gradenamesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Alliance_gradenamesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Alliance_gradenamesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Alliance_gradenamesGroupByOutputType[P]>
            : GetScalarType<T[P], Alliance_gradenamesGroupByOutputType[P]>
        }
      >
    >


  export type alliance_gradenamesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gradename?: boolean
    allianceid?: boolean
  }, ExtArgs["result"]["alliance_gradenames"]>


  export type alliance_gradenamesSelectScalar = {
    id?: boolean
    gradename?: boolean
    allianceid?: boolean
  }


  export type $alliance_gradenamesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "alliance_gradenames"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      gradename: string | null
      allianceid: number | null
    }, ExtArgs["result"]["alliance_gradenames"]>
    composites: {}
  }

  type alliance_gradenamesGetPayload<S extends boolean | null | undefined | alliance_gradenamesDefaultArgs> = $Result.GetResult<Prisma.$alliance_gradenamesPayload, S>

  type alliance_gradenamesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<alliance_gradenamesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Alliance_gradenamesCountAggregateInputType | true
    }

  export interface alliance_gradenamesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['alliance_gradenames'], meta: { name: 'alliance_gradenames' } }
    /**
     * Find zero or one Alliance_gradenames that matches the filter.
     * @param {alliance_gradenamesFindUniqueArgs} args - Arguments to find a Alliance_gradenames
     * @example
     * // Get one Alliance_gradenames
     * const alliance_gradenames = await prisma.alliance_gradenames.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends alliance_gradenamesFindUniqueArgs>(args: SelectSubset<T, alliance_gradenamesFindUniqueArgs<ExtArgs>>): Prisma__alliance_gradenamesClient<$Result.GetResult<Prisma.$alliance_gradenamesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Alliance_gradenames that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {alliance_gradenamesFindUniqueOrThrowArgs} args - Arguments to find a Alliance_gradenames
     * @example
     * // Get one Alliance_gradenames
     * const alliance_gradenames = await prisma.alliance_gradenames.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends alliance_gradenamesFindUniqueOrThrowArgs>(args: SelectSubset<T, alliance_gradenamesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__alliance_gradenamesClient<$Result.GetResult<Prisma.$alliance_gradenamesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Alliance_gradenames that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alliance_gradenamesFindFirstArgs} args - Arguments to find a Alliance_gradenames
     * @example
     * // Get one Alliance_gradenames
     * const alliance_gradenames = await prisma.alliance_gradenames.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends alliance_gradenamesFindFirstArgs>(args?: SelectSubset<T, alliance_gradenamesFindFirstArgs<ExtArgs>>): Prisma__alliance_gradenamesClient<$Result.GetResult<Prisma.$alliance_gradenamesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Alliance_gradenames that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alliance_gradenamesFindFirstOrThrowArgs} args - Arguments to find a Alliance_gradenames
     * @example
     * // Get one Alliance_gradenames
     * const alliance_gradenames = await prisma.alliance_gradenames.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends alliance_gradenamesFindFirstOrThrowArgs>(args?: SelectSubset<T, alliance_gradenamesFindFirstOrThrowArgs<ExtArgs>>): Prisma__alliance_gradenamesClient<$Result.GetResult<Prisma.$alliance_gradenamesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Alliance_gradenames that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alliance_gradenamesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Alliance_gradenames
     * const alliance_gradenames = await prisma.alliance_gradenames.findMany()
     * 
     * // Get first 10 Alliance_gradenames
     * const alliance_gradenames = await prisma.alliance_gradenames.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const alliance_gradenamesWithIdOnly = await prisma.alliance_gradenames.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends alliance_gradenamesFindManyArgs>(args?: SelectSubset<T, alliance_gradenamesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$alliance_gradenamesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Alliance_gradenames.
     * @param {alliance_gradenamesCreateArgs} args - Arguments to create a Alliance_gradenames.
     * @example
     * // Create one Alliance_gradenames
     * const Alliance_gradenames = await prisma.alliance_gradenames.create({
     *   data: {
     *     // ... data to create a Alliance_gradenames
     *   }
     * })
     * 
     */
    create<T extends alliance_gradenamesCreateArgs>(args: SelectSubset<T, alliance_gradenamesCreateArgs<ExtArgs>>): Prisma__alliance_gradenamesClient<$Result.GetResult<Prisma.$alliance_gradenamesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Alliance_gradenames.
     * @param {alliance_gradenamesCreateManyArgs} args - Arguments to create many Alliance_gradenames.
     * @example
     * // Create many Alliance_gradenames
     * const alliance_gradenames = await prisma.alliance_gradenames.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends alliance_gradenamesCreateManyArgs>(args?: SelectSubset<T, alliance_gradenamesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Alliance_gradenames.
     * @param {alliance_gradenamesDeleteArgs} args - Arguments to delete one Alliance_gradenames.
     * @example
     * // Delete one Alliance_gradenames
     * const Alliance_gradenames = await prisma.alliance_gradenames.delete({
     *   where: {
     *     // ... filter to delete one Alliance_gradenames
     *   }
     * })
     * 
     */
    delete<T extends alliance_gradenamesDeleteArgs>(args: SelectSubset<T, alliance_gradenamesDeleteArgs<ExtArgs>>): Prisma__alliance_gradenamesClient<$Result.GetResult<Prisma.$alliance_gradenamesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Alliance_gradenames.
     * @param {alliance_gradenamesUpdateArgs} args - Arguments to update one Alliance_gradenames.
     * @example
     * // Update one Alliance_gradenames
     * const alliance_gradenames = await prisma.alliance_gradenames.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends alliance_gradenamesUpdateArgs>(args: SelectSubset<T, alliance_gradenamesUpdateArgs<ExtArgs>>): Prisma__alliance_gradenamesClient<$Result.GetResult<Prisma.$alliance_gradenamesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Alliance_gradenames.
     * @param {alliance_gradenamesDeleteManyArgs} args - Arguments to filter Alliance_gradenames to delete.
     * @example
     * // Delete a few Alliance_gradenames
     * const { count } = await prisma.alliance_gradenames.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends alliance_gradenamesDeleteManyArgs>(args?: SelectSubset<T, alliance_gradenamesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alliance_gradenames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alliance_gradenamesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Alliance_gradenames
     * const alliance_gradenames = await prisma.alliance_gradenames.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends alliance_gradenamesUpdateManyArgs>(args: SelectSubset<T, alliance_gradenamesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Alliance_gradenames.
     * @param {alliance_gradenamesUpsertArgs} args - Arguments to update or create a Alliance_gradenames.
     * @example
     * // Update or create a Alliance_gradenames
     * const alliance_gradenames = await prisma.alliance_gradenames.upsert({
     *   create: {
     *     // ... data to create a Alliance_gradenames
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Alliance_gradenames we want to update
     *   }
     * })
     */
    upsert<T extends alliance_gradenamesUpsertArgs>(args: SelectSubset<T, alliance_gradenamesUpsertArgs<ExtArgs>>): Prisma__alliance_gradenamesClient<$Result.GetResult<Prisma.$alliance_gradenamesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Alliance_gradenames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alliance_gradenamesCountArgs} args - Arguments to filter Alliance_gradenames to count.
     * @example
     * // Count the number of Alliance_gradenames
     * const count = await prisma.alliance_gradenames.count({
     *   where: {
     *     // ... the filter for the Alliance_gradenames we want to count
     *   }
     * })
    **/
    count<T extends alliance_gradenamesCountArgs>(
      args?: Subset<T, alliance_gradenamesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Alliance_gradenamesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Alliance_gradenames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Alliance_gradenamesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Alliance_gradenamesAggregateArgs>(args: Subset<T, Alliance_gradenamesAggregateArgs>): Prisma.PrismaPromise<GetAlliance_gradenamesAggregateType<T>>

    /**
     * Group by Alliance_gradenames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alliance_gradenamesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends alliance_gradenamesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: alliance_gradenamesGroupByArgs['orderBy'] }
        : { orderBy?: alliance_gradenamesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, alliance_gradenamesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlliance_gradenamesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the alliance_gradenames model
   */
  readonly fields: alliance_gradenamesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for alliance_gradenames.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__alliance_gradenamesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the alliance_gradenames model
   */ 
  interface alliance_gradenamesFieldRefs {
    readonly id: FieldRef<"alliance_gradenames", 'Int'>
    readonly gradename: FieldRef<"alliance_gradenames", 'String'>
    readonly allianceid: FieldRef<"alliance_gradenames", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * alliance_gradenames findUnique
   */
  export type alliance_gradenamesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alliance_gradenames
     */
    select?: alliance_gradenamesSelect<ExtArgs> | null
    /**
     * Filter, which alliance_gradenames to fetch.
     */
    where: alliance_gradenamesWhereUniqueInput
  }

  /**
   * alliance_gradenames findUniqueOrThrow
   */
  export type alliance_gradenamesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alliance_gradenames
     */
    select?: alliance_gradenamesSelect<ExtArgs> | null
    /**
     * Filter, which alliance_gradenames to fetch.
     */
    where: alliance_gradenamesWhereUniqueInput
  }

  /**
   * alliance_gradenames findFirst
   */
  export type alliance_gradenamesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alliance_gradenames
     */
    select?: alliance_gradenamesSelect<ExtArgs> | null
    /**
     * Filter, which alliance_gradenames to fetch.
     */
    where?: alliance_gradenamesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of alliance_gradenames to fetch.
     */
    orderBy?: alliance_gradenamesOrderByWithRelationInput | alliance_gradenamesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for alliance_gradenames.
     */
    cursor?: alliance_gradenamesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` alliance_gradenames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` alliance_gradenames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of alliance_gradenames.
     */
    distinct?: Alliance_gradenamesScalarFieldEnum | Alliance_gradenamesScalarFieldEnum[]
  }

  /**
   * alliance_gradenames findFirstOrThrow
   */
  export type alliance_gradenamesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alliance_gradenames
     */
    select?: alliance_gradenamesSelect<ExtArgs> | null
    /**
     * Filter, which alliance_gradenames to fetch.
     */
    where?: alliance_gradenamesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of alliance_gradenames to fetch.
     */
    orderBy?: alliance_gradenamesOrderByWithRelationInput | alliance_gradenamesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for alliance_gradenames.
     */
    cursor?: alliance_gradenamesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` alliance_gradenames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` alliance_gradenames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of alliance_gradenames.
     */
    distinct?: Alliance_gradenamesScalarFieldEnum | Alliance_gradenamesScalarFieldEnum[]
  }

  /**
   * alliance_gradenames findMany
   */
  export type alliance_gradenamesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alliance_gradenames
     */
    select?: alliance_gradenamesSelect<ExtArgs> | null
    /**
     * Filter, which alliance_gradenames to fetch.
     */
    where?: alliance_gradenamesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of alliance_gradenames to fetch.
     */
    orderBy?: alliance_gradenamesOrderByWithRelationInput | alliance_gradenamesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing alliance_gradenames.
     */
    cursor?: alliance_gradenamesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` alliance_gradenames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` alliance_gradenames.
     */
    skip?: number
    distinct?: Alliance_gradenamesScalarFieldEnum | Alliance_gradenamesScalarFieldEnum[]
  }

  /**
   * alliance_gradenames create
   */
  export type alliance_gradenamesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alliance_gradenames
     */
    select?: alliance_gradenamesSelect<ExtArgs> | null
    /**
     * The data needed to create a alliance_gradenames.
     */
    data?: XOR<alliance_gradenamesCreateInput, alliance_gradenamesUncheckedCreateInput>
  }

  /**
   * alliance_gradenames createMany
   */
  export type alliance_gradenamesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many alliance_gradenames.
     */
    data: alliance_gradenamesCreateManyInput | alliance_gradenamesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * alliance_gradenames update
   */
  export type alliance_gradenamesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alliance_gradenames
     */
    select?: alliance_gradenamesSelect<ExtArgs> | null
    /**
     * The data needed to update a alliance_gradenames.
     */
    data: XOR<alliance_gradenamesUpdateInput, alliance_gradenamesUncheckedUpdateInput>
    /**
     * Choose, which alliance_gradenames to update.
     */
    where: alliance_gradenamesWhereUniqueInput
  }

  /**
   * alliance_gradenames updateMany
   */
  export type alliance_gradenamesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update alliance_gradenames.
     */
    data: XOR<alliance_gradenamesUpdateManyMutationInput, alliance_gradenamesUncheckedUpdateManyInput>
    /**
     * Filter which alliance_gradenames to update
     */
    where?: alliance_gradenamesWhereInput
  }

  /**
   * alliance_gradenames upsert
   */
  export type alliance_gradenamesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alliance_gradenames
     */
    select?: alliance_gradenamesSelect<ExtArgs> | null
    /**
     * The filter to search for the alliance_gradenames to update in case it exists.
     */
    where: alliance_gradenamesWhereUniqueInput
    /**
     * In case the alliance_gradenames found by the `where` argument doesn't exist, create a new alliance_gradenames with this data.
     */
    create: XOR<alliance_gradenamesCreateInput, alliance_gradenamesUncheckedCreateInput>
    /**
     * In case the alliance_gradenames was found with the provided `where` argument, update it with this data.
     */
    update: XOR<alliance_gradenamesUpdateInput, alliance_gradenamesUncheckedUpdateInput>
  }

  /**
   * alliance_gradenames delete
   */
  export type alliance_gradenamesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alliance_gradenames
     */
    select?: alliance_gradenamesSelect<ExtArgs> | null
    /**
     * Filter which alliance_gradenames to delete.
     */
    where: alliance_gradenamesWhereUniqueInput
  }

  /**
   * alliance_gradenames deleteMany
   */
  export type alliance_gradenamesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which alliance_gradenames to delete
     */
    where?: alliance_gradenamesWhereInput
  }

  /**
   * alliance_gradenames without action
   */
  export type alliance_gradenamesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alliance_gradenames
     */
    select?: alliance_gradenamesSelect<ExtArgs> | null
  }


  /**
   * Model alliances
   */

  export type AggregateAlliances = {
    _count: AlliancesCountAggregateOutputType | null
    _avg: AlliancesAvgAggregateOutputType | null
    _sum: AlliancesSumAggregateOutputType | null
    _min: AlliancesMinAggregateOutputType | null
    _max: AlliancesMaxAggregateOutputType | null
  }

  export type AlliancesAvgAggregateOutputType = {
    id: number | null
    maxmembernum: number | null
  }

  export type AlliancesSumAggregateOutputType = {
    id: number | null
    maxmembernum: number | null
  }

  export type AlliancesMinAggregateOutputType = {
    id: number | null
    name: string | null
    maxmembernum: number | null
    notice: string | null
  }

  export type AlliancesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    maxmembernum: number | null
    notice: string | null
  }

  export type AlliancesCountAggregateOutputType = {
    id: number
    name: number
    maxmembernum: number
    notice: number
    _all: number
  }


  export type AlliancesAvgAggregateInputType = {
    id?: true
    maxmembernum?: true
  }

  export type AlliancesSumAggregateInputType = {
    id?: true
    maxmembernum?: true
  }

  export type AlliancesMinAggregateInputType = {
    id?: true
    name?: true
    maxmembernum?: true
    notice?: true
  }

  export type AlliancesMaxAggregateInputType = {
    id?: true
    name?: true
    maxmembernum?: true
    notice?: true
  }

  export type AlliancesCountAggregateInputType = {
    id?: true
    name?: true
    maxmembernum?: true
    notice?: true
    _all?: true
  }

  export type AlliancesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which alliances to aggregate.
     */
    where?: alliancesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of alliances to fetch.
     */
    orderBy?: alliancesOrderByWithRelationInput | alliancesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: alliancesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` alliances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` alliances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned alliances
    **/
    _count?: true | AlliancesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AlliancesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AlliancesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlliancesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlliancesMaxAggregateInputType
  }

  export type GetAlliancesAggregateType<T extends AlliancesAggregateArgs> = {
        [P in keyof T & keyof AggregateAlliances]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlliances[P]>
      : GetScalarType<T[P], AggregateAlliances[P]>
  }




  export type alliancesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: alliancesWhereInput
    orderBy?: alliancesOrderByWithAggregationInput | alliancesOrderByWithAggregationInput[]
    by: AlliancesScalarFieldEnum[] | AlliancesScalarFieldEnum
    having?: alliancesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlliancesCountAggregateInputType | true
    _avg?: AlliancesAvgAggregateInputType
    _sum?: AlliancesSumAggregateInputType
    _min?: AlliancesMinAggregateInputType
    _max?: AlliancesMaxAggregateInputType
  }

  export type AlliancesGroupByOutputType = {
    id: number
    name: string | null
    maxmembernum: number | null
    notice: string | null
    _count: AlliancesCountAggregateOutputType | null
    _avg: AlliancesAvgAggregateOutputType | null
    _sum: AlliancesSumAggregateOutputType | null
    _min: AlliancesMinAggregateOutputType | null
    _max: AlliancesMaxAggregateOutputType | null
  }

  type GetAlliancesGroupByPayload<T extends alliancesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AlliancesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlliancesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlliancesGroupByOutputType[P]>
            : GetScalarType<T[P], AlliancesGroupByOutputType[P]>
        }
      >
    >


  export type alliancesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    maxmembernum?: boolean
    notice?: boolean
  }, ExtArgs["result"]["alliances"]>


  export type alliancesSelectScalar = {
    id?: boolean
    name?: boolean
    maxmembernum?: boolean
    notice?: boolean
  }


  export type $alliancesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "alliances"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string | null
      maxmembernum: number | null
      notice: string | null
    }, ExtArgs["result"]["alliances"]>
    composites: {}
  }

  type alliancesGetPayload<S extends boolean | null | undefined | alliancesDefaultArgs> = $Result.GetResult<Prisma.$alliancesPayload, S>

  type alliancesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<alliancesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AlliancesCountAggregateInputType | true
    }

  export interface alliancesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['alliances'], meta: { name: 'alliances' } }
    /**
     * Find zero or one Alliances that matches the filter.
     * @param {alliancesFindUniqueArgs} args - Arguments to find a Alliances
     * @example
     * // Get one Alliances
     * const alliances = await prisma.alliances.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends alliancesFindUniqueArgs>(args: SelectSubset<T, alliancesFindUniqueArgs<ExtArgs>>): Prisma__alliancesClient<$Result.GetResult<Prisma.$alliancesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Alliances that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {alliancesFindUniqueOrThrowArgs} args - Arguments to find a Alliances
     * @example
     * // Get one Alliances
     * const alliances = await prisma.alliances.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends alliancesFindUniqueOrThrowArgs>(args: SelectSubset<T, alliancesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__alliancesClient<$Result.GetResult<Prisma.$alliancesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Alliances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alliancesFindFirstArgs} args - Arguments to find a Alliances
     * @example
     * // Get one Alliances
     * const alliances = await prisma.alliances.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends alliancesFindFirstArgs>(args?: SelectSubset<T, alliancesFindFirstArgs<ExtArgs>>): Prisma__alliancesClient<$Result.GetResult<Prisma.$alliancesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Alliances that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alliancesFindFirstOrThrowArgs} args - Arguments to find a Alliances
     * @example
     * // Get one Alliances
     * const alliances = await prisma.alliances.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends alliancesFindFirstOrThrowArgs>(args?: SelectSubset<T, alliancesFindFirstOrThrowArgs<ExtArgs>>): Prisma__alliancesClient<$Result.GetResult<Prisma.$alliancesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Alliances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alliancesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Alliances
     * const alliances = await prisma.alliances.findMany()
     * 
     * // Get first 10 Alliances
     * const alliances = await prisma.alliances.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const alliancesWithIdOnly = await prisma.alliances.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends alliancesFindManyArgs>(args?: SelectSubset<T, alliancesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$alliancesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Alliances.
     * @param {alliancesCreateArgs} args - Arguments to create a Alliances.
     * @example
     * // Create one Alliances
     * const Alliances = await prisma.alliances.create({
     *   data: {
     *     // ... data to create a Alliances
     *   }
     * })
     * 
     */
    create<T extends alliancesCreateArgs>(args: SelectSubset<T, alliancesCreateArgs<ExtArgs>>): Prisma__alliancesClient<$Result.GetResult<Prisma.$alliancesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Alliances.
     * @param {alliancesCreateManyArgs} args - Arguments to create many Alliances.
     * @example
     * // Create many Alliances
     * const alliances = await prisma.alliances.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends alliancesCreateManyArgs>(args?: SelectSubset<T, alliancesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Alliances.
     * @param {alliancesDeleteArgs} args - Arguments to delete one Alliances.
     * @example
     * // Delete one Alliances
     * const Alliances = await prisma.alliances.delete({
     *   where: {
     *     // ... filter to delete one Alliances
     *   }
     * })
     * 
     */
    delete<T extends alliancesDeleteArgs>(args: SelectSubset<T, alliancesDeleteArgs<ExtArgs>>): Prisma__alliancesClient<$Result.GetResult<Prisma.$alliancesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Alliances.
     * @param {alliancesUpdateArgs} args - Arguments to update one Alliances.
     * @example
     * // Update one Alliances
     * const alliances = await prisma.alliances.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends alliancesUpdateArgs>(args: SelectSubset<T, alliancesUpdateArgs<ExtArgs>>): Prisma__alliancesClient<$Result.GetResult<Prisma.$alliancesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Alliances.
     * @param {alliancesDeleteManyArgs} args - Arguments to filter Alliances to delete.
     * @example
     * // Delete a few Alliances
     * const { count } = await prisma.alliances.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends alliancesDeleteManyArgs>(args?: SelectSubset<T, alliancesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alliances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alliancesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Alliances
     * const alliances = await prisma.alliances.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends alliancesUpdateManyArgs>(args: SelectSubset<T, alliancesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Alliances.
     * @param {alliancesUpsertArgs} args - Arguments to update or create a Alliances.
     * @example
     * // Update or create a Alliances
     * const alliances = await prisma.alliances.upsert({
     *   create: {
     *     // ... data to create a Alliances
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Alliances we want to update
     *   }
     * })
     */
    upsert<T extends alliancesUpsertArgs>(args: SelectSubset<T, alliancesUpsertArgs<ExtArgs>>): Prisma__alliancesClient<$Result.GetResult<Prisma.$alliancesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Alliances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alliancesCountArgs} args - Arguments to filter Alliances to count.
     * @example
     * // Count the number of Alliances
     * const count = await prisma.alliances.count({
     *   where: {
     *     // ... the filter for the Alliances we want to count
     *   }
     * })
    **/
    count<T extends alliancesCountArgs>(
      args?: Subset<T, alliancesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlliancesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Alliances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlliancesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlliancesAggregateArgs>(args: Subset<T, AlliancesAggregateArgs>): Prisma.PrismaPromise<GetAlliancesAggregateType<T>>

    /**
     * Group by Alliances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alliancesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends alliancesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: alliancesGroupByArgs['orderBy'] }
        : { orderBy?: alliancesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, alliancesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlliancesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the alliances model
   */
  readonly fields: alliancesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for alliances.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__alliancesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the alliances model
   */ 
  interface alliancesFieldRefs {
    readonly id: FieldRef<"alliances", 'Int'>
    readonly name: FieldRef<"alliances", 'String'>
    readonly maxmembernum: FieldRef<"alliances", 'Int'>
    readonly notice: FieldRef<"alliances", 'String'>
  }
    

  // Custom InputTypes
  /**
   * alliances findUnique
   */
  export type alliancesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alliances
     */
    select?: alliancesSelect<ExtArgs> | null
    /**
     * Filter, which alliances to fetch.
     */
    where: alliancesWhereUniqueInput
  }

  /**
   * alliances findUniqueOrThrow
   */
  export type alliancesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alliances
     */
    select?: alliancesSelect<ExtArgs> | null
    /**
     * Filter, which alliances to fetch.
     */
    where: alliancesWhereUniqueInput
  }

  /**
   * alliances findFirst
   */
  export type alliancesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alliances
     */
    select?: alliancesSelect<ExtArgs> | null
    /**
     * Filter, which alliances to fetch.
     */
    where?: alliancesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of alliances to fetch.
     */
    orderBy?: alliancesOrderByWithRelationInput | alliancesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for alliances.
     */
    cursor?: alliancesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` alliances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` alliances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of alliances.
     */
    distinct?: AlliancesScalarFieldEnum | AlliancesScalarFieldEnum[]
  }

  /**
   * alliances findFirstOrThrow
   */
  export type alliancesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alliances
     */
    select?: alliancesSelect<ExtArgs> | null
    /**
     * Filter, which alliances to fetch.
     */
    where?: alliancesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of alliances to fetch.
     */
    orderBy?: alliancesOrderByWithRelationInput | alliancesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for alliances.
     */
    cursor?: alliancesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` alliances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` alliances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of alliances.
     */
    distinct?: AlliancesScalarFieldEnum | AlliancesScalarFieldEnum[]
  }

  /**
   * alliances findMany
   */
  export type alliancesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alliances
     */
    select?: alliancesSelect<ExtArgs> | null
    /**
     * Filter, which alliances to fetch.
     */
    where?: alliancesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of alliances to fetch.
     */
    orderBy?: alliancesOrderByWithRelationInput | alliancesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing alliances.
     */
    cursor?: alliancesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` alliances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` alliances.
     */
    skip?: number
    distinct?: AlliancesScalarFieldEnum | AlliancesScalarFieldEnum[]
  }

  /**
   * alliances create
   */
  export type alliancesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alliances
     */
    select?: alliancesSelect<ExtArgs> | null
    /**
     * The data needed to create a alliances.
     */
    data?: XOR<alliancesCreateInput, alliancesUncheckedCreateInput>
  }

  /**
   * alliances createMany
   */
  export type alliancesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many alliances.
     */
    data: alliancesCreateManyInput | alliancesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * alliances update
   */
  export type alliancesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alliances
     */
    select?: alliancesSelect<ExtArgs> | null
    /**
     * The data needed to update a alliances.
     */
    data: XOR<alliancesUpdateInput, alliancesUncheckedUpdateInput>
    /**
     * Choose, which alliances to update.
     */
    where: alliancesWhereUniqueInput
  }

  /**
   * alliances updateMany
   */
  export type alliancesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update alliances.
     */
    data: XOR<alliancesUpdateManyMutationInput, alliancesUncheckedUpdateManyInput>
    /**
     * Filter which alliances to update
     */
    where?: alliancesWhereInput
  }

  /**
   * alliances upsert
   */
  export type alliancesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alliances
     */
    select?: alliancesSelect<ExtArgs> | null
    /**
     * The filter to search for the alliances to update in case it exists.
     */
    where: alliancesWhereUniqueInput
    /**
     * In case the alliances found by the `where` argument doesn't exist, create a new alliances with this data.
     */
    create: XOR<alliancesCreateInput, alliancesUncheckedCreateInput>
    /**
     * In case the alliances was found with the provided `where` argument, update it with this data.
     */
    update: XOR<alliancesUpdateInput, alliancesUncheckedUpdateInput>
  }

  /**
   * alliances delete
   */
  export type alliancesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alliances
     */
    select?: alliancesSelect<ExtArgs> | null
    /**
     * Filter which alliances to delete.
     */
    where: alliancesWhereUniqueInput
  }

  /**
   * alliances deleteMany
   */
  export type alliancesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which alliances to delete
     */
    where?: alliancesWhereInput
  }

  /**
   * alliances without action
   */
  export type alliancesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alliances
     */
    select?: alliancesSelect<ExtArgs> | null
  }


  /**
   * Model auction_histories
   */

  export type AggregateAuction_histories = {
    _count: Auction_historiesCountAggregateOutputType | null
    _avg: Auction_historiesAvgAggregateOutputType | null
    _sum: Auction_historiesSumAggregateOutputType | null
    _min: Auction_historiesMinAggregateOutputType | null
    _max: Auction_historiesMaxAggregateOutputType | null
  }

  export type Auction_historiesAvgAggregateOutputType = {
    id: number | null
    itemid: number | null
    ownerid: number | null
    historytype: number | null
    mesos: number | null
    buyer: number | null
    bid: number | null
  }

  export type Auction_historiesSumAggregateOutputType = {
    id: number | null
    itemid: number | null
    ownerid: number | null
    historytype: number | null
    mesos: bigint | null
    buyer: number | null
    bid: bigint | null
  }

  export type Auction_historiesMinAggregateOutputType = {
    id: number | null
    itemid: number | null
    bargain: boolean | null
    refund: boolean | null
    ownerid: number | null
    ownername: string | null
    historytype: number | null
    mesos: bigint | null
    buyer: number | null
    bid: bigint | null
    expiredtime: Date | null
    buytime: Date | null
    starttime: Date | null
  }

  export type Auction_historiesMaxAggregateOutputType = {
    id: number | null
    itemid: number | null
    bargain: boolean | null
    refund: boolean | null
    ownerid: number | null
    ownername: string | null
    historytype: number | null
    mesos: bigint | null
    buyer: number | null
    bid: bigint | null
    expiredtime: Date | null
    buytime: Date | null
    starttime: Date | null
  }

  export type Auction_historiesCountAggregateOutputType = {
    id: number
    itemid: number
    bargain: number
    refund: number
    ownerid: number
    ownername: number
    historytype: number
    mesos: number
    buyer: number
    bid: number
    expiredtime: number
    buytime: number
    starttime: number
    _all: number
  }


  export type Auction_historiesAvgAggregateInputType = {
    id?: true
    itemid?: true
    ownerid?: true
    historytype?: true
    mesos?: true
    buyer?: true
    bid?: true
  }

  export type Auction_historiesSumAggregateInputType = {
    id?: true
    itemid?: true
    ownerid?: true
    historytype?: true
    mesos?: true
    buyer?: true
    bid?: true
  }

  export type Auction_historiesMinAggregateInputType = {
    id?: true
    itemid?: true
    bargain?: true
    refund?: true
    ownerid?: true
    ownername?: true
    historytype?: true
    mesos?: true
    buyer?: true
    bid?: true
    expiredtime?: true
    buytime?: true
    starttime?: true
  }

  export type Auction_historiesMaxAggregateInputType = {
    id?: true
    itemid?: true
    bargain?: true
    refund?: true
    ownerid?: true
    ownername?: true
    historytype?: true
    mesos?: true
    buyer?: true
    bid?: true
    expiredtime?: true
    buytime?: true
    starttime?: true
  }

  export type Auction_historiesCountAggregateInputType = {
    id?: true
    itemid?: true
    bargain?: true
    refund?: true
    ownerid?: true
    ownername?: true
    historytype?: true
    mesos?: true
    buyer?: true
    bid?: true
    expiredtime?: true
    buytime?: true
    starttime?: true
    _all?: true
  }

  export type Auction_historiesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which auction_histories to aggregate.
     */
    where?: auction_historiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auction_histories to fetch.
     */
    orderBy?: auction_historiesOrderByWithRelationInput | auction_historiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: auction_historiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auction_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auction_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned auction_histories
    **/
    _count?: true | Auction_historiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Auction_historiesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Auction_historiesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Auction_historiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Auction_historiesMaxAggregateInputType
  }

  export type GetAuction_historiesAggregateType<T extends Auction_historiesAggregateArgs> = {
        [P in keyof T & keyof AggregateAuction_histories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuction_histories[P]>
      : GetScalarType<T[P], AggregateAuction_histories[P]>
  }




  export type auction_historiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: auction_historiesWhereInput
    orderBy?: auction_historiesOrderByWithAggregationInput | auction_historiesOrderByWithAggregationInput[]
    by: Auction_historiesScalarFieldEnum[] | Auction_historiesScalarFieldEnum
    having?: auction_historiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Auction_historiesCountAggregateInputType | true
    _avg?: Auction_historiesAvgAggregateInputType
    _sum?: Auction_historiesSumAggregateInputType
    _min?: Auction_historiesMinAggregateInputType
    _max?: Auction_historiesMaxAggregateInputType
  }

  export type Auction_historiesGroupByOutputType = {
    id: number
    itemid: number | null
    bargain: boolean | null
    refund: boolean | null
    ownerid: number | null
    ownername: string | null
    historytype: number | null
    mesos: bigint | null
    buyer: number | null
    bid: bigint | null
    expiredtime: Date | null
    buytime: Date | null
    starttime: Date | null
    _count: Auction_historiesCountAggregateOutputType | null
    _avg: Auction_historiesAvgAggregateOutputType | null
    _sum: Auction_historiesSumAggregateOutputType | null
    _min: Auction_historiesMinAggregateOutputType | null
    _max: Auction_historiesMaxAggregateOutputType | null
  }

  type GetAuction_historiesGroupByPayload<T extends auction_historiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Auction_historiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Auction_historiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Auction_historiesGroupByOutputType[P]>
            : GetScalarType<T[P], Auction_historiesGroupByOutputType[P]>
        }
      >
    >


  export type auction_historiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemid?: boolean
    bargain?: boolean
    refund?: boolean
    ownerid?: boolean
    ownername?: boolean
    historytype?: boolean
    mesos?: boolean
    buyer?: boolean
    bid?: boolean
    expiredtime?: boolean
    buytime?: boolean
    starttime?: boolean
  }, ExtArgs["result"]["auction_histories"]>


  export type auction_historiesSelectScalar = {
    id?: boolean
    itemid?: boolean
    bargain?: boolean
    refund?: boolean
    ownerid?: boolean
    ownername?: boolean
    historytype?: boolean
    mesos?: boolean
    buyer?: boolean
    bid?: boolean
    expiredtime?: boolean
    buytime?: boolean
    starttime?: boolean
  }


  export type $auction_historiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "auction_histories"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      itemid: number | null
      bargain: boolean | null
      refund: boolean | null
      ownerid: number | null
      ownername: string | null
      historytype: number | null
      mesos: bigint | null
      buyer: number | null
      bid: bigint | null
      expiredtime: Date | null
      buytime: Date | null
      starttime: Date | null
    }, ExtArgs["result"]["auction_histories"]>
    composites: {}
  }

  type auction_historiesGetPayload<S extends boolean | null | undefined | auction_historiesDefaultArgs> = $Result.GetResult<Prisma.$auction_historiesPayload, S>

  type auction_historiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<auction_historiesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Auction_historiesCountAggregateInputType | true
    }

  export interface auction_historiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['auction_histories'], meta: { name: 'auction_histories' } }
    /**
     * Find zero or one Auction_histories that matches the filter.
     * @param {auction_historiesFindUniqueArgs} args - Arguments to find a Auction_histories
     * @example
     * // Get one Auction_histories
     * const auction_histories = await prisma.auction_histories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends auction_historiesFindUniqueArgs>(args: SelectSubset<T, auction_historiesFindUniqueArgs<ExtArgs>>): Prisma__auction_historiesClient<$Result.GetResult<Prisma.$auction_historiesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Auction_histories that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {auction_historiesFindUniqueOrThrowArgs} args - Arguments to find a Auction_histories
     * @example
     * // Get one Auction_histories
     * const auction_histories = await prisma.auction_histories.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends auction_historiesFindUniqueOrThrowArgs>(args: SelectSubset<T, auction_historiesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__auction_historiesClient<$Result.GetResult<Prisma.$auction_historiesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Auction_histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auction_historiesFindFirstArgs} args - Arguments to find a Auction_histories
     * @example
     * // Get one Auction_histories
     * const auction_histories = await prisma.auction_histories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends auction_historiesFindFirstArgs>(args?: SelectSubset<T, auction_historiesFindFirstArgs<ExtArgs>>): Prisma__auction_historiesClient<$Result.GetResult<Prisma.$auction_historiesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Auction_histories that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auction_historiesFindFirstOrThrowArgs} args - Arguments to find a Auction_histories
     * @example
     * // Get one Auction_histories
     * const auction_histories = await prisma.auction_histories.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends auction_historiesFindFirstOrThrowArgs>(args?: SelectSubset<T, auction_historiesFindFirstOrThrowArgs<ExtArgs>>): Prisma__auction_historiesClient<$Result.GetResult<Prisma.$auction_historiesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Auction_histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auction_historiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Auction_histories
     * const auction_histories = await prisma.auction_histories.findMany()
     * 
     * // Get first 10 Auction_histories
     * const auction_histories = await prisma.auction_histories.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auction_historiesWithIdOnly = await prisma.auction_histories.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends auction_historiesFindManyArgs>(args?: SelectSubset<T, auction_historiesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$auction_historiesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Auction_histories.
     * @param {auction_historiesCreateArgs} args - Arguments to create a Auction_histories.
     * @example
     * // Create one Auction_histories
     * const Auction_histories = await prisma.auction_histories.create({
     *   data: {
     *     // ... data to create a Auction_histories
     *   }
     * })
     * 
     */
    create<T extends auction_historiesCreateArgs>(args: SelectSubset<T, auction_historiesCreateArgs<ExtArgs>>): Prisma__auction_historiesClient<$Result.GetResult<Prisma.$auction_historiesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Auction_histories.
     * @param {auction_historiesCreateManyArgs} args - Arguments to create many Auction_histories.
     * @example
     * // Create many Auction_histories
     * const auction_histories = await prisma.auction_histories.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends auction_historiesCreateManyArgs>(args?: SelectSubset<T, auction_historiesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Auction_histories.
     * @param {auction_historiesDeleteArgs} args - Arguments to delete one Auction_histories.
     * @example
     * // Delete one Auction_histories
     * const Auction_histories = await prisma.auction_histories.delete({
     *   where: {
     *     // ... filter to delete one Auction_histories
     *   }
     * })
     * 
     */
    delete<T extends auction_historiesDeleteArgs>(args: SelectSubset<T, auction_historiesDeleteArgs<ExtArgs>>): Prisma__auction_historiesClient<$Result.GetResult<Prisma.$auction_historiesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Auction_histories.
     * @param {auction_historiesUpdateArgs} args - Arguments to update one Auction_histories.
     * @example
     * // Update one Auction_histories
     * const auction_histories = await prisma.auction_histories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends auction_historiesUpdateArgs>(args: SelectSubset<T, auction_historiesUpdateArgs<ExtArgs>>): Prisma__auction_historiesClient<$Result.GetResult<Prisma.$auction_historiesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Auction_histories.
     * @param {auction_historiesDeleteManyArgs} args - Arguments to filter Auction_histories to delete.
     * @example
     * // Delete a few Auction_histories
     * const { count } = await prisma.auction_histories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends auction_historiesDeleteManyArgs>(args?: SelectSubset<T, auction_historiesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Auction_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auction_historiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Auction_histories
     * const auction_histories = await prisma.auction_histories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends auction_historiesUpdateManyArgs>(args: SelectSubset<T, auction_historiesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Auction_histories.
     * @param {auction_historiesUpsertArgs} args - Arguments to update or create a Auction_histories.
     * @example
     * // Update or create a Auction_histories
     * const auction_histories = await prisma.auction_histories.upsert({
     *   create: {
     *     // ... data to create a Auction_histories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Auction_histories we want to update
     *   }
     * })
     */
    upsert<T extends auction_historiesUpsertArgs>(args: SelectSubset<T, auction_historiesUpsertArgs<ExtArgs>>): Prisma__auction_historiesClient<$Result.GetResult<Prisma.$auction_historiesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Auction_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auction_historiesCountArgs} args - Arguments to filter Auction_histories to count.
     * @example
     * // Count the number of Auction_histories
     * const count = await prisma.auction_histories.count({
     *   where: {
     *     // ... the filter for the Auction_histories we want to count
     *   }
     * })
    **/
    count<T extends auction_historiesCountArgs>(
      args?: Subset<T, auction_historiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Auction_historiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Auction_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Auction_historiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Auction_historiesAggregateArgs>(args: Subset<T, Auction_historiesAggregateArgs>): Prisma.PrismaPromise<GetAuction_historiesAggregateType<T>>

    /**
     * Group by Auction_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auction_historiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends auction_historiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: auction_historiesGroupByArgs['orderBy'] }
        : { orderBy?: auction_historiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, auction_historiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuction_historiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the auction_histories model
   */
  readonly fields: auction_historiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for auction_histories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__auction_historiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the auction_histories model
   */ 
  interface auction_historiesFieldRefs {
    readonly id: FieldRef<"auction_histories", 'Int'>
    readonly itemid: FieldRef<"auction_histories", 'Int'>
    readonly bargain: FieldRef<"auction_histories", 'Boolean'>
    readonly refund: FieldRef<"auction_histories", 'Boolean'>
    readonly ownerid: FieldRef<"auction_histories", 'Int'>
    readonly ownername: FieldRef<"auction_histories", 'String'>
    readonly historytype: FieldRef<"auction_histories", 'Int'>
    readonly mesos: FieldRef<"auction_histories", 'BigInt'>
    readonly buyer: FieldRef<"auction_histories", 'Int'>
    readonly bid: FieldRef<"auction_histories", 'BigInt'>
    readonly expiredtime: FieldRef<"auction_histories", 'DateTime'>
    readonly buytime: FieldRef<"auction_histories", 'DateTime'>
    readonly starttime: FieldRef<"auction_histories", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * auction_histories findUnique
   */
  export type auction_historiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auction_histories
     */
    select?: auction_historiesSelect<ExtArgs> | null
    /**
     * Filter, which auction_histories to fetch.
     */
    where: auction_historiesWhereUniqueInput
  }

  /**
   * auction_histories findUniqueOrThrow
   */
  export type auction_historiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auction_histories
     */
    select?: auction_historiesSelect<ExtArgs> | null
    /**
     * Filter, which auction_histories to fetch.
     */
    where: auction_historiesWhereUniqueInput
  }

  /**
   * auction_histories findFirst
   */
  export type auction_historiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auction_histories
     */
    select?: auction_historiesSelect<ExtArgs> | null
    /**
     * Filter, which auction_histories to fetch.
     */
    where?: auction_historiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auction_histories to fetch.
     */
    orderBy?: auction_historiesOrderByWithRelationInput | auction_historiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for auction_histories.
     */
    cursor?: auction_historiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auction_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auction_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of auction_histories.
     */
    distinct?: Auction_historiesScalarFieldEnum | Auction_historiesScalarFieldEnum[]
  }

  /**
   * auction_histories findFirstOrThrow
   */
  export type auction_historiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auction_histories
     */
    select?: auction_historiesSelect<ExtArgs> | null
    /**
     * Filter, which auction_histories to fetch.
     */
    where?: auction_historiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auction_histories to fetch.
     */
    orderBy?: auction_historiesOrderByWithRelationInput | auction_historiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for auction_histories.
     */
    cursor?: auction_historiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auction_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auction_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of auction_histories.
     */
    distinct?: Auction_historiesScalarFieldEnum | Auction_historiesScalarFieldEnum[]
  }

  /**
   * auction_histories findMany
   */
  export type auction_historiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auction_histories
     */
    select?: auction_historiesSelect<ExtArgs> | null
    /**
     * Filter, which auction_histories to fetch.
     */
    where?: auction_historiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auction_histories to fetch.
     */
    orderBy?: auction_historiesOrderByWithRelationInput | auction_historiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing auction_histories.
     */
    cursor?: auction_historiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auction_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auction_histories.
     */
    skip?: number
    distinct?: Auction_historiesScalarFieldEnum | Auction_historiesScalarFieldEnum[]
  }

  /**
   * auction_histories create
   */
  export type auction_historiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auction_histories
     */
    select?: auction_historiesSelect<ExtArgs> | null
    /**
     * The data needed to create a auction_histories.
     */
    data?: XOR<auction_historiesCreateInput, auction_historiesUncheckedCreateInput>
  }

  /**
   * auction_histories createMany
   */
  export type auction_historiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many auction_histories.
     */
    data: auction_historiesCreateManyInput | auction_historiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * auction_histories update
   */
  export type auction_historiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auction_histories
     */
    select?: auction_historiesSelect<ExtArgs> | null
    /**
     * The data needed to update a auction_histories.
     */
    data: XOR<auction_historiesUpdateInput, auction_historiesUncheckedUpdateInput>
    /**
     * Choose, which auction_histories to update.
     */
    where: auction_historiesWhereUniqueInput
  }

  /**
   * auction_histories updateMany
   */
  export type auction_historiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update auction_histories.
     */
    data: XOR<auction_historiesUpdateManyMutationInput, auction_historiesUncheckedUpdateManyInput>
    /**
     * Filter which auction_histories to update
     */
    where?: auction_historiesWhereInput
  }

  /**
   * auction_histories upsert
   */
  export type auction_historiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auction_histories
     */
    select?: auction_historiesSelect<ExtArgs> | null
    /**
     * The filter to search for the auction_histories to update in case it exists.
     */
    where: auction_historiesWhereUniqueInput
    /**
     * In case the auction_histories found by the `where` argument doesn't exist, create a new auction_histories with this data.
     */
    create: XOR<auction_historiesCreateInput, auction_historiesUncheckedCreateInput>
    /**
     * In case the auction_histories was found with the provided `where` argument, update it with this data.
     */
    update: XOR<auction_historiesUpdateInput, auction_historiesUncheckedUpdateInput>
  }

  /**
   * auction_histories delete
   */
  export type auction_historiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auction_histories
     */
    select?: auction_historiesSelect<ExtArgs> | null
    /**
     * Filter which auction_histories to delete.
     */
    where: auction_historiesWhereUniqueInput
  }

  /**
   * auction_histories deleteMany
   */
  export type auction_historiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which auction_histories to delete
     */
    where?: auction_historiesWhereInput
  }

  /**
   * auction_histories without action
   */
  export type auction_historiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auction_histories
     */
    select?: auction_historiesSelect<ExtArgs> | null
  }


  /**
   * Model auction_items
   */

  export type AggregateAuction_items = {
    _count: Auction_itemsCountAggregateOutputType | null
    _avg: Auction_itemsAvgAggregateOutputType | null
    _sum: Auction_itemsSumAggregateOutputType | null
    _min: Auction_itemsMinAggregateOutputType | null
    _max: Auction_itemsMaxAggregateOutputType | null
  }

  export type Auction_itemsAvgAggregateOutputType = {
    id: number | null
    itemid: number | null
    ownerid: number | null
    mesos: number | null
    buyer: number | null
    bid: number | null
  }

  export type Auction_itemsSumAggregateOutputType = {
    id: number | null
    itemid: number | null
    ownerid: number | null
    mesos: bigint | null
    buyer: number | null
    bid: bigint | null
  }

  export type Auction_itemsMinAggregateOutputType = {
    id: number | null
    itemid: number | null
    bargain: boolean | null
    ownerid: number | null
    ownername: string | null
    mesos: bigint | null
    buyer: number | null
    bid: bigint | null
    expiredtime: Date | null
    starttime: Date | null
  }

  export type Auction_itemsMaxAggregateOutputType = {
    id: number | null
    itemid: number | null
    bargain: boolean | null
    ownerid: number | null
    ownername: string | null
    mesos: bigint | null
    buyer: number | null
    bid: bigint | null
    expiredtime: Date | null
    starttime: Date | null
  }

  export type Auction_itemsCountAggregateOutputType = {
    id: number
    itemid: number
    bargain: number
    ownerid: number
    ownername: number
    mesos: number
    buyer: number
    bid: number
    expiredtime: number
    starttime: number
    _all: number
  }


  export type Auction_itemsAvgAggregateInputType = {
    id?: true
    itemid?: true
    ownerid?: true
    mesos?: true
    buyer?: true
    bid?: true
  }

  export type Auction_itemsSumAggregateInputType = {
    id?: true
    itemid?: true
    ownerid?: true
    mesos?: true
    buyer?: true
    bid?: true
  }

  export type Auction_itemsMinAggregateInputType = {
    id?: true
    itemid?: true
    bargain?: true
    ownerid?: true
    ownername?: true
    mesos?: true
    buyer?: true
    bid?: true
    expiredtime?: true
    starttime?: true
  }

  export type Auction_itemsMaxAggregateInputType = {
    id?: true
    itemid?: true
    bargain?: true
    ownerid?: true
    ownername?: true
    mesos?: true
    buyer?: true
    bid?: true
    expiredtime?: true
    starttime?: true
  }

  export type Auction_itemsCountAggregateInputType = {
    id?: true
    itemid?: true
    bargain?: true
    ownerid?: true
    ownername?: true
    mesos?: true
    buyer?: true
    bid?: true
    expiredtime?: true
    starttime?: true
    _all?: true
  }

  export type Auction_itemsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which auction_items to aggregate.
     */
    where?: auction_itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auction_items to fetch.
     */
    orderBy?: auction_itemsOrderByWithRelationInput | auction_itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: auction_itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auction_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auction_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned auction_items
    **/
    _count?: true | Auction_itemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Auction_itemsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Auction_itemsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Auction_itemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Auction_itemsMaxAggregateInputType
  }

  export type GetAuction_itemsAggregateType<T extends Auction_itemsAggregateArgs> = {
        [P in keyof T & keyof AggregateAuction_items]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuction_items[P]>
      : GetScalarType<T[P], AggregateAuction_items[P]>
  }




  export type auction_itemsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: auction_itemsWhereInput
    orderBy?: auction_itemsOrderByWithAggregationInput | auction_itemsOrderByWithAggregationInput[]
    by: Auction_itemsScalarFieldEnum[] | Auction_itemsScalarFieldEnum
    having?: auction_itemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Auction_itemsCountAggregateInputType | true
    _avg?: Auction_itemsAvgAggregateInputType
    _sum?: Auction_itemsSumAggregateInputType
    _min?: Auction_itemsMinAggregateInputType
    _max?: Auction_itemsMaxAggregateInputType
  }

  export type Auction_itemsGroupByOutputType = {
    id: number
    itemid: number | null
    bargain: boolean | null
    ownerid: number | null
    ownername: string | null
    mesos: bigint | null
    buyer: number | null
    bid: bigint | null
    expiredtime: Date | null
    starttime: Date | null
    _count: Auction_itemsCountAggregateOutputType | null
    _avg: Auction_itemsAvgAggregateOutputType | null
    _sum: Auction_itemsSumAggregateOutputType | null
    _min: Auction_itemsMinAggregateOutputType | null
    _max: Auction_itemsMaxAggregateOutputType | null
  }

  type GetAuction_itemsGroupByPayload<T extends auction_itemsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Auction_itemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Auction_itemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Auction_itemsGroupByOutputType[P]>
            : GetScalarType<T[P], Auction_itemsGroupByOutputType[P]>
        }
      >
    >


  export type auction_itemsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemid?: boolean
    bargain?: boolean
    ownerid?: boolean
    ownername?: boolean
    mesos?: boolean
    buyer?: boolean
    bid?: boolean
    expiredtime?: boolean
    starttime?: boolean
  }, ExtArgs["result"]["auction_items"]>


  export type auction_itemsSelectScalar = {
    id?: boolean
    itemid?: boolean
    bargain?: boolean
    ownerid?: boolean
    ownername?: boolean
    mesos?: boolean
    buyer?: boolean
    bid?: boolean
    expiredtime?: boolean
    starttime?: boolean
  }


  export type $auction_itemsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "auction_items"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      itemid: number | null
      bargain: boolean | null
      ownerid: number | null
      ownername: string | null
      mesos: bigint | null
      buyer: number | null
      bid: bigint | null
      expiredtime: Date | null
      starttime: Date | null
    }, ExtArgs["result"]["auction_items"]>
    composites: {}
  }

  type auction_itemsGetPayload<S extends boolean | null | undefined | auction_itemsDefaultArgs> = $Result.GetResult<Prisma.$auction_itemsPayload, S>

  type auction_itemsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<auction_itemsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Auction_itemsCountAggregateInputType | true
    }

  export interface auction_itemsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['auction_items'], meta: { name: 'auction_items' } }
    /**
     * Find zero or one Auction_items that matches the filter.
     * @param {auction_itemsFindUniqueArgs} args - Arguments to find a Auction_items
     * @example
     * // Get one Auction_items
     * const auction_items = await prisma.auction_items.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends auction_itemsFindUniqueArgs>(args: SelectSubset<T, auction_itemsFindUniqueArgs<ExtArgs>>): Prisma__auction_itemsClient<$Result.GetResult<Prisma.$auction_itemsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Auction_items that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {auction_itemsFindUniqueOrThrowArgs} args - Arguments to find a Auction_items
     * @example
     * // Get one Auction_items
     * const auction_items = await prisma.auction_items.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends auction_itemsFindUniqueOrThrowArgs>(args: SelectSubset<T, auction_itemsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__auction_itemsClient<$Result.GetResult<Prisma.$auction_itemsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Auction_items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auction_itemsFindFirstArgs} args - Arguments to find a Auction_items
     * @example
     * // Get one Auction_items
     * const auction_items = await prisma.auction_items.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends auction_itemsFindFirstArgs>(args?: SelectSubset<T, auction_itemsFindFirstArgs<ExtArgs>>): Prisma__auction_itemsClient<$Result.GetResult<Prisma.$auction_itemsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Auction_items that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auction_itemsFindFirstOrThrowArgs} args - Arguments to find a Auction_items
     * @example
     * // Get one Auction_items
     * const auction_items = await prisma.auction_items.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends auction_itemsFindFirstOrThrowArgs>(args?: SelectSubset<T, auction_itemsFindFirstOrThrowArgs<ExtArgs>>): Prisma__auction_itemsClient<$Result.GetResult<Prisma.$auction_itemsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Auction_items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auction_itemsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Auction_items
     * const auction_items = await prisma.auction_items.findMany()
     * 
     * // Get first 10 Auction_items
     * const auction_items = await prisma.auction_items.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auction_itemsWithIdOnly = await prisma.auction_items.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends auction_itemsFindManyArgs>(args?: SelectSubset<T, auction_itemsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$auction_itemsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Auction_items.
     * @param {auction_itemsCreateArgs} args - Arguments to create a Auction_items.
     * @example
     * // Create one Auction_items
     * const Auction_items = await prisma.auction_items.create({
     *   data: {
     *     // ... data to create a Auction_items
     *   }
     * })
     * 
     */
    create<T extends auction_itemsCreateArgs>(args: SelectSubset<T, auction_itemsCreateArgs<ExtArgs>>): Prisma__auction_itemsClient<$Result.GetResult<Prisma.$auction_itemsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Auction_items.
     * @param {auction_itemsCreateManyArgs} args - Arguments to create many Auction_items.
     * @example
     * // Create many Auction_items
     * const auction_items = await prisma.auction_items.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends auction_itemsCreateManyArgs>(args?: SelectSubset<T, auction_itemsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Auction_items.
     * @param {auction_itemsDeleteArgs} args - Arguments to delete one Auction_items.
     * @example
     * // Delete one Auction_items
     * const Auction_items = await prisma.auction_items.delete({
     *   where: {
     *     // ... filter to delete one Auction_items
     *   }
     * })
     * 
     */
    delete<T extends auction_itemsDeleteArgs>(args: SelectSubset<T, auction_itemsDeleteArgs<ExtArgs>>): Prisma__auction_itemsClient<$Result.GetResult<Prisma.$auction_itemsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Auction_items.
     * @param {auction_itemsUpdateArgs} args - Arguments to update one Auction_items.
     * @example
     * // Update one Auction_items
     * const auction_items = await prisma.auction_items.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends auction_itemsUpdateArgs>(args: SelectSubset<T, auction_itemsUpdateArgs<ExtArgs>>): Prisma__auction_itemsClient<$Result.GetResult<Prisma.$auction_itemsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Auction_items.
     * @param {auction_itemsDeleteManyArgs} args - Arguments to filter Auction_items to delete.
     * @example
     * // Delete a few Auction_items
     * const { count } = await prisma.auction_items.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends auction_itemsDeleteManyArgs>(args?: SelectSubset<T, auction_itemsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Auction_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auction_itemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Auction_items
     * const auction_items = await prisma.auction_items.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends auction_itemsUpdateManyArgs>(args: SelectSubset<T, auction_itemsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Auction_items.
     * @param {auction_itemsUpsertArgs} args - Arguments to update or create a Auction_items.
     * @example
     * // Update or create a Auction_items
     * const auction_items = await prisma.auction_items.upsert({
     *   create: {
     *     // ... data to create a Auction_items
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Auction_items we want to update
     *   }
     * })
     */
    upsert<T extends auction_itemsUpsertArgs>(args: SelectSubset<T, auction_itemsUpsertArgs<ExtArgs>>): Prisma__auction_itemsClient<$Result.GetResult<Prisma.$auction_itemsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Auction_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auction_itemsCountArgs} args - Arguments to filter Auction_items to count.
     * @example
     * // Count the number of Auction_items
     * const count = await prisma.auction_items.count({
     *   where: {
     *     // ... the filter for the Auction_items we want to count
     *   }
     * })
    **/
    count<T extends auction_itemsCountArgs>(
      args?: Subset<T, auction_itemsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Auction_itemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Auction_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Auction_itemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Auction_itemsAggregateArgs>(args: Subset<T, Auction_itemsAggregateArgs>): Prisma.PrismaPromise<GetAuction_itemsAggregateType<T>>

    /**
     * Group by Auction_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auction_itemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends auction_itemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: auction_itemsGroupByArgs['orderBy'] }
        : { orderBy?: auction_itemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, auction_itemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuction_itemsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the auction_items model
   */
  readonly fields: auction_itemsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for auction_items.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__auction_itemsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the auction_items model
   */ 
  interface auction_itemsFieldRefs {
    readonly id: FieldRef<"auction_items", 'Int'>
    readonly itemid: FieldRef<"auction_items", 'Int'>
    readonly bargain: FieldRef<"auction_items", 'Boolean'>
    readonly ownerid: FieldRef<"auction_items", 'Int'>
    readonly ownername: FieldRef<"auction_items", 'String'>
    readonly mesos: FieldRef<"auction_items", 'BigInt'>
    readonly buyer: FieldRef<"auction_items", 'Int'>
    readonly bid: FieldRef<"auction_items", 'BigInt'>
    readonly expiredtime: FieldRef<"auction_items", 'DateTime'>
    readonly starttime: FieldRef<"auction_items", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * auction_items findUnique
   */
  export type auction_itemsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auction_items
     */
    select?: auction_itemsSelect<ExtArgs> | null
    /**
     * Filter, which auction_items to fetch.
     */
    where: auction_itemsWhereUniqueInput
  }

  /**
   * auction_items findUniqueOrThrow
   */
  export type auction_itemsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auction_items
     */
    select?: auction_itemsSelect<ExtArgs> | null
    /**
     * Filter, which auction_items to fetch.
     */
    where: auction_itemsWhereUniqueInput
  }

  /**
   * auction_items findFirst
   */
  export type auction_itemsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auction_items
     */
    select?: auction_itemsSelect<ExtArgs> | null
    /**
     * Filter, which auction_items to fetch.
     */
    where?: auction_itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auction_items to fetch.
     */
    orderBy?: auction_itemsOrderByWithRelationInput | auction_itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for auction_items.
     */
    cursor?: auction_itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auction_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auction_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of auction_items.
     */
    distinct?: Auction_itemsScalarFieldEnum | Auction_itemsScalarFieldEnum[]
  }

  /**
   * auction_items findFirstOrThrow
   */
  export type auction_itemsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auction_items
     */
    select?: auction_itemsSelect<ExtArgs> | null
    /**
     * Filter, which auction_items to fetch.
     */
    where?: auction_itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auction_items to fetch.
     */
    orderBy?: auction_itemsOrderByWithRelationInput | auction_itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for auction_items.
     */
    cursor?: auction_itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auction_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auction_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of auction_items.
     */
    distinct?: Auction_itemsScalarFieldEnum | Auction_itemsScalarFieldEnum[]
  }

  /**
   * auction_items findMany
   */
  export type auction_itemsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auction_items
     */
    select?: auction_itemsSelect<ExtArgs> | null
    /**
     * Filter, which auction_items to fetch.
     */
    where?: auction_itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auction_items to fetch.
     */
    orderBy?: auction_itemsOrderByWithRelationInput | auction_itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing auction_items.
     */
    cursor?: auction_itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auction_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auction_items.
     */
    skip?: number
    distinct?: Auction_itemsScalarFieldEnum | Auction_itemsScalarFieldEnum[]
  }

  /**
   * auction_items create
   */
  export type auction_itemsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auction_items
     */
    select?: auction_itemsSelect<ExtArgs> | null
    /**
     * The data needed to create a auction_items.
     */
    data?: XOR<auction_itemsCreateInput, auction_itemsUncheckedCreateInput>
  }

  /**
   * auction_items createMany
   */
  export type auction_itemsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many auction_items.
     */
    data: auction_itemsCreateManyInput | auction_itemsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * auction_items update
   */
  export type auction_itemsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auction_items
     */
    select?: auction_itemsSelect<ExtArgs> | null
    /**
     * The data needed to update a auction_items.
     */
    data: XOR<auction_itemsUpdateInput, auction_itemsUncheckedUpdateInput>
    /**
     * Choose, which auction_items to update.
     */
    where: auction_itemsWhereUniqueInput
  }

  /**
   * auction_items updateMany
   */
  export type auction_itemsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update auction_items.
     */
    data: XOR<auction_itemsUpdateManyMutationInput, auction_itemsUncheckedUpdateManyInput>
    /**
     * Filter which auction_items to update
     */
    where?: auction_itemsWhereInput
  }

  /**
   * auction_items upsert
   */
  export type auction_itemsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auction_items
     */
    select?: auction_itemsSelect<ExtArgs> | null
    /**
     * The filter to search for the auction_items to update in case it exists.
     */
    where: auction_itemsWhereUniqueInput
    /**
     * In case the auction_items found by the `where` argument doesn't exist, create a new auction_items with this data.
     */
    create: XOR<auction_itemsCreateInput, auction_itemsUncheckedCreateInput>
    /**
     * In case the auction_items was found with the provided `where` argument, update it with this data.
     */
    update: XOR<auction_itemsUpdateInput, auction_itemsUncheckedUpdateInput>
  }

  /**
   * auction_items delete
   */
  export type auction_itemsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auction_items
     */
    select?: auction_itemsSelect<ExtArgs> | null
    /**
     * Filter which auction_items to delete.
     */
    where: auction_itemsWhereUniqueInput
  }

  /**
   * auction_items deleteMany
   */
  export type auction_itemsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which auction_items to delete
     */
    where?: auction_itemsWhereInput
  }

  /**
   * auction_items without action
   */
  export type auction_itemsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auction_items
     */
    select?: auction_itemsSelect<ExtArgs> | null
  }


  /**
   * Model avatardata
   */

  export type AggregateAvatardata = {
    _count: AvatardataCountAggregateOutputType | null
    _avg: AvatardataAvgAggregateOutputType | null
    _sum: AvatardataSumAggregateOutputType | null
    _min: AvatardataMinAggregateOutputType | null
    _max: AvatardataMaxAggregateOutputType | null
  }

  export type AvatardataAvgAggregateOutputType = {
    id: number | null
    characterstat: number | null
    avatarlook: number | null
    zeroavatarlook: number | null
  }

  export type AvatardataSumAggregateOutputType = {
    id: number | null
    characterstat: number | null
    avatarlook: number | null
    zeroavatarlook: number | null
  }

  export type AvatardataMinAggregateOutputType = {
    id: number | null
    characterstat: number | null
    avatarlook: number | null
    zeroavatarlook: number | null
  }

  export type AvatardataMaxAggregateOutputType = {
    id: number | null
    characterstat: number | null
    avatarlook: number | null
    zeroavatarlook: number | null
  }

  export type AvatardataCountAggregateOutputType = {
    id: number
    characterstat: number
    avatarlook: number
    zeroavatarlook: number
    _all: number
  }


  export type AvatardataAvgAggregateInputType = {
    id?: true
    characterstat?: true
    avatarlook?: true
    zeroavatarlook?: true
  }

  export type AvatardataSumAggregateInputType = {
    id?: true
    characterstat?: true
    avatarlook?: true
    zeroavatarlook?: true
  }

  export type AvatardataMinAggregateInputType = {
    id?: true
    characterstat?: true
    avatarlook?: true
    zeroavatarlook?: true
  }

  export type AvatardataMaxAggregateInputType = {
    id?: true
    characterstat?: true
    avatarlook?: true
    zeroavatarlook?: true
  }

  export type AvatardataCountAggregateInputType = {
    id?: true
    characterstat?: true
    avatarlook?: true
    zeroavatarlook?: true
    _all?: true
  }

  export type AvatardataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which avatardata to aggregate.
     */
    where?: avatardataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of avatardata to fetch.
     */
    orderBy?: avatardataOrderByWithRelationInput | avatardataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: avatardataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` avatardata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` avatardata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned avatardata
    **/
    _count?: true | AvatardataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AvatardataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AvatardataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AvatardataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AvatardataMaxAggregateInputType
  }

  export type GetAvatardataAggregateType<T extends AvatardataAggregateArgs> = {
        [P in keyof T & keyof AggregateAvatardata]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAvatardata[P]>
      : GetScalarType<T[P], AggregateAvatardata[P]>
  }




  export type avatardataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: avatardataWhereInput
    orderBy?: avatardataOrderByWithAggregationInput | avatardataOrderByWithAggregationInput[]
    by: AvatardataScalarFieldEnum[] | AvatardataScalarFieldEnum
    having?: avatardataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AvatardataCountAggregateInputType | true
    _avg?: AvatardataAvgAggregateInputType
    _sum?: AvatardataSumAggregateInputType
    _min?: AvatardataMinAggregateInputType
    _max?: AvatardataMaxAggregateInputType
  }

  export type AvatardataGroupByOutputType = {
    id: number
    characterstat: number | null
    avatarlook: number | null
    zeroavatarlook: number | null
    _count: AvatardataCountAggregateOutputType | null
    _avg: AvatardataAvgAggregateOutputType | null
    _sum: AvatardataSumAggregateOutputType | null
    _min: AvatardataMinAggregateOutputType | null
    _max: AvatardataMaxAggregateOutputType | null
  }

  type GetAvatardataGroupByPayload<T extends avatardataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AvatardataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AvatardataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AvatardataGroupByOutputType[P]>
            : GetScalarType<T[P], AvatardataGroupByOutputType[P]>
        }
      >
    >


  export type avatardataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    characterstat?: boolean
    avatarlook?: boolean
    zeroavatarlook?: boolean
  }, ExtArgs["result"]["avatardata"]>


  export type avatardataSelectScalar = {
    id?: boolean
    characterstat?: boolean
    avatarlook?: boolean
    zeroavatarlook?: boolean
  }


  export type $avatardataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "avatardata"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      characterstat: number | null
      avatarlook: number | null
      zeroavatarlook: number | null
    }, ExtArgs["result"]["avatardata"]>
    composites: {}
  }

  type avatardataGetPayload<S extends boolean | null | undefined | avatardataDefaultArgs> = $Result.GetResult<Prisma.$avatardataPayload, S>

  type avatardataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<avatardataFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AvatardataCountAggregateInputType | true
    }

  export interface avatardataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['avatardata'], meta: { name: 'avatardata' } }
    /**
     * Find zero or one Avatardata that matches the filter.
     * @param {avatardataFindUniqueArgs} args - Arguments to find a Avatardata
     * @example
     * // Get one Avatardata
     * const avatardata = await prisma.avatardata.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends avatardataFindUniqueArgs>(args: SelectSubset<T, avatardataFindUniqueArgs<ExtArgs>>): Prisma__avatardataClient<$Result.GetResult<Prisma.$avatardataPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Avatardata that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {avatardataFindUniqueOrThrowArgs} args - Arguments to find a Avatardata
     * @example
     * // Get one Avatardata
     * const avatardata = await prisma.avatardata.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends avatardataFindUniqueOrThrowArgs>(args: SelectSubset<T, avatardataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__avatardataClient<$Result.GetResult<Prisma.$avatardataPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Avatardata that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {avatardataFindFirstArgs} args - Arguments to find a Avatardata
     * @example
     * // Get one Avatardata
     * const avatardata = await prisma.avatardata.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends avatardataFindFirstArgs>(args?: SelectSubset<T, avatardataFindFirstArgs<ExtArgs>>): Prisma__avatardataClient<$Result.GetResult<Prisma.$avatardataPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Avatardata that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {avatardataFindFirstOrThrowArgs} args - Arguments to find a Avatardata
     * @example
     * // Get one Avatardata
     * const avatardata = await prisma.avatardata.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends avatardataFindFirstOrThrowArgs>(args?: SelectSubset<T, avatardataFindFirstOrThrowArgs<ExtArgs>>): Prisma__avatardataClient<$Result.GetResult<Prisma.$avatardataPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Avatardata that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {avatardataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Avatardata
     * const avatardata = await prisma.avatardata.findMany()
     * 
     * // Get first 10 Avatardata
     * const avatardata = await prisma.avatardata.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const avatardataWithIdOnly = await prisma.avatardata.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends avatardataFindManyArgs>(args?: SelectSubset<T, avatardataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$avatardataPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Avatardata.
     * @param {avatardataCreateArgs} args - Arguments to create a Avatardata.
     * @example
     * // Create one Avatardata
     * const Avatardata = await prisma.avatardata.create({
     *   data: {
     *     // ... data to create a Avatardata
     *   }
     * })
     * 
     */
    create<T extends avatardataCreateArgs>(args: SelectSubset<T, avatardataCreateArgs<ExtArgs>>): Prisma__avatardataClient<$Result.GetResult<Prisma.$avatardataPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Avatardata.
     * @param {avatardataCreateManyArgs} args - Arguments to create many Avatardata.
     * @example
     * // Create many Avatardata
     * const avatardata = await prisma.avatardata.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends avatardataCreateManyArgs>(args?: SelectSubset<T, avatardataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Avatardata.
     * @param {avatardataDeleteArgs} args - Arguments to delete one Avatardata.
     * @example
     * // Delete one Avatardata
     * const Avatardata = await prisma.avatardata.delete({
     *   where: {
     *     // ... filter to delete one Avatardata
     *   }
     * })
     * 
     */
    delete<T extends avatardataDeleteArgs>(args: SelectSubset<T, avatardataDeleteArgs<ExtArgs>>): Prisma__avatardataClient<$Result.GetResult<Prisma.$avatardataPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Avatardata.
     * @param {avatardataUpdateArgs} args - Arguments to update one Avatardata.
     * @example
     * // Update one Avatardata
     * const avatardata = await prisma.avatardata.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends avatardataUpdateArgs>(args: SelectSubset<T, avatardataUpdateArgs<ExtArgs>>): Prisma__avatardataClient<$Result.GetResult<Prisma.$avatardataPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Avatardata.
     * @param {avatardataDeleteManyArgs} args - Arguments to filter Avatardata to delete.
     * @example
     * // Delete a few Avatardata
     * const { count } = await prisma.avatardata.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends avatardataDeleteManyArgs>(args?: SelectSubset<T, avatardataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Avatardata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {avatardataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Avatardata
     * const avatardata = await prisma.avatardata.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends avatardataUpdateManyArgs>(args: SelectSubset<T, avatardataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Avatardata.
     * @param {avatardataUpsertArgs} args - Arguments to update or create a Avatardata.
     * @example
     * // Update or create a Avatardata
     * const avatardata = await prisma.avatardata.upsert({
     *   create: {
     *     // ... data to create a Avatardata
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Avatardata we want to update
     *   }
     * })
     */
    upsert<T extends avatardataUpsertArgs>(args: SelectSubset<T, avatardataUpsertArgs<ExtArgs>>): Prisma__avatardataClient<$Result.GetResult<Prisma.$avatardataPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Avatardata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {avatardataCountArgs} args - Arguments to filter Avatardata to count.
     * @example
     * // Count the number of Avatardata
     * const count = await prisma.avatardata.count({
     *   where: {
     *     // ... the filter for the Avatardata we want to count
     *   }
     * })
    **/
    count<T extends avatardataCountArgs>(
      args?: Subset<T, avatardataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AvatardataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Avatardata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvatardataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AvatardataAggregateArgs>(args: Subset<T, AvatardataAggregateArgs>): Prisma.PrismaPromise<GetAvatardataAggregateType<T>>

    /**
     * Group by Avatardata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {avatardataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends avatardataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: avatardataGroupByArgs['orderBy'] }
        : { orderBy?: avatardataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, avatardataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAvatardataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the avatardata model
   */
  readonly fields: avatardataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for avatardata.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__avatardataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the avatardata model
   */ 
  interface avatardataFieldRefs {
    readonly id: FieldRef<"avatardata", 'Int'>
    readonly characterstat: FieldRef<"avatardata", 'Int'>
    readonly avatarlook: FieldRef<"avatardata", 'Int'>
    readonly zeroavatarlook: FieldRef<"avatardata", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * avatardata findUnique
   */
  export type avatardataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the avatardata
     */
    select?: avatardataSelect<ExtArgs> | null
    /**
     * Filter, which avatardata to fetch.
     */
    where: avatardataWhereUniqueInput
  }

  /**
   * avatardata findUniqueOrThrow
   */
  export type avatardataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the avatardata
     */
    select?: avatardataSelect<ExtArgs> | null
    /**
     * Filter, which avatardata to fetch.
     */
    where: avatardataWhereUniqueInput
  }

  /**
   * avatardata findFirst
   */
  export type avatardataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the avatardata
     */
    select?: avatardataSelect<ExtArgs> | null
    /**
     * Filter, which avatardata to fetch.
     */
    where?: avatardataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of avatardata to fetch.
     */
    orderBy?: avatardataOrderByWithRelationInput | avatardataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for avatardata.
     */
    cursor?: avatardataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` avatardata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` avatardata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of avatardata.
     */
    distinct?: AvatardataScalarFieldEnum | AvatardataScalarFieldEnum[]
  }

  /**
   * avatardata findFirstOrThrow
   */
  export type avatardataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the avatardata
     */
    select?: avatardataSelect<ExtArgs> | null
    /**
     * Filter, which avatardata to fetch.
     */
    where?: avatardataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of avatardata to fetch.
     */
    orderBy?: avatardataOrderByWithRelationInput | avatardataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for avatardata.
     */
    cursor?: avatardataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` avatardata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` avatardata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of avatardata.
     */
    distinct?: AvatardataScalarFieldEnum | AvatardataScalarFieldEnum[]
  }

  /**
   * avatardata findMany
   */
  export type avatardataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the avatardata
     */
    select?: avatardataSelect<ExtArgs> | null
    /**
     * Filter, which avatardata to fetch.
     */
    where?: avatardataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of avatardata to fetch.
     */
    orderBy?: avatardataOrderByWithRelationInput | avatardataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing avatardata.
     */
    cursor?: avatardataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` avatardata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` avatardata.
     */
    skip?: number
    distinct?: AvatardataScalarFieldEnum | AvatardataScalarFieldEnum[]
  }

  /**
   * avatardata create
   */
  export type avatardataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the avatardata
     */
    select?: avatardataSelect<ExtArgs> | null
    /**
     * The data needed to create a avatardata.
     */
    data?: XOR<avatardataCreateInput, avatardataUncheckedCreateInput>
  }

  /**
   * avatardata createMany
   */
  export type avatardataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many avatardata.
     */
    data: avatardataCreateManyInput | avatardataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * avatardata update
   */
  export type avatardataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the avatardata
     */
    select?: avatardataSelect<ExtArgs> | null
    /**
     * The data needed to update a avatardata.
     */
    data: XOR<avatardataUpdateInput, avatardataUncheckedUpdateInput>
    /**
     * Choose, which avatardata to update.
     */
    where: avatardataWhereUniqueInput
  }

  /**
   * avatardata updateMany
   */
  export type avatardataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update avatardata.
     */
    data: XOR<avatardataUpdateManyMutationInput, avatardataUncheckedUpdateManyInput>
    /**
     * Filter which avatardata to update
     */
    where?: avatardataWhereInput
  }

  /**
   * avatardata upsert
   */
  export type avatardataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the avatardata
     */
    select?: avatardataSelect<ExtArgs> | null
    /**
     * The filter to search for the avatardata to update in case it exists.
     */
    where: avatardataWhereUniqueInput
    /**
     * In case the avatardata found by the `where` argument doesn't exist, create a new avatardata with this data.
     */
    create: XOR<avatardataCreateInput, avatardataUncheckedCreateInput>
    /**
     * In case the avatardata was found with the provided `where` argument, update it with this data.
     */
    update: XOR<avatardataUpdateInput, avatardataUncheckedUpdateInput>
  }

  /**
   * avatardata delete
   */
  export type avatardataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the avatardata
     */
    select?: avatardataSelect<ExtArgs> | null
    /**
     * Filter which avatardata to delete.
     */
    where: avatardataWhereUniqueInput
  }

  /**
   * avatardata deleteMany
   */
  export type avatardataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which avatardata to delete
     */
    where?: avatardataWhereInput
  }

  /**
   * avatardata without action
   */
  export type avatardataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the avatardata
     */
    select?: avatardataSelect<ExtArgs> | null
  }


  /**
   * Model avatarlook
   */

  export type AggregateAvatarlook = {
    _count: AvatarlookCountAggregateOutputType | null
    _avg: AvatarlookAvgAggregateOutputType | null
    _sum: AvatarlookSumAggregateOutputType | null
    _min: AvatarlookMinAggregateOutputType | null
    _max: AvatarlookMaxAggregateOutputType | null
  }

  export type AvatarlookAvgAggregateOutputType = {
    id: number | null
    gender: number | null
    skin: number | null
    face: number | null
    hair: number | null
    weaponstickerid: number | null
    weaponid: number | null
    subweaponid: number | null
    job: number | null
    demonslayerdeffaceacc: number | null
    xenondeffaceacc: number | null
    beasttamerdeffaceacc: number | null
    mixedhaircolor: number | null
    mixhairpercent: number | null
    ears: number | null
    tail: number | null
  }

  export type AvatarlookSumAggregateOutputType = {
    id: number | null
    gender: number | null
    skin: number | null
    face: number | null
    hair: number | null
    weaponstickerid: number | null
    weaponid: number | null
    subweaponid: number | null
    job: number | null
    demonslayerdeffaceacc: number | null
    xenondeffaceacc: number | null
    beasttamerdeffaceacc: number | null
    mixedhaircolor: number | null
    mixhairpercent: number | null
    ears: number | null
    tail: number | null
  }

  export type AvatarlookMinAggregateOutputType = {
    id: number | null
    gender: number | null
    skin: number | null
    face: number | null
    hair: number | null
    weaponstickerid: number | null
    weaponid: number | null
    subweaponid: number | null
    job: number | null
    drawelfear: boolean | null
    demonslayerdeffaceacc: number | null
    xenondeffaceacc: number | null
    beasttamerdeffaceacc: number | null
    iszerobetalook: boolean | null
    mixedhaircolor: number | null
    mixhairpercent: number | null
    ears: number | null
    tail: number | null
  }

  export type AvatarlookMaxAggregateOutputType = {
    id: number | null
    gender: number | null
    skin: number | null
    face: number | null
    hair: number | null
    weaponstickerid: number | null
    weaponid: number | null
    subweaponid: number | null
    job: number | null
    drawelfear: boolean | null
    demonslayerdeffaceacc: number | null
    xenondeffaceacc: number | null
    beasttamerdeffaceacc: number | null
    iszerobetalook: boolean | null
    mixedhaircolor: number | null
    mixhairpercent: number | null
    ears: number | null
    tail: number | null
  }

  export type AvatarlookCountAggregateOutputType = {
    id: number
    gender: number
    skin: number
    face: number
    hair: number
    weaponstickerid: number
    weaponid: number
    subweaponid: number
    job: number
    drawelfear: number
    demonslayerdeffaceacc: number
    xenondeffaceacc: number
    beasttamerdeffaceacc: number
    iszerobetalook: number
    mixedhaircolor: number
    mixhairpercent: number
    ears: number
    tail: number
    _all: number
  }


  export type AvatarlookAvgAggregateInputType = {
    id?: true
    gender?: true
    skin?: true
    face?: true
    hair?: true
    weaponstickerid?: true
    weaponid?: true
    subweaponid?: true
    job?: true
    demonslayerdeffaceacc?: true
    xenondeffaceacc?: true
    beasttamerdeffaceacc?: true
    mixedhaircolor?: true
    mixhairpercent?: true
    ears?: true
    tail?: true
  }

  export type AvatarlookSumAggregateInputType = {
    id?: true
    gender?: true
    skin?: true
    face?: true
    hair?: true
    weaponstickerid?: true
    weaponid?: true
    subweaponid?: true
    job?: true
    demonslayerdeffaceacc?: true
    xenondeffaceacc?: true
    beasttamerdeffaceacc?: true
    mixedhaircolor?: true
    mixhairpercent?: true
    ears?: true
    tail?: true
  }

  export type AvatarlookMinAggregateInputType = {
    id?: true
    gender?: true
    skin?: true
    face?: true
    hair?: true
    weaponstickerid?: true
    weaponid?: true
    subweaponid?: true
    job?: true
    drawelfear?: true
    demonslayerdeffaceacc?: true
    xenondeffaceacc?: true
    beasttamerdeffaceacc?: true
    iszerobetalook?: true
    mixedhaircolor?: true
    mixhairpercent?: true
    ears?: true
    tail?: true
  }

  export type AvatarlookMaxAggregateInputType = {
    id?: true
    gender?: true
    skin?: true
    face?: true
    hair?: true
    weaponstickerid?: true
    weaponid?: true
    subweaponid?: true
    job?: true
    drawelfear?: true
    demonslayerdeffaceacc?: true
    xenondeffaceacc?: true
    beasttamerdeffaceacc?: true
    iszerobetalook?: true
    mixedhaircolor?: true
    mixhairpercent?: true
    ears?: true
    tail?: true
  }

  export type AvatarlookCountAggregateInputType = {
    id?: true
    gender?: true
    skin?: true
    face?: true
    hair?: true
    weaponstickerid?: true
    weaponid?: true
    subweaponid?: true
    job?: true
    drawelfear?: true
    demonslayerdeffaceacc?: true
    xenondeffaceacc?: true
    beasttamerdeffaceacc?: true
    iszerobetalook?: true
    mixedhaircolor?: true
    mixhairpercent?: true
    ears?: true
    tail?: true
    _all?: true
  }

  export type AvatarlookAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which avatarlook to aggregate.
     */
    where?: avatarlookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of avatarlooks to fetch.
     */
    orderBy?: avatarlookOrderByWithRelationInput | avatarlookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: avatarlookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` avatarlooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` avatarlooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned avatarlooks
    **/
    _count?: true | AvatarlookCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AvatarlookAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AvatarlookSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AvatarlookMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AvatarlookMaxAggregateInputType
  }

  export type GetAvatarlookAggregateType<T extends AvatarlookAggregateArgs> = {
        [P in keyof T & keyof AggregateAvatarlook]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAvatarlook[P]>
      : GetScalarType<T[P], AggregateAvatarlook[P]>
  }




  export type avatarlookGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: avatarlookWhereInput
    orderBy?: avatarlookOrderByWithAggregationInput | avatarlookOrderByWithAggregationInput[]
    by: AvatarlookScalarFieldEnum[] | AvatarlookScalarFieldEnum
    having?: avatarlookScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AvatarlookCountAggregateInputType | true
    _avg?: AvatarlookAvgAggregateInputType
    _sum?: AvatarlookSumAggregateInputType
    _min?: AvatarlookMinAggregateInputType
    _max?: AvatarlookMaxAggregateInputType
  }

  export type AvatarlookGroupByOutputType = {
    id: number
    gender: number | null
    skin: number | null
    face: number | null
    hair: number | null
    weaponstickerid: number | null
    weaponid: number | null
    subweaponid: number | null
    job: number | null
    drawelfear: boolean | null
    demonslayerdeffaceacc: number | null
    xenondeffaceacc: number | null
    beasttamerdeffaceacc: number | null
    iszerobetalook: boolean | null
    mixedhaircolor: number | null
    mixhairpercent: number | null
    ears: number | null
    tail: number | null
    _count: AvatarlookCountAggregateOutputType | null
    _avg: AvatarlookAvgAggregateOutputType | null
    _sum: AvatarlookSumAggregateOutputType | null
    _min: AvatarlookMinAggregateOutputType | null
    _max: AvatarlookMaxAggregateOutputType | null
  }

  type GetAvatarlookGroupByPayload<T extends avatarlookGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AvatarlookGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AvatarlookGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AvatarlookGroupByOutputType[P]>
            : GetScalarType<T[P], AvatarlookGroupByOutputType[P]>
        }
      >
    >


  export type avatarlookSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gender?: boolean
    skin?: boolean
    face?: boolean
    hair?: boolean
    weaponstickerid?: boolean
    weaponid?: boolean
    subweaponid?: boolean
    job?: boolean
    drawelfear?: boolean
    demonslayerdeffaceacc?: boolean
    xenondeffaceacc?: boolean
    beasttamerdeffaceacc?: boolean
    iszerobetalook?: boolean
    mixedhaircolor?: boolean
    mixhairpercent?: boolean
    ears?: boolean
    tail?: boolean
  }, ExtArgs["result"]["avatarlook"]>


  export type avatarlookSelectScalar = {
    id?: boolean
    gender?: boolean
    skin?: boolean
    face?: boolean
    hair?: boolean
    weaponstickerid?: boolean
    weaponid?: boolean
    subweaponid?: boolean
    job?: boolean
    drawelfear?: boolean
    demonslayerdeffaceacc?: boolean
    xenondeffaceacc?: boolean
    beasttamerdeffaceacc?: boolean
    iszerobetalook?: boolean
    mixedhaircolor?: boolean
    mixhairpercent?: boolean
    ears?: boolean
    tail?: boolean
  }


  export type $avatarlookPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "avatarlook"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      gender: number | null
      skin: number | null
      face: number | null
      hair: number | null
      weaponstickerid: number | null
      weaponid: number | null
      subweaponid: number | null
      job: number | null
      drawelfear: boolean | null
      demonslayerdeffaceacc: number | null
      xenondeffaceacc: number | null
      beasttamerdeffaceacc: number | null
      iszerobetalook: boolean | null
      mixedhaircolor: number | null
      mixhairpercent: number | null
      ears: number | null
      tail: number | null
    }, ExtArgs["result"]["avatarlook"]>
    composites: {}
  }

  type avatarlookGetPayload<S extends boolean | null | undefined | avatarlookDefaultArgs> = $Result.GetResult<Prisma.$avatarlookPayload, S>

  type avatarlookCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<avatarlookFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AvatarlookCountAggregateInputType | true
    }

  export interface avatarlookDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['avatarlook'], meta: { name: 'avatarlook' } }
    /**
     * Find zero or one Avatarlook that matches the filter.
     * @param {avatarlookFindUniqueArgs} args - Arguments to find a Avatarlook
     * @example
     * // Get one Avatarlook
     * const avatarlook = await prisma.avatarlook.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends avatarlookFindUniqueArgs>(args: SelectSubset<T, avatarlookFindUniqueArgs<ExtArgs>>): Prisma__avatarlookClient<$Result.GetResult<Prisma.$avatarlookPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Avatarlook that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {avatarlookFindUniqueOrThrowArgs} args - Arguments to find a Avatarlook
     * @example
     * // Get one Avatarlook
     * const avatarlook = await prisma.avatarlook.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends avatarlookFindUniqueOrThrowArgs>(args: SelectSubset<T, avatarlookFindUniqueOrThrowArgs<ExtArgs>>): Prisma__avatarlookClient<$Result.GetResult<Prisma.$avatarlookPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Avatarlook that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {avatarlookFindFirstArgs} args - Arguments to find a Avatarlook
     * @example
     * // Get one Avatarlook
     * const avatarlook = await prisma.avatarlook.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends avatarlookFindFirstArgs>(args?: SelectSubset<T, avatarlookFindFirstArgs<ExtArgs>>): Prisma__avatarlookClient<$Result.GetResult<Prisma.$avatarlookPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Avatarlook that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {avatarlookFindFirstOrThrowArgs} args - Arguments to find a Avatarlook
     * @example
     * // Get one Avatarlook
     * const avatarlook = await prisma.avatarlook.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends avatarlookFindFirstOrThrowArgs>(args?: SelectSubset<T, avatarlookFindFirstOrThrowArgs<ExtArgs>>): Prisma__avatarlookClient<$Result.GetResult<Prisma.$avatarlookPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Avatarlooks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {avatarlookFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Avatarlooks
     * const avatarlooks = await prisma.avatarlook.findMany()
     * 
     * // Get first 10 Avatarlooks
     * const avatarlooks = await prisma.avatarlook.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const avatarlookWithIdOnly = await prisma.avatarlook.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends avatarlookFindManyArgs>(args?: SelectSubset<T, avatarlookFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$avatarlookPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Avatarlook.
     * @param {avatarlookCreateArgs} args - Arguments to create a Avatarlook.
     * @example
     * // Create one Avatarlook
     * const Avatarlook = await prisma.avatarlook.create({
     *   data: {
     *     // ... data to create a Avatarlook
     *   }
     * })
     * 
     */
    create<T extends avatarlookCreateArgs>(args: SelectSubset<T, avatarlookCreateArgs<ExtArgs>>): Prisma__avatarlookClient<$Result.GetResult<Prisma.$avatarlookPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Avatarlooks.
     * @param {avatarlookCreateManyArgs} args - Arguments to create many Avatarlooks.
     * @example
     * // Create many Avatarlooks
     * const avatarlook = await prisma.avatarlook.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends avatarlookCreateManyArgs>(args?: SelectSubset<T, avatarlookCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Avatarlook.
     * @param {avatarlookDeleteArgs} args - Arguments to delete one Avatarlook.
     * @example
     * // Delete one Avatarlook
     * const Avatarlook = await prisma.avatarlook.delete({
     *   where: {
     *     // ... filter to delete one Avatarlook
     *   }
     * })
     * 
     */
    delete<T extends avatarlookDeleteArgs>(args: SelectSubset<T, avatarlookDeleteArgs<ExtArgs>>): Prisma__avatarlookClient<$Result.GetResult<Prisma.$avatarlookPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Avatarlook.
     * @param {avatarlookUpdateArgs} args - Arguments to update one Avatarlook.
     * @example
     * // Update one Avatarlook
     * const avatarlook = await prisma.avatarlook.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends avatarlookUpdateArgs>(args: SelectSubset<T, avatarlookUpdateArgs<ExtArgs>>): Prisma__avatarlookClient<$Result.GetResult<Prisma.$avatarlookPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Avatarlooks.
     * @param {avatarlookDeleteManyArgs} args - Arguments to filter Avatarlooks to delete.
     * @example
     * // Delete a few Avatarlooks
     * const { count } = await prisma.avatarlook.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends avatarlookDeleteManyArgs>(args?: SelectSubset<T, avatarlookDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Avatarlooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {avatarlookUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Avatarlooks
     * const avatarlook = await prisma.avatarlook.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends avatarlookUpdateManyArgs>(args: SelectSubset<T, avatarlookUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Avatarlook.
     * @param {avatarlookUpsertArgs} args - Arguments to update or create a Avatarlook.
     * @example
     * // Update or create a Avatarlook
     * const avatarlook = await prisma.avatarlook.upsert({
     *   create: {
     *     // ... data to create a Avatarlook
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Avatarlook we want to update
     *   }
     * })
     */
    upsert<T extends avatarlookUpsertArgs>(args: SelectSubset<T, avatarlookUpsertArgs<ExtArgs>>): Prisma__avatarlookClient<$Result.GetResult<Prisma.$avatarlookPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Avatarlooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {avatarlookCountArgs} args - Arguments to filter Avatarlooks to count.
     * @example
     * // Count the number of Avatarlooks
     * const count = await prisma.avatarlook.count({
     *   where: {
     *     // ... the filter for the Avatarlooks we want to count
     *   }
     * })
    **/
    count<T extends avatarlookCountArgs>(
      args?: Subset<T, avatarlookCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AvatarlookCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Avatarlook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvatarlookAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AvatarlookAggregateArgs>(args: Subset<T, AvatarlookAggregateArgs>): Prisma.PrismaPromise<GetAvatarlookAggregateType<T>>

    /**
     * Group by Avatarlook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {avatarlookGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends avatarlookGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: avatarlookGroupByArgs['orderBy'] }
        : { orderBy?: avatarlookGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, avatarlookGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAvatarlookGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the avatarlook model
   */
  readonly fields: avatarlookFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for avatarlook.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__avatarlookClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the avatarlook model
   */ 
  interface avatarlookFieldRefs {
    readonly id: FieldRef<"avatarlook", 'Int'>
    readonly gender: FieldRef<"avatarlook", 'Int'>
    readonly skin: FieldRef<"avatarlook", 'Int'>
    readonly face: FieldRef<"avatarlook", 'Int'>
    readonly hair: FieldRef<"avatarlook", 'Int'>
    readonly weaponstickerid: FieldRef<"avatarlook", 'Int'>
    readonly weaponid: FieldRef<"avatarlook", 'Int'>
    readonly subweaponid: FieldRef<"avatarlook", 'Int'>
    readonly job: FieldRef<"avatarlook", 'Int'>
    readonly drawelfear: FieldRef<"avatarlook", 'Boolean'>
    readonly demonslayerdeffaceacc: FieldRef<"avatarlook", 'Int'>
    readonly xenondeffaceacc: FieldRef<"avatarlook", 'Int'>
    readonly beasttamerdeffaceacc: FieldRef<"avatarlook", 'Int'>
    readonly iszerobetalook: FieldRef<"avatarlook", 'Boolean'>
    readonly mixedhaircolor: FieldRef<"avatarlook", 'Int'>
    readonly mixhairpercent: FieldRef<"avatarlook", 'Int'>
    readonly ears: FieldRef<"avatarlook", 'Int'>
    readonly tail: FieldRef<"avatarlook", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * avatarlook findUnique
   */
  export type avatarlookFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the avatarlook
     */
    select?: avatarlookSelect<ExtArgs> | null
    /**
     * Filter, which avatarlook to fetch.
     */
    where: avatarlookWhereUniqueInput
  }

  /**
   * avatarlook findUniqueOrThrow
   */
  export type avatarlookFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the avatarlook
     */
    select?: avatarlookSelect<ExtArgs> | null
    /**
     * Filter, which avatarlook to fetch.
     */
    where: avatarlookWhereUniqueInput
  }

  /**
   * avatarlook findFirst
   */
  export type avatarlookFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the avatarlook
     */
    select?: avatarlookSelect<ExtArgs> | null
    /**
     * Filter, which avatarlook to fetch.
     */
    where?: avatarlookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of avatarlooks to fetch.
     */
    orderBy?: avatarlookOrderByWithRelationInput | avatarlookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for avatarlooks.
     */
    cursor?: avatarlookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` avatarlooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` avatarlooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of avatarlooks.
     */
    distinct?: AvatarlookScalarFieldEnum | AvatarlookScalarFieldEnum[]
  }

  /**
   * avatarlook findFirstOrThrow
   */
  export type avatarlookFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the avatarlook
     */
    select?: avatarlookSelect<ExtArgs> | null
    /**
     * Filter, which avatarlook to fetch.
     */
    where?: avatarlookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of avatarlooks to fetch.
     */
    orderBy?: avatarlookOrderByWithRelationInput | avatarlookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for avatarlooks.
     */
    cursor?: avatarlookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` avatarlooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` avatarlooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of avatarlooks.
     */
    distinct?: AvatarlookScalarFieldEnum | AvatarlookScalarFieldEnum[]
  }

  /**
   * avatarlook findMany
   */
  export type avatarlookFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the avatarlook
     */
    select?: avatarlookSelect<ExtArgs> | null
    /**
     * Filter, which avatarlooks to fetch.
     */
    where?: avatarlookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of avatarlooks to fetch.
     */
    orderBy?: avatarlookOrderByWithRelationInput | avatarlookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing avatarlooks.
     */
    cursor?: avatarlookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` avatarlooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` avatarlooks.
     */
    skip?: number
    distinct?: AvatarlookScalarFieldEnum | AvatarlookScalarFieldEnum[]
  }

  /**
   * avatarlook create
   */
  export type avatarlookCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the avatarlook
     */
    select?: avatarlookSelect<ExtArgs> | null
    /**
     * The data needed to create a avatarlook.
     */
    data?: XOR<avatarlookCreateInput, avatarlookUncheckedCreateInput>
  }

  /**
   * avatarlook createMany
   */
  export type avatarlookCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many avatarlooks.
     */
    data: avatarlookCreateManyInput | avatarlookCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * avatarlook update
   */
  export type avatarlookUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the avatarlook
     */
    select?: avatarlookSelect<ExtArgs> | null
    /**
     * The data needed to update a avatarlook.
     */
    data: XOR<avatarlookUpdateInput, avatarlookUncheckedUpdateInput>
    /**
     * Choose, which avatarlook to update.
     */
    where: avatarlookWhereUniqueInput
  }

  /**
   * avatarlook updateMany
   */
  export type avatarlookUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update avatarlooks.
     */
    data: XOR<avatarlookUpdateManyMutationInput, avatarlookUncheckedUpdateManyInput>
    /**
     * Filter which avatarlooks to update
     */
    where?: avatarlookWhereInput
  }

  /**
   * avatarlook upsert
   */
  export type avatarlookUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the avatarlook
     */
    select?: avatarlookSelect<ExtArgs> | null
    /**
     * The filter to search for the avatarlook to update in case it exists.
     */
    where: avatarlookWhereUniqueInput
    /**
     * In case the avatarlook found by the `where` argument doesn't exist, create a new avatarlook with this data.
     */
    create: XOR<avatarlookCreateInput, avatarlookUncheckedCreateInput>
    /**
     * In case the avatarlook was found with the provided `where` argument, update it with this data.
     */
    update: XOR<avatarlookUpdateInput, avatarlookUncheckedUpdateInput>
  }

  /**
   * avatarlook delete
   */
  export type avatarlookDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the avatarlook
     */
    select?: avatarlookSelect<ExtArgs> | null
    /**
     * Filter which avatarlook to delete.
     */
    where: avatarlookWhereUniqueInput
  }

  /**
   * avatarlook deleteMany
   */
  export type avatarlookDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which avatarlooks to delete
     */
    where?: avatarlookWhereInput
  }

  /**
   * avatarlook without action
   */
  export type avatarlookDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the avatarlook
     */
    select?: avatarlookSelect<ExtArgs> | null
  }


  /**
   * Model bbs_records
   */

  export type AggregateBbs_records = {
    _count: Bbs_recordsCountAggregateOutputType | null
    _avg: Bbs_recordsAvgAggregateOutputType | null
    _sum: Bbs_recordsSumAggregateOutputType | null
    _min: Bbs_recordsMinAggregateOutputType | null
    _max: Bbs_recordsMaxAggregateOutputType | null
  }

  export type Bbs_recordsAvgAggregateOutputType = {
    id: number | null
    idforbbs: number | null
    creatorid: number | null
    icon: number | null
    guildid: number | null
  }

  export type Bbs_recordsSumAggregateOutputType = {
    id: number | null
    idforbbs: number | null
    creatorid: number | null
    icon: number | null
    guildid: number | null
  }

  export type Bbs_recordsMinAggregateOutputType = {
    id: number | null
    idforbbs: number | null
    creatorid: number | null
    subject: string | null
    msg: string | null
    creationdate: Date | null
    icon: number | null
    guildid: number | null
  }

  export type Bbs_recordsMaxAggregateOutputType = {
    id: number | null
    idforbbs: number | null
    creatorid: number | null
    subject: string | null
    msg: string | null
    creationdate: Date | null
    icon: number | null
    guildid: number | null
  }

  export type Bbs_recordsCountAggregateOutputType = {
    id: number
    idforbbs: number
    creatorid: number
    subject: number
    msg: number
    creationdate: number
    icon: number
    guildid: number
    _all: number
  }


  export type Bbs_recordsAvgAggregateInputType = {
    id?: true
    idforbbs?: true
    creatorid?: true
    icon?: true
    guildid?: true
  }

  export type Bbs_recordsSumAggregateInputType = {
    id?: true
    idforbbs?: true
    creatorid?: true
    icon?: true
    guildid?: true
  }

  export type Bbs_recordsMinAggregateInputType = {
    id?: true
    idforbbs?: true
    creatorid?: true
    subject?: true
    msg?: true
    creationdate?: true
    icon?: true
    guildid?: true
  }

  export type Bbs_recordsMaxAggregateInputType = {
    id?: true
    idforbbs?: true
    creatorid?: true
    subject?: true
    msg?: true
    creationdate?: true
    icon?: true
    guildid?: true
  }

  export type Bbs_recordsCountAggregateInputType = {
    id?: true
    idforbbs?: true
    creatorid?: true
    subject?: true
    msg?: true
    creationdate?: true
    icon?: true
    guildid?: true
    _all?: true
  }

  export type Bbs_recordsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bbs_records to aggregate.
     */
    where?: bbs_recordsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bbs_records to fetch.
     */
    orderBy?: bbs_recordsOrderByWithRelationInput | bbs_recordsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: bbs_recordsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bbs_records from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bbs_records.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned bbs_records
    **/
    _count?: true | Bbs_recordsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Bbs_recordsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Bbs_recordsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Bbs_recordsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Bbs_recordsMaxAggregateInputType
  }

  export type GetBbs_recordsAggregateType<T extends Bbs_recordsAggregateArgs> = {
        [P in keyof T & keyof AggregateBbs_records]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBbs_records[P]>
      : GetScalarType<T[P], AggregateBbs_records[P]>
  }




  export type bbs_recordsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bbs_recordsWhereInput
    orderBy?: bbs_recordsOrderByWithAggregationInput | bbs_recordsOrderByWithAggregationInput[]
    by: Bbs_recordsScalarFieldEnum[] | Bbs_recordsScalarFieldEnum
    having?: bbs_recordsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Bbs_recordsCountAggregateInputType | true
    _avg?: Bbs_recordsAvgAggregateInputType
    _sum?: Bbs_recordsSumAggregateInputType
    _min?: Bbs_recordsMinAggregateInputType
    _max?: Bbs_recordsMaxAggregateInputType
  }

  export type Bbs_recordsGroupByOutputType = {
    id: number
    idforbbs: number | null
    creatorid: number | null
    subject: string | null
    msg: string | null
    creationdate: Date | null
    icon: number | null
    guildid: number | null
    _count: Bbs_recordsCountAggregateOutputType | null
    _avg: Bbs_recordsAvgAggregateOutputType | null
    _sum: Bbs_recordsSumAggregateOutputType | null
    _min: Bbs_recordsMinAggregateOutputType | null
    _max: Bbs_recordsMaxAggregateOutputType | null
  }

  type GetBbs_recordsGroupByPayload<T extends bbs_recordsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Bbs_recordsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Bbs_recordsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Bbs_recordsGroupByOutputType[P]>
            : GetScalarType<T[P], Bbs_recordsGroupByOutputType[P]>
        }
      >
    >


  export type bbs_recordsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idforbbs?: boolean
    creatorid?: boolean
    subject?: boolean
    msg?: boolean
    creationdate?: boolean
    icon?: boolean
    guildid?: boolean
  }, ExtArgs["result"]["bbs_records"]>


  export type bbs_recordsSelectScalar = {
    id?: boolean
    idforbbs?: boolean
    creatorid?: boolean
    subject?: boolean
    msg?: boolean
    creationdate?: boolean
    icon?: boolean
    guildid?: boolean
  }


  export type $bbs_recordsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "bbs_records"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      idforbbs: number | null
      creatorid: number | null
      subject: string | null
      msg: string | null
      creationdate: Date | null
      icon: number | null
      guildid: number | null
    }, ExtArgs["result"]["bbs_records"]>
    composites: {}
  }

  type bbs_recordsGetPayload<S extends boolean | null | undefined | bbs_recordsDefaultArgs> = $Result.GetResult<Prisma.$bbs_recordsPayload, S>

  type bbs_recordsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<bbs_recordsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Bbs_recordsCountAggregateInputType | true
    }

  export interface bbs_recordsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['bbs_records'], meta: { name: 'bbs_records' } }
    /**
     * Find zero or one Bbs_records that matches the filter.
     * @param {bbs_recordsFindUniqueArgs} args - Arguments to find a Bbs_records
     * @example
     * // Get one Bbs_records
     * const bbs_records = await prisma.bbs_records.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends bbs_recordsFindUniqueArgs>(args: SelectSubset<T, bbs_recordsFindUniqueArgs<ExtArgs>>): Prisma__bbs_recordsClient<$Result.GetResult<Prisma.$bbs_recordsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Bbs_records that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {bbs_recordsFindUniqueOrThrowArgs} args - Arguments to find a Bbs_records
     * @example
     * // Get one Bbs_records
     * const bbs_records = await prisma.bbs_records.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends bbs_recordsFindUniqueOrThrowArgs>(args: SelectSubset<T, bbs_recordsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__bbs_recordsClient<$Result.GetResult<Prisma.$bbs_recordsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Bbs_records that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bbs_recordsFindFirstArgs} args - Arguments to find a Bbs_records
     * @example
     * // Get one Bbs_records
     * const bbs_records = await prisma.bbs_records.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends bbs_recordsFindFirstArgs>(args?: SelectSubset<T, bbs_recordsFindFirstArgs<ExtArgs>>): Prisma__bbs_recordsClient<$Result.GetResult<Prisma.$bbs_recordsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Bbs_records that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bbs_recordsFindFirstOrThrowArgs} args - Arguments to find a Bbs_records
     * @example
     * // Get one Bbs_records
     * const bbs_records = await prisma.bbs_records.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends bbs_recordsFindFirstOrThrowArgs>(args?: SelectSubset<T, bbs_recordsFindFirstOrThrowArgs<ExtArgs>>): Prisma__bbs_recordsClient<$Result.GetResult<Prisma.$bbs_recordsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Bbs_records that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bbs_recordsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bbs_records
     * const bbs_records = await prisma.bbs_records.findMany()
     * 
     * // Get first 10 Bbs_records
     * const bbs_records = await prisma.bbs_records.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bbs_recordsWithIdOnly = await prisma.bbs_records.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends bbs_recordsFindManyArgs>(args?: SelectSubset<T, bbs_recordsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bbs_recordsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Bbs_records.
     * @param {bbs_recordsCreateArgs} args - Arguments to create a Bbs_records.
     * @example
     * // Create one Bbs_records
     * const Bbs_records = await prisma.bbs_records.create({
     *   data: {
     *     // ... data to create a Bbs_records
     *   }
     * })
     * 
     */
    create<T extends bbs_recordsCreateArgs>(args: SelectSubset<T, bbs_recordsCreateArgs<ExtArgs>>): Prisma__bbs_recordsClient<$Result.GetResult<Prisma.$bbs_recordsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Bbs_records.
     * @param {bbs_recordsCreateManyArgs} args - Arguments to create many Bbs_records.
     * @example
     * // Create many Bbs_records
     * const bbs_records = await prisma.bbs_records.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends bbs_recordsCreateManyArgs>(args?: SelectSubset<T, bbs_recordsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Bbs_records.
     * @param {bbs_recordsDeleteArgs} args - Arguments to delete one Bbs_records.
     * @example
     * // Delete one Bbs_records
     * const Bbs_records = await prisma.bbs_records.delete({
     *   where: {
     *     // ... filter to delete one Bbs_records
     *   }
     * })
     * 
     */
    delete<T extends bbs_recordsDeleteArgs>(args: SelectSubset<T, bbs_recordsDeleteArgs<ExtArgs>>): Prisma__bbs_recordsClient<$Result.GetResult<Prisma.$bbs_recordsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Bbs_records.
     * @param {bbs_recordsUpdateArgs} args - Arguments to update one Bbs_records.
     * @example
     * // Update one Bbs_records
     * const bbs_records = await prisma.bbs_records.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends bbs_recordsUpdateArgs>(args: SelectSubset<T, bbs_recordsUpdateArgs<ExtArgs>>): Prisma__bbs_recordsClient<$Result.GetResult<Prisma.$bbs_recordsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Bbs_records.
     * @param {bbs_recordsDeleteManyArgs} args - Arguments to filter Bbs_records to delete.
     * @example
     * // Delete a few Bbs_records
     * const { count } = await prisma.bbs_records.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends bbs_recordsDeleteManyArgs>(args?: SelectSubset<T, bbs_recordsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bbs_records.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bbs_recordsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bbs_records
     * const bbs_records = await prisma.bbs_records.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends bbs_recordsUpdateManyArgs>(args: SelectSubset<T, bbs_recordsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bbs_records.
     * @param {bbs_recordsUpsertArgs} args - Arguments to update or create a Bbs_records.
     * @example
     * // Update or create a Bbs_records
     * const bbs_records = await prisma.bbs_records.upsert({
     *   create: {
     *     // ... data to create a Bbs_records
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bbs_records we want to update
     *   }
     * })
     */
    upsert<T extends bbs_recordsUpsertArgs>(args: SelectSubset<T, bbs_recordsUpsertArgs<ExtArgs>>): Prisma__bbs_recordsClient<$Result.GetResult<Prisma.$bbs_recordsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Bbs_records.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bbs_recordsCountArgs} args - Arguments to filter Bbs_records to count.
     * @example
     * // Count the number of Bbs_records
     * const count = await prisma.bbs_records.count({
     *   where: {
     *     // ... the filter for the Bbs_records we want to count
     *   }
     * })
    **/
    count<T extends bbs_recordsCountArgs>(
      args?: Subset<T, bbs_recordsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Bbs_recordsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bbs_records.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Bbs_recordsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Bbs_recordsAggregateArgs>(args: Subset<T, Bbs_recordsAggregateArgs>): Prisma.PrismaPromise<GetBbs_recordsAggregateType<T>>

    /**
     * Group by Bbs_records.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bbs_recordsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends bbs_recordsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: bbs_recordsGroupByArgs['orderBy'] }
        : { orderBy?: bbs_recordsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, bbs_recordsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBbs_recordsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the bbs_records model
   */
  readonly fields: bbs_recordsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for bbs_records.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__bbs_recordsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the bbs_records model
   */ 
  interface bbs_recordsFieldRefs {
    readonly id: FieldRef<"bbs_records", 'Int'>
    readonly idforbbs: FieldRef<"bbs_records", 'Int'>
    readonly creatorid: FieldRef<"bbs_records", 'Int'>
    readonly subject: FieldRef<"bbs_records", 'String'>
    readonly msg: FieldRef<"bbs_records", 'String'>
    readonly creationdate: FieldRef<"bbs_records", 'DateTime'>
    readonly icon: FieldRef<"bbs_records", 'Int'>
    readonly guildid: FieldRef<"bbs_records", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * bbs_records findUnique
   */
  export type bbs_recordsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bbs_records
     */
    select?: bbs_recordsSelect<ExtArgs> | null
    /**
     * Filter, which bbs_records to fetch.
     */
    where: bbs_recordsWhereUniqueInput
  }

  /**
   * bbs_records findUniqueOrThrow
   */
  export type bbs_recordsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bbs_records
     */
    select?: bbs_recordsSelect<ExtArgs> | null
    /**
     * Filter, which bbs_records to fetch.
     */
    where: bbs_recordsWhereUniqueInput
  }

  /**
   * bbs_records findFirst
   */
  export type bbs_recordsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bbs_records
     */
    select?: bbs_recordsSelect<ExtArgs> | null
    /**
     * Filter, which bbs_records to fetch.
     */
    where?: bbs_recordsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bbs_records to fetch.
     */
    orderBy?: bbs_recordsOrderByWithRelationInput | bbs_recordsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bbs_records.
     */
    cursor?: bbs_recordsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bbs_records from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bbs_records.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bbs_records.
     */
    distinct?: Bbs_recordsScalarFieldEnum | Bbs_recordsScalarFieldEnum[]
  }

  /**
   * bbs_records findFirstOrThrow
   */
  export type bbs_recordsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bbs_records
     */
    select?: bbs_recordsSelect<ExtArgs> | null
    /**
     * Filter, which bbs_records to fetch.
     */
    where?: bbs_recordsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bbs_records to fetch.
     */
    orderBy?: bbs_recordsOrderByWithRelationInput | bbs_recordsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bbs_records.
     */
    cursor?: bbs_recordsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bbs_records from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bbs_records.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bbs_records.
     */
    distinct?: Bbs_recordsScalarFieldEnum | Bbs_recordsScalarFieldEnum[]
  }

  /**
   * bbs_records findMany
   */
  export type bbs_recordsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bbs_records
     */
    select?: bbs_recordsSelect<ExtArgs> | null
    /**
     * Filter, which bbs_records to fetch.
     */
    where?: bbs_recordsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bbs_records to fetch.
     */
    orderBy?: bbs_recordsOrderByWithRelationInput | bbs_recordsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing bbs_records.
     */
    cursor?: bbs_recordsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bbs_records from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bbs_records.
     */
    skip?: number
    distinct?: Bbs_recordsScalarFieldEnum | Bbs_recordsScalarFieldEnum[]
  }

  /**
   * bbs_records create
   */
  export type bbs_recordsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bbs_records
     */
    select?: bbs_recordsSelect<ExtArgs> | null
    /**
     * The data needed to create a bbs_records.
     */
    data?: XOR<bbs_recordsCreateInput, bbs_recordsUncheckedCreateInput>
  }

  /**
   * bbs_records createMany
   */
  export type bbs_recordsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many bbs_records.
     */
    data: bbs_recordsCreateManyInput | bbs_recordsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * bbs_records update
   */
  export type bbs_recordsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bbs_records
     */
    select?: bbs_recordsSelect<ExtArgs> | null
    /**
     * The data needed to update a bbs_records.
     */
    data: XOR<bbs_recordsUpdateInput, bbs_recordsUncheckedUpdateInput>
    /**
     * Choose, which bbs_records to update.
     */
    where: bbs_recordsWhereUniqueInput
  }

  /**
   * bbs_records updateMany
   */
  export type bbs_recordsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update bbs_records.
     */
    data: XOR<bbs_recordsUpdateManyMutationInput, bbs_recordsUncheckedUpdateManyInput>
    /**
     * Filter which bbs_records to update
     */
    where?: bbs_recordsWhereInput
  }

  /**
   * bbs_records upsert
   */
  export type bbs_recordsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bbs_records
     */
    select?: bbs_recordsSelect<ExtArgs> | null
    /**
     * The filter to search for the bbs_records to update in case it exists.
     */
    where: bbs_recordsWhereUniqueInput
    /**
     * In case the bbs_records found by the `where` argument doesn't exist, create a new bbs_records with this data.
     */
    create: XOR<bbs_recordsCreateInput, bbs_recordsUncheckedCreateInput>
    /**
     * In case the bbs_records was found with the provided `where` argument, update it with this data.
     */
    update: XOR<bbs_recordsUpdateInput, bbs_recordsUncheckedUpdateInput>
  }

  /**
   * bbs_records delete
   */
  export type bbs_recordsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bbs_records
     */
    select?: bbs_recordsSelect<ExtArgs> | null
    /**
     * Filter which bbs_records to delete.
     */
    where: bbs_recordsWhereUniqueInput
  }

  /**
   * bbs_records deleteMany
   */
  export type bbs_recordsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bbs_records to delete
     */
    where?: bbs_recordsWhereInput
  }

  /**
   * bbs_records without action
   */
  export type bbs_recordsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bbs_records
     */
    select?: bbs_recordsSelect<ExtArgs> | null
  }


  /**
   * Model bbs_replies
   */

  export type AggregateBbs_replies = {
    _count: Bbs_repliesCountAggregateOutputType | null
    _avg: Bbs_repliesAvgAggregateOutputType | null
    _sum: Bbs_repliesSumAggregateOutputType | null
    _min: Bbs_repliesMinAggregateOutputType | null
    _max: Bbs_repliesMaxAggregateOutputType | null
  }

  export type Bbs_repliesAvgAggregateOutputType = {
    id: number | null
    idforreply: number | null
    creatorid: number | null
    recordid: number | null
  }

  export type Bbs_repliesSumAggregateOutputType = {
    id: number | null
    idforreply: number | null
    creatorid: number | null
    recordid: number | null
  }

  export type Bbs_repliesMinAggregateOutputType = {
    id: number | null
    idforreply: number | null
    creatorid: number | null
    creationdate: Date | null
    msg: string | null
    recordid: number | null
  }

  export type Bbs_repliesMaxAggregateOutputType = {
    id: number | null
    idforreply: number | null
    creatorid: number | null
    creationdate: Date | null
    msg: string | null
    recordid: number | null
  }

  export type Bbs_repliesCountAggregateOutputType = {
    id: number
    idforreply: number
    creatorid: number
    creationdate: number
    msg: number
    recordid: number
    _all: number
  }


  export type Bbs_repliesAvgAggregateInputType = {
    id?: true
    idforreply?: true
    creatorid?: true
    recordid?: true
  }

  export type Bbs_repliesSumAggregateInputType = {
    id?: true
    idforreply?: true
    creatorid?: true
    recordid?: true
  }

  export type Bbs_repliesMinAggregateInputType = {
    id?: true
    idforreply?: true
    creatorid?: true
    creationdate?: true
    msg?: true
    recordid?: true
  }

  export type Bbs_repliesMaxAggregateInputType = {
    id?: true
    idforreply?: true
    creatorid?: true
    creationdate?: true
    msg?: true
    recordid?: true
  }

  export type Bbs_repliesCountAggregateInputType = {
    id?: true
    idforreply?: true
    creatorid?: true
    creationdate?: true
    msg?: true
    recordid?: true
    _all?: true
  }

  export type Bbs_repliesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bbs_replies to aggregate.
     */
    where?: bbs_repliesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bbs_replies to fetch.
     */
    orderBy?: bbs_repliesOrderByWithRelationInput | bbs_repliesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: bbs_repliesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bbs_replies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bbs_replies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned bbs_replies
    **/
    _count?: true | Bbs_repliesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Bbs_repliesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Bbs_repliesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Bbs_repliesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Bbs_repliesMaxAggregateInputType
  }

  export type GetBbs_repliesAggregateType<T extends Bbs_repliesAggregateArgs> = {
        [P in keyof T & keyof AggregateBbs_replies]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBbs_replies[P]>
      : GetScalarType<T[P], AggregateBbs_replies[P]>
  }




  export type bbs_repliesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bbs_repliesWhereInput
    orderBy?: bbs_repliesOrderByWithAggregationInput | bbs_repliesOrderByWithAggregationInput[]
    by: Bbs_repliesScalarFieldEnum[] | Bbs_repliesScalarFieldEnum
    having?: bbs_repliesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Bbs_repliesCountAggregateInputType | true
    _avg?: Bbs_repliesAvgAggregateInputType
    _sum?: Bbs_repliesSumAggregateInputType
    _min?: Bbs_repliesMinAggregateInputType
    _max?: Bbs_repliesMaxAggregateInputType
  }

  export type Bbs_repliesGroupByOutputType = {
    id: number
    idforreply: number | null
    creatorid: number | null
    creationdate: Date | null
    msg: string | null
    recordid: number | null
    _count: Bbs_repliesCountAggregateOutputType | null
    _avg: Bbs_repliesAvgAggregateOutputType | null
    _sum: Bbs_repliesSumAggregateOutputType | null
    _min: Bbs_repliesMinAggregateOutputType | null
    _max: Bbs_repliesMaxAggregateOutputType | null
  }

  type GetBbs_repliesGroupByPayload<T extends bbs_repliesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Bbs_repliesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Bbs_repliesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Bbs_repliesGroupByOutputType[P]>
            : GetScalarType<T[P], Bbs_repliesGroupByOutputType[P]>
        }
      >
    >


  export type bbs_repliesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idforreply?: boolean
    creatorid?: boolean
    creationdate?: boolean
    msg?: boolean
    recordid?: boolean
  }, ExtArgs["result"]["bbs_replies"]>


  export type bbs_repliesSelectScalar = {
    id?: boolean
    idforreply?: boolean
    creatorid?: boolean
    creationdate?: boolean
    msg?: boolean
    recordid?: boolean
  }


  export type $bbs_repliesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "bbs_replies"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      idforreply: number | null
      creatorid: number | null
      creationdate: Date | null
      msg: string | null
      recordid: number | null
    }, ExtArgs["result"]["bbs_replies"]>
    composites: {}
  }

  type bbs_repliesGetPayload<S extends boolean | null | undefined | bbs_repliesDefaultArgs> = $Result.GetResult<Prisma.$bbs_repliesPayload, S>

  type bbs_repliesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<bbs_repliesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Bbs_repliesCountAggregateInputType | true
    }

  export interface bbs_repliesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['bbs_replies'], meta: { name: 'bbs_replies' } }
    /**
     * Find zero or one Bbs_replies that matches the filter.
     * @param {bbs_repliesFindUniqueArgs} args - Arguments to find a Bbs_replies
     * @example
     * // Get one Bbs_replies
     * const bbs_replies = await prisma.bbs_replies.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends bbs_repliesFindUniqueArgs>(args: SelectSubset<T, bbs_repliesFindUniqueArgs<ExtArgs>>): Prisma__bbs_repliesClient<$Result.GetResult<Prisma.$bbs_repliesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Bbs_replies that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {bbs_repliesFindUniqueOrThrowArgs} args - Arguments to find a Bbs_replies
     * @example
     * // Get one Bbs_replies
     * const bbs_replies = await prisma.bbs_replies.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends bbs_repliesFindUniqueOrThrowArgs>(args: SelectSubset<T, bbs_repliesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__bbs_repliesClient<$Result.GetResult<Prisma.$bbs_repliesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Bbs_replies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bbs_repliesFindFirstArgs} args - Arguments to find a Bbs_replies
     * @example
     * // Get one Bbs_replies
     * const bbs_replies = await prisma.bbs_replies.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends bbs_repliesFindFirstArgs>(args?: SelectSubset<T, bbs_repliesFindFirstArgs<ExtArgs>>): Prisma__bbs_repliesClient<$Result.GetResult<Prisma.$bbs_repliesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Bbs_replies that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bbs_repliesFindFirstOrThrowArgs} args - Arguments to find a Bbs_replies
     * @example
     * // Get one Bbs_replies
     * const bbs_replies = await prisma.bbs_replies.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends bbs_repliesFindFirstOrThrowArgs>(args?: SelectSubset<T, bbs_repliesFindFirstOrThrowArgs<ExtArgs>>): Prisma__bbs_repliesClient<$Result.GetResult<Prisma.$bbs_repliesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Bbs_replies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bbs_repliesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bbs_replies
     * const bbs_replies = await prisma.bbs_replies.findMany()
     * 
     * // Get first 10 Bbs_replies
     * const bbs_replies = await prisma.bbs_replies.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bbs_repliesWithIdOnly = await prisma.bbs_replies.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends bbs_repliesFindManyArgs>(args?: SelectSubset<T, bbs_repliesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bbs_repliesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Bbs_replies.
     * @param {bbs_repliesCreateArgs} args - Arguments to create a Bbs_replies.
     * @example
     * // Create one Bbs_replies
     * const Bbs_replies = await prisma.bbs_replies.create({
     *   data: {
     *     // ... data to create a Bbs_replies
     *   }
     * })
     * 
     */
    create<T extends bbs_repliesCreateArgs>(args: SelectSubset<T, bbs_repliesCreateArgs<ExtArgs>>): Prisma__bbs_repliesClient<$Result.GetResult<Prisma.$bbs_repliesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Bbs_replies.
     * @param {bbs_repliesCreateManyArgs} args - Arguments to create many Bbs_replies.
     * @example
     * // Create many Bbs_replies
     * const bbs_replies = await prisma.bbs_replies.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends bbs_repliesCreateManyArgs>(args?: SelectSubset<T, bbs_repliesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Bbs_replies.
     * @param {bbs_repliesDeleteArgs} args - Arguments to delete one Bbs_replies.
     * @example
     * // Delete one Bbs_replies
     * const Bbs_replies = await prisma.bbs_replies.delete({
     *   where: {
     *     // ... filter to delete one Bbs_replies
     *   }
     * })
     * 
     */
    delete<T extends bbs_repliesDeleteArgs>(args: SelectSubset<T, bbs_repliesDeleteArgs<ExtArgs>>): Prisma__bbs_repliesClient<$Result.GetResult<Prisma.$bbs_repliesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Bbs_replies.
     * @param {bbs_repliesUpdateArgs} args - Arguments to update one Bbs_replies.
     * @example
     * // Update one Bbs_replies
     * const bbs_replies = await prisma.bbs_replies.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends bbs_repliesUpdateArgs>(args: SelectSubset<T, bbs_repliesUpdateArgs<ExtArgs>>): Prisma__bbs_repliesClient<$Result.GetResult<Prisma.$bbs_repliesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Bbs_replies.
     * @param {bbs_repliesDeleteManyArgs} args - Arguments to filter Bbs_replies to delete.
     * @example
     * // Delete a few Bbs_replies
     * const { count } = await prisma.bbs_replies.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends bbs_repliesDeleteManyArgs>(args?: SelectSubset<T, bbs_repliesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bbs_replies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bbs_repliesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bbs_replies
     * const bbs_replies = await prisma.bbs_replies.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends bbs_repliesUpdateManyArgs>(args: SelectSubset<T, bbs_repliesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bbs_replies.
     * @param {bbs_repliesUpsertArgs} args - Arguments to update or create a Bbs_replies.
     * @example
     * // Update or create a Bbs_replies
     * const bbs_replies = await prisma.bbs_replies.upsert({
     *   create: {
     *     // ... data to create a Bbs_replies
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bbs_replies we want to update
     *   }
     * })
     */
    upsert<T extends bbs_repliesUpsertArgs>(args: SelectSubset<T, bbs_repliesUpsertArgs<ExtArgs>>): Prisma__bbs_repliesClient<$Result.GetResult<Prisma.$bbs_repliesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Bbs_replies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bbs_repliesCountArgs} args - Arguments to filter Bbs_replies to count.
     * @example
     * // Count the number of Bbs_replies
     * const count = await prisma.bbs_replies.count({
     *   where: {
     *     // ... the filter for the Bbs_replies we want to count
     *   }
     * })
    **/
    count<T extends bbs_repliesCountArgs>(
      args?: Subset<T, bbs_repliesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Bbs_repliesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bbs_replies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Bbs_repliesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Bbs_repliesAggregateArgs>(args: Subset<T, Bbs_repliesAggregateArgs>): Prisma.PrismaPromise<GetBbs_repliesAggregateType<T>>

    /**
     * Group by Bbs_replies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bbs_repliesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends bbs_repliesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: bbs_repliesGroupByArgs['orderBy'] }
        : { orderBy?: bbs_repliesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, bbs_repliesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBbs_repliesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the bbs_replies model
   */
  readonly fields: bbs_repliesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for bbs_replies.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__bbs_repliesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the bbs_replies model
   */ 
  interface bbs_repliesFieldRefs {
    readonly id: FieldRef<"bbs_replies", 'Int'>
    readonly idforreply: FieldRef<"bbs_replies", 'Int'>
    readonly creatorid: FieldRef<"bbs_replies", 'Int'>
    readonly creationdate: FieldRef<"bbs_replies", 'DateTime'>
    readonly msg: FieldRef<"bbs_replies", 'String'>
    readonly recordid: FieldRef<"bbs_replies", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * bbs_replies findUnique
   */
  export type bbs_repliesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bbs_replies
     */
    select?: bbs_repliesSelect<ExtArgs> | null
    /**
     * Filter, which bbs_replies to fetch.
     */
    where: bbs_repliesWhereUniqueInput
  }

  /**
   * bbs_replies findUniqueOrThrow
   */
  export type bbs_repliesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bbs_replies
     */
    select?: bbs_repliesSelect<ExtArgs> | null
    /**
     * Filter, which bbs_replies to fetch.
     */
    where: bbs_repliesWhereUniqueInput
  }

  /**
   * bbs_replies findFirst
   */
  export type bbs_repliesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bbs_replies
     */
    select?: bbs_repliesSelect<ExtArgs> | null
    /**
     * Filter, which bbs_replies to fetch.
     */
    where?: bbs_repliesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bbs_replies to fetch.
     */
    orderBy?: bbs_repliesOrderByWithRelationInput | bbs_repliesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bbs_replies.
     */
    cursor?: bbs_repliesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bbs_replies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bbs_replies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bbs_replies.
     */
    distinct?: Bbs_repliesScalarFieldEnum | Bbs_repliesScalarFieldEnum[]
  }

  /**
   * bbs_replies findFirstOrThrow
   */
  export type bbs_repliesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bbs_replies
     */
    select?: bbs_repliesSelect<ExtArgs> | null
    /**
     * Filter, which bbs_replies to fetch.
     */
    where?: bbs_repliesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bbs_replies to fetch.
     */
    orderBy?: bbs_repliesOrderByWithRelationInput | bbs_repliesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bbs_replies.
     */
    cursor?: bbs_repliesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bbs_replies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bbs_replies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bbs_replies.
     */
    distinct?: Bbs_repliesScalarFieldEnum | Bbs_repliesScalarFieldEnum[]
  }

  /**
   * bbs_replies findMany
   */
  export type bbs_repliesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bbs_replies
     */
    select?: bbs_repliesSelect<ExtArgs> | null
    /**
     * Filter, which bbs_replies to fetch.
     */
    where?: bbs_repliesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bbs_replies to fetch.
     */
    orderBy?: bbs_repliesOrderByWithRelationInput | bbs_repliesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing bbs_replies.
     */
    cursor?: bbs_repliesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bbs_replies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bbs_replies.
     */
    skip?: number
    distinct?: Bbs_repliesScalarFieldEnum | Bbs_repliesScalarFieldEnum[]
  }

  /**
   * bbs_replies create
   */
  export type bbs_repliesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bbs_replies
     */
    select?: bbs_repliesSelect<ExtArgs> | null
    /**
     * The data needed to create a bbs_replies.
     */
    data?: XOR<bbs_repliesCreateInput, bbs_repliesUncheckedCreateInput>
  }

  /**
   * bbs_replies createMany
   */
  export type bbs_repliesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many bbs_replies.
     */
    data: bbs_repliesCreateManyInput | bbs_repliesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * bbs_replies update
   */
  export type bbs_repliesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bbs_replies
     */
    select?: bbs_repliesSelect<ExtArgs> | null
    /**
     * The data needed to update a bbs_replies.
     */
    data: XOR<bbs_repliesUpdateInput, bbs_repliesUncheckedUpdateInput>
    /**
     * Choose, which bbs_replies to update.
     */
    where: bbs_repliesWhereUniqueInput
  }

  /**
   * bbs_replies updateMany
   */
  export type bbs_repliesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update bbs_replies.
     */
    data: XOR<bbs_repliesUpdateManyMutationInput, bbs_repliesUncheckedUpdateManyInput>
    /**
     * Filter which bbs_replies to update
     */
    where?: bbs_repliesWhereInput
  }

  /**
   * bbs_replies upsert
   */
  export type bbs_repliesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bbs_replies
     */
    select?: bbs_repliesSelect<ExtArgs> | null
    /**
     * The filter to search for the bbs_replies to update in case it exists.
     */
    where: bbs_repliesWhereUniqueInput
    /**
     * In case the bbs_replies found by the `where` argument doesn't exist, create a new bbs_replies with this data.
     */
    create: XOR<bbs_repliesCreateInput, bbs_repliesUncheckedCreateInput>
    /**
     * In case the bbs_replies was found with the provided `where` argument, update it with this data.
     */
    update: XOR<bbs_repliesUpdateInput, bbs_repliesUncheckedUpdateInput>
  }

  /**
   * bbs_replies delete
   */
  export type bbs_repliesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bbs_replies
     */
    select?: bbs_repliesSelect<ExtArgs> | null
    /**
     * Filter which bbs_replies to delete.
     */
    where: bbs_repliesWhereUniqueInput
  }

  /**
   * bbs_replies deleteMany
   */
  export type bbs_repliesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bbs_replies to delete
     */
    where?: bbs_repliesWhereInput
  }

  /**
   * bbs_replies without action
   */
  export type bbs_repliesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bbs_replies
     */
    select?: bbs_repliesSelect<ExtArgs> | null
  }


  /**
   * Model beautydata
   */

  export type AggregateBeautydata = {
    _count: BeautydataCountAggregateOutputType | null
    _avg: BeautydataAvgAggregateOutputType | null
    _sum: BeautydataSumAggregateOutputType | null
    _min: BeautydataMinAggregateOutputType | null
    _max: BeautydataMaxAggregateOutputType | null
  }

  export type BeautydataAvgAggregateOutputType = {
    id: number | null
    charID: number | null
    hairSize: number | null
    faceSize: number | null
  }

  export type BeautydataSumAggregateOutputType = {
    id: number | null
    charID: number | null
    hairSize: number | null
    faceSize: number | null
  }

  export type BeautydataMinAggregateOutputType = {
    id: number | null
    charID: number | null
    hairSize: number | null
    faceSize: number | null
    hairString: string | null
    faceString: string | null
  }

  export type BeautydataMaxAggregateOutputType = {
    id: number | null
    charID: number | null
    hairSize: number | null
    faceSize: number | null
    hairString: string | null
    faceString: string | null
  }

  export type BeautydataCountAggregateOutputType = {
    id: number
    charID: number
    hairSize: number
    faceSize: number
    hairString: number
    faceString: number
    _all: number
  }


  export type BeautydataAvgAggregateInputType = {
    id?: true
    charID?: true
    hairSize?: true
    faceSize?: true
  }

  export type BeautydataSumAggregateInputType = {
    id?: true
    charID?: true
    hairSize?: true
    faceSize?: true
  }

  export type BeautydataMinAggregateInputType = {
    id?: true
    charID?: true
    hairSize?: true
    faceSize?: true
    hairString?: true
    faceString?: true
  }

  export type BeautydataMaxAggregateInputType = {
    id?: true
    charID?: true
    hairSize?: true
    faceSize?: true
    hairString?: true
    faceString?: true
  }

  export type BeautydataCountAggregateInputType = {
    id?: true
    charID?: true
    hairSize?: true
    faceSize?: true
    hairString?: true
    faceString?: true
    _all?: true
  }

  export type BeautydataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which beautydata to aggregate.
     */
    where?: beautydataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of beautydata to fetch.
     */
    orderBy?: beautydataOrderByWithRelationInput | beautydataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: beautydataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` beautydata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` beautydata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned beautydata
    **/
    _count?: true | BeautydataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BeautydataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BeautydataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BeautydataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BeautydataMaxAggregateInputType
  }

  export type GetBeautydataAggregateType<T extends BeautydataAggregateArgs> = {
        [P in keyof T & keyof AggregateBeautydata]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBeautydata[P]>
      : GetScalarType<T[P], AggregateBeautydata[P]>
  }




  export type beautydataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: beautydataWhereInput
    orderBy?: beautydataOrderByWithAggregationInput | beautydataOrderByWithAggregationInput[]
    by: BeautydataScalarFieldEnum[] | BeautydataScalarFieldEnum
    having?: beautydataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BeautydataCountAggregateInputType | true
    _avg?: BeautydataAvgAggregateInputType
    _sum?: BeautydataSumAggregateInputType
    _min?: BeautydataMinAggregateInputType
    _max?: BeautydataMaxAggregateInputType
  }

  export type BeautydataGroupByOutputType = {
    id: number
    charID: number
    hairSize: number
    faceSize: number
    hairString: string
    faceString: string
    _count: BeautydataCountAggregateOutputType | null
    _avg: BeautydataAvgAggregateOutputType | null
    _sum: BeautydataSumAggregateOutputType | null
    _min: BeautydataMinAggregateOutputType | null
    _max: BeautydataMaxAggregateOutputType | null
  }

  type GetBeautydataGroupByPayload<T extends beautydataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BeautydataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BeautydataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BeautydataGroupByOutputType[P]>
            : GetScalarType<T[P], BeautydataGroupByOutputType[P]>
        }
      >
    >


  export type beautydataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    charID?: boolean
    hairSize?: boolean
    faceSize?: boolean
    hairString?: boolean
    faceString?: boolean
  }, ExtArgs["result"]["beautydata"]>


  export type beautydataSelectScalar = {
    id?: boolean
    charID?: boolean
    hairSize?: boolean
    faceSize?: boolean
    hairString?: boolean
    faceString?: boolean
  }


  export type $beautydataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "beautydata"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      charID: number
      hairSize: number
      faceSize: number
      hairString: string
      faceString: string
    }, ExtArgs["result"]["beautydata"]>
    composites: {}
  }

  type beautydataGetPayload<S extends boolean | null | undefined | beautydataDefaultArgs> = $Result.GetResult<Prisma.$beautydataPayload, S>

  type beautydataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<beautydataFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BeautydataCountAggregateInputType | true
    }

  export interface beautydataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['beautydata'], meta: { name: 'beautydata' } }
    /**
     * Find zero or one Beautydata that matches the filter.
     * @param {beautydataFindUniqueArgs} args - Arguments to find a Beautydata
     * @example
     * // Get one Beautydata
     * const beautydata = await prisma.beautydata.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends beautydataFindUniqueArgs>(args: SelectSubset<T, beautydataFindUniqueArgs<ExtArgs>>): Prisma__beautydataClient<$Result.GetResult<Prisma.$beautydataPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Beautydata that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {beautydataFindUniqueOrThrowArgs} args - Arguments to find a Beautydata
     * @example
     * // Get one Beautydata
     * const beautydata = await prisma.beautydata.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends beautydataFindUniqueOrThrowArgs>(args: SelectSubset<T, beautydataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__beautydataClient<$Result.GetResult<Prisma.$beautydataPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Beautydata that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {beautydataFindFirstArgs} args - Arguments to find a Beautydata
     * @example
     * // Get one Beautydata
     * const beautydata = await prisma.beautydata.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends beautydataFindFirstArgs>(args?: SelectSubset<T, beautydataFindFirstArgs<ExtArgs>>): Prisma__beautydataClient<$Result.GetResult<Prisma.$beautydataPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Beautydata that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {beautydataFindFirstOrThrowArgs} args - Arguments to find a Beautydata
     * @example
     * // Get one Beautydata
     * const beautydata = await prisma.beautydata.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends beautydataFindFirstOrThrowArgs>(args?: SelectSubset<T, beautydataFindFirstOrThrowArgs<ExtArgs>>): Prisma__beautydataClient<$Result.GetResult<Prisma.$beautydataPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Beautydata that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {beautydataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Beautydata
     * const beautydata = await prisma.beautydata.findMany()
     * 
     * // Get first 10 Beautydata
     * const beautydata = await prisma.beautydata.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const beautydataWithIdOnly = await prisma.beautydata.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends beautydataFindManyArgs>(args?: SelectSubset<T, beautydataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$beautydataPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Beautydata.
     * @param {beautydataCreateArgs} args - Arguments to create a Beautydata.
     * @example
     * // Create one Beautydata
     * const Beautydata = await prisma.beautydata.create({
     *   data: {
     *     // ... data to create a Beautydata
     *   }
     * })
     * 
     */
    create<T extends beautydataCreateArgs>(args: SelectSubset<T, beautydataCreateArgs<ExtArgs>>): Prisma__beautydataClient<$Result.GetResult<Prisma.$beautydataPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Beautydata.
     * @param {beautydataCreateManyArgs} args - Arguments to create many Beautydata.
     * @example
     * // Create many Beautydata
     * const beautydata = await prisma.beautydata.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends beautydataCreateManyArgs>(args?: SelectSubset<T, beautydataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Beautydata.
     * @param {beautydataDeleteArgs} args - Arguments to delete one Beautydata.
     * @example
     * // Delete one Beautydata
     * const Beautydata = await prisma.beautydata.delete({
     *   where: {
     *     // ... filter to delete one Beautydata
     *   }
     * })
     * 
     */
    delete<T extends beautydataDeleteArgs>(args: SelectSubset<T, beautydataDeleteArgs<ExtArgs>>): Prisma__beautydataClient<$Result.GetResult<Prisma.$beautydataPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Beautydata.
     * @param {beautydataUpdateArgs} args - Arguments to update one Beautydata.
     * @example
     * // Update one Beautydata
     * const beautydata = await prisma.beautydata.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends beautydataUpdateArgs>(args: SelectSubset<T, beautydataUpdateArgs<ExtArgs>>): Prisma__beautydataClient<$Result.GetResult<Prisma.$beautydataPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Beautydata.
     * @param {beautydataDeleteManyArgs} args - Arguments to filter Beautydata to delete.
     * @example
     * // Delete a few Beautydata
     * const { count } = await prisma.beautydata.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends beautydataDeleteManyArgs>(args?: SelectSubset<T, beautydataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Beautydata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {beautydataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Beautydata
     * const beautydata = await prisma.beautydata.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends beautydataUpdateManyArgs>(args: SelectSubset<T, beautydataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Beautydata.
     * @param {beautydataUpsertArgs} args - Arguments to update or create a Beautydata.
     * @example
     * // Update or create a Beautydata
     * const beautydata = await prisma.beautydata.upsert({
     *   create: {
     *     // ... data to create a Beautydata
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Beautydata we want to update
     *   }
     * })
     */
    upsert<T extends beautydataUpsertArgs>(args: SelectSubset<T, beautydataUpsertArgs<ExtArgs>>): Prisma__beautydataClient<$Result.GetResult<Prisma.$beautydataPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Beautydata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {beautydataCountArgs} args - Arguments to filter Beautydata to count.
     * @example
     * // Count the number of Beautydata
     * const count = await prisma.beautydata.count({
     *   where: {
     *     // ... the filter for the Beautydata we want to count
     *   }
     * })
    **/
    count<T extends beautydataCountArgs>(
      args?: Subset<T, beautydataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BeautydataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Beautydata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BeautydataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BeautydataAggregateArgs>(args: Subset<T, BeautydataAggregateArgs>): Prisma.PrismaPromise<GetBeautydataAggregateType<T>>

    /**
     * Group by Beautydata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {beautydataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends beautydataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: beautydataGroupByArgs['orderBy'] }
        : { orderBy?: beautydataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, beautydataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBeautydataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the beautydata model
   */
  readonly fields: beautydataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for beautydata.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__beautydataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the beautydata model
   */ 
  interface beautydataFieldRefs {
    readonly id: FieldRef<"beautydata", 'Int'>
    readonly charID: FieldRef<"beautydata", 'Int'>
    readonly hairSize: FieldRef<"beautydata", 'Int'>
    readonly faceSize: FieldRef<"beautydata", 'Int'>
    readonly hairString: FieldRef<"beautydata", 'String'>
    readonly faceString: FieldRef<"beautydata", 'String'>
  }
    

  // Custom InputTypes
  /**
   * beautydata findUnique
   */
  export type beautydataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the beautydata
     */
    select?: beautydataSelect<ExtArgs> | null
    /**
     * Filter, which beautydata to fetch.
     */
    where: beautydataWhereUniqueInput
  }

  /**
   * beautydata findUniqueOrThrow
   */
  export type beautydataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the beautydata
     */
    select?: beautydataSelect<ExtArgs> | null
    /**
     * Filter, which beautydata to fetch.
     */
    where: beautydataWhereUniqueInput
  }

  /**
   * beautydata findFirst
   */
  export type beautydataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the beautydata
     */
    select?: beautydataSelect<ExtArgs> | null
    /**
     * Filter, which beautydata to fetch.
     */
    where?: beautydataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of beautydata to fetch.
     */
    orderBy?: beautydataOrderByWithRelationInput | beautydataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for beautydata.
     */
    cursor?: beautydataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` beautydata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` beautydata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of beautydata.
     */
    distinct?: BeautydataScalarFieldEnum | BeautydataScalarFieldEnum[]
  }

  /**
   * beautydata findFirstOrThrow
   */
  export type beautydataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the beautydata
     */
    select?: beautydataSelect<ExtArgs> | null
    /**
     * Filter, which beautydata to fetch.
     */
    where?: beautydataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of beautydata to fetch.
     */
    orderBy?: beautydataOrderByWithRelationInput | beautydataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for beautydata.
     */
    cursor?: beautydataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` beautydata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` beautydata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of beautydata.
     */
    distinct?: BeautydataScalarFieldEnum | BeautydataScalarFieldEnum[]
  }

  /**
   * beautydata findMany
   */
  export type beautydataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the beautydata
     */
    select?: beautydataSelect<ExtArgs> | null
    /**
     * Filter, which beautydata to fetch.
     */
    where?: beautydataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of beautydata to fetch.
     */
    orderBy?: beautydataOrderByWithRelationInput | beautydataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing beautydata.
     */
    cursor?: beautydataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` beautydata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` beautydata.
     */
    skip?: number
    distinct?: BeautydataScalarFieldEnum | BeautydataScalarFieldEnum[]
  }

  /**
   * beautydata create
   */
  export type beautydataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the beautydata
     */
    select?: beautydataSelect<ExtArgs> | null
    /**
     * The data needed to create a beautydata.
     */
    data: XOR<beautydataCreateInput, beautydataUncheckedCreateInput>
  }

  /**
   * beautydata createMany
   */
  export type beautydataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many beautydata.
     */
    data: beautydataCreateManyInput | beautydataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * beautydata update
   */
  export type beautydataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the beautydata
     */
    select?: beautydataSelect<ExtArgs> | null
    /**
     * The data needed to update a beautydata.
     */
    data: XOR<beautydataUpdateInput, beautydataUncheckedUpdateInput>
    /**
     * Choose, which beautydata to update.
     */
    where: beautydataWhereUniqueInput
  }

  /**
   * beautydata updateMany
   */
  export type beautydataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update beautydata.
     */
    data: XOR<beautydataUpdateManyMutationInput, beautydataUncheckedUpdateManyInput>
    /**
     * Filter which beautydata to update
     */
    where?: beautydataWhereInput
  }

  /**
   * beautydata upsert
   */
  export type beautydataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the beautydata
     */
    select?: beautydataSelect<ExtArgs> | null
    /**
     * The filter to search for the beautydata to update in case it exists.
     */
    where: beautydataWhereUniqueInput
    /**
     * In case the beautydata found by the `where` argument doesn't exist, create a new beautydata with this data.
     */
    create: XOR<beautydataCreateInput, beautydataUncheckedCreateInput>
    /**
     * In case the beautydata was found with the provided `where` argument, update it with this data.
     */
    update: XOR<beautydataUpdateInput, beautydataUncheckedUpdateInput>
  }

  /**
   * beautydata delete
   */
  export type beautydataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the beautydata
     */
    select?: beautydataSelect<ExtArgs> | null
    /**
     * Filter which beautydata to delete.
     */
    where: beautydataWhereUniqueInput
  }

  /**
   * beautydata deleteMany
   */
  export type beautydataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which beautydata to delete
     */
    where?: beautydataWhereInput
  }

  /**
   * beautydata without action
   */
  export type beautydataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the beautydata
     */
    select?: beautydataSelect<ExtArgs> | null
  }


  /**
   * Model bosslog
   */

  export type AggregateBosslog = {
    _count: BosslogCountAggregateOutputType | null
    _avg: BosslogAvgAggregateOutputType | null
    _sum: BosslogSumAggregateOutputType | null
    _min: BosslogMinAggregateOutputType | null
    _max: BosslogMaxAggregateOutputType | null
  }

  export type BosslogAvgAggregateOutputType = {
    id: number | null
    accountid: number | null
    pqentry: number | null
  }

  export type BosslogSumAggregateOutputType = {
    id: number | null
    accountid: number | null
    pqentry: number | null
  }

  export type BosslogMinAggregateOutputType = {
    id: number | null
    accountid: number | null
    bossid: string | null
    lastattempt: Date | null
    pqentry: number | null
  }

  export type BosslogMaxAggregateOutputType = {
    id: number | null
    accountid: number | null
    bossid: string | null
    lastattempt: Date | null
    pqentry: number | null
  }

  export type BosslogCountAggregateOutputType = {
    id: number
    accountid: number
    bossid: number
    lastattempt: number
    pqentry: number
    _all: number
  }


  export type BosslogAvgAggregateInputType = {
    id?: true
    accountid?: true
    pqentry?: true
  }

  export type BosslogSumAggregateInputType = {
    id?: true
    accountid?: true
    pqentry?: true
  }

  export type BosslogMinAggregateInputType = {
    id?: true
    accountid?: true
    bossid?: true
    lastattempt?: true
    pqentry?: true
  }

  export type BosslogMaxAggregateInputType = {
    id?: true
    accountid?: true
    bossid?: true
    lastattempt?: true
    pqentry?: true
  }

  export type BosslogCountAggregateInputType = {
    id?: true
    accountid?: true
    bossid?: true
    lastattempt?: true
    pqentry?: true
    _all?: true
  }

  export type BosslogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bosslog to aggregate.
     */
    where?: bosslogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bosslogs to fetch.
     */
    orderBy?: bosslogOrderByWithRelationInput | bosslogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: bosslogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bosslogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bosslogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned bosslogs
    **/
    _count?: true | BosslogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BosslogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BosslogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BosslogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BosslogMaxAggregateInputType
  }

  export type GetBosslogAggregateType<T extends BosslogAggregateArgs> = {
        [P in keyof T & keyof AggregateBosslog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBosslog[P]>
      : GetScalarType<T[P], AggregateBosslog[P]>
  }




  export type bosslogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bosslogWhereInput
    orderBy?: bosslogOrderByWithAggregationInput | bosslogOrderByWithAggregationInput[]
    by: BosslogScalarFieldEnum[] | BosslogScalarFieldEnum
    having?: bosslogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BosslogCountAggregateInputType | true
    _avg?: BosslogAvgAggregateInputType
    _sum?: BosslogSumAggregateInputType
    _min?: BosslogMinAggregateInputType
    _max?: BosslogMaxAggregateInputType
  }

  export type BosslogGroupByOutputType = {
    id: number
    accountid: number
    bossid: string
    lastattempt: Date
    pqentry: number
    _count: BosslogCountAggregateOutputType | null
    _avg: BosslogAvgAggregateOutputType | null
    _sum: BosslogSumAggregateOutputType | null
    _min: BosslogMinAggregateOutputType | null
    _max: BosslogMaxAggregateOutputType | null
  }

  type GetBosslogGroupByPayload<T extends bosslogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BosslogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BosslogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BosslogGroupByOutputType[P]>
            : GetScalarType<T[P], BosslogGroupByOutputType[P]>
        }
      >
    >


  export type bosslogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountid?: boolean
    bossid?: boolean
    lastattempt?: boolean
    pqentry?: boolean
  }, ExtArgs["result"]["bosslog"]>


  export type bosslogSelectScalar = {
    id?: boolean
    accountid?: boolean
    bossid?: boolean
    lastattempt?: boolean
    pqentry?: boolean
  }


  export type $bosslogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "bosslog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      accountid: number
      bossid: string
      lastattempt: Date
      pqentry: number
    }, ExtArgs["result"]["bosslog"]>
    composites: {}
  }

  type bosslogGetPayload<S extends boolean | null | undefined | bosslogDefaultArgs> = $Result.GetResult<Prisma.$bosslogPayload, S>

  type bosslogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<bosslogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BosslogCountAggregateInputType | true
    }

  export interface bosslogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['bosslog'], meta: { name: 'bosslog' } }
    /**
     * Find zero or one Bosslog that matches the filter.
     * @param {bosslogFindUniqueArgs} args - Arguments to find a Bosslog
     * @example
     * // Get one Bosslog
     * const bosslog = await prisma.bosslog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends bosslogFindUniqueArgs>(args: SelectSubset<T, bosslogFindUniqueArgs<ExtArgs>>): Prisma__bosslogClient<$Result.GetResult<Prisma.$bosslogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Bosslog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {bosslogFindUniqueOrThrowArgs} args - Arguments to find a Bosslog
     * @example
     * // Get one Bosslog
     * const bosslog = await prisma.bosslog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends bosslogFindUniqueOrThrowArgs>(args: SelectSubset<T, bosslogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__bosslogClient<$Result.GetResult<Prisma.$bosslogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Bosslog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bosslogFindFirstArgs} args - Arguments to find a Bosslog
     * @example
     * // Get one Bosslog
     * const bosslog = await prisma.bosslog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends bosslogFindFirstArgs>(args?: SelectSubset<T, bosslogFindFirstArgs<ExtArgs>>): Prisma__bosslogClient<$Result.GetResult<Prisma.$bosslogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Bosslog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bosslogFindFirstOrThrowArgs} args - Arguments to find a Bosslog
     * @example
     * // Get one Bosslog
     * const bosslog = await prisma.bosslog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends bosslogFindFirstOrThrowArgs>(args?: SelectSubset<T, bosslogFindFirstOrThrowArgs<ExtArgs>>): Prisma__bosslogClient<$Result.GetResult<Prisma.$bosslogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Bosslogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bosslogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bosslogs
     * const bosslogs = await prisma.bosslog.findMany()
     * 
     * // Get first 10 Bosslogs
     * const bosslogs = await prisma.bosslog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bosslogWithIdOnly = await prisma.bosslog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends bosslogFindManyArgs>(args?: SelectSubset<T, bosslogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bosslogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Bosslog.
     * @param {bosslogCreateArgs} args - Arguments to create a Bosslog.
     * @example
     * // Create one Bosslog
     * const Bosslog = await prisma.bosslog.create({
     *   data: {
     *     // ... data to create a Bosslog
     *   }
     * })
     * 
     */
    create<T extends bosslogCreateArgs>(args: SelectSubset<T, bosslogCreateArgs<ExtArgs>>): Prisma__bosslogClient<$Result.GetResult<Prisma.$bosslogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Bosslogs.
     * @param {bosslogCreateManyArgs} args - Arguments to create many Bosslogs.
     * @example
     * // Create many Bosslogs
     * const bosslog = await prisma.bosslog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends bosslogCreateManyArgs>(args?: SelectSubset<T, bosslogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Bosslog.
     * @param {bosslogDeleteArgs} args - Arguments to delete one Bosslog.
     * @example
     * // Delete one Bosslog
     * const Bosslog = await prisma.bosslog.delete({
     *   where: {
     *     // ... filter to delete one Bosslog
     *   }
     * })
     * 
     */
    delete<T extends bosslogDeleteArgs>(args: SelectSubset<T, bosslogDeleteArgs<ExtArgs>>): Prisma__bosslogClient<$Result.GetResult<Prisma.$bosslogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Bosslog.
     * @param {bosslogUpdateArgs} args - Arguments to update one Bosslog.
     * @example
     * // Update one Bosslog
     * const bosslog = await prisma.bosslog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends bosslogUpdateArgs>(args: SelectSubset<T, bosslogUpdateArgs<ExtArgs>>): Prisma__bosslogClient<$Result.GetResult<Prisma.$bosslogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Bosslogs.
     * @param {bosslogDeleteManyArgs} args - Arguments to filter Bosslogs to delete.
     * @example
     * // Delete a few Bosslogs
     * const { count } = await prisma.bosslog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends bosslogDeleteManyArgs>(args?: SelectSubset<T, bosslogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bosslogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bosslogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bosslogs
     * const bosslog = await prisma.bosslog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends bosslogUpdateManyArgs>(args: SelectSubset<T, bosslogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bosslog.
     * @param {bosslogUpsertArgs} args - Arguments to update or create a Bosslog.
     * @example
     * // Update or create a Bosslog
     * const bosslog = await prisma.bosslog.upsert({
     *   create: {
     *     // ... data to create a Bosslog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bosslog we want to update
     *   }
     * })
     */
    upsert<T extends bosslogUpsertArgs>(args: SelectSubset<T, bosslogUpsertArgs<ExtArgs>>): Prisma__bosslogClient<$Result.GetResult<Prisma.$bosslogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Bosslogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bosslogCountArgs} args - Arguments to filter Bosslogs to count.
     * @example
     * // Count the number of Bosslogs
     * const count = await prisma.bosslog.count({
     *   where: {
     *     // ... the filter for the Bosslogs we want to count
     *   }
     * })
    **/
    count<T extends bosslogCountArgs>(
      args?: Subset<T, bosslogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BosslogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bosslog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BosslogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BosslogAggregateArgs>(args: Subset<T, BosslogAggregateArgs>): Prisma.PrismaPromise<GetBosslogAggregateType<T>>

    /**
     * Group by Bosslog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bosslogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends bosslogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: bosslogGroupByArgs['orderBy'] }
        : { orderBy?: bosslogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, bosslogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBosslogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the bosslog model
   */
  readonly fields: bosslogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for bosslog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__bosslogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the bosslog model
   */ 
  interface bosslogFieldRefs {
    readonly id: FieldRef<"bosslog", 'Int'>
    readonly accountid: FieldRef<"bosslog", 'Int'>
    readonly bossid: FieldRef<"bosslog", 'String'>
    readonly lastattempt: FieldRef<"bosslog", 'DateTime'>
    readonly pqentry: FieldRef<"bosslog", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * bosslog findUnique
   */
  export type bosslogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bosslog
     */
    select?: bosslogSelect<ExtArgs> | null
    /**
     * Filter, which bosslog to fetch.
     */
    where: bosslogWhereUniqueInput
  }

  /**
   * bosslog findUniqueOrThrow
   */
  export type bosslogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bosslog
     */
    select?: bosslogSelect<ExtArgs> | null
    /**
     * Filter, which bosslog to fetch.
     */
    where: bosslogWhereUniqueInput
  }

  /**
   * bosslog findFirst
   */
  export type bosslogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bosslog
     */
    select?: bosslogSelect<ExtArgs> | null
    /**
     * Filter, which bosslog to fetch.
     */
    where?: bosslogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bosslogs to fetch.
     */
    orderBy?: bosslogOrderByWithRelationInput | bosslogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bosslogs.
     */
    cursor?: bosslogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bosslogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bosslogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bosslogs.
     */
    distinct?: BosslogScalarFieldEnum | BosslogScalarFieldEnum[]
  }

  /**
   * bosslog findFirstOrThrow
   */
  export type bosslogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bosslog
     */
    select?: bosslogSelect<ExtArgs> | null
    /**
     * Filter, which bosslog to fetch.
     */
    where?: bosslogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bosslogs to fetch.
     */
    orderBy?: bosslogOrderByWithRelationInput | bosslogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bosslogs.
     */
    cursor?: bosslogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bosslogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bosslogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bosslogs.
     */
    distinct?: BosslogScalarFieldEnum | BosslogScalarFieldEnum[]
  }

  /**
   * bosslog findMany
   */
  export type bosslogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bosslog
     */
    select?: bosslogSelect<ExtArgs> | null
    /**
     * Filter, which bosslogs to fetch.
     */
    where?: bosslogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bosslogs to fetch.
     */
    orderBy?: bosslogOrderByWithRelationInput | bosslogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing bosslogs.
     */
    cursor?: bosslogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bosslogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bosslogs.
     */
    skip?: number
    distinct?: BosslogScalarFieldEnum | BosslogScalarFieldEnum[]
  }

  /**
   * bosslog create
   */
  export type bosslogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bosslog
     */
    select?: bosslogSelect<ExtArgs> | null
    /**
     * The data needed to create a bosslog.
     */
    data: XOR<bosslogCreateInput, bosslogUncheckedCreateInput>
  }

  /**
   * bosslog createMany
   */
  export type bosslogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many bosslogs.
     */
    data: bosslogCreateManyInput | bosslogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * bosslog update
   */
  export type bosslogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bosslog
     */
    select?: bosslogSelect<ExtArgs> | null
    /**
     * The data needed to update a bosslog.
     */
    data: XOR<bosslogUpdateInput, bosslogUncheckedUpdateInput>
    /**
     * Choose, which bosslog to update.
     */
    where: bosslogWhereUniqueInput
  }

  /**
   * bosslog updateMany
   */
  export type bosslogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update bosslogs.
     */
    data: XOR<bosslogUpdateManyMutationInput, bosslogUncheckedUpdateManyInput>
    /**
     * Filter which bosslogs to update
     */
    where?: bosslogWhereInput
  }

  /**
   * bosslog upsert
   */
  export type bosslogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bosslog
     */
    select?: bosslogSelect<ExtArgs> | null
    /**
     * The filter to search for the bosslog to update in case it exists.
     */
    where: bosslogWhereUniqueInput
    /**
     * In case the bosslog found by the `where` argument doesn't exist, create a new bosslog with this data.
     */
    create: XOR<bosslogCreateInput, bosslogUncheckedCreateInput>
    /**
     * In case the bosslog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<bosslogUpdateInput, bosslogUncheckedUpdateInput>
  }

  /**
   * bosslog delete
   */
  export type bosslogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bosslog
     */
    select?: bosslogSelect<ExtArgs> | null
    /**
     * Filter which bosslog to delete.
     */
    where: bosslogWhereUniqueInput
  }

  /**
   * bosslog deleteMany
   */
  export type bosslogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bosslogs to delete
     */
    where?: bosslogWhereInput
  }

  /**
   * bosslog without action
   */
  export type bosslogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bosslog
     */
    select?: bosslogSelect<ExtArgs> | null
  }


  /**
   * Model cashiteminfos
   */

  export type AggregateCashiteminfos = {
    _count: CashiteminfosCountAggregateOutputType | null
    _avg: CashiteminfosAvgAggregateOutputType | null
    _sum: CashiteminfosSumAggregateOutputType | null
    _min: CashiteminfosMinAggregateOutputType | null
    _max: CashiteminfosMaxAggregateOutputType | null
  }

  export type CashiteminfosAvgAggregateOutputType = {
    id: number | null
    accountid: number | null
    characterid: number | null
    commodityid: number | null
    paybackrate: number | null
    discount: number | null
    orderno: number | null
    productno: number | null
    sourceflag: number | null
    itemid: number | null
    trunkid: number | null
    position: number | null
  }

  export type CashiteminfosSumAggregateOutputType = {
    id: bigint | null
    accountid: number | null
    characterid: number | null
    commodityid: number | null
    paybackrate: number | null
    discount: number | null
    orderno: number | null
    productno: number | null
    sourceflag: number | null
    itemid: number | null
    trunkid: number | null
    position: number | null
  }

  export type CashiteminfosMinAggregateOutputType = {
    id: bigint | null
    accountid: number | null
    characterid: number | null
    commodityid: number | null
    buycharacterid: string | null
    paybackrate: number | null
    discount: number | null
    orderno: number | null
    productno: number | null
    refundable: boolean | null
    sourceflag: number | null
    storebank: boolean | null
    itemid: number | null
    trunkid: number | null
    position: number | null
  }

  export type CashiteminfosMaxAggregateOutputType = {
    id: bigint | null
    accountid: number | null
    characterid: number | null
    commodityid: number | null
    buycharacterid: string | null
    paybackrate: number | null
    discount: number | null
    orderno: number | null
    productno: number | null
    refundable: boolean | null
    sourceflag: number | null
    storebank: boolean | null
    itemid: number | null
    trunkid: number | null
    position: number | null
  }

  export type CashiteminfosCountAggregateOutputType = {
    id: number
    accountid: number
    characterid: number
    commodityid: number
    buycharacterid: number
    paybackrate: number
    discount: number
    orderno: number
    productno: number
    refundable: number
    sourceflag: number
    storebank: number
    itemid: number
    trunkid: number
    position: number
    _all: number
  }


  export type CashiteminfosAvgAggregateInputType = {
    id?: true
    accountid?: true
    characterid?: true
    commodityid?: true
    paybackrate?: true
    discount?: true
    orderno?: true
    productno?: true
    sourceflag?: true
    itemid?: true
    trunkid?: true
    position?: true
  }

  export type CashiteminfosSumAggregateInputType = {
    id?: true
    accountid?: true
    characterid?: true
    commodityid?: true
    paybackrate?: true
    discount?: true
    orderno?: true
    productno?: true
    sourceflag?: true
    itemid?: true
    trunkid?: true
    position?: true
  }

  export type CashiteminfosMinAggregateInputType = {
    id?: true
    accountid?: true
    characterid?: true
    commodityid?: true
    buycharacterid?: true
    paybackrate?: true
    discount?: true
    orderno?: true
    productno?: true
    refundable?: true
    sourceflag?: true
    storebank?: true
    itemid?: true
    trunkid?: true
    position?: true
  }

  export type CashiteminfosMaxAggregateInputType = {
    id?: true
    accountid?: true
    characterid?: true
    commodityid?: true
    buycharacterid?: true
    paybackrate?: true
    discount?: true
    orderno?: true
    productno?: true
    refundable?: true
    sourceflag?: true
    storebank?: true
    itemid?: true
    trunkid?: true
    position?: true
  }

  export type CashiteminfosCountAggregateInputType = {
    id?: true
    accountid?: true
    characterid?: true
    commodityid?: true
    buycharacterid?: true
    paybackrate?: true
    discount?: true
    orderno?: true
    productno?: true
    refundable?: true
    sourceflag?: true
    storebank?: true
    itemid?: true
    trunkid?: true
    position?: true
    _all?: true
  }

  export type CashiteminfosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cashiteminfos to aggregate.
     */
    where?: cashiteminfosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cashiteminfos to fetch.
     */
    orderBy?: cashiteminfosOrderByWithRelationInput | cashiteminfosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: cashiteminfosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cashiteminfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cashiteminfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cashiteminfos
    **/
    _count?: true | CashiteminfosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CashiteminfosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CashiteminfosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CashiteminfosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CashiteminfosMaxAggregateInputType
  }

  export type GetCashiteminfosAggregateType<T extends CashiteminfosAggregateArgs> = {
        [P in keyof T & keyof AggregateCashiteminfos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCashiteminfos[P]>
      : GetScalarType<T[P], AggregateCashiteminfos[P]>
  }




  export type cashiteminfosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cashiteminfosWhereInput
    orderBy?: cashiteminfosOrderByWithAggregationInput | cashiteminfosOrderByWithAggregationInput[]
    by: CashiteminfosScalarFieldEnum[] | CashiteminfosScalarFieldEnum
    having?: cashiteminfosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CashiteminfosCountAggregateInputType | true
    _avg?: CashiteminfosAvgAggregateInputType
    _sum?: CashiteminfosSumAggregateInputType
    _min?: CashiteminfosMinAggregateInputType
    _max?: CashiteminfosMaxAggregateInputType
  }

  export type CashiteminfosGroupByOutputType = {
    id: bigint
    accountid: number | null
    characterid: number | null
    commodityid: number | null
    buycharacterid: string | null
    paybackrate: number | null
    discount: number | null
    orderno: number | null
    productno: number | null
    refundable: boolean | null
    sourceflag: number | null
    storebank: boolean | null
    itemid: number | null
    trunkid: number | null
    position: number | null
    _count: CashiteminfosCountAggregateOutputType | null
    _avg: CashiteminfosAvgAggregateOutputType | null
    _sum: CashiteminfosSumAggregateOutputType | null
    _min: CashiteminfosMinAggregateOutputType | null
    _max: CashiteminfosMaxAggregateOutputType | null
  }

  type GetCashiteminfosGroupByPayload<T extends cashiteminfosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CashiteminfosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CashiteminfosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CashiteminfosGroupByOutputType[P]>
            : GetScalarType<T[P], CashiteminfosGroupByOutputType[P]>
        }
      >
    >


  export type cashiteminfosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountid?: boolean
    characterid?: boolean
    commodityid?: boolean
    buycharacterid?: boolean
    paybackrate?: boolean
    discount?: boolean
    orderno?: boolean
    productno?: boolean
    refundable?: boolean
    sourceflag?: boolean
    storebank?: boolean
    itemid?: boolean
    trunkid?: boolean
    position?: boolean
  }, ExtArgs["result"]["cashiteminfos"]>


  export type cashiteminfosSelectScalar = {
    id?: boolean
    accountid?: boolean
    characterid?: boolean
    commodityid?: boolean
    buycharacterid?: boolean
    paybackrate?: boolean
    discount?: boolean
    orderno?: boolean
    productno?: boolean
    refundable?: boolean
    sourceflag?: boolean
    storebank?: boolean
    itemid?: boolean
    trunkid?: boolean
    position?: boolean
  }


  export type $cashiteminfosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "cashiteminfos"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      accountid: number | null
      characterid: number | null
      commodityid: number | null
      buycharacterid: string | null
      paybackrate: number | null
      discount: number | null
      orderno: number | null
      productno: number | null
      refundable: boolean | null
      sourceflag: number | null
      storebank: boolean | null
      itemid: number | null
      trunkid: number | null
      position: number | null
    }, ExtArgs["result"]["cashiteminfos"]>
    composites: {}
  }

  type cashiteminfosGetPayload<S extends boolean | null | undefined | cashiteminfosDefaultArgs> = $Result.GetResult<Prisma.$cashiteminfosPayload, S>

  type cashiteminfosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<cashiteminfosFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CashiteminfosCountAggregateInputType | true
    }

  export interface cashiteminfosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['cashiteminfos'], meta: { name: 'cashiteminfos' } }
    /**
     * Find zero or one Cashiteminfos that matches the filter.
     * @param {cashiteminfosFindUniqueArgs} args - Arguments to find a Cashiteminfos
     * @example
     * // Get one Cashiteminfos
     * const cashiteminfos = await prisma.cashiteminfos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends cashiteminfosFindUniqueArgs>(args: SelectSubset<T, cashiteminfosFindUniqueArgs<ExtArgs>>): Prisma__cashiteminfosClient<$Result.GetResult<Prisma.$cashiteminfosPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Cashiteminfos that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {cashiteminfosFindUniqueOrThrowArgs} args - Arguments to find a Cashiteminfos
     * @example
     * // Get one Cashiteminfos
     * const cashiteminfos = await prisma.cashiteminfos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends cashiteminfosFindUniqueOrThrowArgs>(args: SelectSubset<T, cashiteminfosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__cashiteminfosClient<$Result.GetResult<Prisma.$cashiteminfosPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Cashiteminfos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cashiteminfosFindFirstArgs} args - Arguments to find a Cashiteminfos
     * @example
     * // Get one Cashiteminfos
     * const cashiteminfos = await prisma.cashiteminfos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends cashiteminfosFindFirstArgs>(args?: SelectSubset<T, cashiteminfosFindFirstArgs<ExtArgs>>): Prisma__cashiteminfosClient<$Result.GetResult<Prisma.$cashiteminfosPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Cashiteminfos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cashiteminfosFindFirstOrThrowArgs} args - Arguments to find a Cashiteminfos
     * @example
     * // Get one Cashiteminfos
     * const cashiteminfos = await prisma.cashiteminfos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends cashiteminfosFindFirstOrThrowArgs>(args?: SelectSubset<T, cashiteminfosFindFirstOrThrowArgs<ExtArgs>>): Prisma__cashiteminfosClient<$Result.GetResult<Prisma.$cashiteminfosPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Cashiteminfos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cashiteminfosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cashiteminfos
     * const cashiteminfos = await prisma.cashiteminfos.findMany()
     * 
     * // Get first 10 Cashiteminfos
     * const cashiteminfos = await prisma.cashiteminfos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cashiteminfosWithIdOnly = await prisma.cashiteminfos.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends cashiteminfosFindManyArgs>(args?: SelectSubset<T, cashiteminfosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cashiteminfosPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Cashiteminfos.
     * @param {cashiteminfosCreateArgs} args - Arguments to create a Cashiteminfos.
     * @example
     * // Create one Cashiteminfos
     * const Cashiteminfos = await prisma.cashiteminfos.create({
     *   data: {
     *     // ... data to create a Cashiteminfos
     *   }
     * })
     * 
     */
    create<T extends cashiteminfosCreateArgs>(args: SelectSubset<T, cashiteminfosCreateArgs<ExtArgs>>): Prisma__cashiteminfosClient<$Result.GetResult<Prisma.$cashiteminfosPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Cashiteminfos.
     * @param {cashiteminfosCreateManyArgs} args - Arguments to create many Cashiteminfos.
     * @example
     * // Create many Cashiteminfos
     * const cashiteminfos = await prisma.cashiteminfos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends cashiteminfosCreateManyArgs>(args?: SelectSubset<T, cashiteminfosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Cashiteminfos.
     * @param {cashiteminfosDeleteArgs} args - Arguments to delete one Cashiteminfos.
     * @example
     * // Delete one Cashiteminfos
     * const Cashiteminfos = await prisma.cashiteminfos.delete({
     *   where: {
     *     // ... filter to delete one Cashiteminfos
     *   }
     * })
     * 
     */
    delete<T extends cashiteminfosDeleteArgs>(args: SelectSubset<T, cashiteminfosDeleteArgs<ExtArgs>>): Prisma__cashiteminfosClient<$Result.GetResult<Prisma.$cashiteminfosPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Cashiteminfos.
     * @param {cashiteminfosUpdateArgs} args - Arguments to update one Cashiteminfos.
     * @example
     * // Update one Cashiteminfos
     * const cashiteminfos = await prisma.cashiteminfos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends cashiteminfosUpdateArgs>(args: SelectSubset<T, cashiteminfosUpdateArgs<ExtArgs>>): Prisma__cashiteminfosClient<$Result.GetResult<Prisma.$cashiteminfosPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Cashiteminfos.
     * @param {cashiteminfosDeleteManyArgs} args - Arguments to filter Cashiteminfos to delete.
     * @example
     * // Delete a few Cashiteminfos
     * const { count } = await prisma.cashiteminfos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends cashiteminfosDeleteManyArgs>(args?: SelectSubset<T, cashiteminfosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cashiteminfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cashiteminfosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cashiteminfos
     * const cashiteminfos = await prisma.cashiteminfos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends cashiteminfosUpdateManyArgs>(args: SelectSubset<T, cashiteminfosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cashiteminfos.
     * @param {cashiteminfosUpsertArgs} args - Arguments to update or create a Cashiteminfos.
     * @example
     * // Update or create a Cashiteminfos
     * const cashiteminfos = await prisma.cashiteminfos.upsert({
     *   create: {
     *     // ... data to create a Cashiteminfos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cashiteminfos we want to update
     *   }
     * })
     */
    upsert<T extends cashiteminfosUpsertArgs>(args: SelectSubset<T, cashiteminfosUpsertArgs<ExtArgs>>): Prisma__cashiteminfosClient<$Result.GetResult<Prisma.$cashiteminfosPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Cashiteminfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cashiteminfosCountArgs} args - Arguments to filter Cashiteminfos to count.
     * @example
     * // Count the number of Cashiteminfos
     * const count = await prisma.cashiteminfos.count({
     *   where: {
     *     // ... the filter for the Cashiteminfos we want to count
     *   }
     * })
    **/
    count<T extends cashiteminfosCountArgs>(
      args?: Subset<T, cashiteminfosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CashiteminfosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cashiteminfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashiteminfosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CashiteminfosAggregateArgs>(args: Subset<T, CashiteminfosAggregateArgs>): Prisma.PrismaPromise<GetCashiteminfosAggregateType<T>>

    /**
     * Group by Cashiteminfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cashiteminfosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends cashiteminfosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: cashiteminfosGroupByArgs['orderBy'] }
        : { orderBy?: cashiteminfosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, cashiteminfosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCashiteminfosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the cashiteminfos model
   */
  readonly fields: cashiteminfosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for cashiteminfos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__cashiteminfosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the cashiteminfos model
   */ 
  interface cashiteminfosFieldRefs {
    readonly id: FieldRef<"cashiteminfos", 'BigInt'>
    readonly accountid: FieldRef<"cashiteminfos", 'Int'>
    readonly characterid: FieldRef<"cashiteminfos", 'Int'>
    readonly commodityid: FieldRef<"cashiteminfos", 'Int'>
    readonly buycharacterid: FieldRef<"cashiteminfos", 'String'>
    readonly paybackrate: FieldRef<"cashiteminfos", 'Int'>
    readonly discount: FieldRef<"cashiteminfos", 'Float'>
    readonly orderno: FieldRef<"cashiteminfos", 'Int'>
    readonly productno: FieldRef<"cashiteminfos", 'Int'>
    readonly refundable: FieldRef<"cashiteminfos", 'Boolean'>
    readonly sourceflag: FieldRef<"cashiteminfos", 'Int'>
    readonly storebank: FieldRef<"cashiteminfos", 'Boolean'>
    readonly itemid: FieldRef<"cashiteminfos", 'Int'>
    readonly trunkid: FieldRef<"cashiteminfos", 'Int'>
    readonly position: FieldRef<"cashiteminfos", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * cashiteminfos findUnique
   */
  export type cashiteminfosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cashiteminfos
     */
    select?: cashiteminfosSelect<ExtArgs> | null
    /**
     * Filter, which cashiteminfos to fetch.
     */
    where: cashiteminfosWhereUniqueInput
  }

  /**
   * cashiteminfos findUniqueOrThrow
   */
  export type cashiteminfosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cashiteminfos
     */
    select?: cashiteminfosSelect<ExtArgs> | null
    /**
     * Filter, which cashiteminfos to fetch.
     */
    where: cashiteminfosWhereUniqueInput
  }

  /**
   * cashiteminfos findFirst
   */
  export type cashiteminfosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cashiteminfos
     */
    select?: cashiteminfosSelect<ExtArgs> | null
    /**
     * Filter, which cashiteminfos to fetch.
     */
    where?: cashiteminfosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cashiteminfos to fetch.
     */
    orderBy?: cashiteminfosOrderByWithRelationInput | cashiteminfosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cashiteminfos.
     */
    cursor?: cashiteminfosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cashiteminfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cashiteminfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cashiteminfos.
     */
    distinct?: CashiteminfosScalarFieldEnum | CashiteminfosScalarFieldEnum[]
  }

  /**
   * cashiteminfos findFirstOrThrow
   */
  export type cashiteminfosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cashiteminfos
     */
    select?: cashiteminfosSelect<ExtArgs> | null
    /**
     * Filter, which cashiteminfos to fetch.
     */
    where?: cashiteminfosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cashiteminfos to fetch.
     */
    orderBy?: cashiteminfosOrderByWithRelationInput | cashiteminfosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cashiteminfos.
     */
    cursor?: cashiteminfosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cashiteminfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cashiteminfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cashiteminfos.
     */
    distinct?: CashiteminfosScalarFieldEnum | CashiteminfosScalarFieldEnum[]
  }

  /**
   * cashiteminfos findMany
   */
  export type cashiteminfosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cashiteminfos
     */
    select?: cashiteminfosSelect<ExtArgs> | null
    /**
     * Filter, which cashiteminfos to fetch.
     */
    where?: cashiteminfosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cashiteminfos to fetch.
     */
    orderBy?: cashiteminfosOrderByWithRelationInput | cashiteminfosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cashiteminfos.
     */
    cursor?: cashiteminfosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cashiteminfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cashiteminfos.
     */
    skip?: number
    distinct?: CashiteminfosScalarFieldEnum | CashiteminfosScalarFieldEnum[]
  }

  /**
   * cashiteminfos create
   */
  export type cashiteminfosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cashiteminfos
     */
    select?: cashiteminfosSelect<ExtArgs> | null
    /**
     * The data needed to create a cashiteminfos.
     */
    data?: XOR<cashiteminfosCreateInput, cashiteminfosUncheckedCreateInput>
  }

  /**
   * cashiteminfos createMany
   */
  export type cashiteminfosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many cashiteminfos.
     */
    data: cashiteminfosCreateManyInput | cashiteminfosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * cashiteminfos update
   */
  export type cashiteminfosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cashiteminfos
     */
    select?: cashiteminfosSelect<ExtArgs> | null
    /**
     * The data needed to update a cashiteminfos.
     */
    data: XOR<cashiteminfosUpdateInput, cashiteminfosUncheckedUpdateInput>
    /**
     * Choose, which cashiteminfos to update.
     */
    where: cashiteminfosWhereUniqueInput
  }

  /**
   * cashiteminfos updateMany
   */
  export type cashiteminfosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update cashiteminfos.
     */
    data: XOR<cashiteminfosUpdateManyMutationInput, cashiteminfosUncheckedUpdateManyInput>
    /**
     * Filter which cashiteminfos to update
     */
    where?: cashiteminfosWhereInput
  }

  /**
   * cashiteminfos upsert
   */
  export type cashiteminfosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cashiteminfos
     */
    select?: cashiteminfosSelect<ExtArgs> | null
    /**
     * The filter to search for the cashiteminfos to update in case it exists.
     */
    where: cashiteminfosWhereUniqueInput
    /**
     * In case the cashiteminfos found by the `where` argument doesn't exist, create a new cashiteminfos with this data.
     */
    create: XOR<cashiteminfosCreateInput, cashiteminfosUncheckedCreateInput>
    /**
     * In case the cashiteminfos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<cashiteminfosUpdateInput, cashiteminfosUncheckedUpdateInput>
  }

  /**
   * cashiteminfos delete
   */
  export type cashiteminfosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cashiteminfos
     */
    select?: cashiteminfosSelect<ExtArgs> | null
    /**
     * Filter which cashiteminfos to delete.
     */
    where: cashiteminfosWhereUniqueInput
  }

  /**
   * cashiteminfos deleteMany
   */
  export type cashiteminfosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cashiteminfos to delete
     */
    where?: cashiteminfosWhereInput
  }

  /**
   * cashiteminfos without action
   */
  export type cashiteminfosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cashiteminfos
     */
    select?: cashiteminfosSelect<ExtArgs> | null
  }


  /**
   * Model characterpotentials
   */

  export type AggregateCharacterpotentials = {
    _count: CharacterpotentialsCountAggregateOutputType | null
    _avg: CharacterpotentialsAvgAggregateOutputType | null
    _sum: CharacterpotentialsSumAggregateOutputType | null
    _min: CharacterpotentialsMinAggregateOutputType | null
    _max: CharacterpotentialsMaxAggregateOutputType | null
  }

  export type CharacterpotentialsAvgAggregateOutputType = {
    id: number | null
    potkey: number | null
    skillid: number | null
    slv: number | null
    grade: number | null
    charid: number | null
  }

  export type CharacterpotentialsSumAggregateOutputType = {
    id: bigint | null
    potkey: number | null
    skillid: number | null
    slv: number | null
    grade: number | null
    charid: number | null
  }

  export type CharacterpotentialsMinAggregateOutputType = {
    id: bigint | null
    potkey: number | null
    skillid: number | null
    slv: number | null
    grade: number | null
    charid: number | null
  }

  export type CharacterpotentialsMaxAggregateOutputType = {
    id: bigint | null
    potkey: number | null
    skillid: number | null
    slv: number | null
    grade: number | null
    charid: number | null
  }

  export type CharacterpotentialsCountAggregateOutputType = {
    id: number
    potkey: number
    skillid: number
    slv: number
    grade: number
    charid: number
    _all: number
  }


  export type CharacterpotentialsAvgAggregateInputType = {
    id?: true
    potkey?: true
    skillid?: true
    slv?: true
    grade?: true
    charid?: true
  }

  export type CharacterpotentialsSumAggregateInputType = {
    id?: true
    potkey?: true
    skillid?: true
    slv?: true
    grade?: true
    charid?: true
  }

  export type CharacterpotentialsMinAggregateInputType = {
    id?: true
    potkey?: true
    skillid?: true
    slv?: true
    grade?: true
    charid?: true
  }

  export type CharacterpotentialsMaxAggregateInputType = {
    id?: true
    potkey?: true
    skillid?: true
    slv?: true
    grade?: true
    charid?: true
  }

  export type CharacterpotentialsCountAggregateInputType = {
    id?: true
    potkey?: true
    skillid?: true
    slv?: true
    grade?: true
    charid?: true
    _all?: true
  }

  export type CharacterpotentialsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which characterpotentials to aggregate.
     */
    where?: characterpotentialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of characterpotentials to fetch.
     */
    orderBy?: characterpotentialsOrderByWithRelationInput | characterpotentialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: characterpotentialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` characterpotentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` characterpotentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned characterpotentials
    **/
    _count?: true | CharacterpotentialsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CharacterpotentialsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CharacterpotentialsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CharacterpotentialsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CharacterpotentialsMaxAggregateInputType
  }

  export type GetCharacterpotentialsAggregateType<T extends CharacterpotentialsAggregateArgs> = {
        [P in keyof T & keyof AggregateCharacterpotentials]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCharacterpotentials[P]>
      : GetScalarType<T[P], AggregateCharacterpotentials[P]>
  }




  export type characterpotentialsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: characterpotentialsWhereInput
    orderBy?: characterpotentialsOrderByWithAggregationInput | characterpotentialsOrderByWithAggregationInput[]
    by: CharacterpotentialsScalarFieldEnum[] | CharacterpotentialsScalarFieldEnum
    having?: characterpotentialsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CharacterpotentialsCountAggregateInputType | true
    _avg?: CharacterpotentialsAvgAggregateInputType
    _sum?: CharacterpotentialsSumAggregateInputType
    _min?: CharacterpotentialsMinAggregateInputType
    _max?: CharacterpotentialsMaxAggregateInputType
  }

  export type CharacterpotentialsGroupByOutputType = {
    id: bigint
    potkey: number | null
    skillid: number | null
    slv: number | null
    grade: number | null
    charid: number | null
    _count: CharacterpotentialsCountAggregateOutputType | null
    _avg: CharacterpotentialsAvgAggregateOutputType | null
    _sum: CharacterpotentialsSumAggregateOutputType | null
    _min: CharacterpotentialsMinAggregateOutputType | null
    _max: CharacterpotentialsMaxAggregateOutputType | null
  }

  type GetCharacterpotentialsGroupByPayload<T extends characterpotentialsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CharacterpotentialsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CharacterpotentialsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CharacterpotentialsGroupByOutputType[P]>
            : GetScalarType<T[P], CharacterpotentialsGroupByOutputType[P]>
        }
      >
    >


  export type characterpotentialsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    potkey?: boolean
    skillid?: boolean
    slv?: boolean
    grade?: boolean
    charid?: boolean
  }, ExtArgs["result"]["characterpotentials"]>


  export type characterpotentialsSelectScalar = {
    id?: boolean
    potkey?: boolean
    skillid?: boolean
    slv?: boolean
    grade?: boolean
    charid?: boolean
  }


  export type $characterpotentialsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "characterpotentials"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      potkey: number | null
      skillid: number | null
      slv: number | null
      grade: number | null
      charid: number | null
    }, ExtArgs["result"]["characterpotentials"]>
    composites: {}
  }

  type characterpotentialsGetPayload<S extends boolean | null | undefined | characterpotentialsDefaultArgs> = $Result.GetResult<Prisma.$characterpotentialsPayload, S>

  type characterpotentialsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<characterpotentialsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CharacterpotentialsCountAggregateInputType | true
    }

  export interface characterpotentialsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['characterpotentials'], meta: { name: 'characterpotentials' } }
    /**
     * Find zero or one Characterpotentials that matches the filter.
     * @param {characterpotentialsFindUniqueArgs} args - Arguments to find a Characterpotentials
     * @example
     * // Get one Characterpotentials
     * const characterpotentials = await prisma.characterpotentials.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends characterpotentialsFindUniqueArgs>(args: SelectSubset<T, characterpotentialsFindUniqueArgs<ExtArgs>>): Prisma__characterpotentialsClient<$Result.GetResult<Prisma.$characterpotentialsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Characterpotentials that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {characterpotentialsFindUniqueOrThrowArgs} args - Arguments to find a Characterpotentials
     * @example
     * // Get one Characterpotentials
     * const characterpotentials = await prisma.characterpotentials.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends characterpotentialsFindUniqueOrThrowArgs>(args: SelectSubset<T, characterpotentialsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__characterpotentialsClient<$Result.GetResult<Prisma.$characterpotentialsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Characterpotentials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {characterpotentialsFindFirstArgs} args - Arguments to find a Characterpotentials
     * @example
     * // Get one Characterpotentials
     * const characterpotentials = await prisma.characterpotentials.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends characterpotentialsFindFirstArgs>(args?: SelectSubset<T, characterpotentialsFindFirstArgs<ExtArgs>>): Prisma__characterpotentialsClient<$Result.GetResult<Prisma.$characterpotentialsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Characterpotentials that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {characterpotentialsFindFirstOrThrowArgs} args - Arguments to find a Characterpotentials
     * @example
     * // Get one Characterpotentials
     * const characterpotentials = await prisma.characterpotentials.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends characterpotentialsFindFirstOrThrowArgs>(args?: SelectSubset<T, characterpotentialsFindFirstOrThrowArgs<ExtArgs>>): Prisma__characterpotentialsClient<$Result.GetResult<Prisma.$characterpotentialsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Characterpotentials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {characterpotentialsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Characterpotentials
     * const characterpotentials = await prisma.characterpotentials.findMany()
     * 
     * // Get first 10 Characterpotentials
     * const characterpotentials = await prisma.characterpotentials.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const characterpotentialsWithIdOnly = await prisma.characterpotentials.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends characterpotentialsFindManyArgs>(args?: SelectSubset<T, characterpotentialsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$characterpotentialsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Characterpotentials.
     * @param {characterpotentialsCreateArgs} args - Arguments to create a Characterpotentials.
     * @example
     * // Create one Characterpotentials
     * const Characterpotentials = await prisma.characterpotentials.create({
     *   data: {
     *     // ... data to create a Characterpotentials
     *   }
     * })
     * 
     */
    create<T extends characterpotentialsCreateArgs>(args: SelectSubset<T, characterpotentialsCreateArgs<ExtArgs>>): Prisma__characterpotentialsClient<$Result.GetResult<Prisma.$characterpotentialsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Characterpotentials.
     * @param {characterpotentialsCreateManyArgs} args - Arguments to create many Characterpotentials.
     * @example
     * // Create many Characterpotentials
     * const characterpotentials = await prisma.characterpotentials.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends characterpotentialsCreateManyArgs>(args?: SelectSubset<T, characterpotentialsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Characterpotentials.
     * @param {characterpotentialsDeleteArgs} args - Arguments to delete one Characterpotentials.
     * @example
     * // Delete one Characterpotentials
     * const Characterpotentials = await prisma.characterpotentials.delete({
     *   where: {
     *     // ... filter to delete one Characterpotentials
     *   }
     * })
     * 
     */
    delete<T extends characterpotentialsDeleteArgs>(args: SelectSubset<T, characterpotentialsDeleteArgs<ExtArgs>>): Prisma__characterpotentialsClient<$Result.GetResult<Prisma.$characterpotentialsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Characterpotentials.
     * @param {characterpotentialsUpdateArgs} args - Arguments to update one Characterpotentials.
     * @example
     * // Update one Characterpotentials
     * const characterpotentials = await prisma.characterpotentials.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends characterpotentialsUpdateArgs>(args: SelectSubset<T, characterpotentialsUpdateArgs<ExtArgs>>): Prisma__characterpotentialsClient<$Result.GetResult<Prisma.$characterpotentialsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Characterpotentials.
     * @param {characterpotentialsDeleteManyArgs} args - Arguments to filter Characterpotentials to delete.
     * @example
     * // Delete a few Characterpotentials
     * const { count } = await prisma.characterpotentials.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends characterpotentialsDeleteManyArgs>(args?: SelectSubset<T, characterpotentialsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Characterpotentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {characterpotentialsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Characterpotentials
     * const characterpotentials = await prisma.characterpotentials.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends characterpotentialsUpdateManyArgs>(args: SelectSubset<T, characterpotentialsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Characterpotentials.
     * @param {characterpotentialsUpsertArgs} args - Arguments to update or create a Characterpotentials.
     * @example
     * // Update or create a Characterpotentials
     * const characterpotentials = await prisma.characterpotentials.upsert({
     *   create: {
     *     // ... data to create a Characterpotentials
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Characterpotentials we want to update
     *   }
     * })
     */
    upsert<T extends characterpotentialsUpsertArgs>(args: SelectSubset<T, characterpotentialsUpsertArgs<ExtArgs>>): Prisma__characterpotentialsClient<$Result.GetResult<Prisma.$characterpotentialsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Characterpotentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {characterpotentialsCountArgs} args - Arguments to filter Characterpotentials to count.
     * @example
     * // Count the number of Characterpotentials
     * const count = await prisma.characterpotentials.count({
     *   where: {
     *     // ... the filter for the Characterpotentials we want to count
     *   }
     * })
    **/
    count<T extends characterpotentialsCountArgs>(
      args?: Subset<T, characterpotentialsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CharacterpotentialsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Characterpotentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterpotentialsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CharacterpotentialsAggregateArgs>(args: Subset<T, CharacterpotentialsAggregateArgs>): Prisma.PrismaPromise<GetCharacterpotentialsAggregateType<T>>

    /**
     * Group by Characterpotentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {characterpotentialsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends characterpotentialsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: characterpotentialsGroupByArgs['orderBy'] }
        : { orderBy?: characterpotentialsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, characterpotentialsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCharacterpotentialsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the characterpotentials model
   */
  readonly fields: characterpotentialsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for characterpotentials.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__characterpotentialsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the characterpotentials model
   */ 
  interface characterpotentialsFieldRefs {
    readonly id: FieldRef<"characterpotentials", 'BigInt'>
    readonly potkey: FieldRef<"characterpotentials", 'Int'>
    readonly skillid: FieldRef<"characterpotentials", 'Int'>
    readonly slv: FieldRef<"characterpotentials", 'Int'>
    readonly grade: FieldRef<"characterpotentials", 'Int'>
    readonly charid: FieldRef<"characterpotentials", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * characterpotentials findUnique
   */
  export type characterpotentialsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the characterpotentials
     */
    select?: characterpotentialsSelect<ExtArgs> | null
    /**
     * Filter, which characterpotentials to fetch.
     */
    where: characterpotentialsWhereUniqueInput
  }

  /**
   * characterpotentials findUniqueOrThrow
   */
  export type characterpotentialsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the characterpotentials
     */
    select?: characterpotentialsSelect<ExtArgs> | null
    /**
     * Filter, which characterpotentials to fetch.
     */
    where: characterpotentialsWhereUniqueInput
  }

  /**
   * characterpotentials findFirst
   */
  export type characterpotentialsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the characterpotentials
     */
    select?: characterpotentialsSelect<ExtArgs> | null
    /**
     * Filter, which characterpotentials to fetch.
     */
    where?: characterpotentialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of characterpotentials to fetch.
     */
    orderBy?: characterpotentialsOrderByWithRelationInput | characterpotentialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for characterpotentials.
     */
    cursor?: characterpotentialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` characterpotentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` characterpotentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of characterpotentials.
     */
    distinct?: CharacterpotentialsScalarFieldEnum | CharacterpotentialsScalarFieldEnum[]
  }

  /**
   * characterpotentials findFirstOrThrow
   */
  export type characterpotentialsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the characterpotentials
     */
    select?: characterpotentialsSelect<ExtArgs> | null
    /**
     * Filter, which characterpotentials to fetch.
     */
    where?: characterpotentialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of characterpotentials to fetch.
     */
    orderBy?: characterpotentialsOrderByWithRelationInput | characterpotentialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for characterpotentials.
     */
    cursor?: characterpotentialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` characterpotentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` characterpotentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of characterpotentials.
     */
    distinct?: CharacterpotentialsScalarFieldEnum | CharacterpotentialsScalarFieldEnum[]
  }

  /**
   * characterpotentials findMany
   */
  export type characterpotentialsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the characterpotentials
     */
    select?: characterpotentialsSelect<ExtArgs> | null
    /**
     * Filter, which characterpotentials to fetch.
     */
    where?: characterpotentialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of characterpotentials to fetch.
     */
    orderBy?: characterpotentialsOrderByWithRelationInput | characterpotentialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing characterpotentials.
     */
    cursor?: characterpotentialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` characterpotentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` characterpotentials.
     */
    skip?: number
    distinct?: CharacterpotentialsScalarFieldEnum | CharacterpotentialsScalarFieldEnum[]
  }

  /**
   * characterpotentials create
   */
  export type characterpotentialsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the characterpotentials
     */
    select?: characterpotentialsSelect<ExtArgs> | null
    /**
     * The data needed to create a characterpotentials.
     */
    data?: XOR<characterpotentialsCreateInput, characterpotentialsUncheckedCreateInput>
  }

  /**
   * characterpotentials createMany
   */
  export type characterpotentialsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many characterpotentials.
     */
    data: characterpotentialsCreateManyInput | characterpotentialsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * characterpotentials update
   */
  export type characterpotentialsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the characterpotentials
     */
    select?: characterpotentialsSelect<ExtArgs> | null
    /**
     * The data needed to update a characterpotentials.
     */
    data: XOR<characterpotentialsUpdateInput, characterpotentialsUncheckedUpdateInput>
    /**
     * Choose, which characterpotentials to update.
     */
    where: characterpotentialsWhereUniqueInput
  }

  /**
   * characterpotentials updateMany
   */
  export type characterpotentialsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update characterpotentials.
     */
    data: XOR<characterpotentialsUpdateManyMutationInput, characterpotentialsUncheckedUpdateManyInput>
    /**
     * Filter which characterpotentials to update
     */
    where?: characterpotentialsWhereInput
  }

  /**
   * characterpotentials upsert
   */
  export type characterpotentialsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the characterpotentials
     */
    select?: characterpotentialsSelect<ExtArgs> | null
    /**
     * The filter to search for the characterpotentials to update in case it exists.
     */
    where: characterpotentialsWhereUniqueInput
    /**
     * In case the characterpotentials found by the `where` argument doesn't exist, create a new characterpotentials with this data.
     */
    create: XOR<characterpotentialsCreateInput, characterpotentialsUncheckedCreateInput>
    /**
     * In case the characterpotentials was found with the provided `where` argument, update it with this data.
     */
    update: XOR<characterpotentialsUpdateInput, characterpotentialsUncheckedUpdateInput>
  }

  /**
   * characterpotentials delete
   */
  export type characterpotentialsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the characterpotentials
     */
    select?: characterpotentialsSelect<ExtArgs> | null
    /**
     * Filter which characterpotentials to delete.
     */
    where: characterpotentialsWhereUniqueInput
  }

  /**
   * characterpotentials deleteMany
   */
  export type characterpotentialsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which characterpotentials to delete
     */
    where?: characterpotentialsWhereInput
  }

  /**
   * characterpotentials without action
   */
  export type characterpotentialsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the characterpotentials
     */
    select?: characterpotentialsSelect<ExtArgs> | null
  }


  /**
   * Model characters
   */

  export type AggregateCharacters = {
    _count: CharactersCountAggregateOutputType | null
    _avg: CharactersAvgAggregateOutputType | null
    _sum: CharactersSumAggregateOutputType | null
    _min: CharactersMinAggregateOutputType | null
    _max: CharactersMaxAggregateOutputType | null
  }

  export type CharactersAvgAggregateOutputType = {
    id: number | null
    accid: number | null
    orderid: number | null
    avatardata: number | null
    equippedinventory: number | null
    equipinventory: number | null
    consumeinventory: number | null
    etcinventory: number | null
    installinventory: number | null
    cashinventory: number | null
    funckeymap_id: number | null
    fieldid: number | null
    questmanager: number | null
    guild: number | null
    rewardPoints: number | null
    monsterbook: number | null
    party: number | null
    medalid: number | null
    monsterparkcount: number | null
    previousFieldID: number | null
    onlineDay: number | null
    onlineTime: number | null
  }

  export type CharactersSumAggregateOutputType = {
    id: number | null
    accid: number | null
    orderid: number | null
    avatardata: number | null
    equippedinventory: number | null
    equipinventory: number | null
    consumeinventory: number | null
    etcinventory: number | null
    installinventory: number | null
    cashinventory: number | null
    funckeymap_id: number | null
    fieldid: number | null
    questmanager: bigint | null
    guild: number | null
    rewardPoints: number | null
    monsterbook: number | null
    party: number | null
    medalid: number | null
    monsterparkcount: number | null
    previousFieldID: bigint | null
    onlineDay: number | null
    onlineTime: bigint | null
  }

  export type CharactersMinAggregateOutputType = {
    id: number | null
    accid: number | null
    orderid: number | null
    avatardata: number | null
    equippedinventory: number | null
    equipinventory: number | null
    consumeinventory: number | null
    etcinventory: number | null
    installinventory: number | null
    cashinventory: number | null
    funckeymap_id: number | null
    fieldid: number | null
    questmanager: bigint | null
    guild: number | null
    rewardPoints: number | null
    monsterbook: number | null
    party: number | null
    medalid: number | null
    monsterparkcount: number | null
    previousFieldID: bigint | null
    onlineDay: number | null
    onlineTime: bigint | null
    quickslotKeys: string | null
  }

  export type CharactersMaxAggregateOutputType = {
    id: number | null
    accid: number | null
    orderid: number | null
    avatardata: number | null
    equippedinventory: number | null
    equipinventory: number | null
    consumeinventory: number | null
    etcinventory: number | null
    installinventory: number | null
    cashinventory: number | null
    funckeymap_id: number | null
    fieldid: number | null
    questmanager: bigint | null
    guild: number | null
    rewardPoints: number | null
    monsterbook: number | null
    party: number | null
    medalid: number | null
    monsterparkcount: number | null
    previousFieldID: bigint | null
    onlineDay: number | null
    onlineTime: bigint | null
    quickslotKeys: string | null
  }

  export type CharactersCountAggregateOutputType = {
    id: number
    accid: number
    orderid: number
    avatardata: number
    equippedinventory: number
    equipinventory: number
    consumeinventory: number
    etcinventory: number
    installinventory: number
    cashinventory: number
    funckeymap_id: number
    fieldid: number
    questmanager: number
    guild: number
    rewardPoints: number
    monsterbook: number
    party: number
    medalid: number
    monsterparkcount: number
    previousFieldID: number
    onlineDay: number
    onlineTime: number
    quickslotKeys: number
    _all: number
  }


  export type CharactersAvgAggregateInputType = {
    id?: true
    accid?: true
    orderid?: true
    avatardata?: true
    equippedinventory?: true
    equipinventory?: true
    consumeinventory?: true
    etcinventory?: true
    installinventory?: true
    cashinventory?: true
    funckeymap_id?: true
    fieldid?: true
    questmanager?: true
    guild?: true
    rewardPoints?: true
    monsterbook?: true
    party?: true
    medalid?: true
    monsterparkcount?: true
    previousFieldID?: true
    onlineDay?: true
    onlineTime?: true
  }

  export type CharactersSumAggregateInputType = {
    id?: true
    accid?: true
    orderid?: true
    avatardata?: true
    equippedinventory?: true
    equipinventory?: true
    consumeinventory?: true
    etcinventory?: true
    installinventory?: true
    cashinventory?: true
    funckeymap_id?: true
    fieldid?: true
    questmanager?: true
    guild?: true
    rewardPoints?: true
    monsterbook?: true
    party?: true
    medalid?: true
    monsterparkcount?: true
    previousFieldID?: true
    onlineDay?: true
    onlineTime?: true
  }

  export type CharactersMinAggregateInputType = {
    id?: true
    accid?: true
    orderid?: true
    avatardata?: true
    equippedinventory?: true
    equipinventory?: true
    consumeinventory?: true
    etcinventory?: true
    installinventory?: true
    cashinventory?: true
    funckeymap_id?: true
    fieldid?: true
    questmanager?: true
    guild?: true
    rewardPoints?: true
    monsterbook?: true
    party?: true
    medalid?: true
    monsterparkcount?: true
    previousFieldID?: true
    onlineDay?: true
    onlineTime?: true
    quickslotKeys?: true
  }

  export type CharactersMaxAggregateInputType = {
    id?: true
    accid?: true
    orderid?: true
    avatardata?: true
    equippedinventory?: true
    equipinventory?: true
    consumeinventory?: true
    etcinventory?: true
    installinventory?: true
    cashinventory?: true
    funckeymap_id?: true
    fieldid?: true
    questmanager?: true
    guild?: true
    rewardPoints?: true
    monsterbook?: true
    party?: true
    medalid?: true
    monsterparkcount?: true
    previousFieldID?: true
    onlineDay?: true
    onlineTime?: true
    quickslotKeys?: true
  }

  export type CharactersCountAggregateInputType = {
    id?: true
    accid?: true
    orderid?: true
    avatardata?: true
    equippedinventory?: true
    equipinventory?: true
    consumeinventory?: true
    etcinventory?: true
    installinventory?: true
    cashinventory?: true
    funckeymap_id?: true
    fieldid?: true
    questmanager?: true
    guild?: true
    rewardPoints?: true
    monsterbook?: true
    party?: true
    medalid?: true
    monsterparkcount?: true
    previousFieldID?: true
    onlineDay?: true
    onlineTime?: true
    quickslotKeys?: true
    _all?: true
  }

  export type CharactersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which characters to aggregate.
     */
    where?: charactersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of characters to fetch.
     */
    orderBy?: charactersOrderByWithRelationInput | charactersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: charactersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` characters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned characters
    **/
    _count?: true | CharactersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CharactersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CharactersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CharactersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CharactersMaxAggregateInputType
  }

  export type GetCharactersAggregateType<T extends CharactersAggregateArgs> = {
        [P in keyof T & keyof AggregateCharacters]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCharacters[P]>
      : GetScalarType<T[P], AggregateCharacters[P]>
  }




  export type charactersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: charactersWhereInput
    orderBy?: charactersOrderByWithAggregationInput | charactersOrderByWithAggregationInput[]
    by: CharactersScalarFieldEnum[] | CharactersScalarFieldEnum
    having?: charactersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CharactersCountAggregateInputType | true
    _avg?: CharactersAvgAggregateInputType
    _sum?: CharactersSumAggregateInputType
    _min?: CharactersMinAggregateInputType
    _max?: CharactersMaxAggregateInputType
  }

  export type CharactersGroupByOutputType = {
    id: number
    accid: number | null
    orderid: number | null
    avatardata: number | null
    equippedinventory: number | null
    equipinventory: number | null
    consumeinventory: number | null
    etcinventory: number | null
    installinventory: number | null
    cashinventory: number | null
    funckeymap_id: number | null
    fieldid: number | null
    questmanager: bigint | null
    guild: number | null
    rewardPoints: number | null
    monsterbook: number | null
    party: number | null
    medalid: number | null
    monsterparkcount: number | null
    previousFieldID: bigint | null
    onlineDay: number | null
    onlineTime: bigint | null
    quickslotKeys: string | null
    _count: CharactersCountAggregateOutputType | null
    _avg: CharactersAvgAggregateOutputType | null
    _sum: CharactersSumAggregateOutputType | null
    _min: CharactersMinAggregateOutputType | null
    _max: CharactersMaxAggregateOutputType | null
  }

  type GetCharactersGroupByPayload<T extends charactersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CharactersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CharactersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CharactersGroupByOutputType[P]>
            : GetScalarType<T[P], CharactersGroupByOutputType[P]>
        }
      >
    >


  export type charactersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accid?: boolean
    orderid?: boolean
    avatardata?: boolean
    equippedinventory?: boolean
    equipinventory?: boolean
    consumeinventory?: boolean
    etcinventory?: boolean
    installinventory?: boolean
    cashinventory?: boolean
    funckeymap_id?: boolean
    fieldid?: boolean
    questmanager?: boolean
    guild?: boolean
    rewardPoints?: boolean
    monsterbook?: boolean
    party?: boolean
    medalid?: boolean
    monsterparkcount?: boolean
    previousFieldID?: boolean
    onlineDay?: boolean
    onlineTime?: boolean
    quickslotKeys?: boolean
  }, ExtArgs["result"]["characters"]>


  export type charactersSelectScalar = {
    id?: boolean
    accid?: boolean
    orderid?: boolean
    avatardata?: boolean
    equippedinventory?: boolean
    equipinventory?: boolean
    consumeinventory?: boolean
    etcinventory?: boolean
    installinventory?: boolean
    cashinventory?: boolean
    funckeymap_id?: boolean
    fieldid?: boolean
    questmanager?: boolean
    guild?: boolean
    rewardPoints?: boolean
    monsterbook?: boolean
    party?: boolean
    medalid?: boolean
    monsterparkcount?: boolean
    previousFieldID?: boolean
    onlineDay?: boolean
    onlineTime?: boolean
    quickslotKeys?: boolean
  }


  export type $charactersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "characters"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      accid: number | null
      orderid: number | null
      avatardata: number | null
      equippedinventory: number | null
      equipinventory: number | null
      consumeinventory: number | null
      etcinventory: number | null
      installinventory: number | null
      cashinventory: number | null
      funckeymap_id: number | null
      fieldid: number | null
      questmanager: bigint | null
      guild: number | null
      rewardPoints: number | null
      monsterbook: number | null
      party: number | null
      medalid: number | null
      monsterparkcount: number | null
      previousFieldID: bigint | null
      onlineDay: number | null
      onlineTime: bigint | null
      quickslotKeys: string | null
    }, ExtArgs["result"]["characters"]>
    composites: {}
  }

  type charactersGetPayload<S extends boolean | null | undefined | charactersDefaultArgs> = $Result.GetResult<Prisma.$charactersPayload, S>

  type charactersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<charactersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CharactersCountAggregateInputType | true
    }

  export interface charactersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['characters'], meta: { name: 'characters' } }
    /**
     * Find zero or one Characters that matches the filter.
     * @param {charactersFindUniqueArgs} args - Arguments to find a Characters
     * @example
     * // Get one Characters
     * const characters = await prisma.characters.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends charactersFindUniqueArgs>(args: SelectSubset<T, charactersFindUniqueArgs<ExtArgs>>): Prisma__charactersClient<$Result.GetResult<Prisma.$charactersPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Characters that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {charactersFindUniqueOrThrowArgs} args - Arguments to find a Characters
     * @example
     * // Get one Characters
     * const characters = await prisma.characters.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends charactersFindUniqueOrThrowArgs>(args: SelectSubset<T, charactersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__charactersClient<$Result.GetResult<Prisma.$charactersPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Characters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {charactersFindFirstArgs} args - Arguments to find a Characters
     * @example
     * // Get one Characters
     * const characters = await prisma.characters.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends charactersFindFirstArgs>(args?: SelectSubset<T, charactersFindFirstArgs<ExtArgs>>): Prisma__charactersClient<$Result.GetResult<Prisma.$charactersPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Characters that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {charactersFindFirstOrThrowArgs} args - Arguments to find a Characters
     * @example
     * // Get one Characters
     * const characters = await prisma.characters.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends charactersFindFirstOrThrowArgs>(args?: SelectSubset<T, charactersFindFirstOrThrowArgs<ExtArgs>>): Prisma__charactersClient<$Result.GetResult<Prisma.$charactersPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Characters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {charactersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Characters
     * const characters = await prisma.characters.findMany()
     * 
     * // Get first 10 Characters
     * const characters = await prisma.characters.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const charactersWithIdOnly = await prisma.characters.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends charactersFindManyArgs>(args?: SelectSubset<T, charactersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$charactersPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Characters.
     * @param {charactersCreateArgs} args - Arguments to create a Characters.
     * @example
     * // Create one Characters
     * const Characters = await prisma.characters.create({
     *   data: {
     *     // ... data to create a Characters
     *   }
     * })
     * 
     */
    create<T extends charactersCreateArgs>(args: SelectSubset<T, charactersCreateArgs<ExtArgs>>): Prisma__charactersClient<$Result.GetResult<Prisma.$charactersPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Characters.
     * @param {charactersCreateManyArgs} args - Arguments to create many Characters.
     * @example
     * // Create many Characters
     * const characters = await prisma.characters.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends charactersCreateManyArgs>(args?: SelectSubset<T, charactersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Characters.
     * @param {charactersDeleteArgs} args - Arguments to delete one Characters.
     * @example
     * // Delete one Characters
     * const Characters = await prisma.characters.delete({
     *   where: {
     *     // ... filter to delete one Characters
     *   }
     * })
     * 
     */
    delete<T extends charactersDeleteArgs>(args: SelectSubset<T, charactersDeleteArgs<ExtArgs>>): Prisma__charactersClient<$Result.GetResult<Prisma.$charactersPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Characters.
     * @param {charactersUpdateArgs} args - Arguments to update one Characters.
     * @example
     * // Update one Characters
     * const characters = await prisma.characters.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends charactersUpdateArgs>(args: SelectSubset<T, charactersUpdateArgs<ExtArgs>>): Prisma__charactersClient<$Result.GetResult<Prisma.$charactersPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Characters.
     * @param {charactersDeleteManyArgs} args - Arguments to filter Characters to delete.
     * @example
     * // Delete a few Characters
     * const { count } = await prisma.characters.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends charactersDeleteManyArgs>(args?: SelectSubset<T, charactersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Characters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {charactersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Characters
     * const characters = await prisma.characters.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends charactersUpdateManyArgs>(args: SelectSubset<T, charactersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Characters.
     * @param {charactersUpsertArgs} args - Arguments to update or create a Characters.
     * @example
     * // Update or create a Characters
     * const characters = await prisma.characters.upsert({
     *   create: {
     *     // ... data to create a Characters
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Characters we want to update
     *   }
     * })
     */
    upsert<T extends charactersUpsertArgs>(args: SelectSubset<T, charactersUpsertArgs<ExtArgs>>): Prisma__charactersClient<$Result.GetResult<Prisma.$charactersPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Characters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {charactersCountArgs} args - Arguments to filter Characters to count.
     * @example
     * // Count the number of Characters
     * const count = await prisma.characters.count({
     *   where: {
     *     // ... the filter for the Characters we want to count
     *   }
     * })
    **/
    count<T extends charactersCountArgs>(
      args?: Subset<T, charactersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CharactersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Characters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharactersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CharactersAggregateArgs>(args: Subset<T, CharactersAggregateArgs>): Prisma.PrismaPromise<GetCharactersAggregateType<T>>

    /**
     * Group by Characters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {charactersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends charactersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: charactersGroupByArgs['orderBy'] }
        : { orderBy?: charactersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, charactersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCharactersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the characters model
   */
  readonly fields: charactersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for characters.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__charactersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the characters model
   */ 
  interface charactersFieldRefs {
    readonly id: FieldRef<"characters", 'Int'>
    readonly accid: FieldRef<"characters", 'Int'>
    readonly orderid: FieldRef<"characters", 'Int'>
    readonly avatardata: FieldRef<"characters", 'Int'>
    readonly equippedinventory: FieldRef<"characters", 'Int'>
    readonly equipinventory: FieldRef<"characters", 'Int'>
    readonly consumeinventory: FieldRef<"characters", 'Int'>
    readonly etcinventory: FieldRef<"characters", 'Int'>
    readonly installinventory: FieldRef<"characters", 'Int'>
    readonly cashinventory: FieldRef<"characters", 'Int'>
    readonly funckeymap_id: FieldRef<"characters", 'Int'>
    readonly fieldid: FieldRef<"characters", 'Int'>
    readonly questmanager: FieldRef<"characters", 'BigInt'>
    readonly guild: FieldRef<"characters", 'Int'>
    readonly rewardPoints: FieldRef<"characters", 'Int'>
    readonly monsterbook: FieldRef<"characters", 'Int'>
    readonly party: FieldRef<"characters", 'Int'>
    readonly medalid: FieldRef<"characters", 'Int'>
    readonly monsterparkcount: FieldRef<"characters", 'Int'>
    readonly previousFieldID: FieldRef<"characters", 'BigInt'>
    readonly onlineDay: FieldRef<"characters", 'Int'>
    readonly onlineTime: FieldRef<"characters", 'BigInt'>
    readonly quickslotKeys: FieldRef<"characters", 'String'>
  }
    

  // Custom InputTypes
  /**
   * characters findUnique
   */
  export type charactersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the characters
     */
    select?: charactersSelect<ExtArgs> | null
    /**
     * Filter, which characters to fetch.
     */
    where: charactersWhereUniqueInput
  }

  /**
   * characters findUniqueOrThrow
   */
  export type charactersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the characters
     */
    select?: charactersSelect<ExtArgs> | null
    /**
     * Filter, which characters to fetch.
     */
    where: charactersWhereUniqueInput
  }

  /**
   * characters findFirst
   */
  export type charactersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the characters
     */
    select?: charactersSelect<ExtArgs> | null
    /**
     * Filter, which characters to fetch.
     */
    where?: charactersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of characters to fetch.
     */
    orderBy?: charactersOrderByWithRelationInput | charactersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for characters.
     */
    cursor?: charactersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` characters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of characters.
     */
    distinct?: CharactersScalarFieldEnum | CharactersScalarFieldEnum[]
  }

  /**
   * characters findFirstOrThrow
   */
  export type charactersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the characters
     */
    select?: charactersSelect<ExtArgs> | null
    /**
     * Filter, which characters to fetch.
     */
    where?: charactersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of characters to fetch.
     */
    orderBy?: charactersOrderByWithRelationInput | charactersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for characters.
     */
    cursor?: charactersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` characters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of characters.
     */
    distinct?: CharactersScalarFieldEnum | CharactersScalarFieldEnum[]
  }

  /**
   * characters findMany
   */
  export type charactersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the characters
     */
    select?: charactersSelect<ExtArgs> | null
    /**
     * Filter, which characters to fetch.
     */
    where?: charactersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of characters to fetch.
     */
    orderBy?: charactersOrderByWithRelationInput | charactersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing characters.
     */
    cursor?: charactersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` characters.
     */
    skip?: number
    distinct?: CharactersScalarFieldEnum | CharactersScalarFieldEnum[]
  }

  /**
   * characters create
   */
  export type charactersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the characters
     */
    select?: charactersSelect<ExtArgs> | null
    /**
     * The data needed to create a characters.
     */
    data?: XOR<charactersCreateInput, charactersUncheckedCreateInput>
  }

  /**
   * characters createMany
   */
  export type charactersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many characters.
     */
    data: charactersCreateManyInput | charactersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * characters update
   */
  export type charactersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the characters
     */
    select?: charactersSelect<ExtArgs> | null
    /**
     * The data needed to update a characters.
     */
    data: XOR<charactersUpdateInput, charactersUncheckedUpdateInput>
    /**
     * Choose, which characters to update.
     */
    where: charactersWhereUniqueInput
  }

  /**
   * characters updateMany
   */
  export type charactersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update characters.
     */
    data: XOR<charactersUpdateManyMutationInput, charactersUncheckedUpdateManyInput>
    /**
     * Filter which characters to update
     */
    where?: charactersWhereInput
  }

  /**
   * characters upsert
   */
  export type charactersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the characters
     */
    select?: charactersSelect<ExtArgs> | null
    /**
     * The filter to search for the characters to update in case it exists.
     */
    where: charactersWhereUniqueInput
    /**
     * In case the characters found by the `where` argument doesn't exist, create a new characters with this data.
     */
    create: XOR<charactersCreateInput, charactersUncheckedCreateInput>
    /**
     * In case the characters was found with the provided `where` argument, update it with this data.
     */
    update: XOR<charactersUpdateInput, charactersUncheckedUpdateInput>
  }

  /**
   * characters delete
   */
  export type charactersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the characters
     */
    select?: charactersSelect<ExtArgs> | null
    /**
     * Filter which characters to delete.
     */
    where: charactersWhereUniqueInput
  }

  /**
   * characters deleteMany
   */
  export type charactersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which characters to delete
     */
    where?: charactersWhereInput
  }

  /**
   * characters without action
   */
  export type charactersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the characters
     */
    select?: charactersSelect<ExtArgs> | null
  }


  /**
   * Model characterstats
   */

  export type AggregateCharacterstats = {
    _count: CharacterstatsCountAggregateOutputType | null
    _avg: CharacterstatsAvgAggregateOutputType | null
    _sum: CharacterstatsSumAggregateOutputType | null
    _min: CharacterstatsMinAggregateOutputType | null
    _max: CharacterstatsMaxAggregateOutputType | null
  }

  export type CharacterstatsAvgAggregateOutputType = {
    id: number | null
    characterid: number | null
    characteridforlog: number | null
    worldidforlog: number | null
    gender: number | null
    skin: number | null
    face: number | null
    hair: number | null
    mixbasehaircolor: number | null
    mixaddhaircolor: number | null
    mixhairbaseprob: number | null
    level: number | null
    job: number | null
    str: number | null
    dex: number | null
    inte: number | null
    luk: number | null
    hp: number | null
    maxhp: number | null
    mp: number | null
    maxmp: number | null
    ap: number | null
    sp: number | null
    pop: number | null
    wp: number | null
    extendsp: number | null
    portal: number | null
    subjob: number | null
    deffaceacc: number | null
    fatigue: number | null
    lastfatigueupdatetime: number | null
    charismaexp: number | null
    insightexp: number | null
    willexp: number | null
    craftexp: number | null
    senseexp: number | null
    charmexp: number | null
    noncombatstatdaylimit: number | null
    mcpoint: number | null
    pvpexp: number | null
    pvpgrade: number | null
    pvppoint: number | null
    pvpmodelevel: number | null
    pvpmodetype: number | null
    eventpoint: number | null
    albaactivityid: number | null
    albaduration: number | null
    albaspecialreward: number | null
    charactercard: number | null
    accountlastlogout: number | null
    gachexp: number | null
    honorexp: number | null
    node_shards: number | null
    maxfriends: number | null
  }

  export type CharacterstatsSumAggregateOutputType = {
    id: number | null
    characterid: number | null
    characteridforlog: number | null
    worldidforlog: number | null
    gender: number | null
    skin: number | null
    face: number | null
    hair: number | null
    mixbasehaircolor: number | null
    mixaddhaircolor: number | null
    mixhairbaseprob: number | null
    level: number | null
    job: number | null
    str: number | null
    dex: number | null
    inte: number | null
    luk: number | null
    hp: number | null
    maxhp: number | null
    mp: number | null
    maxmp: number | null
    ap: number | null
    sp: number | null
    pop: number | null
    wp: number | null
    extendsp: number | null
    portal: number | null
    subjob: number | null
    deffaceacc: number | null
    fatigue: number | null
    lastfatigueupdatetime: number | null
    charismaexp: number | null
    insightexp: number | null
    willexp: number | null
    craftexp: number | null
    senseexp: number | null
    charmexp: number | null
    noncombatstatdaylimit: number | null
    mcpoint: number | null
    pvpexp: number | null
    pvpgrade: number | null
    pvppoint: number | null
    pvpmodelevel: number | null
    pvpmodetype: number | null
    eventpoint: number | null
    albaactivityid: number | null
    albaduration: number | null
    albaspecialreward: number | null
    charactercard: number | null
    accountlastlogout: number | null
    gachexp: number | null
    honorexp: number | null
    node_shards: number | null
    maxfriends: number | null
  }

  export type CharacterstatsMinAggregateOutputType = {
    id: number | null
    characterid: number | null
    characteridforlog: number | null
    worldidforlog: number | null
    name: string | null
    gender: number | null
    skin: number | null
    face: number | null
    hair: number | null
    mixbasehaircolor: number | null
    mixaddhaircolor: number | null
    mixhairbaseprob: number | null
    level: number | null
    job: number | null
    str: number | null
    dex: number | null
    inte: number | null
    luk: number | null
    hp: number | null
    maxhp: number | null
    mp: number | null
    maxmp: number | null
    ap: number | null
    sp: number | null
    exp: string | null
    pop: number | null
    money: string | null
    wp: number | null
    extendsp: number | null
    posmap: string | null
    portal: number | null
    subjob: number | null
    deffaceacc: number | null
    fatigue: number | null
    lastfatigueupdatetime: number | null
    charismaexp: number | null
    insightexp: number | null
    willexp: number | null
    craftexp: number | null
    senseexp: number | null
    charmexp: number | null
    noncombatstatdaylimit: number | null
    mcpoint: number | null
    pvpexp: number | null
    pvpgrade: number | null
    pvppoint: number | null
    pvpmodelevel: number | null
    pvpmodetype: number | null
    eventpoint: number | null
    albaactivityid: number | null
    albastarttime: Date | null
    albaduration: number | null
    albaspecialreward: number | null
    burning: boolean | null
    charactercard: number | null
    accountlastlogout: number | null
    lastlogout: Date | null
    gachexp: number | null
    honorexp: number | null
    nextavailablefametime: Date | null
    node_shards: number | null
    maxfriends: number | null
  }

  export type CharacterstatsMaxAggregateOutputType = {
    id: number | null
    characterid: number | null
    characteridforlog: number | null
    worldidforlog: number | null
    name: string | null
    gender: number | null
    skin: number | null
    face: number | null
    hair: number | null
    mixbasehaircolor: number | null
    mixaddhaircolor: number | null
    mixhairbaseprob: number | null
    level: number | null
    job: number | null
    str: number | null
    dex: number | null
    inte: number | null
    luk: number | null
    hp: number | null
    maxhp: number | null
    mp: number | null
    maxmp: number | null
    ap: number | null
    sp: number | null
    exp: string | null
    pop: number | null
    money: string | null
    wp: number | null
    extendsp: number | null
    posmap: string | null
    portal: number | null
    subjob: number | null
    deffaceacc: number | null
    fatigue: number | null
    lastfatigueupdatetime: number | null
    charismaexp: number | null
    insightexp: number | null
    willexp: number | null
    craftexp: number | null
    senseexp: number | null
    charmexp: number | null
    noncombatstatdaylimit: number | null
    mcpoint: number | null
    pvpexp: number | null
    pvpgrade: number | null
    pvppoint: number | null
    pvpmodelevel: number | null
    pvpmodetype: number | null
    eventpoint: number | null
    albaactivityid: number | null
    albastarttime: Date | null
    albaduration: number | null
    albaspecialreward: number | null
    burning: boolean | null
    charactercard: number | null
    accountlastlogout: number | null
    lastlogout: Date | null
    gachexp: number | null
    honorexp: number | null
    nextavailablefametime: Date | null
    node_shards: number | null
    maxfriends: number | null
  }

  export type CharacterstatsCountAggregateOutputType = {
    id: number
    characterid: number
    characteridforlog: number
    worldidforlog: number
    name: number
    gender: number
    skin: number
    face: number
    hair: number
    mixbasehaircolor: number
    mixaddhaircolor: number
    mixhairbaseprob: number
    level: number
    job: number
    str: number
    dex: number
    inte: number
    luk: number
    hp: number
    maxhp: number
    mp: number
    maxmp: number
    ap: number
    sp: number
    exp: number
    pop: number
    money: number
    wp: number
    extendsp: number
    posmap: number
    portal: number
    subjob: number
    deffaceacc: number
    fatigue: number
    lastfatigueupdatetime: number
    charismaexp: number
    insightexp: number
    willexp: number
    craftexp: number
    senseexp: number
    charmexp: number
    noncombatstatdaylimit: number
    mcpoint: number
    pvpexp: number
    pvpgrade: number
    pvppoint: number
    pvpmodelevel: number
    pvpmodetype: number
    eventpoint: number
    albaactivityid: number
    albastarttime: number
    albaduration: number
    albaspecialreward: number
    burning: number
    charactercard: number
    accountlastlogout: number
    lastlogout: number
    gachexp: number
    honorexp: number
    nextavailablefametime: number
    node_shards: number
    maxfriends: number
    _all: number
  }


  export type CharacterstatsAvgAggregateInputType = {
    id?: true
    characterid?: true
    characteridforlog?: true
    worldidforlog?: true
    gender?: true
    skin?: true
    face?: true
    hair?: true
    mixbasehaircolor?: true
    mixaddhaircolor?: true
    mixhairbaseprob?: true
    level?: true
    job?: true
    str?: true
    dex?: true
    inte?: true
    luk?: true
    hp?: true
    maxhp?: true
    mp?: true
    maxmp?: true
    ap?: true
    sp?: true
    pop?: true
    wp?: true
    extendsp?: true
    portal?: true
    subjob?: true
    deffaceacc?: true
    fatigue?: true
    lastfatigueupdatetime?: true
    charismaexp?: true
    insightexp?: true
    willexp?: true
    craftexp?: true
    senseexp?: true
    charmexp?: true
    noncombatstatdaylimit?: true
    mcpoint?: true
    pvpexp?: true
    pvpgrade?: true
    pvppoint?: true
    pvpmodelevel?: true
    pvpmodetype?: true
    eventpoint?: true
    albaactivityid?: true
    albaduration?: true
    albaspecialreward?: true
    charactercard?: true
    accountlastlogout?: true
    gachexp?: true
    honorexp?: true
    node_shards?: true
    maxfriends?: true
  }

  export type CharacterstatsSumAggregateInputType = {
    id?: true
    characterid?: true
    characteridforlog?: true
    worldidforlog?: true
    gender?: true
    skin?: true
    face?: true
    hair?: true
    mixbasehaircolor?: true
    mixaddhaircolor?: true
    mixhairbaseprob?: true
    level?: true
    job?: true
    str?: true
    dex?: true
    inte?: true
    luk?: true
    hp?: true
    maxhp?: true
    mp?: true
    maxmp?: true
    ap?: true
    sp?: true
    pop?: true
    wp?: true
    extendsp?: true
    portal?: true
    subjob?: true
    deffaceacc?: true
    fatigue?: true
    lastfatigueupdatetime?: true
    charismaexp?: true
    insightexp?: true
    willexp?: true
    craftexp?: true
    senseexp?: true
    charmexp?: true
    noncombatstatdaylimit?: true
    mcpoint?: true
    pvpexp?: true
    pvpgrade?: true
    pvppoint?: true
    pvpmodelevel?: true
    pvpmodetype?: true
    eventpoint?: true
    albaactivityid?: true
    albaduration?: true
    albaspecialreward?: true
    charactercard?: true
    accountlastlogout?: true
    gachexp?: true
    honorexp?: true
    node_shards?: true
    maxfriends?: true
  }

  export type CharacterstatsMinAggregateInputType = {
    id?: true
    characterid?: true
    characteridforlog?: true
    worldidforlog?: true
    name?: true
    gender?: true
    skin?: true
    face?: true
    hair?: true
    mixbasehaircolor?: true
    mixaddhaircolor?: true
    mixhairbaseprob?: true
    level?: true
    job?: true
    str?: true
    dex?: true
    inte?: true
    luk?: true
    hp?: true
    maxhp?: true
    mp?: true
    maxmp?: true
    ap?: true
    sp?: true
    exp?: true
    pop?: true
    money?: true
    wp?: true
    extendsp?: true
    posmap?: true
    portal?: true
    subjob?: true
    deffaceacc?: true
    fatigue?: true
    lastfatigueupdatetime?: true
    charismaexp?: true
    insightexp?: true
    willexp?: true
    craftexp?: true
    senseexp?: true
    charmexp?: true
    noncombatstatdaylimit?: true
    mcpoint?: true
    pvpexp?: true
    pvpgrade?: true
    pvppoint?: true
    pvpmodelevel?: true
    pvpmodetype?: true
    eventpoint?: true
    albaactivityid?: true
    albastarttime?: true
    albaduration?: true
    albaspecialreward?: true
    burning?: true
    charactercard?: true
    accountlastlogout?: true
    lastlogout?: true
    gachexp?: true
    honorexp?: true
    nextavailablefametime?: true
    node_shards?: true
    maxfriends?: true
  }

  export type CharacterstatsMaxAggregateInputType = {
    id?: true
    characterid?: true
    characteridforlog?: true
    worldidforlog?: true
    name?: true
    gender?: true
    skin?: true
    face?: true
    hair?: true
    mixbasehaircolor?: true
    mixaddhaircolor?: true
    mixhairbaseprob?: true
    level?: true
    job?: true
    str?: true
    dex?: true
    inte?: true
    luk?: true
    hp?: true
    maxhp?: true
    mp?: true
    maxmp?: true
    ap?: true
    sp?: true
    exp?: true
    pop?: true
    money?: true
    wp?: true
    extendsp?: true
    posmap?: true
    portal?: true
    subjob?: true
    deffaceacc?: true
    fatigue?: true
    lastfatigueupdatetime?: true
    charismaexp?: true
    insightexp?: true
    willexp?: true
    craftexp?: true
    senseexp?: true
    charmexp?: true
    noncombatstatdaylimit?: true
    mcpoint?: true
    pvpexp?: true
    pvpgrade?: true
    pvppoint?: true
    pvpmodelevel?: true
    pvpmodetype?: true
    eventpoint?: true
    albaactivityid?: true
    albastarttime?: true
    albaduration?: true
    albaspecialreward?: true
    burning?: true
    charactercard?: true
    accountlastlogout?: true
    lastlogout?: true
    gachexp?: true
    honorexp?: true
    nextavailablefametime?: true
    node_shards?: true
    maxfriends?: true
  }

  export type CharacterstatsCountAggregateInputType = {
    id?: true
    characterid?: true
    characteridforlog?: true
    worldidforlog?: true
    name?: true
    gender?: true
    skin?: true
    face?: true
    hair?: true
    mixbasehaircolor?: true
    mixaddhaircolor?: true
    mixhairbaseprob?: true
    level?: true
    job?: true
    str?: true
    dex?: true
    inte?: true
    luk?: true
    hp?: true
    maxhp?: true
    mp?: true
    maxmp?: true
    ap?: true
    sp?: true
    exp?: true
    pop?: true
    money?: true
    wp?: true
    extendsp?: true
    posmap?: true
    portal?: true
    subjob?: true
    deffaceacc?: true
    fatigue?: true
    lastfatigueupdatetime?: true
    charismaexp?: true
    insightexp?: true
    willexp?: true
    craftexp?: true
    senseexp?: true
    charmexp?: true
    noncombatstatdaylimit?: true
    mcpoint?: true
    pvpexp?: true
    pvpgrade?: true
    pvppoint?: true
    pvpmodelevel?: true
    pvpmodetype?: true
    eventpoint?: true
    albaactivityid?: true
    albastarttime?: true
    albaduration?: true
    albaspecialreward?: true
    burning?: true
    charactercard?: true
    accountlastlogout?: true
    lastlogout?: true
    gachexp?: true
    honorexp?: true
    nextavailablefametime?: true
    node_shards?: true
    maxfriends?: true
    _all?: true
  }

  export type CharacterstatsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which characterstats to aggregate.
     */
    where?: characterstatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of characterstats to fetch.
     */
    orderBy?: characterstatsOrderByWithRelationInput | characterstatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: characterstatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` characterstats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` characterstats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned characterstats
    **/
    _count?: true | CharacterstatsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CharacterstatsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CharacterstatsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CharacterstatsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CharacterstatsMaxAggregateInputType
  }

  export type GetCharacterstatsAggregateType<T extends CharacterstatsAggregateArgs> = {
        [P in keyof T & keyof AggregateCharacterstats]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCharacterstats[P]>
      : GetScalarType<T[P], AggregateCharacterstats[P]>
  }




  export type characterstatsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: characterstatsWhereInput
    orderBy?: characterstatsOrderByWithAggregationInput | characterstatsOrderByWithAggregationInput[]
    by: CharacterstatsScalarFieldEnum[] | CharacterstatsScalarFieldEnum
    having?: characterstatsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CharacterstatsCountAggregateInputType | true
    _avg?: CharacterstatsAvgAggregateInputType
    _sum?: CharacterstatsSumAggregateInputType
    _min?: CharacterstatsMinAggregateInputType
    _max?: CharacterstatsMaxAggregateInputType
  }

  export type CharacterstatsGroupByOutputType = {
    id: number
    characterid: number | null
    characteridforlog: number | null
    worldidforlog: number | null
    name: string | null
    gender: number | null
    skin: number | null
    face: number | null
    hair: number | null
    mixbasehaircolor: number | null
    mixaddhaircolor: number | null
    mixhairbaseprob: number | null
    level: number | null
    job: number | null
    str: number | null
    dex: number | null
    inte: number | null
    luk: number | null
    hp: number | null
    maxhp: number | null
    mp: number | null
    maxmp: number | null
    ap: number | null
    sp: number | null
    exp: string | null
    pop: number | null
    money: string | null
    wp: number | null
    extendsp: number | null
    posmap: string | null
    portal: number | null
    subjob: number | null
    deffaceacc: number | null
    fatigue: number | null
    lastfatigueupdatetime: number | null
    charismaexp: number | null
    insightexp: number | null
    willexp: number | null
    craftexp: number | null
    senseexp: number | null
    charmexp: number | null
    noncombatstatdaylimit: number | null
    mcpoint: number | null
    pvpexp: number | null
    pvpgrade: number | null
    pvppoint: number | null
    pvpmodelevel: number | null
    pvpmodetype: number | null
    eventpoint: number | null
    albaactivityid: number | null
    albastarttime: Date | null
    albaduration: number | null
    albaspecialreward: number | null
    burning: boolean | null
    charactercard: number | null
    accountlastlogout: number | null
    lastlogout: Date | null
    gachexp: number | null
    honorexp: number | null
    nextavailablefametime: Date | null
    node_shards: number
    maxfriends: number
    _count: CharacterstatsCountAggregateOutputType | null
    _avg: CharacterstatsAvgAggregateOutputType | null
    _sum: CharacterstatsSumAggregateOutputType | null
    _min: CharacterstatsMinAggregateOutputType | null
    _max: CharacterstatsMaxAggregateOutputType | null
  }

  type GetCharacterstatsGroupByPayload<T extends characterstatsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CharacterstatsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CharacterstatsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CharacterstatsGroupByOutputType[P]>
            : GetScalarType<T[P], CharacterstatsGroupByOutputType[P]>
        }
      >
    >


  export type characterstatsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    characterid?: boolean
    characteridforlog?: boolean
    worldidforlog?: boolean
    name?: boolean
    gender?: boolean
    skin?: boolean
    face?: boolean
    hair?: boolean
    mixbasehaircolor?: boolean
    mixaddhaircolor?: boolean
    mixhairbaseprob?: boolean
    level?: boolean
    job?: boolean
    str?: boolean
    dex?: boolean
    inte?: boolean
    luk?: boolean
    hp?: boolean
    maxhp?: boolean
    mp?: boolean
    maxmp?: boolean
    ap?: boolean
    sp?: boolean
    exp?: boolean
    pop?: boolean
    money?: boolean
    wp?: boolean
    extendsp?: boolean
    posmap?: boolean
    portal?: boolean
    subjob?: boolean
    deffaceacc?: boolean
    fatigue?: boolean
    lastfatigueupdatetime?: boolean
    charismaexp?: boolean
    insightexp?: boolean
    willexp?: boolean
    craftexp?: boolean
    senseexp?: boolean
    charmexp?: boolean
    noncombatstatdaylimit?: boolean
    mcpoint?: boolean
    pvpexp?: boolean
    pvpgrade?: boolean
    pvppoint?: boolean
    pvpmodelevel?: boolean
    pvpmodetype?: boolean
    eventpoint?: boolean
    albaactivityid?: boolean
    albastarttime?: boolean
    albaduration?: boolean
    albaspecialreward?: boolean
    burning?: boolean
    charactercard?: boolean
    accountlastlogout?: boolean
    lastlogout?: boolean
    gachexp?: boolean
    honorexp?: boolean
    nextavailablefametime?: boolean
    node_shards?: boolean
    maxfriends?: boolean
  }, ExtArgs["result"]["characterstats"]>


  export type characterstatsSelectScalar = {
    id?: boolean
    characterid?: boolean
    characteridforlog?: boolean
    worldidforlog?: boolean
    name?: boolean
    gender?: boolean
    skin?: boolean
    face?: boolean
    hair?: boolean
    mixbasehaircolor?: boolean
    mixaddhaircolor?: boolean
    mixhairbaseprob?: boolean
    level?: boolean
    job?: boolean
    str?: boolean
    dex?: boolean
    inte?: boolean
    luk?: boolean
    hp?: boolean
    maxhp?: boolean
    mp?: boolean
    maxmp?: boolean
    ap?: boolean
    sp?: boolean
    exp?: boolean
    pop?: boolean
    money?: boolean
    wp?: boolean
    extendsp?: boolean
    posmap?: boolean
    portal?: boolean
    subjob?: boolean
    deffaceacc?: boolean
    fatigue?: boolean
    lastfatigueupdatetime?: boolean
    charismaexp?: boolean
    insightexp?: boolean
    willexp?: boolean
    craftexp?: boolean
    senseexp?: boolean
    charmexp?: boolean
    noncombatstatdaylimit?: boolean
    mcpoint?: boolean
    pvpexp?: boolean
    pvpgrade?: boolean
    pvppoint?: boolean
    pvpmodelevel?: boolean
    pvpmodetype?: boolean
    eventpoint?: boolean
    albaactivityid?: boolean
    albastarttime?: boolean
    albaduration?: boolean
    albaspecialreward?: boolean
    burning?: boolean
    charactercard?: boolean
    accountlastlogout?: boolean
    lastlogout?: boolean
    gachexp?: boolean
    honorexp?: boolean
    nextavailablefametime?: boolean
    node_shards?: boolean
    maxfriends?: boolean
  }


  export type $characterstatsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "characterstats"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      characterid: number | null
      characteridforlog: number | null
      worldidforlog: number | null
      name: string | null
      gender: number | null
      skin: number | null
      face: number | null
      hair: number | null
      mixbasehaircolor: number | null
      mixaddhaircolor: number | null
      mixhairbaseprob: number | null
      level: number | null
      job: number | null
      str: number | null
      dex: number | null
      inte: number | null
      luk: number | null
      hp: number | null
      maxhp: number | null
      mp: number | null
      maxmp: number | null
      ap: number | null
      sp: number | null
      exp: string | null
      pop: number | null
      money: string | null
      wp: number | null
      extendsp: number | null
      posmap: string | null
      portal: number | null
      subjob: number | null
      deffaceacc: number | null
      fatigue: number | null
      lastfatigueupdatetime: number | null
      charismaexp: number | null
      insightexp: number | null
      willexp: number | null
      craftexp: number | null
      senseexp: number | null
      charmexp: number | null
      noncombatstatdaylimit: number | null
      mcpoint: number | null
      pvpexp: number | null
      pvpgrade: number | null
      pvppoint: number | null
      pvpmodelevel: number | null
      pvpmodetype: number | null
      eventpoint: number | null
      albaactivityid: number | null
      albastarttime: Date | null
      albaduration: number | null
      albaspecialreward: number | null
      burning: boolean | null
      charactercard: number | null
      accountlastlogout: number | null
      lastlogout: Date | null
      gachexp: number | null
      honorexp: number | null
      nextavailablefametime: Date | null
      node_shards: number
      maxfriends: number
    }, ExtArgs["result"]["characterstats"]>
    composites: {}
  }

  type characterstatsGetPayload<S extends boolean | null | undefined | characterstatsDefaultArgs> = $Result.GetResult<Prisma.$characterstatsPayload, S>

  type characterstatsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<characterstatsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CharacterstatsCountAggregateInputType | true
    }

  export interface characterstatsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['characterstats'], meta: { name: 'characterstats' } }
    /**
     * Find zero or one Characterstats that matches the filter.
     * @param {characterstatsFindUniqueArgs} args - Arguments to find a Characterstats
     * @example
     * // Get one Characterstats
     * const characterstats = await prisma.characterstats.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends characterstatsFindUniqueArgs>(args: SelectSubset<T, characterstatsFindUniqueArgs<ExtArgs>>): Prisma__characterstatsClient<$Result.GetResult<Prisma.$characterstatsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Characterstats that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {characterstatsFindUniqueOrThrowArgs} args - Arguments to find a Characterstats
     * @example
     * // Get one Characterstats
     * const characterstats = await prisma.characterstats.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends characterstatsFindUniqueOrThrowArgs>(args: SelectSubset<T, characterstatsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__characterstatsClient<$Result.GetResult<Prisma.$characterstatsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Characterstats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {characterstatsFindFirstArgs} args - Arguments to find a Characterstats
     * @example
     * // Get one Characterstats
     * const characterstats = await prisma.characterstats.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends characterstatsFindFirstArgs>(args?: SelectSubset<T, characterstatsFindFirstArgs<ExtArgs>>): Prisma__characterstatsClient<$Result.GetResult<Prisma.$characterstatsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Characterstats that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {characterstatsFindFirstOrThrowArgs} args - Arguments to find a Characterstats
     * @example
     * // Get one Characterstats
     * const characterstats = await prisma.characterstats.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends characterstatsFindFirstOrThrowArgs>(args?: SelectSubset<T, characterstatsFindFirstOrThrowArgs<ExtArgs>>): Prisma__characterstatsClient<$Result.GetResult<Prisma.$characterstatsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Characterstats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {characterstatsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Characterstats
     * const characterstats = await prisma.characterstats.findMany()
     * 
     * // Get first 10 Characterstats
     * const characterstats = await prisma.characterstats.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const characterstatsWithIdOnly = await prisma.characterstats.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends characterstatsFindManyArgs>(args?: SelectSubset<T, characterstatsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$characterstatsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Characterstats.
     * @param {characterstatsCreateArgs} args - Arguments to create a Characterstats.
     * @example
     * // Create one Characterstats
     * const Characterstats = await prisma.characterstats.create({
     *   data: {
     *     // ... data to create a Characterstats
     *   }
     * })
     * 
     */
    create<T extends characterstatsCreateArgs>(args: SelectSubset<T, characterstatsCreateArgs<ExtArgs>>): Prisma__characterstatsClient<$Result.GetResult<Prisma.$characterstatsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Characterstats.
     * @param {characterstatsCreateManyArgs} args - Arguments to create many Characterstats.
     * @example
     * // Create many Characterstats
     * const characterstats = await prisma.characterstats.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends characterstatsCreateManyArgs>(args?: SelectSubset<T, characterstatsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Characterstats.
     * @param {characterstatsDeleteArgs} args - Arguments to delete one Characterstats.
     * @example
     * // Delete one Characterstats
     * const Characterstats = await prisma.characterstats.delete({
     *   where: {
     *     // ... filter to delete one Characterstats
     *   }
     * })
     * 
     */
    delete<T extends characterstatsDeleteArgs>(args: SelectSubset<T, characterstatsDeleteArgs<ExtArgs>>): Prisma__characterstatsClient<$Result.GetResult<Prisma.$characterstatsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Characterstats.
     * @param {characterstatsUpdateArgs} args - Arguments to update one Characterstats.
     * @example
     * // Update one Characterstats
     * const characterstats = await prisma.characterstats.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends characterstatsUpdateArgs>(args: SelectSubset<T, characterstatsUpdateArgs<ExtArgs>>): Prisma__characterstatsClient<$Result.GetResult<Prisma.$characterstatsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Characterstats.
     * @param {characterstatsDeleteManyArgs} args - Arguments to filter Characterstats to delete.
     * @example
     * // Delete a few Characterstats
     * const { count } = await prisma.characterstats.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends characterstatsDeleteManyArgs>(args?: SelectSubset<T, characterstatsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Characterstats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {characterstatsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Characterstats
     * const characterstats = await prisma.characterstats.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends characterstatsUpdateManyArgs>(args: SelectSubset<T, characterstatsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Characterstats.
     * @param {characterstatsUpsertArgs} args - Arguments to update or create a Characterstats.
     * @example
     * // Update or create a Characterstats
     * const characterstats = await prisma.characterstats.upsert({
     *   create: {
     *     // ... data to create a Characterstats
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Characterstats we want to update
     *   }
     * })
     */
    upsert<T extends characterstatsUpsertArgs>(args: SelectSubset<T, characterstatsUpsertArgs<ExtArgs>>): Prisma__characterstatsClient<$Result.GetResult<Prisma.$characterstatsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Characterstats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {characterstatsCountArgs} args - Arguments to filter Characterstats to count.
     * @example
     * // Count the number of Characterstats
     * const count = await prisma.characterstats.count({
     *   where: {
     *     // ... the filter for the Characterstats we want to count
     *   }
     * })
    **/
    count<T extends characterstatsCountArgs>(
      args?: Subset<T, characterstatsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CharacterstatsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Characterstats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterstatsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CharacterstatsAggregateArgs>(args: Subset<T, CharacterstatsAggregateArgs>): Prisma.PrismaPromise<GetCharacterstatsAggregateType<T>>

    /**
     * Group by Characterstats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {characterstatsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends characterstatsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: characterstatsGroupByArgs['orderBy'] }
        : { orderBy?: characterstatsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, characterstatsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCharacterstatsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the characterstats model
   */
  readonly fields: characterstatsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for characterstats.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__characterstatsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the characterstats model
   */ 
  interface characterstatsFieldRefs {
    readonly id: FieldRef<"characterstats", 'Int'>
    readonly characterid: FieldRef<"characterstats", 'Int'>
    readonly characteridforlog: FieldRef<"characterstats", 'Int'>
    readonly worldidforlog: FieldRef<"characterstats", 'Int'>
    readonly name: FieldRef<"characterstats", 'String'>
    readonly gender: FieldRef<"characterstats", 'Int'>
    readonly skin: FieldRef<"characterstats", 'Int'>
    readonly face: FieldRef<"characterstats", 'Int'>
    readonly hair: FieldRef<"characterstats", 'Int'>
    readonly mixbasehaircolor: FieldRef<"characterstats", 'Int'>
    readonly mixaddhaircolor: FieldRef<"characterstats", 'Int'>
    readonly mixhairbaseprob: FieldRef<"characterstats", 'Int'>
    readonly level: FieldRef<"characterstats", 'Int'>
    readonly job: FieldRef<"characterstats", 'Int'>
    readonly str: FieldRef<"characterstats", 'Int'>
    readonly dex: FieldRef<"characterstats", 'Int'>
    readonly inte: FieldRef<"characterstats", 'Int'>
    readonly luk: FieldRef<"characterstats", 'Int'>
    readonly hp: FieldRef<"characterstats", 'Int'>
    readonly maxhp: FieldRef<"characterstats", 'Int'>
    readonly mp: FieldRef<"characterstats", 'Int'>
    readonly maxmp: FieldRef<"characterstats", 'Int'>
    readonly ap: FieldRef<"characterstats", 'Int'>
    readonly sp: FieldRef<"characterstats", 'Int'>
    readonly exp: FieldRef<"characterstats", 'String'>
    readonly pop: FieldRef<"characterstats", 'Int'>
    readonly money: FieldRef<"characterstats", 'String'>
    readonly wp: FieldRef<"characterstats", 'Int'>
    readonly extendsp: FieldRef<"characterstats", 'Int'>
    readonly posmap: FieldRef<"characterstats", 'String'>
    readonly portal: FieldRef<"characterstats", 'Int'>
    readonly subjob: FieldRef<"characterstats", 'Int'>
    readonly deffaceacc: FieldRef<"characterstats", 'Int'>
    readonly fatigue: FieldRef<"characterstats", 'Int'>
    readonly lastfatigueupdatetime: FieldRef<"characterstats", 'Int'>
    readonly charismaexp: FieldRef<"characterstats", 'Int'>
    readonly insightexp: FieldRef<"characterstats", 'Int'>
    readonly willexp: FieldRef<"characterstats", 'Int'>
    readonly craftexp: FieldRef<"characterstats", 'Int'>
    readonly senseexp: FieldRef<"characterstats", 'Int'>
    readonly charmexp: FieldRef<"characterstats", 'Int'>
    readonly noncombatstatdaylimit: FieldRef<"characterstats", 'Int'>
    readonly mcpoint: FieldRef<"characterstats", 'Int'>
    readonly pvpexp: FieldRef<"characterstats", 'Int'>
    readonly pvpgrade: FieldRef<"characterstats", 'Int'>
    readonly pvppoint: FieldRef<"characterstats", 'Int'>
    readonly pvpmodelevel: FieldRef<"characterstats", 'Int'>
    readonly pvpmodetype: FieldRef<"characterstats", 'Int'>
    readonly eventpoint: FieldRef<"characterstats", 'Int'>
    readonly albaactivityid: FieldRef<"characterstats", 'Int'>
    readonly albastarttime: FieldRef<"characterstats", 'DateTime'>
    readonly albaduration: FieldRef<"characterstats", 'Int'>
    readonly albaspecialreward: FieldRef<"characterstats", 'Int'>
    readonly burning: FieldRef<"characterstats", 'Boolean'>
    readonly charactercard: FieldRef<"characterstats", 'Int'>
    readonly accountlastlogout: FieldRef<"characterstats", 'Int'>
    readonly lastlogout: FieldRef<"characterstats", 'DateTime'>
    readonly gachexp: FieldRef<"characterstats", 'Int'>
    readonly honorexp: FieldRef<"characterstats", 'Int'>
    readonly nextavailablefametime: FieldRef<"characterstats", 'DateTime'>
    readonly node_shards: FieldRef<"characterstats", 'Int'>
    readonly maxfriends: FieldRef<"characterstats", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * characterstats findUnique
   */
  export type characterstatsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the characterstats
     */
    select?: characterstatsSelect<ExtArgs> | null
    /**
     * Filter, which characterstats to fetch.
     */
    where: characterstatsWhereUniqueInput
  }

  /**
   * characterstats findUniqueOrThrow
   */
  export type characterstatsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the characterstats
     */
    select?: characterstatsSelect<ExtArgs> | null
    /**
     * Filter, which characterstats to fetch.
     */
    where: characterstatsWhereUniqueInput
  }

  /**
   * characterstats findFirst
   */
  export type characterstatsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the characterstats
     */
    select?: characterstatsSelect<ExtArgs> | null
    /**
     * Filter, which characterstats to fetch.
     */
    where?: characterstatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of characterstats to fetch.
     */
    orderBy?: characterstatsOrderByWithRelationInput | characterstatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for characterstats.
     */
    cursor?: characterstatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` characterstats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` characterstats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of characterstats.
     */
    distinct?: CharacterstatsScalarFieldEnum | CharacterstatsScalarFieldEnum[]
  }

  /**
   * characterstats findFirstOrThrow
   */
  export type characterstatsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the characterstats
     */
    select?: characterstatsSelect<ExtArgs> | null
    /**
     * Filter, which characterstats to fetch.
     */
    where?: characterstatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of characterstats to fetch.
     */
    orderBy?: characterstatsOrderByWithRelationInput | characterstatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for characterstats.
     */
    cursor?: characterstatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` characterstats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` characterstats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of characterstats.
     */
    distinct?: CharacterstatsScalarFieldEnum | CharacterstatsScalarFieldEnum[]
  }

  /**
   * characterstats findMany
   */
  export type characterstatsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the characterstats
     */
    select?: characterstatsSelect<ExtArgs> | null
    /**
     * Filter, which characterstats to fetch.
     */
    where?: characterstatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of characterstats to fetch.
     */
    orderBy?: characterstatsOrderByWithRelationInput | characterstatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing characterstats.
     */
    cursor?: characterstatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` characterstats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` characterstats.
     */
    skip?: number
    distinct?: CharacterstatsScalarFieldEnum | CharacterstatsScalarFieldEnum[]
  }

  /**
   * characterstats create
   */
  export type characterstatsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the characterstats
     */
    select?: characterstatsSelect<ExtArgs> | null
    /**
     * The data needed to create a characterstats.
     */
    data?: XOR<characterstatsCreateInput, characterstatsUncheckedCreateInput>
  }

  /**
   * characterstats createMany
   */
  export type characterstatsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many characterstats.
     */
    data: characterstatsCreateManyInput | characterstatsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * characterstats update
   */
  export type characterstatsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the characterstats
     */
    select?: characterstatsSelect<ExtArgs> | null
    /**
     * The data needed to update a characterstats.
     */
    data: XOR<characterstatsUpdateInput, characterstatsUncheckedUpdateInput>
    /**
     * Choose, which characterstats to update.
     */
    where: characterstatsWhereUniqueInput
  }

  /**
   * characterstats updateMany
   */
  export type characterstatsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update characterstats.
     */
    data: XOR<characterstatsUpdateManyMutationInput, characterstatsUncheckedUpdateManyInput>
    /**
     * Filter which characterstats to update
     */
    where?: characterstatsWhereInput
  }

  /**
   * characterstats upsert
   */
  export type characterstatsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the characterstats
     */
    select?: characterstatsSelect<ExtArgs> | null
    /**
     * The filter to search for the characterstats to update in case it exists.
     */
    where: characterstatsWhereUniqueInput
    /**
     * In case the characterstats found by the `where` argument doesn't exist, create a new characterstats with this data.
     */
    create: XOR<characterstatsCreateInput, characterstatsUncheckedCreateInput>
    /**
     * In case the characterstats was found with the provided `where` argument, update it with this data.
     */
    update: XOR<characterstatsUpdateInput, characterstatsUncheckedUpdateInput>
  }

  /**
   * characterstats delete
   */
  export type characterstatsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the characterstats
     */
    select?: characterstatsSelect<ExtArgs> | null
    /**
     * Filter which characterstats to delete.
     */
    where: characterstatsWhereUniqueInput
  }

  /**
   * characterstats deleteMany
   */
  export type characterstatsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which characterstats to delete
     */
    where?: characterstatsWhereInput
  }

  /**
   * characterstats without action
   */
  export type characterstatsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the characterstats
     */
    select?: characterstatsSelect<ExtArgs> | null
  }


  /**
   * Model chosenskills
   */

  export type AggregateChosenskills = {
    _count: ChosenskillsCountAggregateOutputType | null
    _avg: ChosenskillsAvgAggregateOutputType | null
    _sum: ChosenskillsSumAggregateOutputType | null
    _min: ChosenskillsMinAggregateOutputType | null
    _max: ChosenskillsMaxAggregateOutputType | null
  }

  export type ChosenskillsAvgAggregateOutputType = {
    id: number | null
    charid: number | null
    skillid: number | null
    position: number | null
  }

  export type ChosenskillsSumAggregateOutputType = {
    id: number | null
    charid: number | null
    skillid: number | null
    position: number | null
  }

  export type ChosenskillsMinAggregateOutputType = {
    id: number | null
    charid: number | null
    skillid: number | null
    position: number | null
  }

  export type ChosenskillsMaxAggregateOutputType = {
    id: number | null
    charid: number | null
    skillid: number | null
    position: number | null
  }

  export type ChosenskillsCountAggregateOutputType = {
    id: number
    charid: number
    skillid: number
    position: number
    _all: number
  }


  export type ChosenskillsAvgAggregateInputType = {
    id?: true
    charid?: true
    skillid?: true
    position?: true
  }

  export type ChosenskillsSumAggregateInputType = {
    id?: true
    charid?: true
    skillid?: true
    position?: true
  }

  export type ChosenskillsMinAggregateInputType = {
    id?: true
    charid?: true
    skillid?: true
    position?: true
  }

  export type ChosenskillsMaxAggregateInputType = {
    id?: true
    charid?: true
    skillid?: true
    position?: true
  }

  export type ChosenskillsCountAggregateInputType = {
    id?: true
    charid?: true
    skillid?: true
    position?: true
    _all?: true
  }

  export type ChosenskillsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chosenskills to aggregate.
     */
    where?: chosenskillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chosenskills to fetch.
     */
    orderBy?: chosenskillsOrderByWithRelationInput | chosenskillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: chosenskillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chosenskills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chosenskills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned chosenskills
    **/
    _count?: true | ChosenskillsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChosenskillsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChosenskillsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChosenskillsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChosenskillsMaxAggregateInputType
  }

  export type GetChosenskillsAggregateType<T extends ChosenskillsAggregateArgs> = {
        [P in keyof T & keyof AggregateChosenskills]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChosenskills[P]>
      : GetScalarType<T[P], AggregateChosenskills[P]>
  }




  export type chosenskillsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chosenskillsWhereInput
    orderBy?: chosenskillsOrderByWithAggregationInput | chosenskillsOrderByWithAggregationInput[]
    by: ChosenskillsScalarFieldEnum[] | ChosenskillsScalarFieldEnum
    having?: chosenskillsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChosenskillsCountAggregateInputType | true
    _avg?: ChosenskillsAvgAggregateInputType
    _sum?: ChosenskillsSumAggregateInputType
    _min?: ChosenskillsMinAggregateInputType
    _max?: ChosenskillsMaxAggregateInputType
  }

  export type ChosenskillsGroupByOutputType = {
    id: number
    charid: number | null
    skillid: number | null
    position: number | null
    _count: ChosenskillsCountAggregateOutputType | null
    _avg: ChosenskillsAvgAggregateOutputType | null
    _sum: ChosenskillsSumAggregateOutputType | null
    _min: ChosenskillsMinAggregateOutputType | null
    _max: ChosenskillsMaxAggregateOutputType | null
  }

  type GetChosenskillsGroupByPayload<T extends chosenskillsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChosenskillsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChosenskillsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChosenskillsGroupByOutputType[P]>
            : GetScalarType<T[P], ChosenskillsGroupByOutputType[P]>
        }
      >
    >


  export type chosenskillsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    charid?: boolean
    skillid?: boolean
    position?: boolean
  }, ExtArgs["result"]["chosenskills"]>


  export type chosenskillsSelectScalar = {
    id?: boolean
    charid?: boolean
    skillid?: boolean
    position?: boolean
  }


  export type $chosenskillsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "chosenskills"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      charid: number | null
      skillid: number | null
      position: number | null
    }, ExtArgs["result"]["chosenskills"]>
    composites: {}
  }

  type chosenskillsGetPayload<S extends boolean | null | undefined | chosenskillsDefaultArgs> = $Result.GetResult<Prisma.$chosenskillsPayload, S>

  type chosenskillsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<chosenskillsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChosenskillsCountAggregateInputType | true
    }

  export interface chosenskillsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['chosenskills'], meta: { name: 'chosenskills' } }
    /**
     * Find zero or one Chosenskills that matches the filter.
     * @param {chosenskillsFindUniqueArgs} args - Arguments to find a Chosenskills
     * @example
     * // Get one Chosenskills
     * const chosenskills = await prisma.chosenskills.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends chosenskillsFindUniqueArgs>(args: SelectSubset<T, chosenskillsFindUniqueArgs<ExtArgs>>): Prisma__chosenskillsClient<$Result.GetResult<Prisma.$chosenskillsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Chosenskills that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {chosenskillsFindUniqueOrThrowArgs} args - Arguments to find a Chosenskills
     * @example
     * // Get one Chosenskills
     * const chosenskills = await prisma.chosenskills.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends chosenskillsFindUniqueOrThrowArgs>(args: SelectSubset<T, chosenskillsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__chosenskillsClient<$Result.GetResult<Prisma.$chosenskillsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Chosenskills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chosenskillsFindFirstArgs} args - Arguments to find a Chosenskills
     * @example
     * // Get one Chosenskills
     * const chosenskills = await prisma.chosenskills.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends chosenskillsFindFirstArgs>(args?: SelectSubset<T, chosenskillsFindFirstArgs<ExtArgs>>): Prisma__chosenskillsClient<$Result.GetResult<Prisma.$chosenskillsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Chosenskills that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chosenskillsFindFirstOrThrowArgs} args - Arguments to find a Chosenskills
     * @example
     * // Get one Chosenskills
     * const chosenskills = await prisma.chosenskills.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends chosenskillsFindFirstOrThrowArgs>(args?: SelectSubset<T, chosenskillsFindFirstOrThrowArgs<ExtArgs>>): Prisma__chosenskillsClient<$Result.GetResult<Prisma.$chosenskillsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Chosenskills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chosenskillsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chosenskills
     * const chosenskills = await prisma.chosenskills.findMany()
     * 
     * // Get first 10 Chosenskills
     * const chosenskills = await prisma.chosenskills.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chosenskillsWithIdOnly = await prisma.chosenskills.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends chosenskillsFindManyArgs>(args?: SelectSubset<T, chosenskillsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chosenskillsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Chosenskills.
     * @param {chosenskillsCreateArgs} args - Arguments to create a Chosenskills.
     * @example
     * // Create one Chosenskills
     * const Chosenskills = await prisma.chosenskills.create({
     *   data: {
     *     // ... data to create a Chosenskills
     *   }
     * })
     * 
     */
    create<T extends chosenskillsCreateArgs>(args: SelectSubset<T, chosenskillsCreateArgs<ExtArgs>>): Prisma__chosenskillsClient<$Result.GetResult<Prisma.$chosenskillsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Chosenskills.
     * @param {chosenskillsCreateManyArgs} args - Arguments to create many Chosenskills.
     * @example
     * // Create many Chosenskills
     * const chosenskills = await prisma.chosenskills.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends chosenskillsCreateManyArgs>(args?: SelectSubset<T, chosenskillsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Chosenskills.
     * @param {chosenskillsDeleteArgs} args - Arguments to delete one Chosenskills.
     * @example
     * // Delete one Chosenskills
     * const Chosenskills = await prisma.chosenskills.delete({
     *   where: {
     *     // ... filter to delete one Chosenskills
     *   }
     * })
     * 
     */
    delete<T extends chosenskillsDeleteArgs>(args: SelectSubset<T, chosenskillsDeleteArgs<ExtArgs>>): Prisma__chosenskillsClient<$Result.GetResult<Prisma.$chosenskillsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Chosenskills.
     * @param {chosenskillsUpdateArgs} args - Arguments to update one Chosenskills.
     * @example
     * // Update one Chosenskills
     * const chosenskills = await prisma.chosenskills.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends chosenskillsUpdateArgs>(args: SelectSubset<T, chosenskillsUpdateArgs<ExtArgs>>): Prisma__chosenskillsClient<$Result.GetResult<Prisma.$chosenskillsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Chosenskills.
     * @param {chosenskillsDeleteManyArgs} args - Arguments to filter Chosenskills to delete.
     * @example
     * // Delete a few Chosenskills
     * const { count } = await prisma.chosenskills.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends chosenskillsDeleteManyArgs>(args?: SelectSubset<T, chosenskillsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chosenskills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chosenskillsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chosenskills
     * const chosenskills = await prisma.chosenskills.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends chosenskillsUpdateManyArgs>(args: SelectSubset<T, chosenskillsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Chosenskills.
     * @param {chosenskillsUpsertArgs} args - Arguments to update or create a Chosenskills.
     * @example
     * // Update or create a Chosenskills
     * const chosenskills = await prisma.chosenskills.upsert({
     *   create: {
     *     // ... data to create a Chosenskills
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chosenskills we want to update
     *   }
     * })
     */
    upsert<T extends chosenskillsUpsertArgs>(args: SelectSubset<T, chosenskillsUpsertArgs<ExtArgs>>): Prisma__chosenskillsClient<$Result.GetResult<Prisma.$chosenskillsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Chosenskills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chosenskillsCountArgs} args - Arguments to filter Chosenskills to count.
     * @example
     * // Count the number of Chosenskills
     * const count = await prisma.chosenskills.count({
     *   where: {
     *     // ... the filter for the Chosenskills we want to count
     *   }
     * })
    **/
    count<T extends chosenskillsCountArgs>(
      args?: Subset<T, chosenskillsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChosenskillsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chosenskills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChosenskillsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChosenskillsAggregateArgs>(args: Subset<T, ChosenskillsAggregateArgs>): Prisma.PrismaPromise<GetChosenskillsAggregateType<T>>

    /**
     * Group by Chosenskills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chosenskillsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends chosenskillsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: chosenskillsGroupByArgs['orderBy'] }
        : { orderBy?: chosenskillsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, chosenskillsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChosenskillsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the chosenskills model
   */
  readonly fields: chosenskillsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for chosenskills.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__chosenskillsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the chosenskills model
   */ 
  interface chosenskillsFieldRefs {
    readonly id: FieldRef<"chosenskills", 'Int'>
    readonly charid: FieldRef<"chosenskills", 'Int'>
    readonly skillid: FieldRef<"chosenskills", 'Int'>
    readonly position: FieldRef<"chosenskills", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * chosenskills findUnique
   */
  export type chosenskillsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chosenskills
     */
    select?: chosenskillsSelect<ExtArgs> | null
    /**
     * Filter, which chosenskills to fetch.
     */
    where: chosenskillsWhereUniqueInput
  }

  /**
   * chosenskills findUniqueOrThrow
   */
  export type chosenskillsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chosenskills
     */
    select?: chosenskillsSelect<ExtArgs> | null
    /**
     * Filter, which chosenskills to fetch.
     */
    where: chosenskillsWhereUniqueInput
  }

  /**
   * chosenskills findFirst
   */
  export type chosenskillsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chosenskills
     */
    select?: chosenskillsSelect<ExtArgs> | null
    /**
     * Filter, which chosenskills to fetch.
     */
    where?: chosenskillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chosenskills to fetch.
     */
    orderBy?: chosenskillsOrderByWithRelationInput | chosenskillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chosenskills.
     */
    cursor?: chosenskillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chosenskills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chosenskills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chosenskills.
     */
    distinct?: ChosenskillsScalarFieldEnum | ChosenskillsScalarFieldEnum[]
  }

  /**
   * chosenskills findFirstOrThrow
   */
  export type chosenskillsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chosenskills
     */
    select?: chosenskillsSelect<ExtArgs> | null
    /**
     * Filter, which chosenskills to fetch.
     */
    where?: chosenskillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chosenskills to fetch.
     */
    orderBy?: chosenskillsOrderByWithRelationInput | chosenskillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chosenskills.
     */
    cursor?: chosenskillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chosenskills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chosenskills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chosenskills.
     */
    distinct?: ChosenskillsScalarFieldEnum | ChosenskillsScalarFieldEnum[]
  }

  /**
   * chosenskills findMany
   */
  export type chosenskillsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chosenskills
     */
    select?: chosenskillsSelect<ExtArgs> | null
    /**
     * Filter, which chosenskills to fetch.
     */
    where?: chosenskillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chosenskills to fetch.
     */
    orderBy?: chosenskillsOrderByWithRelationInput | chosenskillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing chosenskills.
     */
    cursor?: chosenskillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chosenskills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chosenskills.
     */
    skip?: number
    distinct?: ChosenskillsScalarFieldEnum | ChosenskillsScalarFieldEnum[]
  }

  /**
   * chosenskills create
   */
  export type chosenskillsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chosenskills
     */
    select?: chosenskillsSelect<ExtArgs> | null
    /**
     * The data needed to create a chosenskills.
     */
    data?: XOR<chosenskillsCreateInput, chosenskillsUncheckedCreateInput>
  }

  /**
   * chosenskills createMany
   */
  export type chosenskillsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many chosenskills.
     */
    data: chosenskillsCreateManyInput | chosenskillsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * chosenskills update
   */
  export type chosenskillsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chosenskills
     */
    select?: chosenskillsSelect<ExtArgs> | null
    /**
     * The data needed to update a chosenskills.
     */
    data: XOR<chosenskillsUpdateInput, chosenskillsUncheckedUpdateInput>
    /**
     * Choose, which chosenskills to update.
     */
    where: chosenskillsWhereUniqueInput
  }

  /**
   * chosenskills updateMany
   */
  export type chosenskillsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update chosenskills.
     */
    data: XOR<chosenskillsUpdateManyMutationInput, chosenskillsUncheckedUpdateManyInput>
    /**
     * Filter which chosenskills to update
     */
    where?: chosenskillsWhereInput
  }

  /**
   * chosenskills upsert
   */
  export type chosenskillsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chosenskills
     */
    select?: chosenskillsSelect<ExtArgs> | null
    /**
     * The filter to search for the chosenskills to update in case it exists.
     */
    where: chosenskillsWhereUniqueInput
    /**
     * In case the chosenskills found by the `where` argument doesn't exist, create a new chosenskills with this data.
     */
    create: XOR<chosenskillsCreateInput, chosenskillsUncheckedCreateInput>
    /**
     * In case the chosenskills was found with the provided `where` argument, update it with this data.
     */
    update: XOR<chosenskillsUpdateInput, chosenskillsUncheckedUpdateInput>
  }

  /**
   * chosenskills delete
   */
  export type chosenskillsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chosenskills
     */
    select?: chosenskillsSelect<ExtArgs> | null
    /**
     * Filter which chosenskills to delete.
     */
    where: chosenskillsWhereUniqueInput
  }

  /**
   * chosenskills deleteMany
   */
  export type chosenskillsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chosenskills to delete
     */
    where?: chosenskillsWhereInput
  }

  /**
   * chosenskills without action
   */
  export type chosenskillsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chosenskills
     */
    select?: chosenskillsSelect<ExtArgs> | null
  }


  /**
   * Model cms_votes
   */

  export type AggregateCms_votes = {
    _count: Cms_votesCountAggregateOutputType | null
    _avg: Cms_votesAvgAggregateOutputType | null
    _sum: Cms_votesSumAggregateOutputType | null
    _min: Cms_votesMinAggregateOutputType | null
    _max: Cms_votesMaxAggregateOutputType | null
  }

  export type Cms_votesAvgAggregateOutputType = {
    id: number | null
    accountid: number | null
    vp: number | null
    collected: number | null
  }

  export type Cms_votesSumAggregateOutputType = {
    id: number | null
    accountid: number | null
    vp: number | null
    collected: number | null
  }

  export type Cms_votesMinAggregateOutputType = {
    id: number | null
    accountid: number | null
    ip: string | null
    time: Date | null
    vp: number | null
    collected: number | null
  }

  export type Cms_votesMaxAggregateOutputType = {
    id: number | null
    accountid: number | null
    ip: string | null
    time: Date | null
    vp: number | null
    collected: number | null
  }

  export type Cms_votesCountAggregateOutputType = {
    id: number
    accountid: number
    ip: number
    time: number
    vp: number
    collected: number
    _all: number
  }


  export type Cms_votesAvgAggregateInputType = {
    id?: true
    accountid?: true
    vp?: true
    collected?: true
  }

  export type Cms_votesSumAggregateInputType = {
    id?: true
    accountid?: true
    vp?: true
    collected?: true
  }

  export type Cms_votesMinAggregateInputType = {
    id?: true
    accountid?: true
    ip?: true
    time?: true
    vp?: true
    collected?: true
  }

  export type Cms_votesMaxAggregateInputType = {
    id?: true
    accountid?: true
    ip?: true
    time?: true
    vp?: true
    collected?: true
  }

  export type Cms_votesCountAggregateInputType = {
    id?: true
    accountid?: true
    ip?: true
    time?: true
    vp?: true
    collected?: true
    _all?: true
  }

  export type Cms_votesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cms_votes to aggregate.
     */
    where?: cms_votesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cms_votes to fetch.
     */
    orderBy?: cms_votesOrderByWithRelationInput | cms_votesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: cms_votesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cms_votes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cms_votes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cms_votes
    **/
    _count?: true | Cms_votesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Cms_votesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Cms_votesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Cms_votesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Cms_votesMaxAggregateInputType
  }

  export type GetCms_votesAggregateType<T extends Cms_votesAggregateArgs> = {
        [P in keyof T & keyof AggregateCms_votes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCms_votes[P]>
      : GetScalarType<T[P], AggregateCms_votes[P]>
  }




  export type cms_votesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cms_votesWhereInput
    orderBy?: cms_votesOrderByWithAggregationInput | cms_votesOrderByWithAggregationInput[]
    by: Cms_votesScalarFieldEnum[] | Cms_votesScalarFieldEnum
    having?: cms_votesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Cms_votesCountAggregateInputType | true
    _avg?: Cms_votesAvgAggregateInputType
    _sum?: Cms_votesSumAggregateInputType
    _min?: Cms_votesMinAggregateInputType
    _max?: Cms_votesMaxAggregateInputType
  }

  export type Cms_votesGroupByOutputType = {
    id: number
    accountid: number
    ip: string
    time: Date
    vp: number
    collected: number
    _count: Cms_votesCountAggregateOutputType | null
    _avg: Cms_votesAvgAggregateOutputType | null
    _sum: Cms_votesSumAggregateOutputType | null
    _min: Cms_votesMinAggregateOutputType | null
    _max: Cms_votesMaxAggregateOutputType | null
  }

  type GetCms_votesGroupByPayload<T extends cms_votesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Cms_votesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Cms_votesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Cms_votesGroupByOutputType[P]>
            : GetScalarType<T[P], Cms_votesGroupByOutputType[P]>
        }
      >
    >


  export type cms_votesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountid?: boolean
    ip?: boolean
    time?: boolean
    vp?: boolean
    collected?: boolean
  }, ExtArgs["result"]["cms_votes"]>


  export type cms_votesSelectScalar = {
    id?: boolean
    accountid?: boolean
    ip?: boolean
    time?: boolean
    vp?: boolean
    collected?: boolean
  }


  export type $cms_votesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "cms_votes"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      accountid: number
      ip: string
      time: Date
      vp: number
      collected: number
    }, ExtArgs["result"]["cms_votes"]>
    composites: {}
  }

  type cms_votesGetPayload<S extends boolean | null | undefined | cms_votesDefaultArgs> = $Result.GetResult<Prisma.$cms_votesPayload, S>

  type cms_votesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<cms_votesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Cms_votesCountAggregateInputType | true
    }

  export interface cms_votesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['cms_votes'], meta: { name: 'cms_votes' } }
    /**
     * Find zero or one Cms_votes that matches the filter.
     * @param {cms_votesFindUniqueArgs} args - Arguments to find a Cms_votes
     * @example
     * // Get one Cms_votes
     * const cms_votes = await prisma.cms_votes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends cms_votesFindUniqueArgs>(args: SelectSubset<T, cms_votesFindUniqueArgs<ExtArgs>>): Prisma__cms_votesClient<$Result.GetResult<Prisma.$cms_votesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Cms_votes that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {cms_votesFindUniqueOrThrowArgs} args - Arguments to find a Cms_votes
     * @example
     * // Get one Cms_votes
     * const cms_votes = await prisma.cms_votes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends cms_votesFindUniqueOrThrowArgs>(args: SelectSubset<T, cms_votesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__cms_votesClient<$Result.GetResult<Prisma.$cms_votesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Cms_votes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cms_votesFindFirstArgs} args - Arguments to find a Cms_votes
     * @example
     * // Get one Cms_votes
     * const cms_votes = await prisma.cms_votes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends cms_votesFindFirstArgs>(args?: SelectSubset<T, cms_votesFindFirstArgs<ExtArgs>>): Prisma__cms_votesClient<$Result.GetResult<Prisma.$cms_votesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Cms_votes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cms_votesFindFirstOrThrowArgs} args - Arguments to find a Cms_votes
     * @example
     * // Get one Cms_votes
     * const cms_votes = await prisma.cms_votes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends cms_votesFindFirstOrThrowArgs>(args?: SelectSubset<T, cms_votesFindFirstOrThrowArgs<ExtArgs>>): Prisma__cms_votesClient<$Result.GetResult<Prisma.$cms_votesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Cms_votes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cms_votesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cms_votes
     * const cms_votes = await prisma.cms_votes.findMany()
     * 
     * // Get first 10 Cms_votes
     * const cms_votes = await prisma.cms_votes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cms_votesWithIdOnly = await prisma.cms_votes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends cms_votesFindManyArgs>(args?: SelectSubset<T, cms_votesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cms_votesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Cms_votes.
     * @param {cms_votesCreateArgs} args - Arguments to create a Cms_votes.
     * @example
     * // Create one Cms_votes
     * const Cms_votes = await prisma.cms_votes.create({
     *   data: {
     *     // ... data to create a Cms_votes
     *   }
     * })
     * 
     */
    create<T extends cms_votesCreateArgs>(args: SelectSubset<T, cms_votesCreateArgs<ExtArgs>>): Prisma__cms_votesClient<$Result.GetResult<Prisma.$cms_votesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Cms_votes.
     * @param {cms_votesCreateManyArgs} args - Arguments to create many Cms_votes.
     * @example
     * // Create many Cms_votes
     * const cms_votes = await prisma.cms_votes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends cms_votesCreateManyArgs>(args?: SelectSubset<T, cms_votesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Cms_votes.
     * @param {cms_votesDeleteArgs} args - Arguments to delete one Cms_votes.
     * @example
     * // Delete one Cms_votes
     * const Cms_votes = await prisma.cms_votes.delete({
     *   where: {
     *     // ... filter to delete one Cms_votes
     *   }
     * })
     * 
     */
    delete<T extends cms_votesDeleteArgs>(args: SelectSubset<T, cms_votesDeleteArgs<ExtArgs>>): Prisma__cms_votesClient<$Result.GetResult<Prisma.$cms_votesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Cms_votes.
     * @param {cms_votesUpdateArgs} args - Arguments to update one Cms_votes.
     * @example
     * // Update one Cms_votes
     * const cms_votes = await prisma.cms_votes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends cms_votesUpdateArgs>(args: SelectSubset<T, cms_votesUpdateArgs<ExtArgs>>): Prisma__cms_votesClient<$Result.GetResult<Prisma.$cms_votesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Cms_votes.
     * @param {cms_votesDeleteManyArgs} args - Arguments to filter Cms_votes to delete.
     * @example
     * // Delete a few Cms_votes
     * const { count } = await prisma.cms_votes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends cms_votesDeleteManyArgs>(args?: SelectSubset<T, cms_votesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cms_votes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cms_votesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cms_votes
     * const cms_votes = await prisma.cms_votes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends cms_votesUpdateManyArgs>(args: SelectSubset<T, cms_votesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cms_votes.
     * @param {cms_votesUpsertArgs} args - Arguments to update or create a Cms_votes.
     * @example
     * // Update or create a Cms_votes
     * const cms_votes = await prisma.cms_votes.upsert({
     *   create: {
     *     // ... data to create a Cms_votes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cms_votes we want to update
     *   }
     * })
     */
    upsert<T extends cms_votesUpsertArgs>(args: SelectSubset<T, cms_votesUpsertArgs<ExtArgs>>): Prisma__cms_votesClient<$Result.GetResult<Prisma.$cms_votesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Cms_votes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cms_votesCountArgs} args - Arguments to filter Cms_votes to count.
     * @example
     * // Count the number of Cms_votes
     * const count = await prisma.cms_votes.count({
     *   where: {
     *     // ... the filter for the Cms_votes we want to count
     *   }
     * })
    **/
    count<T extends cms_votesCountArgs>(
      args?: Subset<T, cms_votesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Cms_votesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cms_votes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Cms_votesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Cms_votesAggregateArgs>(args: Subset<T, Cms_votesAggregateArgs>): Prisma.PrismaPromise<GetCms_votesAggregateType<T>>

    /**
     * Group by Cms_votes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cms_votesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends cms_votesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: cms_votesGroupByArgs['orderBy'] }
        : { orderBy?: cms_votesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, cms_votesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCms_votesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the cms_votes model
   */
  readonly fields: cms_votesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for cms_votes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__cms_votesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the cms_votes model
   */ 
  interface cms_votesFieldRefs {
    readonly id: FieldRef<"cms_votes", 'Int'>
    readonly accountid: FieldRef<"cms_votes", 'Int'>
    readonly ip: FieldRef<"cms_votes", 'String'>
    readonly time: FieldRef<"cms_votes", 'DateTime'>
    readonly vp: FieldRef<"cms_votes", 'Int'>
    readonly collected: FieldRef<"cms_votes", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * cms_votes findUnique
   */
  export type cms_votesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cms_votes
     */
    select?: cms_votesSelect<ExtArgs> | null
    /**
     * Filter, which cms_votes to fetch.
     */
    where: cms_votesWhereUniqueInput
  }

  /**
   * cms_votes findUniqueOrThrow
   */
  export type cms_votesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cms_votes
     */
    select?: cms_votesSelect<ExtArgs> | null
    /**
     * Filter, which cms_votes to fetch.
     */
    where: cms_votesWhereUniqueInput
  }

  /**
   * cms_votes findFirst
   */
  export type cms_votesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cms_votes
     */
    select?: cms_votesSelect<ExtArgs> | null
    /**
     * Filter, which cms_votes to fetch.
     */
    where?: cms_votesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cms_votes to fetch.
     */
    orderBy?: cms_votesOrderByWithRelationInput | cms_votesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cms_votes.
     */
    cursor?: cms_votesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cms_votes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cms_votes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cms_votes.
     */
    distinct?: Cms_votesScalarFieldEnum | Cms_votesScalarFieldEnum[]
  }

  /**
   * cms_votes findFirstOrThrow
   */
  export type cms_votesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cms_votes
     */
    select?: cms_votesSelect<ExtArgs> | null
    /**
     * Filter, which cms_votes to fetch.
     */
    where?: cms_votesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cms_votes to fetch.
     */
    orderBy?: cms_votesOrderByWithRelationInput | cms_votesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cms_votes.
     */
    cursor?: cms_votesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cms_votes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cms_votes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cms_votes.
     */
    distinct?: Cms_votesScalarFieldEnum | Cms_votesScalarFieldEnum[]
  }

  /**
   * cms_votes findMany
   */
  export type cms_votesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cms_votes
     */
    select?: cms_votesSelect<ExtArgs> | null
    /**
     * Filter, which cms_votes to fetch.
     */
    where?: cms_votesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cms_votes to fetch.
     */
    orderBy?: cms_votesOrderByWithRelationInput | cms_votesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cms_votes.
     */
    cursor?: cms_votesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cms_votes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cms_votes.
     */
    skip?: number
    distinct?: Cms_votesScalarFieldEnum | Cms_votesScalarFieldEnum[]
  }

  /**
   * cms_votes create
   */
  export type cms_votesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cms_votes
     */
    select?: cms_votesSelect<ExtArgs> | null
    /**
     * The data needed to create a cms_votes.
     */
    data: XOR<cms_votesCreateInput, cms_votesUncheckedCreateInput>
  }

  /**
   * cms_votes createMany
   */
  export type cms_votesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many cms_votes.
     */
    data: cms_votesCreateManyInput | cms_votesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * cms_votes update
   */
  export type cms_votesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cms_votes
     */
    select?: cms_votesSelect<ExtArgs> | null
    /**
     * The data needed to update a cms_votes.
     */
    data: XOR<cms_votesUpdateInput, cms_votesUncheckedUpdateInput>
    /**
     * Choose, which cms_votes to update.
     */
    where: cms_votesWhereUniqueInput
  }

  /**
   * cms_votes updateMany
   */
  export type cms_votesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update cms_votes.
     */
    data: XOR<cms_votesUpdateManyMutationInput, cms_votesUncheckedUpdateManyInput>
    /**
     * Filter which cms_votes to update
     */
    where?: cms_votesWhereInput
  }

  /**
   * cms_votes upsert
   */
  export type cms_votesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cms_votes
     */
    select?: cms_votesSelect<ExtArgs> | null
    /**
     * The filter to search for the cms_votes to update in case it exists.
     */
    where: cms_votesWhereUniqueInput
    /**
     * In case the cms_votes found by the `where` argument doesn't exist, create a new cms_votes with this data.
     */
    create: XOR<cms_votesCreateInput, cms_votesUncheckedCreateInput>
    /**
     * In case the cms_votes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<cms_votesUpdateInput, cms_votesUncheckedUpdateInput>
  }

  /**
   * cms_votes delete
   */
  export type cms_votesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cms_votes
     */
    select?: cms_votesSelect<ExtArgs> | null
    /**
     * Filter which cms_votes to delete.
     */
    where: cms_votesWhereUniqueInput
  }

  /**
   * cms_votes deleteMany
   */
  export type cms_votesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cms_votes to delete
     */
    where?: cms_votesWhereInput
  }

  /**
   * cms_votes without action
   */
  export type cms_votesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cms_votes
     */
    select?: cms_votesSelect<ExtArgs> | null
  }


  /**
   * Model cooldowns
   */

  export type AggregateCooldowns = {
    _count: CooldownsCountAggregateOutputType | null
    _avg: CooldownsAvgAggregateOutputType | null
    _sum: CooldownsSumAggregateOutputType | null
    _min: CooldownsMinAggregateOutputType | null
    _max: CooldownsMaxAggregateOutputType | null
  }

  export type CooldownsAvgAggregateOutputType = {
    id: number | null
    cooldown_type: number | null
  }

  export type CooldownsSumAggregateOutputType = {
    id: number | null
    cooldown_type: number | null
  }

  export type CooldownsMinAggregateOutputType = {
    id: number | null
    player_name: string | null
    cooldown_type: number | null
    expiry_time: Date | null
  }

  export type CooldownsMaxAggregateOutputType = {
    id: number | null
    player_name: string | null
    cooldown_type: number | null
    expiry_time: Date | null
  }

  export type CooldownsCountAggregateOutputType = {
    id: number
    player_name: number
    cooldown_type: number
    expiry_time: number
    _all: number
  }


  export type CooldownsAvgAggregateInputType = {
    id?: true
    cooldown_type?: true
  }

  export type CooldownsSumAggregateInputType = {
    id?: true
    cooldown_type?: true
  }

  export type CooldownsMinAggregateInputType = {
    id?: true
    player_name?: true
    cooldown_type?: true
    expiry_time?: true
  }

  export type CooldownsMaxAggregateInputType = {
    id?: true
    player_name?: true
    cooldown_type?: true
    expiry_time?: true
  }

  export type CooldownsCountAggregateInputType = {
    id?: true
    player_name?: true
    cooldown_type?: true
    expiry_time?: true
    _all?: true
  }

  export type CooldownsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cooldowns to aggregate.
     */
    where?: cooldownsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cooldowns to fetch.
     */
    orderBy?: cooldownsOrderByWithRelationInput | cooldownsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: cooldownsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cooldowns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cooldowns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cooldowns
    **/
    _count?: true | CooldownsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CooldownsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CooldownsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CooldownsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CooldownsMaxAggregateInputType
  }

  export type GetCooldownsAggregateType<T extends CooldownsAggregateArgs> = {
        [P in keyof T & keyof AggregateCooldowns]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCooldowns[P]>
      : GetScalarType<T[P], AggregateCooldowns[P]>
  }




  export type cooldownsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cooldownsWhereInput
    orderBy?: cooldownsOrderByWithAggregationInput | cooldownsOrderByWithAggregationInput[]
    by: CooldownsScalarFieldEnum[] | CooldownsScalarFieldEnum
    having?: cooldownsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CooldownsCountAggregateInputType | true
    _avg?: CooldownsAvgAggregateInputType
    _sum?: CooldownsSumAggregateInputType
    _min?: CooldownsMinAggregateInputType
    _max?: CooldownsMaxAggregateInputType
  }

  export type CooldownsGroupByOutputType = {
    id: number
    player_name: string
    cooldown_type: number
    expiry_time: Date
    _count: CooldownsCountAggregateOutputType | null
    _avg: CooldownsAvgAggregateOutputType | null
    _sum: CooldownsSumAggregateOutputType | null
    _min: CooldownsMinAggregateOutputType | null
    _max: CooldownsMaxAggregateOutputType | null
  }

  type GetCooldownsGroupByPayload<T extends cooldownsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CooldownsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CooldownsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CooldownsGroupByOutputType[P]>
            : GetScalarType<T[P], CooldownsGroupByOutputType[P]>
        }
      >
    >


  export type cooldownsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    player_name?: boolean
    cooldown_type?: boolean
    expiry_time?: boolean
  }, ExtArgs["result"]["cooldowns"]>


  export type cooldownsSelectScalar = {
    id?: boolean
    player_name?: boolean
    cooldown_type?: boolean
    expiry_time?: boolean
  }


  export type $cooldownsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "cooldowns"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      player_name: string
      cooldown_type: number
      expiry_time: Date
    }, ExtArgs["result"]["cooldowns"]>
    composites: {}
  }

  type cooldownsGetPayload<S extends boolean | null | undefined | cooldownsDefaultArgs> = $Result.GetResult<Prisma.$cooldownsPayload, S>

  type cooldownsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<cooldownsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CooldownsCountAggregateInputType | true
    }

  export interface cooldownsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['cooldowns'], meta: { name: 'cooldowns' } }
    /**
     * Find zero or one Cooldowns that matches the filter.
     * @param {cooldownsFindUniqueArgs} args - Arguments to find a Cooldowns
     * @example
     * // Get one Cooldowns
     * const cooldowns = await prisma.cooldowns.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends cooldownsFindUniqueArgs>(args: SelectSubset<T, cooldownsFindUniqueArgs<ExtArgs>>): Prisma__cooldownsClient<$Result.GetResult<Prisma.$cooldownsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Cooldowns that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {cooldownsFindUniqueOrThrowArgs} args - Arguments to find a Cooldowns
     * @example
     * // Get one Cooldowns
     * const cooldowns = await prisma.cooldowns.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends cooldownsFindUniqueOrThrowArgs>(args: SelectSubset<T, cooldownsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__cooldownsClient<$Result.GetResult<Prisma.$cooldownsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Cooldowns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cooldownsFindFirstArgs} args - Arguments to find a Cooldowns
     * @example
     * // Get one Cooldowns
     * const cooldowns = await prisma.cooldowns.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends cooldownsFindFirstArgs>(args?: SelectSubset<T, cooldownsFindFirstArgs<ExtArgs>>): Prisma__cooldownsClient<$Result.GetResult<Prisma.$cooldownsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Cooldowns that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cooldownsFindFirstOrThrowArgs} args - Arguments to find a Cooldowns
     * @example
     * // Get one Cooldowns
     * const cooldowns = await prisma.cooldowns.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends cooldownsFindFirstOrThrowArgs>(args?: SelectSubset<T, cooldownsFindFirstOrThrowArgs<ExtArgs>>): Prisma__cooldownsClient<$Result.GetResult<Prisma.$cooldownsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Cooldowns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cooldownsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cooldowns
     * const cooldowns = await prisma.cooldowns.findMany()
     * 
     * // Get first 10 Cooldowns
     * const cooldowns = await prisma.cooldowns.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cooldownsWithIdOnly = await prisma.cooldowns.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends cooldownsFindManyArgs>(args?: SelectSubset<T, cooldownsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cooldownsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Cooldowns.
     * @param {cooldownsCreateArgs} args - Arguments to create a Cooldowns.
     * @example
     * // Create one Cooldowns
     * const Cooldowns = await prisma.cooldowns.create({
     *   data: {
     *     // ... data to create a Cooldowns
     *   }
     * })
     * 
     */
    create<T extends cooldownsCreateArgs>(args: SelectSubset<T, cooldownsCreateArgs<ExtArgs>>): Prisma__cooldownsClient<$Result.GetResult<Prisma.$cooldownsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Cooldowns.
     * @param {cooldownsCreateManyArgs} args - Arguments to create many Cooldowns.
     * @example
     * // Create many Cooldowns
     * const cooldowns = await prisma.cooldowns.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends cooldownsCreateManyArgs>(args?: SelectSubset<T, cooldownsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Cooldowns.
     * @param {cooldownsDeleteArgs} args - Arguments to delete one Cooldowns.
     * @example
     * // Delete one Cooldowns
     * const Cooldowns = await prisma.cooldowns.delete({
     *   where: {
     *     // ... filter to delete one Cooldowns
     *   }
     * })
     * 
     */
    delete<T extends cooldownsDeleteArgs>(args: SelectSubset<T, cooldownsDeleteArgs<ExtArgs>>): Prisma__cooldownsClient<$Result.GetResult<Prisma.$cooldownsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Cooldowns.
     * @param {cooldownsUpdateArgs} args - Arguments to update one Cooldowns.
     * @example
     * // Update one Cooldowns
     * const cooldowns = await prisma.cooldowns.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends cooldownsUpdateArgs>(args: SelectSubset<T, cooldownsUpdateArgs<ExtArgs>>): Prisma__cooldownsClient<$Result.GetResult<Prisma.$cooldownsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Cooldowns.
     * @param {cooldownsDeleteManyArgs} args - Arguments to filter Cooldowns to delete.
     * @example
     * // Delete a few Cooldowns
     * const { count } = await prisma.cooldowns.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends cooldownsDeleteManyArgs>(args?: SelectSubset<T, cooldownsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cooldowns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cooldownsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cooldowns
     * const cooldowns = await prisma.cooldowns.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends cooldownsUpdateManyArgs>(args: SelectSubset<T, cooldownsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cooldowns.
     * @param {cooldownsUpsertArgs} args - Arguments to update or create a Cooldowns.
     * @example
     * // Update or create a Cooldowns
     * const cooldowns = await prisma.cooldowns.upsert({
     *   create: {
     *     // ... data to create a Cooldowns
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cooldowns we want to update
     *   }
     * })
     */
    upsert<T extends cooldownsUpsertArgs>(args: SelectSubset<T, cooldownsUpsertArgs<ExtArgs>>): Prisma__cooldownsClient<$Result.GetResult<Prisma.$cooldownsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Cooldowns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cooldownsCountArgs} args - Arguments to filter Cooldowns to count.
     * @example
     * // Count the number of Cooldowns
     * const count = await prisma.cooldowns.count({
     *   where: {
     *     // ... the filter for the Cooldowns we want to count
     *   }
     * })
    **/
    count<T extends cooldownsCountArgs>(
      args?: Subset<T, cooldownsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CooldownsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cooldowns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CooldownsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CooldownsAggregateArgs>(args: Subset<T, CooldownsAggregateArgs>): Prisma.PrismaPromise<GetCooldownsAggregateType<T>>

    /**
     * Group by Cooldowns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cooldownsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends cooldownsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: cooldownsGroupByArgs['orderBy'] }
        : { orderBy?: cooldownsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, cooldownsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCooldownsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the cooldowns model
   */
  readonly fields: cooldownsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for cooldowns.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__cooldownsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the cooldowns model
   */ 
  interface cooldownsFieldRefs {
    readonly id: FieldRef<"cooldowns", 'Int'>
    readonly player_name: FieldRef<"cooldowns", 'String'>
    readonly cooldown_type: FieldRef<"cooldowns", 'Int'>
    readonly expiry_time: FieldRef<"cooldowns", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * cooldowns findUnique
   */
  export type cooldownsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cooldowns
     */
    select?: cooldownsSelect<ExtArgs> | null
    /**
     * Filter, which cooldowns to fetch.
     */
    where: cooldownsWhereUniqueInput
  }

  /**
   * cooldowns findUniqueOrThrow
   */
  export type cooldownsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cooldowns
     */
    select?: cooldownsSelect<ExtArgs> | null
    /**
     * Filter, which cooldowns to fetch.
     */
    where: cooldownsWhereUniqueInput
  }

  /**
   * cooldowns findFirst
   */
  export type cooldownsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cooldowns
     */
    select?: cooldownsSelect<ExtArgs> | null
    /**
     * Filter, which cooldowns to fetch.
     */
    where?: cooldownsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cooldowns to fetch.
     */
    orderBy?: cooldownsOrderByWithRelationInput | cooldownsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cooldowns.
     */
    cursor?: cooldownsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cooldowns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cooldowns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cooldowns.
     */
    distinct?: CooldownsScalarFieldEnum | CooldownsScalarFieldEnum[]
  }

  /**
   * cooldowns findFirstOrThrow
   */
  export type cooldownsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cooldowns
     */
    select?: cooldownsSelect<ExtArgs> | null
    /**
     * Filter, which cooldowns to fetch.
     */
    where?: cooldownsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cooldowns to fetch.
     */
    orderBy?: cooldownsOrderByWithRelationInput | cooldownsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cooldowns.
     */
    cursor?: cooldownsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cooldowns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cooldowns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cooldowns.
     */
    distinct?: CooldownsScalarFieldEnum | CooldownsScalarFieldEnum[]
  }

  /**
   * cooldowns findMany
   */
  export type cooldownsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cooldowns
     */
    select?: cooldownsSelect<ExtArgs> | null
    /**
     * Filter, which cooldowns to fetch.
     */
    where?: cooldownsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cooldowns to fetch.
     */
    orderBy?: cooldownsOrderByWithRelationInput | cooldownsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cooldowns.
     */
    cursor?: cooldownsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cooldowns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cooldowns.
     */
    skip?: number
    distinct?: CooldownsScalarFieldEnum | CooldownsScalarFieldEnum[]
  }

  /**
   * cooldowns create
   */
  export type cooldownsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cooldowns
     */
    select?: cooldownsSelect<ExtArgs> | null
    /**
     * The data needed to create a cooldowns.
     */
    data: XOR<cooldownsCreateInput, cooldownsUncheckedCreateInput>
  }

  /**
   * cooldowns createMany
   */
  export type cooldownsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many cooldowns.
     */
    data: cooldownsCreateManyInput | cooldownsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * cooldowns update
   */
  export type cooldownsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cooldowns
     */
    select?: cooldownsSelect<ExtArgs> | null
    /**
     * The data needed to update a cooldowns.
     */
    data: XOR<cooldownsUpdateInput, cooldownsUncheckedUpdateInput>
    /**
     * Choose, which cooldowns to update.
     */
    where: cooldownsWhereUniqueInput
  }

  /**
   * cooldowns updateMany
   */
  export type cooldownsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update cooldowns.
     */
    data: XOR<cooldownsUpdateManyMutationInput, cooldownsUncheckedUpdateManyInput>
    /**
     * Filter which cooldowns to update
     */
    where?: cooldownsWhereInput
  }

  /**
   * cooldowns upsert
   */
  export type cooldownsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cooldowns
     */
    select?: cooldownsSelect<ExtArgs> | null
    /**
     * The filter to search for the cooldowns to update in case it exists.
     */
    where: cooldownsWhereUniqueInput
    /**
     * In case the cooldowns found by the `where` argument doesn't exist, create a new cooldowns with this data.
     */
    create: XOR<cooldownsCreateInput, cooldownsUncheckedCreateInput>
    /**
     * In case the cooldowns was found with the provided `where` argument, update it with this data.
     */
    update: XOR<cooldownsUpdateInput, cooldownsUncheckedUpdateInput>
  }

  /**
   * cooldowns delete
   */
  export type cooldownsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cooldowns
     */
    select?: cooldownsSelect<ExtArgs> | null
    /**
     * Filter which cooldowns to delete.
     */
    where: cooldownsWhereUniqueInput
  }

  /**
   * cooldowns deleteMany
   */
  export type cooldownsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cooldowns to delete
     */
    where?: cooldownsWhereInput
  }

  /**
   * cooldowns without action
   */
  export type cooldownsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cooldowns
     */
    select?: cooldownsSelect<ExtArgs> | null
  }


  /**
   * Model cores
   */

  export type AggregateCores = {
    _count: CoresCountAggregateOutputType | null
    _avg: CoresAvgAggregateOutputType | null
    _sum: CoresSumAggregateOutputType | null
    _min: CoresMinAggregateOutputType | null
    _max: CoresMaxAggregateOutputType | null
  }

  export type CoresAvgAggregateOutputType = {
    id: number | null
    pos: number | null
    charid: number | null
    slottype: number | null
    coreid: number | null
    leftCount: number | null
  }

  export type CoresSumAggregateOutputType = {
    id: number | null
    pos: number | null
    charid: number | null
    slottype: number | null
    coreid: number | null
    leftCount: number | null
  }

  export type CoresMinAggregateOutputType = {
    id: number | null
    pos: number | null
    charid: number | null
    slottype: number | null
    coreid: number | null
    leftCount: number | null
  }

  export type CoresMaxAggregateOutputType = {
    id: number | null
    pos: number | null
    charid: number | null
    slottype: number | null
    coreid: number | null
    leftCount: number | null
  }

  export type CoresCountAggregateOutputType = {
    id: number
    pos: number
    charid: number
    slottype: number
    coreid: number
    leftCount: number
    _all: number
  }


  export type CoresAvgAggregateInputType = {
    id?: true
    pos?: true
    charid?: true
    slottype?: true
    coreid?: true
    leftCount?: true
  }

  export type CoresSumAggregateInputType = {
    id?: true
    pos?: true
    charid?: true
    slottype?: true
    coreid?: true
    leftCount?: true
  }

  export type CoresMinAggregateInputType = {
    id?: true
    pos?: true
    charid?: true
    slottype?: true
    coreid?: true
    leftCount?: true
  }

  export type CoresMaxAggregateInputType = {
    id?: true
    pos?: true
    charid?: true
    slottype?: true
    coreid?: true
    leftCount?: true
  }

  export type CoresCountAggregateInputType = {
    id?: true
    pos?: true
    charid?: true
    slottype?: true
    coreid?: true
    leftCount?: true
    _all?: true
  }

  export type CoresAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cores to aggregate.
     */
    where?: coresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cores to fetch.
     */
    orderBy?: coresOrderByWithRelationInput | coresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: coresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cores
    **/
    _count?: true | CoresCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CoresAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CoresSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CoresMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CoresMaxAggregateInputType
  }

  export type GetCoresAggregateType<T extends CoresAggregateArgs> = {
        [P in keyof T & keyof AggregateCores]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCores[P]>
      : GetScalarType<T[P], AggregateCores[P]>
  }




  export type coresGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: coresWhereInput
    orderBy?: coresOrderByWithAggregationInput | coresOrderByWithAggregationInput[]
    by: CoresScalarFieldEnum[] | CoresScalarFieldEnum
    having?: coresScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CoresCountAggregateInputType | true
    _avg?: CoresAvgAggregateInputType
    _sum?: CoresSumAggregateInputType
    _min?: CoresMinAggregateInputType
    _max?: CoresMaxAggregateInputType
  }

  export type CoresGroupByOutputType = {
    id: number
    pos: number | null
    charid: number | null
    slottype: number | null
    coreid: number | null
    leftCount: number | null
    _count: CoresCountAggregateOutputType | null
    _avg: CoresAvgAggregateOutputType | null
    _sum: CoresSumAggregateOutputType | null
    _min: CoresMinAggregateOutputType | null
    _max: CoresMaxAggregateOutputType | null
  }

  type GetCoresGroupByPayload<T extends coresGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CoresGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CoresGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CoresGroupByOutputType[P]>
            : GetScalarType<T[P], CoresGroupByOutputType[P]>
        }
      >
    >


  export type coresSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pos?: boolean
    charid?: boolean
    slottype?: boolean
    coreid?: boolean
    leftCount?: boolean
  }, ExtArgs["result"]["cores"]>


  export type coresSelectScalar = {
    id?: boolean
    pos?: boolean
    charid?: boolean
    slottype?: boolean
    coreid?: boolean
    leftCount?: boolean
  }


  export type $coresPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "cores"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      pos: number | null
      charid: number | null
      slottype: number | null
      coreid: number | null
      leftCount: number | null
    }, ExtArgs["result"]["cores"]>
    composites: {}
  }

  type coresGetPayload<S extends boolean | null | undefined | coresDefaultArgs> = $Result.GetResult<Prisma.$coresPayload, S>

  type coresCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<coresFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CoresCountAggregateInputType | true
    }

  export interface coresDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['cores'], meta: { name: 'cores' } }
    /**
     * Find zero or one Cores that matches the filter.
     * @param {coresFindUniqueArgs} args - Arguments to find a Cores
     * @example
     * // Get one Cores
     * const cores = await prisma.cores.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends coresFindUniqueArgs>(args: SelectSubset<T, coresFindUniqueArgs<ExtArgs>>): Prisma__coresClient<$Result.GetResult<Prisma.$coresPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Cores that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {coresFindUniqueOrThrowArgs} args - Arguments to find a Cores
     * @example
     * // Get one Cores
     * const cores = await prisma.cores.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends coresFindUniqueOrThrowArgs>(args: SelectSubset<T, coresFindUniqueOrThrowArgs<ExtArgs>>): Prisma__coresClient<$Result.GetResult<Prisma.$coresPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Cores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {coresFindFirstArgs} args - Arguments to find a Cores
     * @example
     * // Get one Cores
     * const cores = await prisma.cores.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends coresFindFirstArgs>(args?: SelectSubset<T, coresFindFirstArgs<ExtArgs>>): Prisma__coresClient<$Result.GetResult<Prisma.$coresPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Cores that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {coresFindFirstOrThrowArgs} args - Arguments to find a Cores
     * @example
     * // Get one Cores
     * const cores = await prisma.cores.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends coresFindFirstOrThrowArgs>(args?: SelectSubset<T, coresFindFirstOrThrowArgs<ExtArgs>>): Prisma__coresClient<$Result.GetResult<Prisma.$coresPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Cores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {coresFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cores
     * const cores = await prisma.cores.findMany()
     * 
     * // Get first 10 Cores
     * const cores = await prisma.cores.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const coresWithIdOnly = await prisma.cores.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends coresFindManyArgs>(args?: SelectSubset<T, coresFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$coresPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Cores.
     * @param {coresCreateArgs} args - Arguments to create a Cores.
     * @example
     * // Create one Cores
     * const Cores = await prisma.cores.create({
     *   data: {
     *     // ... data to create a Cores
     *   }
     * })
     * 
     */
    create<T extends coresCreateArgs>(args: SelectSubset<T, coresCreateArgs<ExtArgs>>): Prisma__coresClient<$Result.GetResult<Prisma.$coresPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Cores.
     * @param {coresCreateManyArgs} args - Arguments to create many Cores.
     * @example
     * // Create many Cores
     * const cores = await prisma.cores.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends coresCreateManyArgs>(args?: SelectSubset<T, coresCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Cores.
     * @param {coresDeleteArgs} args - Arguments to delete one Cores.
     * @example
     * // Delete one Cores
     * const Cores = await prisma.cores.delete({
     *   where: {
     *     // ... filter to delete one Cores
     *   }
     * })
     * 
     */
    delete<T extends coresDeleteArgs>(args: SelectSubset<T, coresDeleteArgs<ExtArgs>>): Prisma__coresClient<$Result.GetResult<Prisma.$coresPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Cores.
     * @param {coresUpdateArgs} args - Arguments to update one Cores.
     * @example
     * // Update one Cores
     * const cores = await prisma.cores.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends coresUpdateArgs>(args: SelectSubset<T, coresUpdateArgs<ExtArgs>>): Prisma__coresClient<$Result.GetResult<Prisma.$coresPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Cores.
     * @param {coresDeleteManyArgs} args - Arguments to filter Cores to delete.
     * @example
     * // Delete a few Cores
     * const { count } = await prisma.cores.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends coresDeleteManyArgs>(args?: SelectSubset<T, coresDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {coresUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cores
     * const cores = await prisma.cores.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends coresUpdateManyArgs>(args: SelectSubset<T, coresUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cores.
     * @param {coresUpsertArgs} args - Arguments to update or create a Cores.
     * @example
     * // Update or create a Cores
     * const cores = await prisma.cores.upsert({
     *   create: {
     *     // ... data to create a Cores
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cores we want to update
     *   }
     * })
     */
    upsert<T extends coresUpsertArgs>(args: SelectSubset<T, coresUpsertArgs<ExtArgs>>): Prisma__coresClient<$Result.GetResult<Prisma.$coresPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Cores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {coresCountArgs} args - Arguments to filter Cores to count.
     * @example
     * // Count the number of Cores
     * const count = await prisma.cores.count({
     *   where: {
     *     // ... the filter for the Cores we want to count
     *   }
     * })
    **/
    count<T extends coresCountArgs>(
      args?: Subset<T, coresCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CoresCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoresAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CoresAggregateArgs>(args: Subset<T, CoresAggregateArgs>): Prisma.PrismaPromise<GetCoresAggregateType<T>>

    /**
     * Group by Cores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {coresGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends coresGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: coresGroupByArgs['orderBy'] }
        : { orderBy?: coresGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, coresGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCoresGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the cores model
   */
  readonly fields: coresFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for cores.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__coresClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the cores model
   */ 
  interface coresFieldRefs {
    readonly id: FieldRef<"cores", 'Int'>
    readonly pos: FieldRef<"cores", 'Int'>
    readonly charid: FieldRef<"cores", 'Int'>
    readonly slottype: FieldRef<"cores", 'Int'>
    readonly coreid: FieldRef<"cores", 'Int'>
    readonly leftCount: FieldRef<"cores", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * cores findUnique
   */
  export type coresFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cores
     */
    select?: coresSelect<ExtArgs> | null
    /**
     * Filter, which cores to fetch.
     */
    where: coresWhereUniqueInput
  }

  /**
   * cores findUniqueOrThrow
   */
  export type coresFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cores
     */
    select?: coresSelect<ExtArgs> | null
    /**
     * Filter, which cores to fetch.
     */
    where: coresWhereUniqueInput
  }

  /**
   * cores findFirst
   */
  export type coresFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cores
     */
    select?: coresSelect<ExtArgs> | null
    /**
     * Filter, which cores to fetch.
     */
    where?: coresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cores to fetch.
     */
    orderBy?: coresOrderByWithRelationInput | coresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cores.
     */
    cursor?: coresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cores.
     */
    distinct?: CoresScalarFieldEnum | CoresScalarFieldEnum[]
  }

  /**
   * cores findFirstOrThrow
   */
  export type coresFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cores
     */
    select?: coresSelect<ExtArgs> | null
    /**
     * Filter, which cores to fetch.
     */
    where?: coresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cores to fetch.
     */
    orderBy?: coresOrderByWithRelationInput | coresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cores.
     */
    cursor?: coresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cores.
     */
    distinct?: CoresScalarFieldEnum | CoresScalarFieldEnum[]
  }

  /**
   * cores findMany
   */
  export type coresFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cores
     */
    select?: coresSelect<ExtArgs> | null
    /**
     * Filter, which cores to fetch.
     */
    where?: coresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cores to fetch.
     */
    orderBy?: coresOrderByWithRelationInput | coresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cores.
     */
    cursor?: coresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cores.
     */
    skip?: number
    distinct?: CoresScalarFieldEnum | CoresScalarFieldEnum[]
  }

  /**
   * cores create
   */
  export type coresCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cores
     */
    select?: coresSelect<ExtArgs> | null
    /**
     * The data needed to create a cores.
     */
    data?: XOR<coresCreateInput, coresUncheckedCreateInput>
  }

  /**
   * cores createMany
   */
  export type coresCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many cores.
     */
    data: coresCreateManyInput | coresCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * cores update
   */
  export type coresUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cores
     */
    select?: coresSelect<ExtArgs> | null
    /**
     * The data needed to update a cores.
     */
    data: XOR<coresUpdateInput, coresUncheckedUpdateInput>
    /**
     * Choose, which cores to update.
     */
    where: coresWhereUniqueInput
  }

  /**
   * cores updateMany
   */
  export type coresUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update cores.
     */
    data: XOR<coresUpdateManyMutationInput, coresUncheckedUpdateManyInput>
    /**
     * Filter which cores to update
     */
    where?: coresWhereInput
  }

  /**
   * cores upsert
   */
  export type coresUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cores
     */
    select?: coresSelect<ExtArgs> | null
    /**
     * The filter to search for the cores to update in case it exists.
     */
    where: coresWhereUniqueInput
    /**
     * In case the cores found by the `where` argument doesn't exist, create a new cores with this data.
     */
    create: XOR<coresCreateInput, coresUncheckedCreateInput>
    /**
     * In case the cores was found with the provided `where` argument, update it with this data.
     */
    update: XOR<coresUpdateInput, coresUncheckedUpdateInput>
  }

  /**
   * cores delete
   */
  export type coresDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cores
     */
    select?: coresSelect<ExtArgs> | null
    /**
     * Filter which cores to delete.
     */
    where: coresWhereUniqueInput
  }

  /**
   * cores deleteMany
   */
  export type coresDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cores to delete
     */
    where?: coresWhereInput
  }

  /**
   * cores without action
   */
  export type coresDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cores
     */
    select?: coresSelect<ExtArgs> | null
  }


  /**
   * Model cs_categories
   */

  export type AggregateCs_categories = {
    _count: Cs_categoriesCountAggregateOutputType | null
    _avg: Cs_categoriesAvgAggregateOutputType | null
    _sum: Cs_categoriesSumAggregateOutputType | null
    _min: Cs_categoriesMinAggregateOutputType | null
    _max: Cs_categoriesMaxAggregateOutputType | null
  }

  export type Cs_categoriesAvgAggregateOutputType = {
    id: number | null
    idx: number | null
    flag: number | null
    parentIdx: number | null
    stock: number | null
  }

  export type Cs_categoriesSumAggregateOutputType = {
    id: number | null
    idx: number | null
    flag: number | null
    parentIdx: number | null
    stock: number | null
  }

  export type Cs_categoriesMinAggregateOutputType = {
    id: number | null
    idx: number | null
    name: string | null
    flag: number | null
    parentIdx: number | null
    stock: number | null
  }

  export type Cs_categoriesMaxAggregateOutputType = {
    id: number | null
    idx: number | null
    name: string | null
    flag: number | null
    parentIdx: number | null
    stock: number | null
  }

  export type Cs_categoriesCountAggregateOutputType = {
    id: number
    idx: number
    name: number
    flag: number
    parentIdx: number
    stock: number
    _all: number
  }


  export type Cs_categoriesAvgAggregateInputType = {
    id?: true
    idx?: true
    flag?: true
    parentIdx?: true
    stock?: true
  }

  export type Cs_categoriesSumAggregateInputType = {
    id?: true
    idx?: true
    flag?: true
    parentIdx?: true
    stock?: true
  }

  export type Cs_categoriesMinAggregateInputType = {
    id?: true
    idx?: true
    name?: true
    flag?: true
    parentIdx?: true
    stock?: true
  }

  export type Cs_categoriesMaxAggregateInputType = {
    id?: true
    idx?: true
    name?: true
    flag?: true
    parentIdx?: true
    stock?: true
  }

  export type Cs_categoriesCountAggregateInputType = {
    id?: true
    idx?: true
    name?: true
    flag?: true
    parentIdx?: true
    stock?: true
    _all?: true
  }

  export type Cs_categoriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cs_categories to aggregate.
     */
    where?: cs_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cs_categories to fetch.
     */
    orderBy?: cs_categoriesOrderByWithRelationInput | cs_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: cs_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cs_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cs_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cs_categories
    **/
    _count?: true | Cs_categoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Cs_categoriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Cs_categoriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Cs_categoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Cs_categoriesMaxAggregateInputType
  }

  export type GetCs_categoriesAggregateType<T extends Cs_categoriesAggregateArgs> = {
        [P in keyof T & keyof AggregateCs_categories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCs_categories[P]>
      : GetScalarType<T[P], AggregateCs_categories[P]>
  }




  export type cs_categoriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cs_categoriesWhereInput
    orderBy?: cs_categoriesOrderByWithAggregationInput | cs_categoriesOrderByWithAggregationInput[]
    by: Cs_categoriesScalarFieldEnum[] | Cs_categoriesScalarFieldEnum
    having?: cs_categoriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Cs_categoriesCountAggregateInputType | true
    _avg?: Cs_categoriesAvgAggregateInputType
    _sum?: Cs_categoriesSumAggregateInputType
    _min?: Cs_categoriesMinAggregateInputType
    _max?: Cs_categoriesMaxAggregateInputType
  }

  export type Cs_categoriesGroupByOutputType = {
    id: number
    idx: number | null
    name: string | null
    flag: number | null
    parentIdx: number | null
    stock: number | null
    _count: Cs_categoriesCountAggregateOutputType | null
    _avg: Cs_categoriesAvgAggregateOutputType | null
    _sum: Cs_categoriesSumAggregateOutputType | null
    _min: Cs_categoriesMinAggregateOutputType | null
    _max: Cs_categoriesMaxAggregateOutputType | null
  }

  type GetCs_categoriesGroupByPayload<T extends cs_categoriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Cs_categoriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Cs_categoriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Cs_categoriesGroupByOutputType[P]>
            : GetScalarType<T[P], Cs_categoriesGroupByOutputType[P]>
        }
      >
    >


  export type cs_categoriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idx?: boolean
    name?: boolean
    flag?: boolean
    parentIdx?: boolean
    stock?: boolean
  }, ExtArgs["result"]["cs_categories"]>


  export type cs_categoriesSelectScalar = {
    id?: boolean
    idx?: boolean
    name?: boolean
    flag?: boolean
    parentIdx?: boolean
    stock?: boolean
  }


  export type $cs_categoriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "cs_categories"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      idx: number | null
      name: string | null
      flag: number | null
      parentIdx: number | null
      stock: number | null
    }, ExtArgs["result"]["cs_categories"]>
    composites: {}
  }

  type cs_categoriesGetPayload<S extends boolean | null | undefined | cs_categoriesDefaultArgs> = $Result.GetResult<Prisma.$cs_categoriesPayload, S>

  type cs_categoriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<cs_categoriesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Cs_categoriesCountAggregateInputType | true
    }

  export interface cs_categoriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['cs_categories'], meta: { name: 'cs_categories' } }
    /**
     * Find zero or one Cs_categories that matches the filter.
     * @param {cs_categoriesFindUniqueArgs} args - Arguments to find a Cs_categories
     * @example
     * // Get one Cs_categories
     * const cs_categories = await prisma.cs_categories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends cs_categoriesFindUniqueArgs>(args: SelectSubset<T, cs_categoriesFindUniqueArgs<ExtArgs>>): Prisma__cs_categoriesClient<$Result.GetResult<Prisma.$cs_categoriesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Cs_categories that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {cs_categoriesFindUniqueOrThrowArgs} args - Arguments to find a Cs_categories
     * @example
     * // Get one Cs_categories
     * const cs_categories = await prisma.cs_categories.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends cs_categoriesFindUniqueOrThrowArgs>(args: SelectSubset<T, cs_categoriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__cs_categoriesClient<$Result.GetResult<Prisma.$cs_categoriesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Cs_categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cs_categoriesFindFirstArgs} args - Arguments to find a Cs_categories
     * @example
     * // Get one Cs_categories
     * const cs_categories = await prisma.cs_categories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends cs_categoriesFindFirstArgs>(args?: SelectSubset<T, cs_categoriesFindFirstArgs<ExtArgs>>): Prisma__cs_categoriesClient<$Result.GetResult<Prisma.$cs_categoriesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Cs_categories that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cs_categoriesFindFirstOrThrowArgs} args - Arguments to find a Cs_categories
     * @example
     * // Get one Cs_categories
     * const cs_categories = await prisma.cs_categories.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends cs_categoriesFindFirstOrThrowArgs>(args?: SelectSubset<T, cs_categoriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__cs_categoriesClient<$Result.GetResult<Prisma.$cs_categoriesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Cs_categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cs_categoriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cs_categories
     * const cs_categories = await prisma.cs_categories.findMany()
     * 
     * // Get first 10 Cs_categories
     * const cs_categories = await prisma.cs_categories.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cs_categoriesWithIdOnly = await prisma.cs_categories.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends cs_categoriesFindManyArgs>(args?: SelectSubset<T, cs_categoriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cs_categoriesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Cs_categories.
     * @param {cs_categoriesCreateArgs} args - Arguments to create a Cs_categories.
     * @example
     * // Create one Cs_categories
     * const Cs_categories = await prisma.cs_categories.create({
     *   data: {
     *     // ... data to create a Cs_categories
     *   }
     * })
     * 
     */
    create<T extends cs_categoriesCreateArgs>(args: SelectSubset<T, cs_categoriesCreateArgs<ExtArgs>>): Prisma__cs_categoriesClient<$Result.GetResult<Prisma.$cs_categoriesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Cs_categories.
     * @param {cs_categoriesCreateManyArgs} args - Arguments to create many Cs_categories.
     * @example
     * // Create many Cs_categories
     * const cs_categories = await prisma.cs_categories.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends cs_categoriesCreateManyArgs>(args?: SelectSubset<T, cs_categoriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Cs_categories.
     * @param {cs_categoriesDeleteArgs} args - Arguments to delete one Cs_categories.
     * @example
     * // Delete one Cs_categories
     * const Cs_categories = await prisma.cs_categories.delete({
     *   where: {
     *     // ... filter to delete one Cs_categories
     *   }
     * })
     * 
     */
    delete<T extends cs_categoriesDeleteArgs>(args: SelectSubset<T, cs_categoriesDeleteArgs<ExtArgs>>): Prisma__cs_categoriesClient<$Result.GetResult<Prisma.$cs_categoriesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Cs_categories.
     * @param {cs_categoriesUpdateArgs} args - Arguments to update one Cs_categories.
     * @example
     * // Update one Cs_categories
     * const cs_categories = await prisma.cs_categories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends cs_categoriesUpdateArgs>(args: SelectSubset<T, cs_categoriesUpdateArgs<ExtArgs>>): Prisma__cs_categoriesClient<$Result.GetResult<Prisma.$cs_categoriesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Cs_categories.
     * @param {cs_categoriesDeleteManyArgs} args - Arguments to filter Cs_categories to delete.
     * @example
     * // Delete a few Cs_categories
     * const { count } = await prisma.cs_categories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends cs_categoriesDeleteManyArgs>(args?: SelectSubset<T, cs_categoriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cs_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cs_categoriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cs_categories
     * const cs_categories = await prisma.cs_categories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends cs_categoriesUpdateManyArgs>(args: SelectSubset<T, cs_categoriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cs_categories.
     * @param {cs_categoriesUpsertArgs} args - Arguments to update or create a Cs_categories.
     * @example
     * // Update or create a Cs_categories
     * const cs_categories = await prisma.cs_categories.upsert({
     *   create: {
     *     // ... data to create a Cs_categories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cs_categories we want to update
     *   }
     * })
     */
    upsert<T extends cs_categoriesUpsertArgs>(args: SelectSubset<T, cs_categoriesUpsertArgs<ExtArgs>>): Prisma__cs_categoriesClient<$Result.GetResult<Prisma.$cs_categoriesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Cs_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cs_categoriesCountArgs} args - Arguments to filter Cs_categories to count.
     * @example
     * // Count the number of Cs_categories
     * const count = await prisma.cs_categories.count({
     *   where: {
     *     // ... the filter for the Cs_categories we want to count
     *   }
     * })
    **/
    count<T extends cs_categoriesCountArgs>(
      args?: Subset<T, cs_categoriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Cs_categoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cs_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Cs_categoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Cs_categoriesAggregateArgs>(args: Subset<T, Cs_categoriesAggregateArgs>): Prisma.PrismaPromise<GetCs_categoriesAggregateType<T>>

    /**
     * Group by Cs_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cs_categoriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends cs_categoriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: cs_categoriesGroupByArgs['orderBy'] }
        : { orderBy?: cs_categoriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, cs_categoriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCs_categoriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the cs_categories model
   */
  readonly fields: cs_categoriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for cs_categories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__cs_categoriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the cs_categories model
   */ 
  interface cs_categoriesFieldRefs {
    readonly id: FieldRef<"cs_categories", 'Int'>
    readonly idx: FieldRef<"cs_categories", 'Int'>
    readonly name: FieldRef<"cs_categories", 'String'>
    readonly flag: FieldRef<"cs_categories", 'Int'>
    readonly parentIdx: FieldRef<"cs_categories", 'Int'>
    readonly stock: FieldRef<"cs_categories", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * cs_categories findUnique
   */
  export type cs_categoriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cs_categories
     */
    select?: cs_categoriesSelect<ExtArgs> | null
    /**
     * Filter, which cs_categories to fetch.
     */
    where: cs_categoriesWhereUniqueInput
  }

  /**
   * cs_categories findUniqueOrThrow
   */
  export type cs_categoriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cs_categories
     */
    select?: cs_categoriesSelect<ExtArgs> | null
    /**
     * Filter, which cs_categories to fetch.
     */
    where: cs_categoriesWhereUniqueInput
  }

  /**
   * cs_categories findFirst
   */
  export type cs_categoriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cs_categories
     */
    select?: cs_categoriesSelect<ExtArgs> | null
    /**
     * Filter, which cs_categories to fetch.
     */
    where?: cs_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cs_categories to fetch.
     */
    orderBy?: cs_categoriesOrderByWithRelationInput | cs_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cs_categories.
     */
    cursor?: cs_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cs_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cs_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cs_categories.
     */
    distinct?: Cs_categoriesScalarFieldEnum | Cs_categoriesScalarFieldEnum[]
  }

  /**
   * cs_categories findFirstOrThrow
   */
  export type cs_categoriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cs_categories
     */
    select?: cs_categoriesSelect<ExtArgs> | null
    /**
     * Filter, which cs_categories to fetch.
     */
    where?: cs_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cs_categories to fetch.
     */
    orderBy?: cs_categoriesOrderByWithRelationInput | cs_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cs_categories.
     */
    cursor?: cs_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cs_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cs_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cs_categories.
     */
    distinct?: Cs_categoriesScalarFieldEnum | Cs_categoriesScalarFieldEnum[]
  }

  /**
   * cs_categories findMany
   */
  export type cs_categoriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cs_categories
     */
    select?: cs_categoriesSelect<ExtArgs> | null
    /**
     * Filter, which cs_categories to fetch.
     */
    where?: cs_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cs_categories to fetch.
     */
    orderBy?: cs_categoriesOrderByWithRelationInput | cs_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cs_categories.
     */
    cursor?: cs_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cs_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cs_categories.
     */
    skip?: number
    distinct?: Cs_categoriesScalarFieldEnum | Cs_categoriesScalarFieldEnum[]
  }

  /**
   * cs_categories create
   */
  export type cs_categoriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cs_categories
     */
    select?: cs_categoriesSelect<ExtArgs> | null
    /**
     * The data needed to create a cs_categories.
     */
    data?: XOR<cs_categoriesCreateInput, cs_categoriesUncheckedCreateInput>
  }

  /**
   * cs_categories createMany
   */
  export type cs_categoriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many cs_categories.
     */
    data: cs_categoriesCreateManyInput | cs_categoriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * cs_categories update
   */
  export type cs_categoriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cs_categories
     */
    select?: cs_categoriesSelect<ExtArgs> | null
    /**
     * The data needed to update a cs_categories.
     */
    data: XOR<cs_categoriesUpdateInput, cs_categoriesUncheckedUpdateInput>
    /**
     * Choose, which cs_categories to update.
     */
    where: cs_categoriesWhereUniqueInput
  }

  /**
   * cs_categories updateMany
   */
  export type cs_categoriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update cs_categories.
     */
    data: XOR<cs_categoriesUpdateManyMutationInput, cs_categoriesUncheckedUpdateManyInput>
    /**
     * Filter which cs_categories to update
     */
    where?: cs_categoriesWhereInput
  }

  /**
   * cs_categories upsert
   */
  export type cs_categoriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cs_categories
     */
    select?: cs_categoriesSelect<ExtArgs> | null
    /**
     * The filter to search for the cs_categories to update in case it exists.
     */
    where: cs_categoriesWhereUniqueInput
    /**
     * In case the cs_categories found by the `where` argument doesn't exist, create a new cs_categories with this data.
     */
    create: XOR<cs_categoriesCreateInput, cs_categoriesUncheckedCreateInput>
    /**
     * In case the cs_categories was found with the provided `where` argument, update it with this data.
     */
    update: XOR<cs_categoriesUpdateInput, cs_categoriesUncheckedUpdateInput>
  }

  /**
   * cs_categories delete
   */
  export type cs_categoriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cs_categories
     */
    select?: cs_categoriesSelect<ExtArgs> | null
    /**
     * Filter which cs_categories to delete.
     */
    where: cs_categoriesWhereUniqueInput
  }

  /**
   * cs_categories deleteMany
   */
  export type cs_categoriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cs_categories to delete
     */
    where?: cs_categoriesWhereInput
  }

  /**
   * cs_categories without action
   */
  export type cs_categoriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cs_categories
     */
    select?: cs_categoriesSelect<ExtArgs> | null
  }


  /**
   * Model cs_items
   */

  export type AggregateCs_items = {
    _count: Cs_itemsCountAggregateOutputType | null
    _avg: Cs_itemsAvgAggregateOutputType | null
    _sum: Cs_itemsSumAggregateOutputType | null
    _min: Cs_itemsMinAggregateOutputType | null
    _max: Cs_itemsMaxAggregateOutputType | null
  }

  export type Cs_itemsAvgAggregateOutputType = {
    id: number | null
    itemID: number | null
    stock: number | null
    shopItemFlag: number | null
    idk1: number | null
    idk2: number | null
    oldPrice: number | null
    newPrice: number | null
    idk3: number | null
    bundleQuantity: number | null
    availableDays: number | null
    buyableWithMaplePoints: number | null
    buyableWithCredit: number | null
    buyableWithPrepaid: number | null
    likable: number | null
    meso: number | null
    favoritable: number | null
    gender: number | null
    likes: number | null
    requiredLevel: number | null
    idk11: number | null
    idk13: number | null
    idk14: number | null
  }

  export type Cs_itemsSumAggregateOutputType = {
    id: number | null
    itemID: number | null
    stock: number | null
    shopItemFlag: number | null
    idk1: number | null
    idk2: number | null
    oldPrice: number | null
    newPrice: number | null
    idk3: number | null
    bundleQuantity: number | null
    availableDays: number | null
    buyableWithMaplePoints: number | null
    buyableWithCredit: number | null
    buyableWithPrepaid: number | null
    likable: number | null
    meso: number | null
    favoritable: number | null
    gender: number | null
    likes: number | null
    requiredLevel: number | null
    idk11: number | null
    idk13: number | null
    idk14: number | null
  }

  export type Cs_itemsMinAggregateOutputType = {
    id: number | null
    itemID: number | null
    stock: number | null
    shopItemFlag: number | null
    idk1: number | null
    idk2: number | null
    oldPrice: number | null
    newPrice: number | null
    idkTime1: Date | null
    saleFromFT: Date | null
    idkTime3: Date | null
    saleToFT: Date | null
    idk3: number | null
    bundleQuantity: number | null
    availableDays: number | null
    buyableWithMaplePoints: number | null
    buyableWithCredit: number | null
    buyableWithPrepaid: number | null
    likable: number | null
    meso: number | null
    favoritable: number | null
    gender: number | null
    likes: number | null
    requiredLevel: number | null
    idk10: string | null
    idk11: number | null
    idk13: number | null
    idk14: number | null
    category: string | null
  }

  export type Cs_itemsMaxAggregateOutputType = {
    id: number | null
    itemID: number | null
    stock: number | null
    shopItemFlag: number | null
    idk1: number | null
    idk2: number | null
    oldPrice: number | null
    newPrice: number | null
    idkTime1: Date | null
    saleFromFT: Date | null
    idkTime3: Date | null
    saleToFT: Date | null
    idk3: number | null
    bundleQuantity: number | null
    availableDays: number | null
    buyableWithMaplePoints: number | null
    buyableWithCredit: number | null
    buyableWithPrepaid: number | null
    likable: number | null
    meso: number | null
    favoritable: number | null
    gender: number | null
    likes: number | null
    requiredLevel: number | null
    idk10: string | null
    idk11: number | null
    idk13: number | null
    idk14: number | null
    category: string | null
  }

  export type Cs_itemsCountAggregateOutputType = {
    id: number
    itemID: number
    stock: number
    shopItemFlag: number
    idk1: number
    idk2: number
    oldPrice: number
    newPrice: number
    idkTime1: number
    saleFromFT: number
    idkTime3: number
    saleToFT: number
    idk3: number
    bundleQuantity: number
    availableDays: number
    buyableWithMaplePoints: number
    buyableWithCredit: number
    buyableWithPrepaid: number
    likable: number
    meso: number
    favoritable: number
    gender: number
    likes: number
    requiredLevel: number
    idk10: number
    idk11: number
    idk13: number
    idk14: number
    category: number
    _all: number
  }


  export type Cs_itemsAvgAggregateInputType = {
    id?: true
    itemID?: true
    stock?: true
    shopItemFlag?: true
    idk1?: true
    idk2?: true
    oldPrice?: true
    newPrice?: true
    idk3?: true
    bundleQuantity?: true
    availableDays?: true
    buyableWithMaplePoints?: true
    buyableWithCredit?: true
    buyableWithPrepaid?: true
    likable?: true
    meso?: true
    favoritable?: true
    gender?: true
    likes?: true
    requiredLevel?: true
    idk11?: true
    idk13?: true
    idk14?: true
  }

  export type Cs_itemsSumAggregateInputType = {
    id?: true
    itemID?: true
    stock?: true
    shopItemFlag?: true
    idk1?: true
    idk2?: true
    oldPrice?: true
    newPrice?: true
    idk3?: true
    bundleQuantity?: true
    availableDays?: true
    buyableWithMaplePoints?: true
    buyableWithCredit?: true
    buyableWithPrepaid?: true
    likable?: true
    meso?: true
    favoritable?: true
    gender?: true
    likes?: true
    requiredLevel?: true
    idk11?: true
    idk13?: true
    idk14?: true
  }

  export type Cs_itemsMinAggregateInputType = {
    id?: true
    itemID?: true
    stock?: true
    shopItemFlag?: true
    idk1?: true
    idk2?: true
    oldPrice?: true
    newPrice?: true
    idkTime1?: true
    saleFromFT?: true
    idkTime3?: true
    saleToFT?: true
    idk3?: true
    bundleQuantity?: true
    availableDays?: true
    buyableWithMaplePoints?: true
    buyableWithCredit?: true
    buyableWithPrepaid?: true
    likable?: true
    meso?: true
    favoritable?: true
    gender?: true
    likes?: true
    requiredLevel?: true
    idk10?: true
    idk11?: true
    idk13?: true
    idk14?: true
    category?: true
  }

  export type Cs_itemsMaxAggregateInputType = {
    id?: true
    itemID?: true
    stock?: true
    shopItemFlag?: true
    idk1?: true
    idk2?: true
    oldPrice?: true
    newPrice?: true
    idkTime1?: true
    saleFromFT?: true
    idkTime3?: true
    saleToFT?: true
    idk3?: true
    bundleQuantity?: true
    availableDays?: true
    buyableWithMaplePoints?: true
    buyableWithCredit?: true
    buyableWithPrepaid?: true
    likable?: true
    meso?: true
    favoritable?: true
    gender?: true
    likes?: true
    requiredLevel?: true
    idk10?: true
    idk11?: true
    idk13?: true
    idk14?: true
    category?: true
  }

  export type Cs_itemsCountAggregateInputType = {
    id?: true
    itemID?: true
    stock?: true
    shopItemFlag?: true
    idk1?: true
    idk2?: true
    oldPrice?: true
    newPrice?: true
    idkTime1?: true
    saleFromFT?: true
    idkTime3?: true
    saleToFT?: true
    idk3?: true
    bundleQuantity?: true
    availableDays?: true
    buyableWithMaplePoints?: true
    buyableWithCredit?: true
    buyableWithPrepaid?: true
    likable?: true
    meso?: true
    favoritable?: true
    gender?: true
    likes?: true
    requiredLevel?: true
    idk10?: true
    idk11?: true
    idk13?: true
    idk14?: true
    category?: true
    _all?: true
  }

  export type Cs_itemsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cs_items to aggregate.
     */
    where?: cs_itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cs_items to fetch.
     */
    orderBy?: cs_itemsOrderByWithRelationInput | cs_itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: cs_itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cs_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cs_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cs_items
    **/
    _count?: true | Cs_itemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Cs_itemsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Cs_itemsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Cs_itemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Cs_itemsMaxAggregateInputType
  }

  export type GetCs_itemsAggregateType<T extends Cs_itemsAggregateArgs> = {
        [P in keyof T & keyof AggregateCs_items]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCs_items[P]>
      : GetScalarType<T[P], AggregateCs_items[P]>
  }




  export type cs_itemsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cs_itemsWhereInput
    orderBy?: cs_itemsOrderByWithAggregationInput | cs_itemsOrderByWithAggregationInput[]
    by: Cs_itemsScalarFieldEnum[] | Cs_itemsScalarFieldEnum
    having?: cs_itemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Cs_itemsCountAggregateInputType | true
    _avg?: Cs_itemsAvgAggregateInputType
    _sum?: Cs_itemsSumAggregateInputType
    _min?: Cs_itemsMinAggregateInputType
    _max?: Cs_itemsMaxAggregateInputType
  }

  export type Cs_itemsGroupByOutputType = {
    id: number
    itemID: number
    stock: number | null
    shopItemFlag: number | null
    idk1: number | null
    idk2: number | null
    oldPrice: number | null
    newPrice: number | null
    idkTime1: Date | null
    saleFromFT: Date | null
    idkTime3: Date | null
    saleToFT: Date | null
    idk3: number | null
    bundleQuantity: number | null
    availableDays: number | null
    buyableWithMaplePoints: number | null
    buyableWithCredit: number | null
    buyableWithPrepaid: number | null
    likable: number | null
    meso: number | null
    favoritable: number | null
    gender: number | null
    likes: number | null
    requiredLevel: number | null
    idk10: string | null
    idk11: number | null
    idk13: number | null
    idk14: number | null
    category: string | null
    _count: Cs_itemsCountAggregateOutputType | null
    _avg: Cs_itemsAvgAggregateOutputType | null
    _sum: Cs_itemsSumAggregateOutputType | null
    _min: Cs_itemsMinAggregateOutputType | null
    _max: Cs_itemsMaxAggregateOutputType | null
  }

  type GetCs_itemsGroupByPayload<T extends cs_itemsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Cs_itemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Cs_itemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Cs_itemsGroupByOutputType[P]>
            : GetScalarType<T[P], Cs_itemsGroupByOutputType[P]>
        }
      >
    >


  export type cs_itemsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemID?: boolean
    stock?: boolean
    shopItemFlag?: boolean
    idk1?: boolean
    idk2?: boolean
    oldPrice?: boolean
    newPrice?: boolean
    idkTime1?: boolean
    saleFromFT?: boolean
    idkTime3?: boolean
    saleToFT?: boolean
    idk3?: boolean
    bundleQuantity?: boolean
    availableDays?: boolean
    buyableWithMaplePoints?: boolean
    buyableWithCredit?: boolean
    buyableWithPrepaid?: boolean
    likable?: boolean
    meso?: boolean
    favoritable?: boolean
    gender?: boolean
    likes?: boolean
    requiredLevel?: boolean
    idk10?: boolean
    idk11?: boolean
    idk13?: boolean
    idk14?: boolean
    category?: boolean
  }, ExtArgs["result"]["cs_items"]>


  export type cs_itemsSelectScalar = {
    id?: boolean
    itemID?: boolean
    stock?: boolean
    shopItemFlag?: boolean
    idk1?: boolean
    idk2?: boolean
    oldPrice?: boolean
    newPrice?: boolean
    idkTime1?: boolean
    saleFromFT?: boolean
    idkTime3?: boolean
    saleToFT?: boolean
    idk3?: boolean
    bundleQuantity?: boolean
    availableDays?: boolean
    buyableWithMaplePoints?: boolean
    buyableWithCredit?: boolean
    buyableWithPrepaid?: boolean
    likable?: boolean
    meso?: boolean
    favoritable?: boolean
    gender?: boolean
    likes?: boolean
    requiredLevel?: boolean
    idk10?: boolean
    idk11?: boolean
    idk13?: boolean
    idk14?: boolean
    category?: boolean
  }


  export type $cs_itemsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "cs_items"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      itemID: number
      stock: number | null
      shopItemFlag: number | null
      idk1: number | null
      idk2: number | null
      oldPrice: number | null
      newPrice: number | null
      idkTime1: Date | null
      saleFromFT: Date | null
      idkTime3: Date | null
      saleToFT: Date | null
      idk3: number | null
      bundleQuantity: number | null
      availableDays: number | null
      buyableWithMaplePoints: number | null
      buyableWithCredit: number | null
      buyableWithPrepaid: number | null
      likable: number | null
      meso: number | null
      favoritable: number | null
      gender: number | null
      likes: number | null
      requiredLevel: number | null
      idk10: string | null
      idk11: number | null
      idk13: number | null
      idk14: number | null
      category: string | null
    }, ExtArgs["result"]["cs_items"]>
    composites: {}
  }

  type cs_itemsGetPayload<S extends boolean | null | undefined | cs_itemsDefaultArgs> = $Result.GetResult<Prisma.$cs_itemsPayload, S>

  type cs_itemsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<cs_itemsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Cs_itemsCountAggregateInputType | true
    }

  export interface cs_itemsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['cs_items'], meta: { name: 'cs_items' } }
    /**
     * Find zero or one Cs_items that matches the filter.
     * @param {cs_itemsFindUniqueArgs} args - Arguments to find a Cs_items
     * @example
     * // Get one Cs_items
     * const cs_items = await prisma.cs_items.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends cs_itemsFindUniqueArgs>(args: SelectSubset<T, cs_itemsFindUniqueArgs<ExtArgs>>): Prisma__cs_itemsClient<$Result.GetResult<Prisma.$cs_itemsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Cs_items that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {cs_itemsFindUniqueOrThrowArgs} args - Arguments to find a Cs_items
     * @example
     * // Get one Cs_items
     * const cs_items = await prisma.cs_items.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends cs_itemsFindUniqueOrThrowArgs>(args: SelectSubset<T, cs_itemsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__cs_itemsClient<$Result.GetResult<Prisma.$cs_itemsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Cs_items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cs_itemsFindFirstArgs} args - Arguments to find a Cs_items
     * @example
     * // Get one Cs_items
     * const cs_items = await prisma.cs_items.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends cs_itemsFindFirstArgs>(args?: SelectSubset<T, cs_itemsFindFirstArgs<ExtArgs>>): Prisma__cs_itemsClient<$Result.GetResult<Prisma.$cs_itemsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Cs_items that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cs_itemsFindFirstOrThrowArgs} args - Arguments to find a Cs_items
     * @example
     * // Get one Cs_items
     * const cs_items = await prisma.cs_items.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends cs_itemsFindFirstOrThrowArgs>(args?: SelectSubset<T, cs_itemsFindFirstOrThrowArgs<ExtArgs>>): Prisma__cs_itemsClient<$Result.GetResult<Prisma.$cs_itemsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Cs_items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cs_itemsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cs_items
     * const cs_items = await prisma.cs_items.findMany()
     * 
     * // Get first 10 Cs_items
     * const cs_items = await prisma.cs_items.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cs_itemsWithIdOnly = await prisma.cs_items.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends cs_itemsFindManyArgs>(args?: SelectSubset<T, cs_itemsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cs_itemsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Cs_items.
     * @param {cs_itemsCreateArgs} args - Arguments to create a Cs_items.
     * @example
     * // Create one Cs_items
     * const Cs_items = await prisma.cs_items.create({
     *   data: {
     *     // ... data to create a Cs_items
     *   }
     * })
     * 
     */
    create<T extends cs_itemsCreateArgs>(args: SelectSubset<T, cs_itemsCreateArgs<ExtArgs>>): Prisma__cs_itemsClient<$Result.GetResult<Prisma.$cs_itemsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Cs_items.
     * @param {cs_itemsCreateManyArgs} args - Arguments to create many Cs_items.
     * @example
     * // Create many Cs_items
     * const cs_items = await prisma.cs_items.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends cs_itemsCreateManyArgs>(args?: SelectSubset<T, cs_itemsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Cs_items.
     * @param {cs_itemsDeleteArgs} args - Arguments to delete one Cs_items.
     * @example
     * // Delete one Cs_items
     * const Cs_items = await prisma.cs_items.delete({
     *   where: {
     *     // ... filter to delete one Cs_items
     *   }
     * })
     * 
     */
    delete<T extends cs_itemsDeleteArgs>(args: SelectSubset<T, cs_itemsDeleteArgs<ExtArgs>>): Prisma__cs_itemsClient<$Result.GetResult<Prisma.$cs_itemsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Cs_items.
     * @param {cs_itemsUpdateArgs} args - Arguments to update one Cs_items.
     * @example
     * // Update one Cs_items
     * const cs_items = await prisma.cs_items.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends cs_itemsUpdateArgs>(args: SelectSubset<T, cs_itemsUpdateArgs<ExtArgs>>): Prisma__cs_itemsClient<$Result.GetResult<Prisma.$cs_itemsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Cs_items.
     * @param {cs_itemsDeleteManyArgs} args - Arguments to filter Cs_items to delete.
     * @example
     * // Delete a few Cs_items
     * const { count } = await prisma.cs_items.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends cs_itemsDeleteManyArgs>(args?: SelectSubset<T, cs_itemsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cs_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cs_itemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cs_items
     * const cs_items = await prisma.cs_items.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends cs_itemsUpdateManyArgs>(args: SelectSubset<T, cs_itemsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cs_items.
     * @param {cs_itemsUpsertArgs} args - Arguments to update or create a Cs_items.
     * @example
     * // Update or create a Cs_items
     * const cs_items = await prisma.cs_items.upsert({
     *   create: {
     *     // ... data to create a Cs_items
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cs_items we want to update
     *   }
     * })
     */
    upsert<T extends cs_itemsUpsertArgs>(args: SelectSubset<T, cs_itemsUpsertArgs<ExtArgs>>): Prisma__cs_itemsClient<$Result.GetResult<Prisma.$cs_itemsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Cs_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cs_itemsCountArgs} args - Arguments to filter Cs_items to count.
     * @example
     * // Count the number of Cs_items
     * const count = await prisma.cs_items.count({
     *   where: {
     *     // ... the filter for the Cs_items we want to count
     *   }
     * })
    **/
    count<T extends cs_itemsCountArgs>(
      args?: Subset<T, cs_itemsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Cs_itemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cs_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Cs_itemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Cs_itemsAggregateArgs>(args: Subset<T, Cs_itemsAggregateArgs>): Prisma.PrismaPromise<GetCs_itemsAggregateType<T>>

    /**
     * Group by Cs_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cs_itemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends cs_itemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: cs_itemsGroupByArgs['orderBy'] }
        : { orderBy?: cs_itemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, cs_itemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCs_itemsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the cs_items model
   */
  readonly fields: cs_itemsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for cs_items.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__cs_itemsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the cs_items model
   */ 
  interface cs_itemsFieldRefs {
    readonly id: FieldRef<"cs_items", 'Int'>
    readonly itemID: FieldRef<"cs_items", 'Int'>
    readonly stock: FieldRef<"cs_items", 'Int'>
    readonly shopItemFlag: FieldRef<"cs_items", 'Int'>
    readonly idk1: FieldRef<"cs_items", 'Int'>
    readonly idk2: FieldRef<"cs_items", 'Int'>
    readonly oldPrice: FieldRef<"cs_items", 'Int'>
    readonly newPrice: FieldRef<"cs_items", 'Int'>
    readonly idkTime1: FieldRef<"cs_items", 'DateTime'>
    readonly saleFromFT: FieldRef<"cs_items", 'DateTime'>
    readonly idkTime3: FieldRef<"cs_items", 'DateTime'>
    readonly saleToFT: FieldRef<"cs_items", 'DateTime'>
    readonly idk3: FieldRef<"cs_items", 'Int'>
    readonly bundleQuantity: FieldRef<"cs_items", 'Int'>
    readonly availableDays: FieldRef<"cs_items", 'Int'>
    readonly buyableWithMaplePoints: FieldRef<"cs_items", 'Int'>
    readonly buyableWithCredit: FieldRef<"cs_items", 'Int'>
    readonly buyableWithPrepaid: FieldRef<"cs_items", 'Int'>
    readonly likable: FieldRef<"cs_items", 'Int'>
    readonly meso: FieldRef<"cs_items", 'Int'>
    readonly favoritable: FieldRef<"cs_items", 'Int'>
    readonly gender: FieldRef<"cs_items", 'Int'>
    readonly likes: FieldRef<"cs_items", 'Int'>
    readonly requiredLevel: FieldRef<"cs_items", 'Int'>
    readonly idk10: FieldRef<"cs_items", 'String'>
    readonly idk11: FieldRef<"cs_items", 'Int'>
    readonly idk13: FieldRef<"cs_items", 'Int'>
    readonly idk14: FieldRef<"cs_items", 'Int'>
    readonly category: FieldRef<"cs_items", 'String'>
  }
    

  // Custom InputTypes
  /**
   * cs_items findUnique
   */
  export type cs_itemsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cs_items
     */
    select?: cs_itemsSelect<ExtArgs> | null
    /**
     * Filter, which cs_items to fetch.
     */
    where: cs_itemsWhereUniqueInput
  }

  /**
   * cs_items findUniqueOrThrow
   */
  export type cs_itemsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cs_items
     */
    select?: cs_itemsSelect<ExtArgs> | null
    /**
     * Filter, which cs_items to fetch.
     */
    where: cs_itemsWhereUniqueInput
  }

  /**
   * cs_items findFirst
   */
  export type cs_itemsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cs_items
     */
    select?: cs_itemsSelect<ExtArgs> | null
    /**
     * Filter, which cs_items to fetch.
     */
    where?: cs_itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cs_items to fetch.
     */
    orderBy?: cs_itemsOrderByWithRelationInput | cs_itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cs_items.
     */
    cursor?: cs_itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cs_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cs_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cs_items.
     */
    distinct?: Cs_itemsScalarFieldEnum | Cs_itemsScalarFieldEnum[]
  }

  /**
   * cs_items findFirstOrThrow
   */
  export type cs_itemsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cs_items
     */
    select?: cs_itemsSelect<ExtArgs> | null
    /**
     * Filter, which cs_items to fetch.
     */
    where?: cs_itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cs_items to fetch.
     */
    orderBy?: cs_itemsOrderByWithRelationInput | cs_itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cs_items.
     */
    cursor?: cs_itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cs_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cs_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cs_items.
     */
    distinct?: Cs_itemsScalarFieldEnum | Cs_itemsScalarFieldEnum[]
  }

  /**
   * cs_items findMany
   */
  export type cs_itemsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cs_items
     */
    select?: cs_itemsSelect<ExtArgs> | null
    /**
     * Filter, which cs_items to fetch.
     */
    where?: cs_itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cs_items to fetch.
     */
    orderBy?: cs_itemsOrderByWithRelationInput | cs_itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cs_items.
     */
    cursor?: cs_itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cs_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cs_items.
     */
    skip?: number
    distinct?: Cs_itemsScalarFieldEnum | Cs_itemsScalarFieldEnum[]
  }

  /**
   * cs_items create
   */
  export type cs_itemsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cs_items
     */
    select?: cs_itemsSelect<ExtArgs> | null
    /**
     * The data needed to create a cs_items.
     */
    data: XOR<cs_itemsCreateInput, cs_itemsUncheckedCreateInput>
  }

  /**
   * cs_items createMany
   */
  export type cs_itemsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many cs_items.
     */
    data: cs_itemsCreateManyInput | cs_itemsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * cs_items update
   */
  export type cs_itemsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cs_items
     */
    select?: cs_itemsSelect<ExtArgs> | null
    /**
     * The data needed to update a cs_items.
     */
    data: XOR<cs_itemsUpdateInput, cs_itemsUncheckedUpdateInput>
    /**
     * Choose, which cs_items to update.
     */
    where: cs_itemsWhereUniqueInput
  }

  /**
   * cs_items updateMany
   */
  export type cs_itemsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update cs_items.
     */
    data: XOR<cs_itemsUpdateManyMutationInput, cs_itemsUncheckedUpdateManyInput>
    /**
     * Filter which cs_items to update
     */
    where?: cs_itemsWhereInput
  }

  /**
   * cs_items upsert
   */
  export type cs_itemsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cs_items
     */
    select?: cs_itemsSelect<ExtArgs> | null
    /**
     * The filter to search for the cs_items to update in case it exists.
     */
    where: cs_itemsWhereUniqueInput
    /**
     * In case the cs_items found by the `where` argument doesn't exist, create a new cs_items with this data.
     */
    create: XOR<cs_itemsCreateInput, cs_itemsUncheckedCreateInput>
    /**
     * In case the cs_items was found with the provided `where` argument, update it with this data.
     */
    update: XOR<cs_itemsUpdateInput, cs_itemsUncheckedUpdateInput>
  }

  /**
   * cs_items delete
   */
  export type cs_itemsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cs_items
     */
    select?: cs_itemsSelect<ExtArgs> | null
    /**
     * Filter which cs_items to delete.
     */
    where: cs_itemsWhereUniqueInput
  }

  /**
   * cs_items deleteMany
   */
  export type cs_itemsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cs_items to delete
     */
    where?: cs_itemsWhereInput
  }

  /**
   * cs_items without action
   */
  export type cs_itemsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cs_items
     */
    select?: cs_itemsSelect<ExtArgs> | null
  }


  /**
   * Model damageskins
   */

  export type AggregateDamageskins = {
    _count: DamageskinsCountAggregateOutputType | null
    _avg: DamageskinsAvgAggregateOutputType | null
    _sum: DamageskinsSumAggregateOutputType | null
    _min: DamageskinsMinAggregateOutputType | null
    _max: DamageskinsMaxAggregateOutputType | null
  }

  export type DamageskinsAvgAggregateOutputType = {
    id: number | null
    charid: number | null
    damageskinid: number | null
    itemid: number | null
  }

  export type DamageskinsSumAggregateOutputType = {
    id: bigint | null
    charid: number | null
    damageskinid: number | null
    itemid: number | null
  }

  export type DamageskinsMinAggregateOutputType = {
    id: bigint | null
    charid: number | null
    damageskinid: number | null
    itemid: number | null
    notsave: boolean | null
    description: string | null
  }

  export type DamageskinsMaxAggregateOutputType = {
    id: bigint | null
    charid: number | null
    damageskinid: number | null
    itemid: number | null
    notsave: boolean | null
    description: string | null
  }

  export type DamageskinsCountAggregateOutputType = {
    id: number
    charid: number
    damageskinid: number
    itemid: number
    notsave: number
    description: number
    _all: number
  }


  export type DamageskinsAvgAggregateInputType = {
    id?: true
    charid?: true
    damageskinid?: true
    itemid?: true
  }

  export type DamageskinsSumAggregateInputType = {
    id?: true
    charid?: true
    damageskinid?: true
    itemid?: true
  }

  export type DamageskinsMinAggregateInputType = {
    id?: true
    charid?: true
    damageskinid?: true
    itemid?: true
    notsave?: true
    description?: true
  }

  export type DamageskinsMaxAggregateInputType = {
    id?: true
    charid?: true
    damageskinid?: true
    itemid?: true
    notsave?: true
    description?: true
  }

  export type DamageskinsCountAggregateInputType = {
    id?: true
    charid?: true
    damageskinid?: true
    itemid?: true
    notsave?: true
    description?: true
    _all?: true
  }

  export type DamageskinsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which damageskins to aggregate.
     */
    where?: damageskinsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of damageskins to fetch.
     */
    orderBy?: damageskinsOrderByWithRelationInput | damageskinsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: damageskinsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` damageskins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` damageskins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned damageskins
    **/
    _count?: true | DamageskinsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DamageskinsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DamageskinsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DamageskinsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DamageskinsMaxAggregateInputType
  }

  export type GetDamageskinsAggregateType<T extends DamageskinsAggregateArgs> = {
        [P in keyof T & keyof AggregateDamageskins]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDamageskins[P]>
      : GetScalarType<T[P], AggregateDamageskins[P]>
  }




  export type damageskinsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: damageskinsWhereInput
    orderBy?: damageskinsOrderByWithAggregationInput | damageskinsOrderByWithAggregationInput[]
    by: DamageskinsScalarFieldEnum[] | DamageskinsScalarFieldEnum
    having?: damageskinsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DamageskinsCountAggregateInputType | true
    _avg?: DamageskinsAvgAggregateInputType
    _sum?: DamageskinsSumAggregateInputType
    _min?: DamageskinsMinAggregateInputType
    _max?: DamageskinsMaxAggregateInputType
  }

  export type DamageskinsGroupByOutputType = {
    id: bigint
    charid: number | null
    damageskinid: number | null
    itemid: number | null
    notsave: boolean | null
    description: string | null
    _count: DamageskinsCountAggregateOutputType | null
    _avg: DamageskinsAvgAggregateOutputType | null
    _sum: DamageskinsSumAggregateOutputType | null
    _min: DamageskinsMinAggregateOutputType | null
    _max: DamageskinsMaxAggregateOutputType | null
  }

  type GetDamageskinsGroupByPayload<T extends damageskinsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DamageskinsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DamageskinsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DamageskinsGroupByOutputType[P]>
            : GetScalarType<T[P], DamageskinsGroupByOutputType[P]>
        }
      >
    >


  export type damageskinsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    charid?: boolean
    damageskinid?: boolean
    itemid?: boolean
    notsave?: boolean
    description?: boolean
  }, ExtArgs["result"]["damageskins"]>


  export type damageskinsSelectScalar = {
    id?: boolean
    charid?: boolean
    damageskinid?: boolean
    itemid?: boolean
    notsave?: boolean
    description?: boolean
  }


  export type $damageskinsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "damageskins"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      charid: number | null
      damageskinid: number | null
      itemid: number | null
      notsave: boolean | null
      description: string | null
    }, ExtArgs["result"]["damageskins"]>
    composites: {}
  }

  type damageskinsGetPayload<S extends boolean | null | undefined | damageskinsDefaultArgs> = $Result.GetResult<Prisma.$damageskinsPayload, S>

  type damageskinsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<damageskinsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DamageskinsCountAggregateInputType | true
    }

  export interface damageskinsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['damageskins'], meta: { name: 'damageskins' } }
    /**
     * Find zero or one Damageskins that matches the filter.
     * @param {damageskinsFindUniqueArgs} args - Arguments to find a Damageskins
     * @example
     * // Get one Damageskins
     * const damageskins = await prisma.damageskins.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends damageskinsFindUniqueArgs>(args: SelectSubset<T, damageskinsFindUniqueArgs<ExtArgs>>): Prisma__damageskinsClient<$Result.GetResult<Prisma.$damageskinsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Damageskins that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {damageskinsFindUniqueOrThrowArgs} args - Arguments to find a Damageskins
     * @example
     * // Get one Damageskins
     * const damageskins = await prisma.damageskins.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends damageskinsFindUniqueOrThrowArgs>(args: SelectSubset<T, damageskinsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__damageskinsClient<$Result.GetResult<Prisma.$damageskinsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Damageskins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {damageskinsFindFirstArgs} args - Arguments to find a Damageskins
     * @example
     * // Get one Damageskins
     * const damageskins = await prisma.damageskins.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends damageskinsFindFirstArgs>(args?: SelectSubset<T, damageskinsFindFirstArgs<ExtArgs>>): Prisma__damageskinsClient<$Result.GetResult<Prisma.$damageskinsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Damageskins that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {damageskinsFindFirstOrThrowArgs} args - Arguments to find a Damageskins
     * @example
     * // Get one Damageskins
     * const damageskins = await prisma.damageskins.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends damageskinsFindFirstOrThrowArgs>(args?: SelectSubset<T, damageskinsFindFirstOrThrowArgs<ExtArgs>>): Prisma__damageskinsClient<$Result.GetResult<Prisma.$damageskinsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Damageskins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {damageskinsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Damageskins
     * const damageskins = await prisma.damageskins.findMany()
     * 
     * // Get first 10 Damageskins
     * const damageskins = await prisma.damageskins.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const damageskinsWithIdOnly = await prisma.damageskins.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends damageskinsFindManyArgs>(args?: SelectSubset<T, damageskinsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$damageskinsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Damageskins.
     * @param {damageskinsCreateArgs} args - Arguments to create a Damageskins.
     * @example
     * // Create one Damageskins
     * const Damageskins = await prisma.damageskins.create({
     *   data: {
     *     // ... data to create a Damageskins
     *   }
     * })
     * 
     */
    create<T extends damageskinsCreateArgs>(args: SelectSubset<T, damageskinsCreateArgs<ExtArgs>>): Prisma__damageskinsClient<$Result.GetResult<Prisma.$damageskinsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Damageskins.
     * @param {damageskinsCreateManyArgs} args - Arguments to create many Damageskins.
     * @example
     * // Create many Damageskins
     * const damageskins = await prisma.damageskins.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends damageskinsCreateManyArgs>(args?: SelectSubset<T, damageskinsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Damageskins.
     * @param {damageskinsDeleteArgs} args - Arguments to delete one Damageskins.
     * @example
     * // Delete one Damageskins
     * const Damageskins = await prisma.damageskins.delete({
     *   where: {
     *     // ... filter to delete one Damageskins
     *   }
     * })
     * 
     */
    delete<T extends damageskinsDeleteArgs>(args: SelectSubset<T, damageskinsDeleteArgs<ExtArgs>>): Prisma__damageskinsClient<$Result.GetResult<Prisma.$damageskinsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Damageskins.
     * @param {damageskinsUpdateArgs} args - Arguments to update one Damageskins.
     * @example
     * // Update one Damageskins
     * const damageskins = await prisma.damageskins.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends damageskinsUpdateArgs>(args: SelectSubset<T, damageskinsUpdateArgs<ExtArgs>>): Prisma__damageskinsClient<$Result.GetResult<Prisma.$damageskinsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Damageskins.
     * @param {damageskinsDeleteManyArgs} args - Arguments to filter Damageskins to delete.
     * @example
     * // Delete a few Damageskins
     * const { count } = await prisma.damageskins.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends damageskinsDeleteManyArgs>(args?: SelectSubset<T, damageskinsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Damageskins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {damageskinsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Damageskins
     * const damageskins = await prisma.damageskins.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends damageskinsUpdateManyArgs>(args: SelectSubset<T, damageskinsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Damageskins.
     * @param {damageskinsUpsertArgs} args - Arguments to update or create a Damageskins.
     * @example
     * // Update or create a Damageskins
     * const damageskins = await prisma.damageskins.upsert({
     *   create: {
     *     // ... data to create a Damageskins
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Damageskins we want to update
     *   }
     * })
     */
    upsert<T extends damageskinsUpsertArgs>(args: SelectSubset<T, damageskinsUpsertArgs<ExtArgs>>): Prisma__damageskinsClient<$Result.GetResult<Prisma.$damageskinsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Damageskins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {damageskinsCountArgs} args - Arguments to filter Damageskins to count.
     * @example
     * // Count the number of Damageskins
     * const count = await prisma.damageskins.count({
     *   where: {
     *     // ... the filter for the Damageskins we want to count
     *   }
     * })
    **/
    count<T extends damageskinsCountArgs>(
      args?: Subset<T, damageskinsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DamageskinsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Damageskins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DamageskinsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DamageskinsAggregateArgs>(args: Subset<T, DamageskinsAggregateArgs>): Prisma.PrismaPromise<GetDamageskinsAggregateType<T>>

    /**
     * Group by Damageskins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {damageskinsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends damageskinsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: damageskinsGroupByArgs['orderBy'] }
        : { orderBy?: damageskinsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, damageskinsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDamageskinsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the damageskins model
   */
  readonly fields: damageskinsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for damageskins.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__damageskinsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the damageskins model
   */ 
  interface damageskinsFieldRefs {
    readonly id: FieldRef<"damageskins", 'BigInt'>
    readonly charid: FieldRef<"damageskins", 'Int'>
    readonly damageskinid: FieldRef<"damageskins", 'Int'>
    readonly itemid: FieldRef<"damageskins", 'Int'>
    readonly notsave: FieldRef<"damageskins", 'Boolean'>
    readonly description: FieldRef<"damageskins", 'String'>
  }
    

  // Custom InputTypes
  /**
   * damageskins findUnique
   */
  export type damageskinsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the damageskins
     */
    select?: damageskinsSelect<ExtArgs> | null
    /**
     * Filter, which damageskins to fetch.
     */
    where: damageskinsWhereUniqueInput
  }

  /**
   * damageskins findUniqueOrThrow
   */
  export type damageskinsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the damageskins
     */
    select?: damageskinsSelect<ExtArgs> | null
    /**
     * Filter, which damageskins to fetch.
     */
    where: damageskinsWhereUniqueInput
  }

  /**
   * damageskins findFirst
   */
  export type damageskinsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the damageskins
     */
    select?: damageskinsSelect<ExtArgs> | null
    /**
     * Filter, which damageskins to fetch.
     */
    where?: damageskinsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of damageskins to fetch.
     */
    orderBy?: damageskinsOrderByWithRelationInput | damageskinsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for damageskins.
     */
    cursor?: damageskinsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` damageskins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` damageskins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of damageskins.
     */
    distinct?: DamageskinsScalarFieldEnum | DamageskinsScalarFieldEnum[]
  }

  /**
   * damageskins findFirstOrThrow
   */
  export type damageskinsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the damageskins
     */
    select?: damageskinsSelect<ExtArgs> | null
    /**
     * Filter, which damageskins to fetch.
     */
    where?: damageskinsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of damageskins to fetch.
     */
    orderBy?: damageskinsOrderByWithRelationInput | damageskinsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for damageskins.
     */
    cursor?: damageskinsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` damageskins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` damageskins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of damageskins.
     */
    distinct?: DamageskinsScalarFieldEnum | DamageskinsScalarFieldEnum[]
  }

  /**
   * damageskins findMany
   */
  export type damageskinsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the damageskins
     */
    select?: damageskinsSelect<ExtArgs> | null
    /**
     * Filter, which damageskins to fetch.
     */
    where?: damageskinsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of damageskins to fetch.
     */
    orderBy?: damageskinsOrderByWithRelationInput | damageskinsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing damageskins.
     */
    cursor?: damageskinsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` damageskins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` damageskins.
     */
    skip?: number
    distinct?: DamageskinsScalarFieldEnum | DamageskinsScalarFieldEnum[]
  }

  /**
   * damageskins create
   */
  export type damageskinsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the damageskins
     */
    select?: damageskinsSelect<ExtArgs> | null
    /**
     * The data needed to create a damageskins.
     */
    data?: XOR<damageskinsCreateInput, damageskinsUncheckedCreateInput>
  }

  /**
   * damageskins createMany
   */
  export type damageskinsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many damageskins.
     */
    data: damageskinsCreateManyInput | damageskinsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * damageskins update
   */
  export type damageskinsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the damageskins
     */
    select?: damageskinsSelect<ExtArgs> | null
    /**
     * The data needed to update a damageskins.
     */
    data: XOR<damageskinsUpdateInput, damageskinsUncheckedUpdateInput>
    /**
     * Choose, which damageskins to update.
     */
    where: damageskinsWhereUniqueInput
  }

  /**
   * damageskins updateMany
   */
  export type damageskinsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update damageskins.
     */
    data: XOR<damageskinsUpdateManyMutationInput, damageskinsUncheckedUpdateManyInput>
    /**
     * Filter which damageskins to update
     */
    where?: damageskinsWhereInput
  }

  /**
   * damageskins upsert
   */
  export type damageskinsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the damageskins
     */
    select?: damageskinsSelect<ExtArgs> | null
    /**
     * The filter to search for the damageskins to update in case it exists.
     */
    where: damageskinsWhereUniqueInput
    /**
     * In case the damageskins found by the `where` argument doesn't exist, create a new damageskins with this data.
     */
    create: XOR<damageskinsCreateInput, damageskinsUncheckedCreateInput>
    /**
     * In case the damageskins was found with the provided `where` argument, update it with this data.
     */
    update: XOR<damageskinsUpdateInput, damageskinsUncheckedUpdateInput>
  }

  /**
   * damageskins delete
   */
  export type damageskinsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the damageskins
     */
    select?: damageskinsSelect<ExtArgs> | null
    /**
     * Filter which damageskins to delete.
     */
    where: damageskinsWhereUniqueInput
  }

  /**
   * damageskins deleteMany
   */
  export type damageskinsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which damageskins to delete
     */
    where?: damageskinsWhereInput
  }

  /**
   * damageskins without action
   */
  export type damageskinsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the damageskins
     */
    select?: damageskinsSelect<ExtArgs> | null
  }


  /**
   * Model employeetrunk
   */

  export type AggregateEmployeetrunk = {
    _count: EmployeetrunkCountAggregateOutputType | null
    _avg: EmployeetrunkAvgAggregateOutputType | null
    _sum: EmployeetrunkSumAggregateOutputType | null
    _min: EmployeetrunkMinAggregateOutputType | null
    _max: EmployeetrunkMaxAggregateOutputType | null
  }

  export type EmployeetrunkAvgAggregateOutputType = {
    id: number | null
    money: number | null
  }

  export type EmployeetrunkSumAggregateOutputType = {
    id: number | null
    money: bigint | null
  }

  export type EmployeetrunkMinAggregateOutputType = {
    id: number | null
    money: bigint | null
  }

  export type EmployeetrunkMaxAggregateOutputType = {
    id: number | null
    money: bigint | null
  }

  export type EmployeetrunkCountAggregateOutputType = {
    id: number
    money: number
    _all: number
  }


  export type EmployeetrunkAvgAggregateInputType = {
    id?: true
    money?: true
  }

  export type EmployeetrunkSumAggregateInputType = {
    id?: true
    money?: true
  }

  export type EmployeetrunkMinAggregateInputType = {
    id?: true
    money?: true
  }

  export type EmployeetrunkMaxAggregateInputType = {
    id?: true
    money?: true
  }

  export type EmployeetrunkCountAggregateInputType = {
    id?: true
    money?: true
    _all?: true
  }

  export type EmployeetrunkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which employeetrunk to aggregate.
     */
    where?: employeetrunkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employeetrunks to fetch.
     */
    orderBy?: employeetrunkOrderByWithRelationInput | employeetrunkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: employeetrunkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employeetrunks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employeetrunks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned employeetrunks
    **/
    _count?: true | EmployeetrunkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeetrunkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeetrunkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeetrunkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeetrunkMaxAggregateInputType
  }

  export type GetEmployeetrunkAggregateType<T extends EmployeetrunkAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployeetrunk]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployeetrunk[P]>
      : GetScalarType<T[P], AggregateEmployeetrunk[P]>
  }




  export type employeetrunkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: employeetrunkWhereInput
    orderBy?: employeetrunkOrderByWithAggregationInput | employeetrunkOrderByWithAggregationInput[]
    by: EmployeetrunkScalarFieldEnum[] | EmployeetrunkScalarFieldEnum
    having?: employeetrunkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeetrunkCountAggregateInputType | true
    _avg?: EmployeetrunkAvgAggregateInputType
    _sum?: EmployeetrunkSumAggregateInputType
    _min?: EmployeetrunkMinAggregateInputType
    _max?: EmployeetrunkMaxAggregateInputType
  }

  export type EmployeetrunkGroupByOutputType = {
    id: number
    money: bigint | null
    _count: EmployeetrunkCountAggregateOutputType | null
    _avg: EmployeetrunkAvgAggregateOutputType | null
    _sum: EmployeetrunkSumAggregateOutputType | null
    _min: EmployeetrunkMinAggregateOutputType | null
    _max: EmployeetrunkMaxAggregateOutputType | null
  }

  type GetEmployeetrunkGroupByPayload<T extends employeetrunkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeetrunkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeetrunkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeetrunkGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeetrunkGroupByOutputType[P]>
        }
      >
    >


  export type employeetrunkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    money?: boolean
  }, ExtArgs["result"]["employeetrunk"]>


  export type employeetrunkSelectScalar = {
    id?: boolean
    money?: boolean
  }


  export type $employeetrunkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "employeetrunk"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      money: bigint | null
    }, ExtArgs["result"]["employeetrunk"]>
    composites: {}
  }

  type employeetrunkGetPayload<S extends boolean | null | undefined | employeetrunkDefaultArgs> = $Result.GetResult<Prisma.$employeetrunkPayload, S>

  type employeetrunkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<employeetrunkFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmployeetrunkCountAggregateInputType | true
    }

  export interface employeetrunkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['employeetrunk'], meta: { name: 'employeetrunk' } }
    /**
     * Find zero or one Employeetrunk that matches the filter.
     * @param {employeetrunkFindUniqueArgs} args - Arguments to find a Employeetrunk
     * @example
     * // Get one Employeetrunk
     * const employeetrunk = await prisma.employeetrunk.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends employeetrunkFindUniqueArgs>(args: SelectSubset<T, employeetrunkFindUniqueArgs<ExtArgs>>): Prisma__employeetrunkClient<$Result.GetResult<Prisma.$employeetrunkPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Employeetrunk that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {employeetrunkFindUniqueOrThrowArgs} args - Arguments to find a Employeetrunk
     * @example
     * // Get one Employeetrunk
     * const employeetrunk = await prisma.employeetrunk.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends employeetrunkFindUniqueOrThrowArgs>(args: SelectSubset<T, employeetrunkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__employeetrunkClient<$Result.GetResult<Prisma.$employeetrunkPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Employeetrunk that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeetrunkFindFirstArgs} args - Arguments to find a Employeetrunk
     * @example
     * // Get one Employeetrunk
     * const employeetrunk = await prisma.employeetrunk.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends employeetrunkFindFirstArgs>(args?: SelectSubset<T, employeetrunkFindFirstArgs<ExtArgs>>): Prisma__employeetrunkClient<$Result.GetResult<Prisma.$employeetrunkPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Employeetrunk that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeetrunkFindFirstOrThrowArgs} args - Arguments to find a Employeetrunk
     * @example
     * // Get one Employeetrunk
     * const employeetrunk = await prisma.employeetrunk.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends employeetrunkFindFirstOrThrowArgs>(args?: SelectSubset<T, employeetrunkFindFirstOrThrowArgs<ExtArgs>>): Prisma__employeetrunkClient<$Result.GetResult<Prisma.$employeetrunkPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Employeetrunks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeetrunkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employeetrunks
     * const employeetrunks = await prisma.employeetrunk.findMany()
     * 
     * // Get first 10 Employeetrunks
     * const employeetrunks = await prisma.employeetrunk.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeetrunkWithIdOnly = await prisma.employeetrunk.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends employeetrunkFindManyArgs>(args?: SelectSubset<T, employeetrunkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$employeetrunkPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Employeetrunk.
     * @param {employeetrunkCreateArgs} args - Arguments to create a Employeetrunk.
     * @example
     * // Create one Employeetrunk
     * const Employeetrunk = await prisma.employeetrunk.create({
     *   data: {
     *     // ... data to create a Employeetrunk
     *   }
     * })
     * 
     */
    create<T extends employeetrunkCreateArgs>(args: SelectSubset<T, employeetrunkCreateArgs<ExtArgs>>): Prisma__employeetrunkClient<$Result.GetResult<Prisma.$employeetrunkPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Employeetrunks.
     * @param {employeetrunkCreateManyArgs} args - Arguments to create many Employeetrunks.
     * @example
     * // Create many Employeetrunks
     * const employeetrunk = await prisma.employeetrunk.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends employeetrunkCreateManyArgs>(args?: SelectSubset<T, employeetrunkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Employeetrunk.
     * @param {employeetrunkDeleteArgs} args - Arguments to delete one Employeetrunk.
     * @example
     * // Delete one Employeetrunk
     * const Employeetrunk = await prisma.employeetrunk.delete({
     *   where: {
     *     // ... filter to delete one Employeetrunk
     *   }
     * })
     * 
     */
    delete<T extends employeetrunkDeleteArgs>(args: SelectSubset<T, employeetrunkDeleteArgs<ExtArgs>>): Prisma__employeetrunkClient<$Result.GetResult<Prisma.$employeetrunkPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Employeetrunk.
     * @param {employeetrunkUpdateArgs} args - Arguments to update one Employeetrunk.
     * @example
     * // Update one Employeetrunk
     * const employeetrunk = await prisma.employeetrunk.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends employeetrunkUpdateArgs>(args: SelectSubset<T, employeetrunkUpdateArgs<ExtArgs>>): Prisma__employeetrunkClient<$Result.GetResult<Prisma.$employeetrunkPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Employeetrunks.
     * @param {employeetrunkDeleteManyArgs} args - Arguments to filter Employeetrunks to delete.
     * @example
     * // Delete a few Employeetrunks
     * const { count } = await prisma.employeetrunk.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends employeetrunkDeleteManyArgs>(args?: SelectSubset<T, employeetrunkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employeetrunks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeetrunkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employeetrunks
     * const employeetrunk = await prisma.employeetrunk.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends employeetrunkUpdateManyArgs>(args: SelectSubset<T, employeetrunkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Employeetrunk.
     * @param {employeetrunkUpsertArgs} args - Arguments to update or create a Employeetrunk.
     * @example
     * // Update or create a Employeetrunk
     * const employeetrunk = await prisma.employeetrunk.upsert({
     *   create: {
     *     // ... data to create a Employeetrunk
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employeetrunk we want to update
     *   }
     * })
     */
    upsert<T extends employeetrunkUpsertArgs>(args: SelectSubset<T, employeetrunkUpsertArgs<ExtArgs>>): Prisma__employeetrunkClient<$Result.GetResult<Prisma.$employeetrunkPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Employeetrunks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeetrunkCountArgs} args - Arguments to filter Employeetrunks to count.
     * @example
     * // Count the number of Employeetrunks
     * const count = await prisma.employeetrunk.count({
     *   where: {
     *     // ... the filter for the Employeetrunks we want to count
     *   }
     * })
    **/
    count<T extends employeetrunkCountArgs>(
      args?: Subset<T, employeetrunkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeetrunkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employeetrunk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeetrunkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeetrunkAggregateArgs>(args: Subset<T, EmployeetrunkAggregateArgs>): Prisma.PrismaPromise<GetEmployeetrunkAggregateType<T>>

    /**
     * Group by Employeetrunk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeetrunkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends employeetrunkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: employeetrunkGroupByArgs['orderBy'] }
        : { orderBy?: employeetrunkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, employeetrunkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeetrunkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the employeetrunk model
   */
  readonly fields: employeetrunkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for employeetrunk.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__employeetrunkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the employeetrunk model
   */ 
  interface employeetrunkFieldRefs {
    readonly id: FieldRef<"employeetrunk", 'Int'>
    readonly money: FieldRef<"employeetrunk", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * employeetrunk findUnique
   */
  export type employeetrunkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employeetrunk
     */
    select?: employeetrunkSelect<ExtArgs> | null
    /**
     * Filter, which employeetrunk to fetch.
     */
    where: employeetrunkWhereUniqueInput
  }

  /**
   * employeetrunk findUniqueOrThrow
   */
  export type employeetrunkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employeetrunk
     */
    select?: employeetrunkSelect<ExtArgs> | null
    /**
     * Filter, which employeetrunk to fetch.
     */
    where: employeetrunkWhereUniqueInput
  }

  /**
   * employeetrunk findFirst
   */
  export type employeetrunkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employeetrunk
     */
    select?: employeetrunkSelect<ExtArgs> | null
    /**
     * Filter, which employeetrunk to fetch.
     */
    where?: employeetrunkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employeetrunks to fetch.
     */
    orderBy?: employeetrunkOrderByWithRelationInput | employeetrunkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for employeetrunks.
     */
    cursor?: employeetrunkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employeetrunks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employeetrunks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of employeetrunks.
     */
    distinct?: EmployeetrunkScalarFieldEnum | EmployeetrunkScalarFieldEnum[]
  }

  /**
   * employeetrunk findFirstOrThrow
   */
  export type employeetrunkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employeetrunk
     */
    select?: employeetrunkSelect<ExtArgs> | null
    /**
     * Filter, which employeetrunk to fetch.
     */
    where?: employeetrunkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employeetrunks to fetch.
     */
    orderBy?: employeetrunkOrderByWithRelationInput | employeetrunkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for employeetrunks.
     */
    cursor?: employeetrunkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employeetrunks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employeetrunks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of employeetrunks.
     */
    distinct?: EmployeetrunkScalarFieldEnum | EmployeetrunkScalarFieldEnum[]
  }

  /**
   * employeetrunk findMany
   */
  export type employeetrunkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employeetrunk
     */
    select?: employeetrunkSelect<ExtArgs> | null
    /**
     * Filter, which employeetrunks to fetch.
     */
    where?: employeetrunkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employeetrunks to fetch.
     */
    orderBy?: employeetrunkOrderByWithRelationInput | employeetrunkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing employeetrunks.
     */
    cursor?: employeetrunkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employeetrunks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employeetrunks.
     */
    skip?: number
    distinct?: EmployeetrunkScalarFieldEnum | EmployeetrunkScalarFieldEnum[]
  }

  /**
   * employeetrunk create
   */
  export type employeetrunkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employeetrunk
     */
    select?: employeetrunkSelect<ExtArgs> | null
    /**
     * The data needed to create a employeetrunk.
     */
    data?: XOR<employeetrunkCreateInput, employeetrunkUncheckedCreateInput>
  }

  /**
   * employeetrunk createMany
   */
  export type employeetrunkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many employeetrunks.
     */
    data: employeetrunkCreateManyInput | employeetrunkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * employeetrunk update
   */
  export type employeetrunkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employeetrunk
     */
    select?: employeetrunkSelect<ExtArgs> | null
    /**
     * The data needed to update a employeetrunk.
     */
    data: XOR<employeetrunkUpdateInput, employeetrunkUncheckedUpdateInput>
    /**
     * Choose, which employeetrunk to update.
     */
    where: employeetrunkWhereUniqueInput
  }

  /**
   * employeetrunk updateMany
   */
  export type employeetrunkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update employeetrunks.
     */
    data: XOR<employeetrunkUpdateManyMutationInput, employeetrunkUncheckedUpdateManyInput>
    /**
     * Filter which employeetrunks to update
     */
    where?: employeetrunkWhereInput
  }

  /**
   * employeetrunk upsert
   */
  export type employeetrunkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employeetrunk
     */
    select?: employeetrunkSelect<ExtArgs> | null
    /**
     * The filter to search for the employeetrunk to update in case it exists.
     */
    where: employeetrunkWhereUniqueInput
    /**
     * In case the employeetrunk found by the `where` argument doesn't exist, create a new employeetrunk with this data.
     */
    create: XOR<employeetrunkCreateInput, employeetrunkUncheckedCreateInput>
    /**
     * In case the employeetrunk was found with the provided `where` argument, update it with this data.
     */
    update: XOR<employeetrunkUpdateInput, employeetrunkUncheckedUpdateInput>
  }

  /**
   * employeetrunk delete
   */
  export type employeetrunkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employeetrunk
     */
    select?: employeetrunkSelect<ExtArgs> | null
    /**
     * Filter which employeetrunk to delete.
     */
    where: employeetrunkWhereUniqueInput
  }

  /**
   * employeetrunk deleteMany
   */
  export type employeetrunkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which employeetrunks to delete
     */
    where?: employeetrunkWhereInput
  }

  /**
   * employeetrunk without action
   */
  export type employeetrunkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employeetrunk
     */
    select?: employeetrunkSelect<ExtArgs> | null
  }


  /**
   * Model equips
   */

  export type AggregateEquips = {
    _count: EquipsCountAggregateOutputType | null
    _avg: EquipsAvgAggregateOutputType | null
    _sum: EquipsSumAggregateOutputType | null
    _min: EquipsMinAggregateOutputType | null
    _max: EquipsMaxAggregateOutputType | null
  }

  export type EquipsAvgAggregateOutputType = {
    serialnumber: number | null
    itemid: number | null
    prevbonusexprate: number | null
    tuc: number | null
    cuc: number | null
    istr: number | null
    idex: number | null
    iint: number | null
    iluk: number | null
    imaxhp: number | null
    imaxhpr: number | null
    imaxmp: number | null
    imaxmpr: number | null
    ipad: number | null
    imad: number | null
    ipdd: number | null
    imdd: number | null
    iacc: number | null
    ieva: number | null
    icraft: number | null
    ispeed: number | null
    ijump: number | null
    arcaneid: number | null
    attribute: number | null
    leveluptype: number | null
    level: number | null
    exp: number | null
    durability: number | null
    iuc: number | null
    ipvpdamage: number | null
    ireducereq: number | null
    specialattribute: number | null
    durabilitymax: number | null
    iincreq: number | null
    growthenchant: number | null
    psenchant: number | null
    hyperupgrade: number | null
    bdr: number | null
    imdr: number | null
    damr: number | null
    statr: number | null
    cuttable: number | null
    exgradeoption: number | null
    itemstate: number | null
    grade: number | null
    chuc: number | null
    souloptionid: number | null
    soulsocketid: number | null
    souloption: number | null
    soulitemid: number | null
    rstr: number | null
    rdex: number | null
    rint: number | null
    rluk: number | null
    rlevel: number | null
    rjob: number | null
    rpop: number | null
    specialgrade: number | null
    attackspeed: number | null
    price: number | null
    charmexp: number | null
    setitemid: number | null
    fixedgrade: number | null
    nopotential: number | null
    bossreward: number | null
    superioreqp: number | null
    flameid: number | null
    android: number | null
    androidgrade: number | null
    arcane_stat: number | null
    arcane_exp: number | null
    arcane_level: number | null
    flame_str: number | null
    flame_dex: number | null
    flame_int: number | null
    flame_luk: number | null
    flame_pad: number | null
    flame_mad: number | null
    flame_pdd: number | null
    flame_hp: number | null
    flame_mp: number | null
    flame_speed: number | null
    flame_jump: number | null
    flame_allStatR: number | null
    flame_bossDamageR: number | null
    flame_damageR: number | null
    flame_reduceReqLevel: number | null
  }

  export type EquipsSumAggregateOutputType = {
    serialnumber: bigint | null
    itemid: bigint | null
    prevbonusexprate: number | null
    tuc: number | null
    cuc: number | null
    istr: number | null
    idex: number | null
    iint: number | null
    iluk: number | null
    imaxhp: number | null
    imaxhpr: number | null
    imaxmp: number | null
    imaxmpr: number | null
    ipad: number | null
    imad: number | null
    ipdd: number | null
    imdd: number | null
    iacc: number | null
    ieva: number | null
    icraft: number | null
    ispeed: number | null
    ijump: number | null
    arcaneid: bigint | null
    attribute: number | null
    leveluptype: number | null
    level: number | null
    exp: number | null
    durability: number | null
    iuc: number | null
    ipvpdamage: number | null
    ireducereq: number | null
    specialattribute: number | null
    durabilitymax: number | null
    iincreq: number | null
    growthenchant: number | null
    psenchant: number | null
    hyperupgrade: number | null
    bdr: number | null
    imdr: number | null
    damr: number | null
    statr: number | null
    cuttable: number | null
    exgradeoption: bigint | null
    itemstate: number | null
    grade: number | null
    chuc: number | null
    souloptionid: number | null
    soulsocketid: number | null
    souloption: number | null
    soulitemid: number | null
    rstr: number | null
    rdex: number | null
    rint: number | null
    rluk: number | null
    rlevel: number | null
    rjob: number | null
    rpop: number | null
    specialgrade: number | null
    attackspeed: number | null
    price: number | null
    charmexp: number | null
    setitemid: number | null
    fixedgrade: number | null
    nopotential: number | null
    bossreward: number | null
    superioreqp: number | null
    flameid: bigint | null
    android: number | null
    androidgrade: number | null
    arcane_stat: number | null
    arcane_exp: number | null
    arcane_level: number | null
    flame_str: number | null
    flame_dex: number | null
    flame_int: number | null
    flame_luk: number | null
    flame_pad: number | null
    flame_mad: number | null
    flame_pdd: number | null
    flame_hp: number | null
    flame_mp: number | null
    flame_speed: number | null
    flame_jump: number | null
    flame_allStatR: number | null
    flame_bossDamageR: number | null
    flame_damageR: number | null
    flame_reduceReqLevel: number | null
  }

  export type EquipsMinAggregateOutputType = {
    serialnumber: bigint | null
    itemid: bigint | null
    title: string | null
    equippeddate: Date | null
    prevbonusexprate: number | null
    options: string | null
    sockets: string | null
    tuc: number | null
    cuc: number | null
    istr: number | null
    idex: number | null
    iint: number | null
    iluk: number | null
    imaxhp: number | null
    imaxhpr: number | null
    imaxmp: number | null
    imaxmpr: number | null
    ipad: number | null
    imad: number | null
    ipdd: number | null
    imdd: number | null
    iacc: number | null
    ieva: number | null
    icraft: number | null
    ispeed: number | null
    ijump: number | null
    arcaneid: bigint | null
    attribute: number | null
    leveluptype: number | null
    level: number | null
    exp: number | null
    durability: number | null
    iuc: number | null
    ipvpdamage: number | null
    ireducereq: number | null
    specialattribute: number | null
    durabilitymax: number | null
    iincreq: number | null
    growthenchant: number | null
    psenchant: number | null
    hyperupgrade: number | null
    bdr: number | null
    imdr: number | null
    damr: number | null
    statr: number | null
    cuttable: number | null
    exgradeoption: bigint | null
    itemstate: number | null
    grade: number | null
    chuc: number | null
    souloptionid: number | null
    soulsocketid: number | null
    souloption: number | null
    soulitemid: number | null
    rstr: number | null
    rdex: number | null
    rint: number | null
    rluk: number | null
    rlevel: number | null
    rjob: number | null
    rpop: number | null
    specialgrade: number | null
    fixedpotential: boolean | null
    tradeblock: boolean | null
    isonly: boolean | null
    notsale: boolean | null
    attackspeed: number | null
    price: number | null
    charmexp: number | null
    setitemid: number | null
    exitem: boolean | null
    equiptradeblock: boolean | null
    islot: string | null
    vslot: string | null
    fixedgrade: number | null
    nopotential: number | null
    bossreward: number | null
    superioreqp: number | null
    flameid: bigint | null
    android: number | null
    androidgrade: number | null
    arcane_stat: number | null
    arcane_exp: number | null
    arcane_level: number | null
    flame_str: number | null
    flame_dex: number | null
    flame_int: number | null
    flame_luk: number | null
    flame_pad: number | null
    flame_mad: number | null
    flame_pdd: number | null
    flame_hp: number | null
    flame_mp: number | null
    flame_speed: number | null
    flame_jump: number | null
    flame_allStatR: number | null
    flame_bossDamageR: number | null
    flame_damageR: number | null
    flame_reduceReqLevel: number | null
  }

  export type EquipsMaxAggregateOutputType = {
    serialnumber: bigint | null
    itemid: bigint | null
    title: string | null
    equippeddate: Date | null
    prevbonusexprate: number | null
    options: string | null
    sockets: string | null
    tuc: number | null
    cuc: number | null
    istr: number | null
    idex: number | null
    iint: number | null
    iluk: number | null
    imaxhp: number | null
    imaxhpr: number | null
    imaxmp: number | null
    imaxmpr: number | null
    ipad: number | null
    imad: number | null
    ipdd: number | null
    imdd: number | null
    iacc: number | null
    ieva: number | null
    icraft: number | null
    ispeed: number | null
    ijump: number | null
    arcaneid: bigint | null
    attribute: number | null
    leveluptype: number | null
    level: number | null
    exp: number | null
    durability: number | null
    iuc: number | null
    ipvpdamage: number | null
    ireducereq: number | null
    specialattribute: number | null
    durabilitymax: number | null
    iincreq: number | null
    growthenchant: number | null
    psenchant: number | null
    hyperupgrade: number | null
    bdr: number | null
    imdr: number | null
    damr: number | null
    statr: number | null
    cuttable: number | null
    exgradeoption: bigint | null
    itemstate: number | null
    grade: number | null
    chuc: number | null
    souloptionid: number | null
    soulsocketid: number | null
    souloption: number | null
    soulitemid: number | null
    rstr: number | null
    rdex: number | null
    rint: number | null
    rluk: number | null
    rlevel: number | null
    rjob: number | null
    rpop: number | null
    specialgrade: number | null
    fixedpotential: boolean | null
    tradeblock: boolean | null
    isonly: boolean | null
    notsale: boolean | null
    attackspeed: number | null
    price: number | null
    charmexp: number | null
    setitemid: number | null
    exitem: boolean | null
    equiptradeblock: boolean | null
    islot: string | null
    vslot: string | null
    fixedgrade: number | null
    nopotential: number | null
    bossreward: number | null
    superioreqp: number | null
    flameid: bigint | null
    android: number | null
    androidgrade: number | null
    arcane_stat: number | null
    arcane_exp: number | null
    arcane_level: number | null
    flame_str: number | null
    flame_dex: number | null
    flame_int: number | null
    flame_luk: number | null
    flame_pad: number | null
    flame_mad: number | null
    flame_pdd: number | null
    flame_hp: number | null
    flame_mp: number | null
    flame_speed: number | null
    flame_jump: number | null
    flame_allStatR: number | null
    flame_bossDamageR: number | null
    flame_damageR: number | null
    flame_reduceReqLevel: number | null
  }

  export type EquipsCountAggregateOutputType = {
    serialnumber: number
    itemid: number
    title: number
    equippeddate: number
    prevbonusexprate: number
    options: number
    sockets: number
    tuc: number
    cuc: number
    istr: number
    idex: number
    iint: number
    iluk: number
    imaxhp: number
    imaxhpr: number
    imaxmp: number
    imaxmpr: number
    ipad: number
    imad: number
    ipdd: number
    imdd: number
    iacc: number
    ieva: number
    icraft: number
    ispeed: number
    ijump: number
    arcaneid: number
    attribute: number
    leveluptype: number
    level: number
    exp: number
    durability: number
    iuc: number
    ipvpdamage: number
    ireducereq: number
    specialattribute: number
    durabilitymax: number
    iincreq: number
    growthenchant: number
    psenchant: number
    hyperupgrade: number
    bdr: number
    imdr: number
    damr: number
    statr: number
    cuttable: number
    exgradeoption: number
    itemstate: number
    grade: number
    chuc: number
    souloptionid: number
    soulsocketid: number
    souloption: number
    soulitemid: number
    rstr: number
    rdex: number
    rint: number
    rluk: number
    rlevel: number
    rjob: number
    rpop: number
    specialgrade: number
    fixedpotential: number
    tradeblock: number
    isonly: number
    notsale: number
    attackspeed: number
    price: number
    charmexp: number
    setitemid: number
    exitem: number
    equiptradeblock: number
    islot: number
    vslot: number
    fixedgrade: number
    nopotential: number
    bossreward: number
    superioreqp: number
    flameid: number
    android: number
    androidgrade: number
    arcane_stat: number
    arcane_exp: number
    arcane_level: number
    flame_str: number
    flame_dex: number
    flame_int: number
    flame_luk: number
    flame_pad: number
    flame_mad: number
    flame_pdd: number
    flame_hp: number
    flame_mp: number
    flame_speed: number
    flame_jump: number
    flame_allStatR: number
    flame_bossDamageR: number
    flame_damageR: number
    flame_reduceReqLevel: number
    _all: number
  }


  export type EquipsAvgAggregateInputType = {
    serialnumber?: true
    itemid?: true
    prevbonusexprate?: true
    tuc?: true
    cuc?: true
    istr?: true
    idex?: true
    iint?: true
    iluk?: true
    imaxhp?: true
    imaxhpr?: true
    imaxmp?: true
    imaxmpr?: true
    ipad?: true
    imad?: true
    ipdd?: true
    imdd?: true
    iacc?: true
    ieva?: true
    icraft?: true
    ispeed?: true
    ijump?: true
    arcaneid?: true
    attribute?: true
    leveluptype?: true
    level?: true
    exp?: true
    durability?: true
    iuc?: true
    ipvpdamage?: true
    ireducereq?: true
    specialattribute?: true
    durabilitymax?: true
    iincreq?: true
    growthenchant?: true
    psenchant?: true
    hyperupgrade?: true
    bdr?: true
    imdr?: true
    damr?: true
    statr?: true
    cuttable?: true
    exgradeoption?: true
    itemstate?: true
    grade?: true
    chuc?: true
    souloptionid?: true
    soulsocketid?: true
    souloption?: true
    soulitemid?: true
    rstr?: true
    rdex?: true
    rint?: true
    rluk?: true
    rlevel?: true
    rjob?: true
    rpop?: true
    specialgrade?: true
    attackspeed?: true
    price?: true
    charmexp?: true
    setitemid?: true
    fixedgrade?: true
    nopotential?: true
    bossreward?: true
    superioreqp?: true
    flameid?: true
    android?: true
    androidgrade?: true
    arcane_stat?: true
    arcane_exp?: true
    arcane_level?: true
    flame_str?: true
    flame_dex?: true
    flame_int?: true
    flame_luk?: true
    flame_pad?: true
    flame_mad?: true
    flame_pdd?: true
    flame_hp?: true
    flame_mp?: true
    flame_speed?: true
    flame_jump?: true
    flame_allStatR?: true
    flame_bossDamageR?: true
    flame_damageR?: true
    flame_reduceReqLevel?: true
  }

  export type EquipsSumAggregateInputType = {
    serialnumber?: true
    itemid?: true
    prevbonusexprate?: true
    tuc?: true
    cuc?: true
    istr?: true
    idex?: true
    iint?: true
    iluk?: true
    imaxhp?: true
    imaxhpr?: true
    imaxmp?: true
    imaxmpr?: true
    ipad?: true
    imad?: true
    ipdd?: true
    imdd?: true
    iacc?: true
    ieva?: true
    icraft?: true
    ispeed?: true
    ijump?: true
    arcaneid?: true
    attribute?: true
    leveluptype?: true
    level?: true
    exp?: true
    durability?: true
    iuc?: true
    ipvpdamage?: true
    ireducereq?: true
    specialattribute?: true
    durabilitymax?: true
    iincreq?: true
    growthenchant?: true
    psenchant?: true
    hyperupgrade?: true
    bdr?: true
    imdr?: true
    damr?: true
    statr?: true
    cuttable?: true
    exgradeoption?: true
    itemstate?: true
    grade?: true
    chuc?: true
    souloptionid?: true
    soulsocketid?: true
    souloption?: true
    soulitemid?: true
    rstr?: true
    rdex?: true
    rint?: true
    rluk?: true
    rlevel?: true
    rjob?: true
    rpop?: true
    specialgrade?: true
    attackspeed?: true
    price?: true
    charmexp?: true
    setitemid?: true
    fixedgrade?: true
    nopotential?: true
    bossreward?: true
    superioreqp?: true
    flameid?: true
    android?: true
    androidgrade?: true
    arcane_stat?: true
    arcane_exp?: true
    arcane_level?: true
    flame_str?: true
    flame_dex?: true
    flame_int?: true
    flame_luk?: true
    flame_pad?: true
    flame_mad?: true
    flame_pdd?: true
    flame_hp?: true
    flame_mp?: true
    flame_speed?: true
    flame_jump?: true
    flame_allStatR?: true
    flame_bossDamageR?: true
    flame_damageR?: true
    flame_reduceReqLevel?: true
  }

  export type EquipsMinAggregateInputType = {
    serialnumber?: true
    itemid?: true
    title?: true
    equippeddate?: true
    prevbonusexprate?: true
    options?: true
    sockets?: true
    tuc?: true
    cuc?: true
    istr?: true
    idex?: true
    iint?: true
    iluk?: true
    imaxhp?: true
    imaxhpr?: true
    imaxmp?: true
    imaxmpr?: true
    ipad?: true
    imad?: true
    ipdd?: true
    imdd?: true
    iacc?: true
    ieva?: true
    icraft?: true
    ispeed?: true
    ijump?: true
    arcaneid?: true
    attribute?: true
    leveluptype?: true
    level?: true
    exp?: true
    durability?: true
    iuc?: true
    ipvpdamage?: true
    ireducereq?: true
    specialattribute?: true
    durabilitymax?: true
    iincreq?: true
    growthenchant?: true
    psenchant?: true
    hyperupgrade?: true
    bdr?: true
    imdr?: true
    damr?: true
    statr?: true
    cuttable?: true
    exgradeoption?: true
    itemstate?: true
    grade?: true
    chuc?: true
    souloptionid?: true
    soulsocketid?: true
    souloption?: true
    soulitemid?: true
    rstr?: true
    rdex?: true
    rint?: true
    rluk?: true
    rlevel?: true
    rjob?: true
    rpop?: true
    specialgrade?: true
    fixedpotential?: true
    tradeblock?: true
    isonly?: true
    notsale?: true
    attackspeed?: true
    price?: true
    charmexp?: true
    setitemid?: true
    exitem?: true
    equiptradeblock?: true
    islot?: true
    vslot?: true
    fixedgrade?: true
    nopotential?: true
    bossreward?: true
    superioreqp?: true
    flameid?: true
    android?: true
    androidgrade?: true
    arcane_stat?: true
    arcane_exp?: true
    arcane_level?: true
    flame_str?: true
    flame_dex?: true
    flame_int?: true
    flame_luk?: true
    flame_pad?: true
    flame_mad?: true
    flame_pdd?: true
    flame_hp?: true
    flame_mp?: true
    flame_speed?: true
    flame_jump?: true
    flame_allStatR?: true
    flame_bossDamageR?: true
    flame_damageR?: true
    flame_reduceReqLevel?: true
  }

  export type EquipsMaxAggregateInputType = {
    serialnumber?: true
    itemid?: true
    title?: true
    equippeddate?: true
    prevbonusexprate?: true
    options?: true
    sockets?: true
    tuc?: true
    cuc?: true
    istr?: true
    idex?: true
    iint?: true
    iluk?: true
    imaxhp?: true
    imaxhpr?: true
    imaxmp?: true
    imaxmpr?: true
    ipad?: true
    imad?: true
    ipdd?: true
    imdd?: true
    iacc?: true
    ieva?: true
    icraft?: true
    ispeed?: true
    ijump?: true
    arcaneid?: true
    attribute?: true
    leveluptype?: true
    level?: true
    exp?: true
    durability?: true
    iuc?: true
    ipvpdamage?: true
    ireducereq?: true
    specialattribute?: true
    durabilitymax?: true
    iincreq?: true
    growthenchant?: true
    psenchant?: true
    hyperupgrade?: true
    bdr?: true
    imdr?: true
    damr?: true
    statr?: true
    cuttable?: true
    exgradeoption?: true
    itemstate?: true
    grade?: true
    chuc?: true
    souloptionid?: true
    soulsocketid?: true
    souloption?: true
    soulitemid?: true
    rstr?: true
    rdex?: true
    rint?: true
    rluk?: true
    rlevel?: true
    rjob?: true
    rpop?: true
    specialgrade?: true
    fixedpotential?: true
    tradeblock?: true
    isonly?: true
    notsale?: true
    attackspeed?: true
    price?: true
    charmexp?: true
    setitemid?: true
    exitem?: true
    equiptradeblock?: true
    islot?: true
    vslot?: true
    fixedgrade?: true
    nopotential?: true
    bossreward?: true
    superioreqp?: true
    flameid?: true
    android?: true
    androidgrade?: true
    arcane_stat?: true
    arcane_exp?: true
    arcane_level?: true
    flame_str?: true
    flame_dex?: true
    flame_int?: true
    flame_luk?: true
    flame_pad?: true
    flame_mad?: true
    flame_pdd?: true
    flame_hp?: true
    flame_mp?: true
    flame_speed?: true
    flame_jump?: true
    flame_allStatR?: true
    flame_bossDamageR?: true
    flame_damageR?: true
    flame_reduceReqLevel?: true
  }

  export type EquipsCountAggregateInputType = {
    serialnumber?: true
    itemid?: true
    title?: true
    equippeddate?: true
    prevbonusexprate?: true
    options?: true
    sockets?: true
    tuc?: true
    cuc?: true
    istr?: true
    idex?: true
    iint?: true
    iluk?: true
    imaxhp?: true
    imaxhpr?: true
    imaxmp?: true
    imaxmpr?: true
    ipad?: true
    imad?: true
    ipdd?: true
    imdd?: true
    iacc?: true
    ieva?: true
    icraft?: true
    ispeed?: true
    ijump?: true
    arcaneid?: true
    attribute?: true
    leveluptype?: true
    level?: true
    exp?: true
    durability?: true
    iuc?: true
    ipvpdamage?: true
    ireducereq?: true
    specialattribute?: true
    durabilitymax?: true
    iincreq?: true
    growthenchant?: true
    psenchant?: true
    hyperupgrade?: true
    bdr?: true
    imdr?: true
    damr?: true
    statr?: true
    cuttable?: true
    exgradeoption?: true
    itemstate?: true
    grade?: true
    chuc?: true
    souloptionid?: true
    soulsocketid?: true
    souloption?: true
    soulitemid?: true
    rstr?: true
    rdex?: true
    rint?: true
    rluk?: true
    rlevel?: true
    rjob?: true
    rpop?: true
    specialgrade?: true
    fixedpotential?: true
    tradeblock?: true
    isonly?: true
    notsale?: true
    attackspeed?: true
    price?: true
    charmexp?: true
    setitemid?: true
    exitem?: true
    equiptradeblock?: true
    islot?: true
    vslot?: true
    fixedgrade?: true
    nopotential?: true
    bossreward?: true
    superioreqp?: true
    flameid?: true
    android?: true
    androidgrade?: true
    arcane_stat?: true
    arcane_exp?: true
    arcane_level?: true
    flame_str?: true
    flame_dex?: true
    flame_int?: true
    flame_luk?: true
    flame_pad?: true
    flame_mad?: true
    flame_pdd?: true
    flame_hp?: true
    flame_mp?: true
    flame_speed?: true
    flame_jump?: true
    flame_allStatR?: true
    flame_bossDamageR?: true
    flame_damageR?: true
    flame_reduceReqLevel?: true
    _all?: true
  }

  export type EquipsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which equips to aggregate.
     */
    where?: equipsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of equips to fetch.
     */
    orderBy?: equipsOrderByWithRelationInput | equipsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: equipsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` equips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` equips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned equips
    **/
    _count?: true | EquipsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EquipsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EquipsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EquipsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EquipsMaxAggregateInputType
  }

  export type GetEquipsAggregateType<T extends EquipsAggregateArgs> = {
        [P in keyof T & keyof AggregateEquips]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEquips[P]>
      : GetScalarType<T[P], AggregateEquips[P]>
  }




  export type equipsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: equipsWhereInput
    orderBy?: equipsOrderByWithAggregationInput | equipsOrderByWithAggregationInput[]
    by: EquipsScalarFieldEnum[] | EquipsScalarFieldEnum
    having?: equipsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EquipsCountAggregateInputType | true
    _avg?: EquipsAvgAggregateInputType
    _sum?: EquipsSumAggregateInputType
    _min?: EquipsMinAggregateInputType
    _max?: EquipsMaxAggregateInputType
  }

  export type EquipsGroupByOutputType = {
    serialnumber: bigint | null
    itemid: bigint
    title: string | null
    equippeddate: Date | null
    prevbonusexprate: number | null
    options: string | null
    sockets: string | null
    tuc: number | null
    cuc: number | null
    istr: number | null
    idex: number | null
    iint: number | null
    iluk: number | null
    imaxhp: number | null
    imaxhpr: number
    imaxmp: number | null
    imaxmpr: number
    ipad: number | null
    imad: number | null
    ipdd: number | null
    imdd: number | null
    iacc: number | null
    ieva: number | null
    icraft: number | null
    ispeed: number | null
    ijump: number | null
    arcaneid: bigint | null
    attribute: number | null
    leveluptype: number | null
    level: number | null
    exp: number | null
    durability: number | null
    iuc: number | null
    ipvpdamage: number | null
    ireducereq: number | null
    specialattribute: number | null
    durabilitymax: number | null
    iincreq: number | null
    growthenchant: number | null
    psenchant: number | null
    hyperupgrade: number | null
    bdr: number | null
    imdr: number | null
    damr: number | null
    statr: number | null
    cuttable: number | null
    exgradeoption: bigint | null
    itemstate: number | null
    grade: number | null
    chuc: number | null
    souloptionid: number | null
    soulsocketid: number | null
    souloption: number | null
    soulitemid: number | null
    rstr: number | null
    rdex: number | null
    rint: number | null
    rluk: number | null
    rlevel: number | null
    rjob: number | null
    rpop: number | null
    specialgrade: number | null
    fixedpotential: boolean | null
    tradeblock: boolean | null
    isonly: boolean | null
    notsale: boolean | null
    attackspeed: number | null
    price: number | null
    charmexp: number | null
    setitemid: number | null
    exitem: boolean | null
    equiptradeblock: boolean | null
    islot: string | null
    vslot: string | null
    fixedgrade: number | null
    nopotential: number | null
    bossreward: number | null
    superioreqp: number | null
    flameid: bigint | null
    android: number | null
    androidgrade: number | null
    arcane_stat: number | null
    arcane_exp: number | null
    arcane_level: number | null
    flame_str: number | null
    flame_dex: number | null
    flame_int: number | null
    flame_luk: number | null
    flame_pad: number | null
    flame_mad: number | null
    flame_pdd: number | null
    flame_hp: number | null
    flame_mp: number | null
    flame_speed: number | null
    flame_jump: number | null
    flame_allStatR: number | null
    flame_bossDamageR: number | null
    flame_damageR: number | null
    flame_reduceReqLevel: number | null
    _count: EquipsCountAggregateOutputType | null
    _avg: EquipsAvgAggregateOutputType | null
    _sum: EquipsSumAggregateOutputType | null
    _min: EquipsMinAggregateOutputType | null
    _max: EquipsMaxAggregateOutputType | null
  }

  type GetEquipsGroupByPayload<T extends equipsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EquipsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EquipsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EquipsGroupByOutputType[P]>
            : GetScalarType<T[P], EquipsGroupByOutputType[P]>
        }
      >
    >


  export type equipsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    serialnumber?: boolean
    itemid?: boolean
    title?: boolean
    equippeddate?: boolean
    prevbonusexprate?: boolean
    options?: boolean
    sockets?: boolean
    tuc?: boolean
    cuc?: boolean
    istr?: boolean
    idex?: boolean
    iint?: boolean
    iluk?: boolean
    imaxhp?: boolean
    imaxhpr?: boolean
    imaxmp?: boolean
    imaxmpr?: boolean
    ipad?: boolean
    imad?: boolean
    ipdd?: boolean
    imdd?: boolean
    iacc?: boolean
    ieva?: boolean
    icraft?: boolean
    ispeed?: boolean
    ijump?: boolean
    arcaneid?: boolean
    attribute?: boolean
    leveluptype?: boolean
    level?: boolean
    exp?: boolean
    durability?: boolean
    iuc?: boolean
    ipvpdamage?: boolean
    ireducereq?: boolean
    specialattribute?: boolean
    durabilitymax?: boolean
    iincreq?: boolean
    growthenchant?: boolean
    psenchant?: boolean
    hyperupgrade?: boolean
    bdr?: boolean
    imdr?: boolean
    damr?: boolean
    statr?: boolean
    cuttable?: boolean
    exgradeoption?: boolean
    itemstate?: boolean
    grade?: boolean
    chuc?: boolean
    souloptionid?: boolean
    soulsocketid?: boolean
    souloption?: boolean
    soulitemid?: boolean
    rstr?: boolean
    rdex?: boolean
    rint?: boolean
    rluk?: boolean
    rlevel?: boolean
    rjob?: boolean
    rpop?: boolean
    specialgrade?: boolean
    fixedpotential?: boolean
    tradeblock?: boolean
    isonly?: boolean
    notsale?: boolean
    attackspeed?: boolean
    price?: boolean
    charmexp?: boolean
    setitemid?: boolean
    exitem?: boolean
    equiptradeblock?: boolean
    islot?: boolean
    vslot?: boolean
    fixedgrade?: boolean
    nopotential?: boolean
    bossreward?: boolean
    superioreqp?: boolean
    flameid?: boolean
    android?: boolean
    androidgrade?: boolean
    arcane_stat?: boolean
    arcane_exp?: boolean
    arcane_level?: boolean
    flame_str?: boolean
    flame_dex?: boolean
    flame_int?: boolean
    flame_luk?: boolean
    flame_pad?: boolean
    flame_mad?: boolean
    flame_pdd?: boolean
    flame_hp?: boolean
    flame_mp?: boolean
    flame_speed?: boolean
    flame_jump?: boolean
    flame_allStatR?: boolean
    flame_bossDamageR?: boolean
    flame_damageR?: boolean
    flame_reduceReqLevel?: boolean
  }, ExtArgs["result"]["equips"]>


  export type equipsSelectScalar = {
    serialnumber?: boolean
    itemid?: boolean
    title?: boolean
    equippeddate?: boolean
    prevbonusexprate?: boolean
    options?: boolean
    sockets?: boolean
    tuc?: boolean
    cuc?: boolean
    istr?: boolean
    idex?: boolean
    iint?: boolean
    iluk?: boolean
    imaxhp?: boolean
    imaxhpr?: boolean
    imaxmp?: boolean
    imaxmpr?: boolean
    ipad?: boolean
    imad?: boolean
    ipdd?: boolean
    imdd?: boolean
    iacc?: boolean
    ieva?: boolean
    icraft?: boolean
    ispeed?: boolean
    ijump?: boolean
    arcaneid?: boolean
    attribute?: boolean
    leveluptype?: boolean
    level?: boolean
    exp?: boolean
    durability?: boolean
    iuc?: boolean
    ipvpdamage?: boolean
    ireducereq?: boolean
    specialattribute?: boolean
    durabilitymax?: boolean
    iincreq?: boolean
    growthenchant?: boolean
    psenchant?: boolean
    hyperupgrade?: boolean
    bdr?: boolean
    imdr?: boolean
    damr?: boolean
    statr?: boolean
    cuttable?: boolean
    exgradeoption?: boolean
    itemstate?: boolean
    grade?: boolean
    chuc?: boolean
    souloptionid?: boolean
    soulsocketid?: boolean
    souloption?: boolean
    soulitemid?: boolean
    rstr?: boolean
    rdex?: boolean
    rint?: boolean
    rluk?: boolean
    rlevel?: boolean
    rjob?: boolean
    rpop?: boolean
    specialgrade?: boolean
    fixedpotential?: boolean
    tradeblock?: boolean
    isonly?: boolean
    notsale?: boolean
    attackspeed?: boolean
    price?: boolean
    charmexp?: boolean
    setitemid?: boolean
    exitem?: boolean
    equiptradeblock?: boolean
    islot?: boolean
    vslot?: boolean
    fixedgrade?: boolean
    nopotential?: boolean
    bossreward?: boolean
    superioreqp?: boolean
    flameid?: boolean
    android?: boolean
    androidgrade?: boolean
    arcane_stat?: boolean
    arcane_exp?: boolean
    arcane_level?: boolean
    flame_str?: boolean
    flame_dex?: boolean
    flame_int?: boolean
    flame_luk?: boolean
    flame_pad?: boolean
    flame_mad?: boolean
    flame_pdd?: boolean
    flame_hp?: boolean
    flame_mp?: boolean
    flame_speed?: boolean
    flame_jump?: boolean
    flame_allStatR?: boolean
    flame_bossDamageR?: boolean
    flame_damageR?: boolean
    flame_reduceReqLevel?: boolean
  }


  export type $equipsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "equips"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      serialnumber: bigint | null
      itemid: bigint
      title: string | null
      equippeddate: Date | null
      prevbonusexprate: number | null
      options: string | null
      sockets: string | null
      tuc: number | null
      cuc: number | null
      istr: number | null
      idex: number | null
      iint: number | null
      iluk: number | null
      imaxhp: number | null
      imaxhpr: number
      imaxmp: number | null
      imaxmpr: number
      ipad: number | null
      imad: number | null
      ipdd: number | null
      imdd: number | null
      iacc: number | null
      ieva: number | null
      icraft: number | null
      ispeed: number | null
      ijump: number | null
      arcaneid: bigint | null
      attribute: number | null
      leveluptype: number | null
      level: number | null
      exp: number | null
      durability: number | null
      iuc: number | null
      ipvpdamage: number | null
      ireducereq: number | null
      specialattribute: number | null
      durabilitymax: number | null
      iincreq: number | null
      growthenchant: number | null
      psenchant: number | null
      hyperupgrade: number | null
      bdr: number | null
      imdr: number | null
      damr: number | null
      statr: number | null
      cuttable: number | null
      exgradeoption: bigint | null
      itemstate: number | null
      grade: number | null
      chuc: number | null
      souloptionid: number | null
      soulsocketid: number | null
      souloption: number | null
      soulitemid: number | null
      rstr: number | null
      rdex: number | null
      rint: number | null
      rluk: number | null
      rlevel: number | null
      rjob: number | null
      rpop: number | null
      specialgrade: number | null
      fixedpotential: boolean | null
      tradeblock: boolean | null
      isonly: boolean | null
      notsale: boolean | null
      attackspeed: number | null
      price: number | null
      charmexp: number | null
      setitemid: number | null
      exitem: boolean | null
      equiptradeblock: boolean | null
      islot: string | null
      vslot: string | null
      fixedgrade: number | null
      nopotential: number | null
      bossreward: number | null
      superioreqp: number | null
      flameid: bigint | null
      android: number | null
      androidgrade: number | null
      arcane_stat: number | null
      arcane_exp: number | null
      arcane_level: number | null
      flame_str: number | null
      flame_dex: number | null
      flame_int: number | null
      flame_luk: number | null
      flame_pad: number | null
      flame_mad: number | null
      flame_pdd: number | null
      flame_hp: number | null
      flame_mp: number | null
      flame_speed: number | null
      flame_jump: number | null
      flame_allStatR: number | null
      flame_bossDamageR: number | null
      flame_damageR: number | null
      flame_reduceReqLevel: number | null
    }, ExtArgs["result"]["equips"]>
    composites: {}
  }

  type equipsGetPayload<S extends boolean | null | undefined | equipsDefaultArgs> = $Result.GetResult<Prisma.$equipsPayload, S>

  type equipsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<equipsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EquipsCountAggregateInputType | true
    }

  export interface equipsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['equips'], meta: { name: 'equips' } }
    /**
     * Find zero or one Equips that matches the filter.
     * @param {equipsFindUniqueArgs} args - Arguments to find a Equips
     * @example
     * // Get one Equips
     * const equips = await prisma.equips.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends equipsFindUniqueArgs>(args: SelectSubset<T, equipsFindUniqueArgs<ExtArgs>>): Prisma__equipsClient<$Result.GetResult<Prisma.$equipsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Equips that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {equipsFindUniqueOrThrowArgs} args - Arguments to find a Equips
     * @example
     * // Get one Equips
     * const equips = await prisma.equips.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends equipsFindUniqueOrThrowArgs>(args: SelectSubset<T, equipsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__equipsClient<$Result.GetResult<Prisma.$equipsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Equips that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipsFindFirstArgs} args - Arguments to find a Equips
     * @example
     * // Get one Equips
     * const equips = await prisma.equips.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends equipsFindFirstArgs>(args?: SelectSubset<T, equipsFindFirstArgs<ExtArgs>>): Prisma__equipsClient<$Result.GetResult<Prisma.$equipsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Equips that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipsFindFirstOrThrowArgs} args - Arguments to find a Equips
     * @example
     * // Get one Equips
     * const equips = await prisma.equips.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends equipsFindFirstOrThrowArgs>(args?: SelectSubset<T, equipsFindFirstOrThrowArgs<ExtArgs>>): Prisma__equipsClient<$Result.GetResult<Prisma.$equipsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Equips that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Equips
     * const equips = await prisma.equips.findMany()
     * 
     * // Get first 10 Equips
     * const equips = await prisma.equips.findMany({ take: 10 })
     * 
     * // Only select the `serialnumber`
     * const equipsWithSerialnumberOnly = await prisma.equips.findMany({ select: { serialnumber: true } })
     * 
     */
    findMany<T extends equipsFindManyArgs>(args?: SelectSubset<T, equipsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$equipsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Equips.
     * @param {equipsCreateArgs} args - Arguments to create a Equips.
     * @example
     * // Create one Equips
     * const Equips = await prisma.equips.create({
     *   data: {
     *     // ... data to create a Equips
     *   }
     * })
     * 
     */
    create<T extends equipsCreateArgs>(args: SelectSubset<T, equipsCreateArgs<ExtArgs>>): Prisma__equipsClient<$Result.GetResult<Prisma.$equipsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Equips.
     * @param {equipsCreateManyArgs} args - Arguments to create many Equips.
     * @example
     * // Create many Equips
     * const equips = await prisma.equips.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends equipsCreateManyArgs>(args?: SelectSubset<T, equipsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Equips.
     * @param {equipsDeleteArgs} args - Arguments to delete one Equips.
     * @example
     * // Delete one Equips
     * const Equips = await prisma.equips.delete({
     *   where: {
     *     // ... filter to delete one Equips
     *   }
     * })
     * 
     */
    delete<T extends equipsDeleteArgs>(args: SelectSubset<T, equipsDeleteArgs<ExtArgs>>): Prisma__equipsClient<$Result.GetResult<Prisma.$equipsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Equips.
     * @param {equipsUpdateArgs} args - Arguments to update one Equips.
     * @example
     * // Update one Equips
     * const equips = await prisma.equips.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends equipsUpdateArgs>(args: SelectSubset<T, equipsUpdateArgs<ExtArgs>>): Prisma__equipsClient<$Result.GetResult<Prisma.$equipsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Equips.
     * @param {equipsDeleteManyArgs} args - Arguments to filter Equips to delete.
     * @example
     * // Delete a few Equips
     * const { count } = await prisma.equips.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends equipsDeleteManyArgs>(args?: SelectSubset<T, equipsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Equips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Equips
     * const equips = await prisma.equips.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends equipsUpdateManyArgs>(args: SelectSubset<T, equipsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Equips.
     * @param {equipsUpsertArgs} args - Arguments to update or create a Equips.
     * @example
     * // Update or create a Equips
     * const equips = await prisma.equips.upsert({
     *   create: {
     *     // ... data to create a Equips
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Equips we want to update
     *   }
     * })
     */
    upsert<T extends equipsUpsertArgs>(args: SelectSubset<T, equipsUpsertArgs<ExtArgs>>): Prisma__equipsClient<$Result.GetResult<Prisma.$equipsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Equips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipsCountArgs} args - Arguments to filter Equips to count.
     * @example
     * // Count the number of Equips
     * const count = await prisma.equips.count({
     *   where: {
     *     // ... the filter for the Equips we want to count
     *   }
     * })
    **/
    count<T extends equipsCountArgs>(
      args?: Subset<T, equipsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EquipsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Equips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EquipsAggregateArgs>(args: Subset<T, EquipsAggregateArgs>): Prisma.PrismaPromise<GetEquipsAggregateType<T>>

    /**
     * Group by Equips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends equipsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: equipsGroupByArgs['orderBy'] }
        : { orderBy?: equipsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, equipsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEquipsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the equips model
   */
  readonly fields: equipsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for equips.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__equipsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the equips model
   */ 
  interface equipsFieldRefs {
    readonly serialnumber: FieldRef<"equips", 'BigInt'>
    readonly itemid: FieldRef<"equips", 'BigInt'>
    readonly title: FieldRef<"equips", 'String'>
    readonly equippeddate: FieldRef<"equips", 'DateTime'>
    readonly prevbonusexprate: FieldRef<"equips", 'Int'>
    readonly options: FieldRef<"equips", 'String'>
    readonly sockets: FieldRef<"equips", 'String'>
    readonly tuc: FieldRef<"equips", 'Int'>
    readonly cuc: FieldRef<"equips", 'Int'>
    readonly istr: FieldRef<"equips", 'Int'>
    readonly idex: FieldRef<"equips", 'Int'>
    readonly iint: FieldRef<"equips", 'Int'>
    readonly iluk: FieldRef<"equips", 'Int'>
    readonly imaxhp: FieldRef<"equips", 'Int'>
    readonly imaxhpr: FieldRef<"equips", 'Int'>
    readonly imaxmp: FieldRef<"equips", 'Int'>
    readonly imaxmpr: FieldRef<"equips", 'Int'>
    readonly ipad: FieldRef<"equips", 'Int'>
    readonly imad: FieldRef<"equips", 'Int'>
    readonly ipdd: FieldRef<"equips", 'Int'>
    readonly imdd: FieldRef<"equips", 'Int'>
    readonly iacc: FieldRef<"equips", 'Int'>
    readonly ieva: FieldRef<"equips", 'Int'>
    readonly icraft: FieldRef<"equips", 'Int'>
    readonly ispeed: FieldRef<"equips", 'Int'>
    readonly ijump: FieldRef<"equips", 'Int'>
    readonly arcaneid: FieldRef<"equips", 'BigInt'>
    readonly attribute: FieldRef<"equips", 'Int'>
    readonly leveluptype: FieldRef<"equips", 'Int'>
    readonly level: FieldRef<"equips", 'Int'>
    readonly exp: FieldRef<"equips", 'Int'>
    readonly durability: FieldRef<"equips", 'Int'>
    readonly iuc: FieldRef<"equips", 'Int'>
    readonly ipvpdamage: FieldRef<"equips", 'Int'>
    readonly ireducereq: FieldRef<"equips", 'Int'>
    readonly specialattribute: FieldRef<"equips", 'Int'>
    readonly durabilitymax: FieldRef<"equips", 'Int'>
    readonly iincreq: FieldRef<"equips", 'Int'>
    readonly growthenchant: FieldRef<"equips", 'Int'>
    readonly psenchant: FieldRef<"equips", 'Int'>
    readonly hyperupgrade: FieldRef<"equips", 'Int'>
    readonly bdr: FieldRef<"equips", 'Int'>
    readonly imdr: FieldRef<"equips", 'Int'>
    readonly damr: FieldRef<"equips", 'Int'>
    readonly statr: FieldRef<"equips", 'Int'>
    readonly cuttable: FieldRef<"equips", 'Int'>
    readonly exgradeoption: FieldRef<"equips", 'BigInt'>
    readonly itemstate: FieldRef<"equips", 'Int'>
    readonly grade: FieldRef<"equips", 'Int'>
    readonly chuc: FieldRef<"equips", 'Int'>
    readonly souloptionid: FieldRef<"equips", 'Int'>
    readonly soulsocketid: FieldRef<"equips", 'Int'>
    readonly souloption: FieldRef<"equips", 'Int'>
    readonly soulitemid: FieldRef<"equips", 'Int'>
    readonly rstr: FieldRef<"equips", 'Int'>
    readonly rdex: FieldRef<"equips", 'Int'>
    readonly rint: FieldRef<"equips", 'Int'>
    readonly rluk: FieldRef<"equips", 'Int'>
    readonly rlevel: FieldRef<"equips", 'Int'>
    readonly rjob: FieldRef<"equips", 'Int'>
    readonly rpop: FieldRef<"equips", 'Int'>
    readonly specialgrade: FieldRef<"equips", 'Int'>
    readonly fixedpotential: FieldRef<"equips", 'Boolean'>
    readonly tradeblock: FieldRef<"equips", 'Boolean'>
    readonly isonly: FieldRef<"equips", 'Boolean'>
    readonly notsale: FieldRef<"equips", 'Boolean'>
    readonly attackspeed: FieldRef<"equips", 'Int'>
    readonly price: FieldRef<"equips", 'Int'>
    readonly charmexp: FieldRef<"equips", 'Int'>
    readonly setitemid: FieldRef<"equips", 'Int'>
    readonly exitem: FieldRef<"equips", 'Boolean'>
    readonly equiptradeblock: FieldRef<"equips", 'Boolean'>
    readonly islot: FieldRef<"equips", 'String'>
    readonly vslot: FieldRef<"equips", 'String'>
    readonly fixedgrade: FieldRef<"equips", 'Int'>
    readonly nopotential: FieldRef<"equips", 'Int'>
    readonly bossreward: FieldRef<"equips", 'Int'>
    readonly superioreqp: FieldRef<"equips", 'Int'>
    readonly flameid: FieldRef<"equips", 'BigInt'>
    readonly android: FieldRef<"equips", 'Int'>
    readonly androidgrade: FieldRef<"equips", 'Int'>
    readonly arcane_stat: FieldRef<"equips", 'Int'>
    readonly arcane_exp: FieldRef<"equips", 'Int'>
    readonly arcane_level: FieldRef<"equips", 'Int'>
    readonly flame_str: FieldRef<"equips", 'Int'>
    readonly flame_dex: FieldRef<"equips", 'Int'>
    readonly flame_int: FieldRef<"equips", 'Int'>
    readonly flame_luk: FieldRef<"equips", 'Int'>
    readonly flame_pad: FieldRef<"equips", 'Int'>
    readonly flame_mad: FieldRef<"equips", 'Int'>
    readonly flame_pdd: FieldRef<"equips", 'Int'>
    readonly flame_hp: FieldRef<"equips", 'Int'>
    readonly flame_mp: FieldRef<"equips", 'Int'>
    readonly flame_speed: FieldRef<"equips", 'Int'>
    readonly flame_jump: FieldRef<"equips", 'Int'>
    readonly flame_allStatR: FieldRef<"equips", 'Int'>
    readonly flame_bossDamageR: FieldRef<"equips", 'Int'>
    readonly flame_damageR: FieldRef<"equips", 'Int'>
    readonly flame_reduceReqLevel: FieldRef<"equips", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * equips findUnique
   */
  export type equipsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equips
     */
    select?: equipsSelect<ExtArgs> | null
    /**
     * Filter, which equips to fetch.
     */
    where: equipsWhereUniqueInput
  }

  /**
   * equips findUniqueOrThrow
   */
  export type equipsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equips
     */
    select?: equipsSelect<ExtArgs> | null
    /**
     * Filter, which equips to fetch.
     */
    where: equipsWhereUniqueInput
  }

  /**
   * equips findFirst
   */
  export type equipsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equips
     */
    select?: equipsSelect<ExtArgs> | null
    /**
     * Filter, which equips to fetch.
     */
    where?: equipsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of equips to fetch.
     */
    orderBy?: equipsOrderByWithRelationInput | equipsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for equips.
     */
    cursor?: equipsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` equips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` equips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of equips.
     */
    distinct?: EquipsScalarFieldEnum | EquipsScalarFieldEnum[]
  }

  /**
   * equips findFirstOrThrow
   */
  export type equipsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equips
     */
    select?: equipsSelect<ExtArgs> | null
    /**
     * Filter, which equips to fetch.
     */
    where?: equipsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of equips to fetch.
     */
    orderBy?: equipsOrderByWithRelationInput | equipsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for equips.
     */
    cursor?: equipsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` equips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` equips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of equips.
     */
    distinct?: EquipsScalarFieldEnum | EquipsScalarFieldEnum[]
  }

  /**
   * equips findMany
   */
  export type equipsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equips
     */
    select?: equipsSelect<ExtArgs> | null
    /**
     * Filter, which equips to fetch.
     */
    where?: equipsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of equips to fetch.
     */
    orderBy?: equipsOrderByWithRelationInput | equipsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing equips.
     */
    cursor?: equipsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` equips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` equips.
     */
    skip?: number
    distinct?: EquipsScalarFieldEnum | EquipsScalarFieldEnum[]
  }

  /**
   * equips create
   */
  export type equipsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equips
     */
    select?: equipsSelect<ExtArgs> | null
    /**
     * The data needed to create a equips.
     */
    data: XOR<equipsCreateInput, equipsUncheckedCreateInput>
  }

  /**
   * equips createMany
   */
  export type equipsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many equips.
     */
    data: equipsCreateManyInput | equipsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * equips update
   */
  export type equipsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equips
     */
    select?: equipsSelect<ExtArgs> | null
    /**
     * The data needed to update a equips.
     */
    data: XOR<equipsUpdateInput, equipsUncheckedUpdateInput>
    /**
     * Choose, which equips to update.
     */
    where: equipsWhereUniqueInput
  }

  /**
   * equips updateMany
   */
  export type equipsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update equips.
     */
    data: XOR<equipsUpdateManyMutationInput, equipsUncheckedUpdateManyInput>
    /**
     * Filter which equips to update
     */
    where?: equipsWhereInput
  }

  /**
   * equips upsert
   */
  export type equipsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equips
     */
    select?: equipsSelect<ExtArgs> | null
    /**
     * The filter to search for the equips to update in case it exists.
     */
    where: equipsWhereUniqueInput
    /**
     * In case the equips found by the `where` argument doesn't exist, create a new equips with this data.
     */
    create: XOR<equipsCreateInput, equipsUncheckedCreateInput>
    /**
     * In case the equips was found with the provided `where` argument, update it with this data.
     */
    update: XOR<equipsUpdateInput, equipsUncheckedUpdateInput>
  }

  /**
   * equips delete
   */
  export type equipsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equips
     */
    select?: equipsSelect<ExtArgs> | null
    /**
     * Filter which equips to delete.
     */
    where: equipsWhereUniqueInput
  }

  /**
   * equips deleteMany
   */
  export type equipsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which equips to delete
     */
    where?: equipsWhereInput
  }

  /**
   * equips without action
   */
  export type equipsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equips
     */
    select?: equipsSelect<ExtArgs> | null
  }


  /**
   * Model eventnametag
   */

  export type AggregateEventnametag = {
    _count: EventnametagCountAggregateOutputType | null
    _avg: EventnametagAvgAggregateOutputType | null
    _sum: EventnametagSumAggregateOutputType | null
    _min: EventnametagMinAggregateOutputType | null
    _max: EventnametagMaxAggregateOutputType | null
  }

  export type EventnametagAvgAggregateOutputType = {
    id: number | null
    charid: number | null
    activeRed: number | null
    activeBlue: number | null
    activeYellow: number | null
    activeGreen: number | null
    activePurple: number | null
  }

  export type EventnametagSumAggregateOutputType = {
    id: number | null
    charid: number | null
    activeRed: number | null
    activeBlue: number | null
    activeYellow: number | null
    activeGreen: number | null
    activePurple: number | null
  }

  export type EventnametagMinAggregateOutputType = {
    id: number | null
    charid: number | null
    activeRed: number | null
    activeBlue: number | null
    activeYellow: number | null
    activeGreen: number | null
    activePurple: number | null
    sRed: string | null
    sBlue: string | null
    sYellow: string | null
    sGreen: string | null
    sPurple: string | null
  }

  export type EventnametagMaxAggregateOutputType = {
    id: number | null
    charid: number | null
    activeRed: number | null
    activeBlue: number | null
    activeYellow: number | null
    activeGreen: number | null
    activePurple: number | null
    sRed: string | null
    sBlue: string | null
    sYellow: string | null
    sGreen: string | null
    sPurple: string | null
  }

  export type EventnametagCountAggregateOutputType = {
    id: number
    charid: number
    activeRed: number
    activeBlue: number
    activeYellow: number
    activeGreen: number
    activePurple: number
    sRed: number
    sBlue: number
    sYellow: number
    sGreen: number
    sPurple: number
    _all: number
  }


  export type EventnametagAvgAggregateInputType = {
    id?: true
    charid?: true
    activeRed?: true
    activeBlue?: true
    activeYellow?: true
    activeGreen?: true
    activePurple?: true
  }

  export type EventnametagSumAggregateInputType = {
    id?: true
    charid?: true
    activeRed?: true
    activeBlue?: true
    activeYellow?: true
    activeGreen?: true
    activePurple?: true
  }

  export type EventnametagMinAggregateInputType = {
    id?: true
    charid?: true
    activeRed?: true
    activeBlue?: true
    activeYellow?: true
    activeGreen?: true
    activePurple?: true
    sRed?: true
    sBlue?: true
    sYellow?: true
    sGreen?: true
    sPurple?: true
  }

  export type EventnametagMaxAggregateInputType = {
    id?: true
    charid?: true
    activeRed?: true
    activeBlue?: true
    activeYellow?: true
    activeGreen?: true
    activePurple?: true
    sRed?: true
    sBlue?: true
    sYellow?: true
    sGreen?: true
    sPurple?: true
  }

  export type EventnametagCountAggregateInputType = {
    id?: true
    charid?: true
    activeRed?: true
    activeBlue?: true
    activeYellow?: true
    activeGreen?: true
    activePurple?: true
    sRed?: true
    sBlue?: true
    sYellow?: true
    sGreen?: true
    sPurple?: true
    _all?: true
  }

  export type EventnametagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which eventnametag to aggregate.
     */
    where?: eventnametagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of eventnametags to fetch.
     */
    orderBy?: eventnametagOrderByWithRelationInput | eventnametagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: eventnametagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` eventnametags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` eventnametags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned eventnametags
    **/
    _count?: true | EventnametagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EventnametagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EventnametagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventnametagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventnametagMaxAggregateInputType
  }

  export type GetEventnametagAggregateType<T extends EventnametagAggregateArgs> = {
        [P in keyof T & keyof AggregateEventnametag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEventnametag[P]>
      : GetScalarType<T[P], AggregateEventnametag[P]>
  }




  export type eventnametagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: eventnametagWhereInput
    orderBy?: eventnametagOrderByWithAggregationInput | eventnametagOrderByWithAggregationInput[]
    by: EventnametagScalarFieldEnum[] | EventnametagScalarFieldEnum
    having?: eventnametagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventnametagCountAggregateInputType | true
    _avg?: EventnametagAvgAggregateInputType
    _sum?: EventnametagSumAggregateInputType
    _min?: EventnametagMinAggregateInputType
    _max?: EventnametagMaxAggregateInputType
  }

  export type EventnametagGroupByOutputType = {
    id: number
    charid: number
    activeRed: number
    activeBlue: number
    activeYellow: number
    activeGreen: number
    activePurple: number
    sRed: string
    sBlue: string
    sYellow: string
    sGreen: string
    sPurple: string
    _count: EventnametagCountAggregateOutputType | null
    _avg: EventnametagAvgAggregateOutputType | null
    _sum: EventnametagSumAggregateOutputType | null
    _min: EventnametagMinAggregateOutputType | null
    _max: EventnametagMaxAggregateOutputType | null
  }

  type GetEventnametagGroupByPayload<T extends eventnametagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventnametagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventnametagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventnametagGroupByOutputType[P]>
            : GetScalarType<T[P], EventnametagGroupByOutputType[P]>
        }
      >
    >


  export type eventnametagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    charid?: boolean
    activeRed?: boolean
    activeBlue?: boolean
    activeYellow?: boolean
    activeGreen?: boolean
    activePurple?: boolean
    sRed?: boolean
    sBlue?: boolean
    sYellow?: boolean
    sGreen?: boolean
    sPurple?: boolean
  }, ExtArgs["result"]["eventnametag"]>


  export type eventnametagSelectScalar = {
    id?: boolean
    charid?: boolean
    activeRed?: boolean
    activeBlue?: boolean
    activeYellow?: boolean
    activeGreen?: boolean
    activePurple?: boolean
    sRed?: boolean
    sBlue?: boolean
    sYellow?: boolean
    sGreen?: boolean
    sPurple?: boolean
  }


  export type $eventnametagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "eventnametag"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      charid: number
      activeRed: number
      activeBlue: number
      activeYellow: number
      activeGreen: number
      activePurple: number
      sRed: string
      sBlue: string
      sYellow: string
      sGreen: string
      sPurple: string
    }, ExtArgs["result"]["eventnametag"]>
    composites: {}
  }

  type eventnametagGetPayload<S extends boolean | null | undefined | eventnametagDefaultArgs> = $Result.GetResult<Prisma.$eventnametagPayload, S>

  type eventnametagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<eventnametagFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EventnametagCountAggregateInputType | true
    }

  export interface eventnametagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['eventnametag'], meta: { name: 'eventnametag' } }
    /**
     * Find zero or one Eventnametag that matches the filter.
     * @param {eventnametagFindUniqueArgs} args - Arguments to find a Eventnametag
     * @example
     * // Get one Eventnametag
     * const eventnametag = await prisma.eventnametag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends eventnametagFindUniqueArgs>(args: SelectSubset<T, eventnametagFindUniqueArgs<ExtArgs>>): Prisma__eventnametagClient<$Result.GetResult<Prisma.$eventnametagPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Eventnametag that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {eventnametagFindUniqueOrThrowArgs} args - Arguments to find a Eventnametag
     * @example
     * // Get one Eventnametag
     * const eventnametag = await prisma.eventnametag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends eventnametagFindUniqueOrThrowArgs>(args: SelectSubset<T, eventnametagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__eventnametagClient<$Result.GetResult<Prisma.$eventnametagPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Eventnametag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventnametagFindFirstArgs} args - Arguments to find a Eventnametag
     * @example
     * // Get one Eventnametag
     * const eventnametag = await prisma.eventnametag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends eventnametagFindFirstArgs>(args?: SelectSubset<T, eventnametagFindFirstArgs<ExtArgs>>): Prisma__eventnametagClient<$Result.GetResult<Prisma.$eventnametagPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Eventnametag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventnametagFindFirstOrThrowArgs} args - Arguments to find a Eventnametag
     * @example
     * // Get one Eventnametag
     * const eventnametag = await prisma.eventnametag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends eventnametagFindFirstOrThrowArgs>(args?: SelectSubset<T, eventnametagFindFirstOrThrowArgs<ExtArgs>>): Prisma__eventnametagClient<$Result.GetResult<Prisma.$eventnametagPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Eventnametags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventnametagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Eventnametags
     * const eventnametags = await prisma.eventnametag.findMany()
     * 
     * // Get first 10 Eventnametags
     * const eventnametags = await prisma.eventnametag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventnametagWithIdOnly = await prisma.eventnametag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends eventnametagFindManyArgs>(args?: SelectSubset<T, eventnametagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$eventnametagPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Eventnametag.
     * @param {eventnametagCreateArgs} args - Arguments to create a Eventnametag.
     * @example
     * // Create one Eventnametag
     * const Eventnametag = await prisma.eventnametag.create({
     *   data: {
     *     // ... data to create a Eventnametag
     *   }
     * })
     * 
     */
    create<T extends eventnametagCreateArgs>(args: SelectSubset<T, eventnametagCreateArgs<ExtArgs>>): Prisma__eventnametagClient<$Result.GetResult<Prisma.$eventnametagPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Eventnametags.
     * @param {eventnametagCreateManyArgs} args - Arguments to create many Eventnametags.
     * @example
     * // Create many Eventnametags
     * const eventnametag = await prisma.eventnametag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends eventnametagCreateManyArgs>(args?: SelectSubset<T, eventnametagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Eventnametag.
     * @param {eventnametagDeleteArgs} args - Arguments to delete one Eventnametag.
     * @example
     * // Delete one Eventnametag
     * const Eventnametag = await prisma.eventnametag.delete({
     *   where: {
     *     // ... filter to delete one Eventnametag
     *   }
     * })
     * 
     */
    delete<T extends eventnametagDeleteArgs>(args: SelectSubset<T, eventnametagDeleteArgs<ExtArgs>>): Prisma__eventnametagClient<$Result.GetResult<Prisma.$eventnametagPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Eventnametag.
     * @param {eventnametagUpdateArgs} args - Arguments to update one Eventnametag.
     * @example
     * // Update one Eventnametag
     * const eventnametag = await prisma.eventnametag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends eventnametagUpdateArgs>(args: SelectSubset<T, eventnametagUpdateArgs<ExtArgs>>): Prisma__eventnametagClient<$Result.GetResult<Prisma.$eventnametagPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Eventnametags.
     * @param {eventnametagDeleteManyArgs} args - Arguments to filter Eventnametags to delete.
     * @example
     * // Delete a few Eventnametags
     * const { count } = await prisma.eventnametag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends eventnametagDeleteManyArgs>(args?: SelectSubset<T, eventnametagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Eventnametags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventnametagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Eventnametags
     * const eventnametag = await prisma.eventnametag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends eventnametagUpdateManyArgs>(args: SelectSubset<T, eventnametagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Eventnametag.
     * @param {eventnametagUpsertArgs} args - Arguments to update or create a Eventnametag.
     * @example
     * // Update or create a Eventnametag
     * const eventnametag = await prisma.eventnametag.upsert({
     *   create: {
     *     // ... data to create a Eventnametag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Eventnametag we want to update
     *   }
     * })
     */
    upsert<T extends eventnametagUpsertArgs>(args: SelectSubset<T, eventnametagUpsertArgs<ExtArgs>>): Prisma__eventnametagClient<$Result.GetResult<Prisma.$eventnametagPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Eventnametags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventnametagCountArgs} args - Arguments to filter Eventnametags to count.
     * @example
     * // Count the number of Eventnametags
     * const count = await prisma.eventnametag.count({
     *   where: {
     *     // ... the filter for the Eventnametags we want to count
     *   }
     * })
    **/
    count<T extends eventnametagCountArgs>(
      args?: Subset<T, eventnametagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventnametagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Eventnametag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventnametagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventnametagAggregateArgs>(args: Subset<T, EventnametagAggregateArgs>): Prisma.PrismaPromise<GetEventnametagAggregateType<T>>

    /**
     * Group by Eventnametag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventnametagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends eventnametagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: eventnametagGroupByArgs['orderBy'] }
        : { orderBy?: eventnametagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, eventnametagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventnametagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the eventnametag model
   */
  readonly fields: eventnametagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for eventnametag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__eventnametagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the eventnametag model
   */ 
  interface eventnametagFieldRefs {
    readonly id: FieldRef<"eventnametag", 'Int'>
    readonly charid: FieldRef<"eventnametag", 'Int'>
    readonly activeRed: FieldRef<"eventnametag", 'Int'>
    readonly activeBlue: FieldRef<"eventnametag", 'Int'>
    readonly activeYellow: FieldRef<"eventnametag", 'Int'>
    readonly activeGreen: FieldRef<"eventnametag", 'Int'>
    readonly activePurple: FieldRef<"eventnametag", 'Int'>
    readonly sRed: FieldRef<"eventnametag", 'String'>
    readonly sBlue: FieldRef<"eventnametag", 'String'>
    readonly sYellow: FieldRef<"eventnametag", 'String'>
    readonly sGreen: FieldRef<"eventnametag", 'String'>
    readonly sPurple: FieldRef<"eventnametag", 'String'>
  }
    

  // Custom InputTypes
  /**
   * eventnametag findUnique
   */
  export type eventnametagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eventnametag
     */
    select?: eventnametagSelect<ExtArgs> | null
    /**
     * Filter, which eventnametag to fetch.
     */
    where: eventnametagWhereUniqueInput
  }

  /**
   * eventnametag findUniqueOrThrow
   */
  export type eventnametagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eventnametag
     */
    select?: eventnametagSelect<ExtArgs> | null
    /**
     * Filter, which eventnametag to fetch.
     */
    where: eventnametagWhereUniqueInput
  }

  /**
   * eventnametag findFirst
   */
  export type eventnametagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eventnametag
     */
    select?: eventnametagSelect<ExtArgs> | null
    /**
     * Filter, which eventnametag to fetch.
     */
    where?: eventnametagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of eventnametags to fetch.
     */
    orderBy?: eventnametagOrderByWithRelationInput | eventnametagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for eventnametags.
     */
    cursor?: eventnametagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` eventnametags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` eventnametags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of eventnametags.
     */
    distinct?: EventnametagScalarFieldEnum | EventnametagScalarFieldEnum[]
  }

  /**
   * eventnametag findFirstOrThrow
   */
  export type eventnametagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eventnametag
     */
    select?: eventnametagSelect<ExtArgs> | null
    /**
     * Filter, which eventnametag to fetch.
     */
    where?: eventnametagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of eventnametags to fetch.
     */
    orderBy?: eventnametagOrderByWithRelationInput | eventnametagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for eventnametags.
     */
    cursor?: eventnametagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` eventnametags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` eventnametags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of eventnametags.
     */
    distinct?: EventnametagScalarFieldEnum | EventnametagScalarFieldEnum[]
  }

  /**
   * eventnametag findMany
   */
  export type eventnametagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eventnametag
     */
    select?: eventnametagSelect<ExtArgs> | null
    /**
     * Filter, which eventnametags to fetch.
     */
    where?: eventnametagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of eventnametags to fetch.
     */
    orderBy?: eventnametagOrderByWithRelationInput | eventnametagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing eventnametags.
     */
    cursor?: eventnametagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` eventnametags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` eventnametags.
     */
    skip?: number
    distinct?: EventnametagScalarFieldEnum | EventnametagScalarFieldEnum[]
  }

  /**
   * eventnametag create
   */
  export type eventnametagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eventnametag
     */
    select?: eventnametagSelect<ExtArgs> | null
    /**
     * The data needed to create a eventnametag.
     */
    data?: XOR<eventnametagCreateInput, eventnametagUncheckedCreateInput>
  }

  /**
   * eventnametag createMany
   */
  export type eventnametagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many eventnametags.
     */
    data: eventnametagCreateManyInput | eventnametagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * eventnametag update
   */
  export type eventnametagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eventnametag
     */
    select?: eventnametagSelect<ExtArgs> | null
    /**
     * The data needed to update a eventnametag.
     */
    data: XOR<eventnametagUpdateInput, eventnametagUncheckedUpdateInput>
    /**
     * Choose, which eventnametag to update.
     */
    where: eventnametagWhereUniqueInput
  }

  /**
   * eventnametag updateMany
   */
  export type eventnametagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update eventnametags.
     */
    data: XOR<eventnametagUpdateManyMutationInput, eventnametagUncheckedUpdateManyInput>
    /**
     * Filter which eventnametags to update
     */
    where?: eventnametagWhereInput
  }

  /**
   * eventnametag upsert
   */
  export type eventnametagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eventnametag
     */
    select?: eventnametagSelect<ExtArgs> | null
    /**
     * The filter to search for the eventnametag to update in case it exists.
     */
    where: eventnametagWhereUniqueInput
    /**
     * In case the eventnametag found by the `where` argument doesn't exist, create a new eventnametag with this data.
     */
    create: XOR<eventnametagCreateInput, eventnametagUncheckedCreateInput>
    /**
     * In case the eventnametag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<eventnametagUpdateInput, eventnametagUncheckedUpdateInput>
  }

  /**
   * eventnametag delete
   */
  export type eventnametagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eventnametag
     */
    select?: eventnametagSelect<ExtArgs> | null
    /**
     * Filter which eventnametag to delete.
     */
    where: eventnametagWhereUniqueInput
  }

  /**
   * eventnametag deleteMany
   */
  export type eventnametagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which eventnametags to delete
     */
    where?: eventnametagWhereInput
  }

  /**
   * eventnametag without action
   */
  export type eventnametagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eventnametag
     */
    select?: eventnametagSelect<ExtArgs> | null
  }


  /**
   * Model extendsp
   */

  export type AggregateExtendsp = {
    _count: ExtendspCountAggregateOutputType | null
    _avg: ExtendspAvgAggregateOutputType | null
    _sum: ExtendspSumAggregateOutputType | null
    _min: ExtendspMinAggregateOutputType | null
    _max: ExtendspMaxAggregateOutputType | null
  }

  export type ExtendspAvgAggregateOutputType = {
    id: number | null
  }

  export type ExtendspSumAggregateOutputType = {
    id: number | null
  }

  export type ExtendspMinAggregateOutputType = {
    id: number | null
  }

  export type ExtendspMaxAggregateOutputType = {
    id: number | null
  }

  export type ExtendspCountAggregateOutputType = {
    id: number
    _all: number
  }


  export type ExtendspAvgAggregateInputType = {
    id?: true
  }

  export type ExtendspSumAggregateInputType = {
    id?: true
  }

  export type ExtendspMinAggregateInputType = {
    id?: true
  }

  export type ExtendspMaxAggregateInputType = {
    id?: true
  }

  export type ExtendspCountAggregateInputType = {
    id?: true
    _all?: true
  }

  export type ExtendspAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which extendsp to aggregate.
     */
    where?: extendspWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of extendsps to fetch.
     */
    orderBy?: extendspOrderByWithRelationInput | extendspOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: extendspWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` extendsps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` extendsps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned extendsps
    **/
    _count?: true | ExtendspCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExtendspAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExtendspSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExtendspMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExtendspMaxAggregateInputType
  }

  export type GetExtendspAggregateType<T extends ExtendspAggregateArgs> = {
        [P in keyof T & keyof AggregateExtendsp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExtendsp[P]>
      : GetScalarType<T[P], AggregateExtendsp[P]>
  }




  export type extendspGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: extendspWhereInput
    orderBy?: extendspOrderByWithAggregationInput | extendspOrderByWithAggregationInput[]
    by: ExtendspScalarFieldEnum[] | ExtendspScalarFieldEnum
    having?: extendspScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExtendspCountAggregateInputType | true
    _avg?: ExtendspAvgAggregateInputType
    _sum?: ExtendspSumAggregateInputType
    _min?: ExtendspMinAggregateInputType
    _max?: ExtendspMaxAggregateInputType
  }

  export type ExtendspGroupByOutputType = {
    id: number
    _count: ExtendspCountAggregateOutputType | null
    _avg: ExtendspAvgAggregateOutputType | null
    _sum: ExtendspSumAggregateOutputType | null
    _min: ExtendspMinAggregateOutputType | null
    _max: ExtendspMaxAggregateOutputType | null
  }

  type GetExtendspGroupByPayload<T extends extendspGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExtendspGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExtendspGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExtendspGroupByOutputType[P]>
            : GetScalarType<T[P], ExtendspGroupByOutputType[P]>
        }
      >
    >


  export type extendspSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
  }, ExtArgs["result"]["extendsp"]>


  export type extendspSelectScalar = {
    id?: boolean
  }


  export type $extendspPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "extendsp"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
    }, ExtArgs["result"]["extendsp"]>
    composites: {}
  }

  type extendspGetPayload<S extends boolean | null | undefined | extendspDefaultArgs> = $Result.GetResult<Prisma.$extendspPayload, S>

  type extendspCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<extendspFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExtendspCountAggregateInputType | true
    }

  export interface extendspDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['extendsp'], meta: { name: 'extendsp' } }
    /**
     * Find zero or one Extendsp that matches the filter.
     * @param {extendspFindUniqueArgs} args - Arguments to find a Extendsp
     * @example
     * // Get one Extendsp
     * const extendsp = await prisma.extendsp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends extendspFindUniqueArgs>(args: SelectSubset<T, extendspFindUniqueArgs<ExtArgs>>): Prisma__extendspClient<$Result.GetResult<Prisma.$extendspPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Extendsp that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {extendspFindUniqueOrThrowArgs} args - Arguments to find a Extendsp
     * @example
     * // Get one Extendsp
     * const extendsp = await prisma.extendsp.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends extendspFindUniqueOrThrowArgs>(args: SelectSubset<T, extendspFindUniqueOrThrowArgs<ExtArgs>>): Prisma__extendspClient<$Result.GetResult<Prisma.$extendspPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Extendsp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {extendspFindFirstArgs} args - Arguments to find a Extendsp
     * @example
     * // Get one Extendsp
     * const extendsp = await prisma.extendsp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends extendspFindFirstArgs>(args?: SelectSubset<T, extendspFindFirstArgs<ExtArgs>>): Prisma__extendspClient<$Result.GetResult<Prisma.$extendspPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Extendsp that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {extendspFindFirstOrThrowArgs} args - Arguments to find a Extendsp
     * @example
     * // Get one Extendsp
     * const extendsp = await prisma.extendsp.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends extendspFindFirstOrThrowArgs>(args?: SelectSubset<T, extendspFindFirstOrThrowArgs<ExtArgs>>): Prisma__extendspClient<$Result.GetResult<Prisma.$extendspPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Extendsps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {extendspFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Extendsps
     * const extendsps = await prisma.extendsp.findMany()
     * 
     * // Get first 10 Extendsps
     * const extendsps = await prisma.extendsp.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const extendspWithIdOnly = await prisma.extendsp.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends extendspFindManyArgs>(args?: SelectSubset<T, extendspFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$extendspPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Extendsp.
     * @param {extendspCreateArgs} args - Arguments to create a Extendsp.
     * @example
     * // Create one Extendsp
     * const Extendsp = await prisma.extendsp.create({
     *   data: {
     *     // ... data to create a Extendsp
     *   }
     * })
     * 
     */
    create<T extends extendspCreateArgs>(args: SelectSubset<T, extendspCreateArgs<ExtArgs>>): Prisma__extendspClient<$Result.GetResult<Prisma.$extendspPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Extendsps.
     * @param {extendspCreateManyArgs} args - Arguments to create many Extendsps.
     * @example
     * // Create many Extendsps
     * const extendsp = await prisma.extendsp.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends extendspCreateManyArgs>(args?: SelectSubset<T, extendspCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Extendsp.
     * @param {extendspDeleteArgs} args - Arguments to delete one Extendsp.
     * @example
     * // Delete one Extendsp
     * const Extendsp = await prisma.extendsp.delete({
     *   where: {
     *     // ... filter to delete one Extendsp
     *   }
     * })
     * 
     */
    delete<T extends extendspDeleteArgs>(args: SelectSubset<T, extendspDeleteArgs<ExtArgs>>): Prisma__extendspClient<$Result.GetResult<Prisma.$extendspPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Extendsp.
     * @param {extendspUpdateArgs} args - Arguments to update one Extendsp.
     * @example
     * // Update one Extendsp
     * const extendsp = await prisma.extendsp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends extendspUpdateArgs>(args: SelectSubset<T, extendspUpdateArgs<ExtArgs>>): Prisma__extendspClient<$Result.GetResult<Prisma.$extendspPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Extendsps.
     * @param {extendspDeleteManyArgs} args - Arguments to filter Extendsps to delete.
     * @example
     * // Delete a few Extendsps
     * const { count } = await prisma.extendsp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends extendspDeleteManyArgs>(args?: SelectSubset<T, extendspDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Extendsps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {extendspUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Extendsps
     * const extendsp = await prisma.extendsp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends extendspUpdateManyArgs>(args: SelectSubset<T, extendspUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Extendsp.
     * @param {extendspUpsertArgs} args - Arguments to update or create a Extendsp.
     * @example
     * // Update or create a Extendsp
     * const extendsp = await prisma.extendsp.upsert({
     *   create: {
     *     // ... data to create a Extendsp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Extendsp we want to update
     *   }
     * })
     */
    upsert<T extends extendspUpsertArgs>(args: SelectSubset<T, extendspUpsertArgs<ExtArgs>>): Prisma__extendspClient<$Result.GetResult<Prisma.$extendspPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Extendsps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {extendspCountArgs} args - Arguments to filter Extendsps to count.
     * @example
     * // Count the number of Extendsps
     * const count = await prisma.extendsp.count({
     *   where: {
     *     // ... the filter for the Extendsps we want to count
     *   }
     * })
    **/
    count<T extends extendspCountArgs>(
      args?: Subset<T, extendspCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExtendspCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Extendsp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtendspAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExtendspAggregateArgs>(args: Subset<T, ExtendspAggregateArgs>): Prisma.PrismaPromise<GetExtendspAggregateType<T>>

    /**
     * Group by Extendsp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {extendspGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends extendspGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: extendspGroupByArgs['orderBy'] }
        : { orderBy?: extendspGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, extendspGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExtendspGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the extendsp model
   */
  readonly fields: extendspFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for extendsp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__extendspClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the extendsp model
   */ 
  interface extendspFieldRefs {
    readonly id: FieldRef<"extendsp", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * extendsp findUnique
   */
  export type extendspFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the extendsp
     */
    select?: extendspSelect<ExtArgs> | null
    /**
     * Filter, which extendsp to fetch.
     */
    where: extendspWhereUniqueInput
  }

  /**
   * extendsp findUniqueOrThrow
   */
  export type extendspFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the extendsp
     */
    select?: extendspSelect<ExtArgs> | null
    /**
     * Filter, which extendsp to fetch.
     */
    where: extendspWhereUniqueInput
  }

  /**
   * extendsp findFirst
   */
  export type extendspFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the extendsp
     */
    select?: extendspSelect<ExtArgs> | null
    /**
     * Filter, which extendsp to fetch.
     */
    where?: extendspWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of extendsps to fetch.
     */
    orderBy?: extendspOrderByWithRelationInput | extendspOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for extendsps.
     */
    cursor?: extendspWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` extendsps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` extendsps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of extendsps.
     */
    distinct?: ExtendspScalarFieldEnum | ExtendspScalarFieldEnum[]
  }

  /**
   * extendsp findFirstOrThrow
   */
  export type extendspFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the extendsp
     */
    select?: extendspSelect<ExtArgs> | null
    /**
     * Filter, which extendsp to fetch.
     */
    where?: extendspWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of extendsps to fetch.
     */
    orderBy?: extendspOrderByWithRelationInput | extendspOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for extendsps.
     */
    cursor?: extendspWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` extendsps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` extendsps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of extendsps.
     */
    distinct?: ExtendspScalarFieldEnum | ExtendspScalarFieldEnum[]
  }

  /**
   * extendsp findMany
   */
  export type extendspFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the extendsp
     */
    select?: extendspSelect<ExtArgs> | null
    /**
     * Filter, which extendsps to fetch.
     */
    where?: extendspWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of extendsps to fetch.
     */
    orderBy?: extendspOrderByWithRelationInput | extendspOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing extendsps.
     */
    cursor?: extendspWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` extendsps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` extendsps.
     */
    skip?: number
    distinct?: ExtendspScalarFieldEnum | ExtendspScalarFieldEnum[]
  }

  /**
   * extendsp create
   */
  export type extendspCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the extendsp
     */
    select?: extendspSelect<ExtArgs> | null
    /**
     * The data needed to create a extendsp.
     */
    data?: XOR<extendspCreateInput, extendspUncheckedCreateInput>
  }

  /**
   * extendsp createMany
   */
  export type extendspCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many extendsps.
     */
    data: extendspCreateManyInput | extendspCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * extendsp update
   */
  export type extendspUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the extendsp
     */
    select?: extendspSelect<ExtArgs> | null
    /**
     * The data needed to update a extendsp.
     */
    data: XOR<extendspUpdateInput, extendspUncheckedUpdateInput>
    /**
     * Choose, which extendsp to update.
     */
    where: extendspWhereUniqueInput
  }

  /**
   * extendsp updateMany
   */
  export type extendspUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update extendsps.
     */
    data: XOR<extendspUpdateManyMutationInput, extendspUncheckedUpdateManyInput>
    /**
     * Filter which extendsps to update
     */
    where?: extendspWhereInput
  }

  /**
   * extendsp upsert
   */
  export type extendspUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the extendsp
     */
    select?: extendspSelect<ExtArgs> | null
    /**
     * The filter to search for the extendsp to update in case it exists.
     */
    where: extendspWhereUniqueInput
    /**
     * In case the extendsp found by the `where` argument doesn't exist, create a new extendsp with this data.
     */
    create: XOR<extendspCreateInput, extendspUncheckedCreateInput>
    /**
     * In case the extendsp was found with the provided `where` argument, update it with this data.
     */
    update: XOR<extendspUpdateInput, extendspUncheckedUpdateInput>
  }

  /**
   * extendsp delete
   */
  export type extendspDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the extendsp
     */
    select?: extendspSelect<ExtArgs> | null
    /**
     * Filter which extendsp to delete.
     */
    where: extendspWhereUniqueInput
  }

  /**
   * extendsp deleteMany
   */
  export type extendspDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which extendsps to delete
     */
    where?: extendspWhereInput
  }

  /**
   * extendsp without action
   */
  export type extendspDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the extendsp
     */
    select?: extendspSelect<ExtArgs> | null
  }


  /**
   * Model familiars
   */

  export type AggregateFamiliars = {
    _count: FamiliarsCountAggregateOutputType | null
    _avg: FamiliarsAvgAggregateOutputType | null
    _sum: FamiliarsSumAggregateOutputType | null
    _min: FamiliarsMinAggregateOutputType | null
    _max: FamiliarsMaxAggregateOutputType | null
  }

  export type FamiliarsAvgAggregateOutputType = {
    id: number | null
    charid: number | null
    idk1: number | null
    familiarid: number | null
    idk3: number | null
    fatigue: number | null
    idk4: number | null
    idk5: number | null
    vitality: number | null
  }

  export type FamiliarsSumAggregateOutputType = {
    id: bigint | null
    charid: number | null
    idk1: number | null
    familiarid: number | null
    idk3: number | null
    fatigue: number | null
    idk4: bigint | null
    idk5: bigint | null
    vitality: number | null
  }

  export type FamiliarsMinAggregateOutputType = {
    id: bigint | null
    charid: number | null
    idk1: number | null
    familiarid: number | null
    name: string | null
    idk2: boolean | null
    idk3: number | null
    fatigue: number | null
    idk4: bigint | null
    idk5: bigint | null
    expiration: Date | null
    vitality: number | null
  }

  export type FamiliarsMaxAggregateOutputType = {
    id: bigint | null
    charid: number | null
    idk1: number | null
    familiarid: number | null
    name: string | null
    idk2: boolean | null
    idk3: number | null
    fatigue: number | null
    idk4: bigint | null
    idk5: bigint | null
    expiration: Date | null
    vitality: number | null
  }

  export type FamiliarsCountAggregateOutputType = {
    id: number
    charid: number
    idk1: number
    familiarid: number
    name: number
    idk2: number
    idk3: number
    fatigue: number
    idk4: number
    idk5: number
    expiration: number
    vitality: number
    _all: number
  }


  export type FamiliarsAvgAggregateInputType = {
    id?: true
    charid?: true
    idk1?: true
    familiarid?: true
    idk3?: true
    fatigue?: true
    idk4?: true
    idk5?: true
    vitality?: true
  }

  export type FamiliarsSumAggregateInputType = {
    id?: true
    charid?: true
    idk1?: true
    familiarid?: true
    idk3?: true
    fatigue?: true
    idk4?: true
    idk5?: true
    vitality?: true
  }

  export type FamiliarsMinAggregateInputType = {
    id?: true
    charid?: true
    idk1?: true
    familiarid?: true
    name?: true
    idk2?: true
    idk3?: true
    fatigue?: true
    idk4?: true
    idk5?: true
    expiration?: true
    vitality?: true
  }

  export type FamiliarsMaxAggregateInputType = {
    id?: true
    charid?: true
    idk1?: true
    familiarid?: true
    name?: true
    idk2?: true
    idk3?: true
    fatigue?: true
    idk4?: true
    idk5?: true
    expiration?: true
    vitality?: true
  }

  export type FamiliarsCountAggregateInputType = {
    id?: true
    charid?: true
    idk1?: true
    familiarid?: true
    name?: true
    idk2?: true
    idk3?: true
    fatigue?: true
    idk4?: true
    idk5?: true
    expiration?: true
    vitality?: true
    _all?: true
  }

  export type FamiliarsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which familiars to aggregate.
     */
    where?: familiarsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of familiars to fetch.
     */
    orderBy?: familiarsOrderByWithRelationInput | familiarsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: familiarsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` familiars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` familiars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned familiars
    **/
    _count?: true | FamiliarsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FamiliarsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FamiliarsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FamiliarsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FamiliarsMaxAggregateInputType
  }

  export type GetFamiliarsAggregateType<T extends FamiliarsAggregateArgs> = {
        [P in keyof T & keyof AggregateFamiliars]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFamiliars[P]>
      : GetScalarType<T[P], AggregateFamiliars[P]>
  }




  export type familiarsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: familiarsWhereInput
    orderBy?: familiarsOrderByWithAggregationInput | familiarsOrderByWithAggregationInput[]
    by: FamiliarsScalarFieldEnum[] | FamiliarsScalarFieldEnum
    having?: familiarsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FamiliarsCountAggregateInputType | true
    _avg?: FamiliarsAvgAggregateInputType
    _sum?: FamiliarsSumAggregateInputType
    _min?: FamiliarsMinAggregateInputType
    _max?: FamiliarsMaxAggregateInputType
  }

  export type FamiliarsGroupByOutputType = {
    id: bigint
    charid: number | null
    idk1: number | null
    familiarid: number | null
    name: string | null
    idk2: boolean | null
    idk3: number | null
    fatigue: number | null
    idk4: bigint | null
    idk5: bigint | null
    expiration: Date | null
    vitality: number | null
    _count: FamiliarsCountAggregateOutputType | null
    _avg: FamiliarsAvgAggregateOutputType | null
    _sum: FamiliarsSumAggregateOutputType | null
    _min: FamiliarsMinAggregateOutputType | null
    _max: FamiliarsMaxAggregateOutputType | null
  }

  type GetFamiliarsGroupByPayload<T extends familiarsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FamiliarsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FamiliarsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FamiliarsGroupByOutputType[P]>
            : GetScalarType<T[P], FamiliarsGroupByOutputType[P]>
        }
      >
    >


  export type familiarsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    charid?: boolean
    idk1?: boolean
    familiarid?: boolean
    name?: boolean
    idk2?: boolean
    idk3?: boolean
    fatigue?: boolean
    idk4?: boolean
    idk5?: boolean
    expiration?: boolean
    vitality?: boolean
  }, ExtArgs["result"]["familiars"]>


  export type familiarsSelectScalar = {
    id?: boolean
    charid?: boolean
    idk1?: boolean
    familiarid?: boolean
    name?: boolean
    idk2?: boolean
    idk3?: boolean
    fatigue?: boolean
    idk4?: boolean
    idk5?: boolean
    expiration?: boolean
    vitality?: boolean
  }


  export type $familiarsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "familiars"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      charid: number | null
      idk1: number | null
      familiarid: number | null
      name: string | null
      idk2: boolean | null
      idk3: number | null
      fatigue: number | null
      idk4: bigint | null
      idk5: bigint | null
      expiration: Date | null
      vitality: number | null
    }, ExtArgs["result"]["familiars"]>
    composites: {}
  }

  type familiarsGetPayload<S extends boolean | null | undefined | familiarsDefaultArgs> = $Result.GetResult<Prisma.$familiarsPayload, S>

  type familiarsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<familiarsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FamiliarsCountAggregateInputType | true
    }

  export interface familiarsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['familiars'], meta: { name: 'familiars' } }
    /**
     * Find zero or one Familiars that matches the filter.
     * @param {familiarsFindUniqueArgs} args - Arguments to find a Familiars
     * @example
     * // Get one Familiars
     * const familiars = await prisma.familiars.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends familiarsFindUniqueArgs>(args: SelectSubset<T, familiarsFindUniqueArgs<ExtArgs>>): Prisma__familiarsClient<$Result.GetResult<Prisma.$familiarsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Familiars that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {familiarsFindUniqueOrThrowArgs} args - Arguments to find a Familiars
     * @example
     * // Get one Familiars
     * const familiars = await prisma.familiars.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends familiarsFindUniqueOrThrowArgs>(args: SelectSubset<T, familiarsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__familiarsClient<$Result.GetResult<Prisma.$familiarsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Familiars that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {familiarsFindFirstArgs} args - Arguments to find a Familiars
     * @example
     * // Get one Familiars
     * const familiars = await prisma.familiars.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends familiarsFindFirstArgs>(args?: SelectSubset<T, familiarsFindFirstArgs<ExtArgs>>): Prisma__familiarsClient<$Result.GetResult<Prisma.$familiarsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Familiars that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {familiarsFindFirstOrThrowArgs} args - Arguments to find a Familiars
     * @example
     * // Get one Familiars
     * const familiars = await prisma.familiars.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends familiarsFindFirstOrThrowArgs>(args?: SelectSubset<T, familiarsFindFirstOrThrowArgs<ExtArgs>>): Prisma__familiarsClient<$Result.GetResult<Prisma.$familiarsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Familiars that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {familiarsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Familiars
     * const familiars = await prisma.familiars.findMany()
     * 
     * // Get first 10 Familiars
     * const familiars = await prisma.familiars.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const familiarsWithIdOnly = await prisma.familiars.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends familiarsFindManyArgs>(args?: SelectSubset<T, familiarsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$familiarsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Familiars.
     * @param {familiarsCreateArgs} args - Arguments to create a Familiars.
     * @example
     * // Create one Familiars
     * const Familiars = await prisma.familiars.create({
     *   data: {
     *     // ... data to create a Familiars
     *   }
     * })
     * 
     */
    create<T extends familiarsCreateArgs>(args: SelectSubset<T, familiarsCreateArgs<ExtArgs>>): Prisma__familiarsClient<$Result.GetResult<Prisma.$familiarsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Familiars.
     * @param {familiarsCreateManyArgs} args - Arguments to create many Familiars.
     * @example
     * // Create many Familiars
     * const familiars = await prisma.familiars.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends familiarsCreateManyArgs>(args?: SelectSubset<T, familiarsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Familiars.
     * @param {familiarsDeleteArgs} args - Arguments to delete one Familiars.
     * @example
     * // Delete one Familiars
     * const Familiars = await prisma.familiars.delete({
     *   where: {
     *     // ... filter to delete one Familiars
     *   }
     * })
     * 
     */
    delete<T extends familiarsDeleteArgs>(args: SelectSubset<T, familiarsDeleteArgs<ExtArgs>>): Prisma__familiarsClient<$Result.GetResult<Prisma.$familiarsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Familiars.
     * @param {familiarsUpdateArgs} args - Arguments to update one Familiars.
     * @example
     * // Update one Familiars
     * const familiars = await prisma.familiars.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends familiarsUpdateArgs>(args: SelectSubset<T, familiarsUpdateArgs<ExtArgs>>): Prisma__familiarsClient<$Result.GetResult<Prisma.$familiarsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Familiars.
     * @param {familiarsDeleteManyArgs} args - Arguments to filter Familiars to delete.
     * @example
     * // Delete a few Familiars
     * const { count } = await prisma.familiars.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends familiarsDeleteManyArgs>(args?: SelectSubset<T, familiarsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Familiars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {familiarsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Familiars
     * const familiars = await prisma.familiars.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends familiarsUpdateManyArgs>(args: SelectSubset<T, familiarsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Familiars.
     * @param {familiarsUpsertArgs} args - Arguments to update or create a Familiars.
     * @example
     * // Update or create a Familiars
     * const familiars = await prisma.familiars.upsert({
     *   create: {
     *     // ... data to create a Familiars
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Familiars we want to update
     *   }
     * })
     */
    upsert<T extends familiarsUpsertArgs>(args: SelectSubset<T, familiarsUpsertArgs<ExtArgs>>): Prisma__familiarsClient<$Result.GetResult<Prisma.$familiarsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Familiars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {familiarsCountArgs} args - Arguments to filter Familiars to count.
     * @example
     * // Count the number of Familiars
     * const count = await prisma.familiars.count({
     *   where: {
     *     // ... the filter for the Familiars we want to count
     *   }
     * })
    **/
    count<T extends familiarsCountArgs>(
      args?: Subset<T, familiarsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FamiliarsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Familiars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamiliarsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FamiliarsAggregateArgs>(args: Subset<T, FamiliarsAggregateArgs>): Prisma.PrismaPromise<GetFamiliarsAggregateType<T>>

    /**
     * Group by Familiars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {familiarsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends familiarsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: familiarsGroupByArgs['orderBy'] }
        : { orderBy?: familiarsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, familiarsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFamiliarsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the familiars model
   */
  readonly fields: familiarsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for familiars.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__familiarsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the familiars model
   */ 
  interface familiarsFieldRefs {
    readonly id: FieldRef<"familiars", 'BigInt'>
    readonly charid: FieldRef<"familiars", 'Int'>
    readonly idk1: FieldRef<"familiars", 'Int'>
    readonly familiarid: FieldRef<"familiars", 'Int'>
    readonly name: FieldRef<"familiars", 'String'>
    readonly idk2: FieldRef<"familiars", 'Boolean'>
    readonly idk3: FieldRef<"familiars", 'Int'>
    readonly fatigue: FieldRef<"familiars", 'Int'>
    readonly idk4: FieldRef<"familiars", 'BigInt'>
    readonly idk5: FieldRef<"familiars", 'BigInt'>
    readonly expiration: FieldRef<"familiars", 'DateTime'>
    readonly vitality: FieldRef<"familiars", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * familiars findUnique
   */
  export type familiarsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the familiars
     */
    select?: familiarsSelect<ExtArgs> | null
    /**
     * Filter, which familiars to fetch.
     */
    where: familiarsWhereUniqueInput
  }

  /**
   * familiars findUniqueOrThrow
   */
  export type familiarsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the familiars
     */
    select?: familiarsSelect<ExtArgs> | null
    /**
     * Filter, which familiars to fetch.
     */
    where: familiarsWhereUniqueInput
  }

  /**
   * familiars findFirst
   */
  export type familiarsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the familiars
     */
    select?: familiarsSelect<ExtArgs> | null
    /**
     * Filter, which familiars to fetch.
     */
    where?: familiarsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of familiars to fetch.
     */
    orderBy?: familiarsOrderByWithRelationInput | familiarsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for familiars.
     */
    cursor?: familiarsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` familiars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` familiars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of familiars.
     */
    distinct?: FamiliarsScalarFieldEnum | FamiliarsScalarFieldEnum[]
  }

  /**
   * familiars findFirstOrThrow
   */
  export type familiarsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the familiars
     */
    select?: familiarsSelect<ExtArgs> | null
    /**
     * Filter, which familiars to fetch.
     */
    where?: familiarsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of familiars to fetch.
     */
    orderBy?: familiarsOrderByWithRelationInput | familiarsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for familiars.
     */
    cursor?: familiarsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` familiars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` familiars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of familiars.
     */
    distinct?: FamiliarsScalarFieldEnum | FamiliarsScalarFieldEnum[]
  }

  /**
   * familiars findMany
   */
  export type familiarsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the familiars
     */
    select?: familiarsSelect<ExtArgs> | null
    /**
     * Filter, which familiars to fetch.
     */
    where?: familiarsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of familiars to fetch.
     */
    orderBy?: familiarsOrderByWithRelationInput | familiarsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing familiars.
     */
    cursor?: familiarsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` familiars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` familiars.
     */
    skip?: number
    distinct?: FamiliarsScalarFieldEnum | FamiliarsScalarFieldEnum[]
  }

  /**
   * familiars create
   */
  export type familiarsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the familiars
     */
    select?: familiarsSelect<ExtArgs> | null
    /**
     * The data needed to create a familiars.
     */
    data?: XOR<familiarsCreateInput, familiarsUncheckedCreateInput>
  }

  /**
   * familiars createMany
   */
  export type familiarsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many familiars.
     */
    data: familiarsCreateManyInput | familiarsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * familiars update
   */
  export type familiarsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the familiars
     */
    select?: familiarsSelect<ExtArgs> | null
    /**
     * The data needed to update a familiars.
     */
    data: XOR<familiarsUpdateInput, familiarsUncheckedUpdateInput>
    /**
     * Choose, which familiars to update.
     */
    where: familiarsWhereUniqueInput
  }

  /**
   * familiars updateMany
   */
  export type familiarsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update familiars.
     */
    data: XOR<familiarsUpdateManyMutationInput, familiarsUncheckedUpdateManyInput>
    /**
     * Filter which familiars to update
     */
    where?: familiarsWhereInput
  }

  /**
   * familiars upsert
   */
  export type familiarsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the familiars
     */
    select?: familiarsSelect<ExtArgs> | null
    /**
     * The filter to search for the familiars to update in case it exists.
     */
    where: familiarsWhereUniqueInput
    /**
     * In case the familiars found by the `where` argument doesn't exist, create a new familiars with this data.
     */
    create: XOR<familiarsCreateInput, familiarsUncheckedCreateInput>
    /**
     * In case the familiars was found with the provided `where` argument, update it with this data.
     */
    update: XOR<familiarsUpdateInput, familiarsUncheckedUpdateInput>
  }

  /**
   * familiars delete
   */
  export type familiarsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the familiars
     */
    select?: familiarsSelect<ExtArgs> | null
    /**
     * Filter which familiars to delete.
     */
    where: familiarsWhereUniqueInput
  }

  /**
   * familiars deleteMany
   */
  export type familiarsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which familiars to delete
     */
    where?: familiarsWhereInput
  }

  /**
   * familiars without action
   */
  export type familiarsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the familiars
     */
    select?: familiarsSelect<ExtArgs> | null
  }


  /**
   * Model friends
   */

  export type AggregateFriends = {
    _count: FriendsCountAggregateOutputType | null
    _avg: FriendsAvgAggregateOutputType | null
    _sum: FriendsSumAggregateOutputType | null
    _min: FriendsMinAggregateOutputType | null
    _max: FriendsMaxAggregateOutputType | null
  }

  export type FriendsAvgAggregateOutputType = {
    id: number | null
    ownerid: number | null
    owneraccid: number | null
    friendid: number | null
    friendaccountid: number | null
    flag: number | null
    mobile: number | null
  }

  export type FriendsSumAggregateOutputType = {
    id: number | null
    ownerid: number | null
    owneraccid: number | null
    friendid: number | null
    friendaccountid: number | null
    flag: number | null
    mobile: number | null
  }

  export type FriendsMinAggregateOutputType = {
    id: number | null
    ownerid: number | null
    owneraccid: number | null
    friendid: number | null
    friendaccountid: number | null
    name: string | null
    flag: number | null
    groupname: string | null
    mobile: number | null
    nickname: string | null
    memo: string | null
  }

  export type FriendsMaxAggregateOutputType = {
    id: number | null
    ownerid: number | null
    owneraccid: number | null
    friendid: number | null
    friendaccountid: number | null
    name: string | null
    flag: number | null
    groupname: string | null
    mobile: number | null
    nickname: string | null
    memo: string | null
  }

  export type FriendsCountAggregateOutputType = {
    id: number
    ownerid: number
    owneraccid: number
    friendid: number
    friendaccountid: number
    name: number
    flag: number
    groupname: number
    mobile: number
    nickname: number
    memo: number
    _all: number
  }


  export type FriendsAvgAggregateInputType = {
    id?: true
    ownerid?: true
    owneraccid?: true
    friendid?: true
    friendaccountid?: true
    flag?: true
    mobile?: true
  }

  export type FriendsSumAggregateInputType = {
    id?: true
    ownerid?: true
    owneraccid?: true
    friendid?: true
    friendaccountid?: true
    flag?: true
    mobile?: true
  }

  export type FriendsMinAggregateInputType = {
    id?: true
    ownerid?: true
    owneraccid?: true
    friendid?: true
    friendaccountid?: true
    name?: true
    flag?: true
    groupname?: true
    mobile?: true
    nickname?: true
    memo?: true
  }

  export type FriendsMaxAggregateInputType = {
    id?: true
    ownerid?: true
    owneraccid?: true
    friendid?: true
    friendaccountid?: true
    name?: true
    flag?: true
    groupname?: true
    mobile?: true
    nickname?: true
    memo?: true
  }

  export type FriendsCountAggregateInputType = {
    id?: true
    ownerid?: true
    owneraccid?: true
    friendid?: true
    friendaccountid?: true
    name?: true
    flag?: true
    groupname?: true
    mobile?: true
    nickname?: true
    memo?: true
    _all?: true
  }

  export type FriendsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which friends to aggregate.
     */
    where?: friendsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of friends to fetch.
     */
    orderBy?: friendsOrderByWithRelationInput | friendsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: friendsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` friends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` friends.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned friends
    **/
    _count?: true | FriendsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FriendsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FriendsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FriendsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FriendsMaxAggregateInputType
  }

  export type GetFriendsAggregateType<T extends FriendsAggregateArgs> = {
        [P in keyof T & keyof AggregateFriends]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFriends[P]>
      : GetScalarType<T[P], AggregateFriends[P]>
  }




  export type friendsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: friendsWhereInput
    orderBy?: friendsOrderByWithAggregationInput | friendsOrderByWithAggregationInput[]
    by: FriendsScalarFieldEnum[] | FriendsScalarFieldEnum
    having?: friendsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FriendsCountAggregateInputType | true
    _avg?: FriendsAvgAggregateInputType
    _sum?: FriendsSumAggregateInputType
    _min?: FriendsMinAggregateInputType
    _max?: FriendsMaxAggregateInputType
  }

  export type FriendsGroupByOutputType = {
    id: number
    ownerid: number | null
    owneraccid: number | null
    friendid: number | null
    friendaccountid: number | null
    name: string | null
    flag: number | null
    groupname: string | null
    mobile: number | null
    nickname: string | null
    memo: string | null
    _count: FriendsCountAggregateOutputType | null
    _avg: FriendsAvgAggregateOutputType | null
    _sum: FriendsSumAggregateOutputType | null
    _min: FriendsMinAggregateOutputType | null
    _max: FriendsMaxAggregateOutputType | null
  }

  type GetFriendsGroupByPayload<T extends friendsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FriendsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FriendsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FriendsGroupByOutputType[P]>
            : GetScalarType<T[P], FriendsGroupByOutputType[P]>
        }
      >
    >


  export type friendsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerid?: boolean
    owneraccid?: boolean
    friendid?: boolean
    friendaccountid?: boolean
    name?: boolean
    flag?: boolean
    groupname?: boolean
    mobile?: boolean
    nickname?: boolean
    memo?: boolean
  }, ExtArgs["result"]["friends"]>


  export type friendsSelectScalar = {
    id?: boolean
    ownerid?: boolean
    owneraccid?: boolean
    friendid?: boolean
    friendaccountid?: boolean
    name?: boolean
    flag?: boolean
    groupname?: boolean
    mobile?: boolean
    nickname?: boolean
    memo?: boolean
  }


  export type $friendsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "friends"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      ownerid: number | null
      owneraccid: number | null
      friendid: number | null
      friendaccountid: number | null
      name: string | null
      flag: number | null
      groupname: string | null
      mobile: number | null
      nickname: string | null
      memo: string | null
    }, ExtArgs["result"]["friends"]>
    composites: {}
  }

  type friendsGetPayload<S extends boolean | null | undefined | friendsDefaultArgs> = $Result.GetResult<Prisma.$friendsPayload, S>

  type friendsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<friendsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FriendsCountAggregateInputType | true
    }

  export interface friendsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['friends'], meta: { name: 'friends' } }
    /**
     * Find zero or one Friends that matches the filter.
     * @param {friendsFindUniqueArgs} args - Arguments to find a Friends
     * @example
     * // Get one Friends
     * const friends = await prisma.friends.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends friendsFindUniqueArgs>(args: SelectSubset<T, friendsFindUniqueArgs<ExtArgs>>): Prisma__friendsClient<$Result.GetResult<Prisma.$friendsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Friends that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {friendsFindUniqueOrThrowArgs} args - Arguments to find a Friends
     * @example
     * // Get one Friends
     * const friends = await prisma.friends.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends friendsFindUniqueOrThrowArgs>(args: SelectSubset<T, friendsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__friendsClient<$Result.GetResult<Prisma.$friendsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Friends that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {friendsFindFirstArgs} args - Arguments to find a Friends
     * @example
     * // Get one Friends
     * const friends = await prisma.friends.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends friendsFindFirstArgs>(args?: SelectSubset<T, friendsFindFirstArgs<ExtArgs>>): Prisma__friendsClient<$Result.GetResult<Prisma.$friendsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Friends that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {friendsFindFirstOrThrowArgs} args - Arguments to find a Friends
     * @example
     * // Get one Friends
     * const friends = await prisma.friends.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends friendsFindFirstOrThrowArgs>(args?: SelectSubset<T, friendsFindFirstOrThrowArgs<ExtArgs>>): Prisma__friendsClient<$Result.GetResult<Prisma.$friendsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Friends that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {friendsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Friends
     * const friends = await prisma.friends.findMany()
     * 
     * // Get first 10 Friends
     * const friends = await prisma.friends.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const friendsWithIdOnly = await prisma.friends.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends friendsFindManyArgs>(args?: SelectSubset<T, friendsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$friendsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Friends.
     * @param {friendsCreateArgs} args - Arguments to create a Friends.
     * @example
     * // Create one Friends
     * const Friends = await prisma.friends.create({
     *   data: {
     *     // ... data to create a Friends
     *   }
     * })
     * 
     */
    create<T extends friendsCreateArgs>(args: SelectSubset<T, friendsCreateArgs<ExtArgs>>): Prisma__friendsClient<$Result.GetResult<Prisma.$friendsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Friends.
     * @param {friendsCreateManyArgs} args - Arguments to create many Friends.
     * @example
     * // Create many Friends
     * const friends = await prisma.friends.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends friendsCreateManyArgs>(args?: SelectSubset<T, friendsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Friends.
     * @param {friendsDeleteArgs} args - Arguments to delete one Friends.
     * @example
     * // Delete one Friends
     * const Friends = await prisma.friends.delete({
     *   where: {
     *     // ... filter to delete one Friends
     *   }
     * })
     * 
     */
    delete<T extends friendsDeleteArgs>(args: SelectSubset<T, friendsDeleteArgs<ExtArgs>>): Prisma__friendsClient<$Result.GetResult<Prisma.$friendsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Friends.
     * @param {friendsUpdateArgs} args - Arguments to update one Friends.
     * @example
     * // Update one Friends
     * const friends = await prisma.friends.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends friendsUpdateArgs>(args: SelectSubset<T, friendsUpdateArgs<ExtArgs>>): Prisma__friendsClient<$Result.GetResult<Prisma.$friendsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Friends.
     * @param {friendsDeleteManyArgs} args - Arguments to filter Friends to delete.
     * @example
     * // Delete a few Friends
     * const { count } = await prisma.friends.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends friendsDeleteManyArgs>(args?: SelectSubset<T, friendsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Friends.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {friendsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Friends
     * const friends = await prisma.friends.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends friendsUpdateManyArgs>(args: SelectSubset<T, friendsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Friends.
     * @param {friendsUpsertArgs} args - Arguments to update or create a Friends.
     * @example
     * // Update or create a Friends
     * const friends = await prisma.friends.upsert({
     *   create: {
     *     // ... data to create a Friends
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Friends we want to update
     *   }
     * })
     */
    upsert<T extends friendsUpsertArgs>(args: SelectSubset<T, friendsUpsertArgs<ExtArgs>>): Prisma__friendsClient<$Result.GetResult<Prisma.$friendsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Friends.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {friendsCountArgs} args - Arguments to filter Friends to count.
     * @example
     * // Count the number of Friends
     * const count = await prisma.friends.count({
     *   where: {
     *     // ... the filter for the Friends we want to count
     *   }
     * })
    **/
    count<T extends friendsCountArgs>(
      args?: Subset<T, friendsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FriendsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Friends.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FriendsAggregateArgs>(args: Subset<T, FriendsAggregateArgs>): Prisma.PrismaPromise<GetFriendsAggregateType<T>>

    /**
     * Group by Friends.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {friendsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends friendsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: friendsGroupByArgs['orderBy'] }
        : { orderBy?: friendsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, friendsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFriendsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the friends model
   */
  readonly fields: friendsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for friends.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__friendsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the friends model
   */ 
  interface friendsFieldRefs {
    readonly id: FieldRef<"friends", 'Int'>
    readonly ownerid: FieldRef<"friends", 'Int'>
    readonly owneraccid: FieldRef<"friends", 'Int'>
    readonly friendid: FieldRef<"friends", 'Int'>
    readonly friendaccountid: FieldRef<"friends", 'Int'>
    readonly name: FieldRef<"friends", 'String'>
    readonly flag: FieldRef<"friends", 'Int'>
    readonly groupname: FieldRef<"friends", 'String'>
    readonly mobile: FieldRef<"friends", 'Int'>
    readonly nickname: FieldRef<"friends", 'String'>
    readonly memo: FieldRef<"friends", 'String'>
  }
    

  // Custom InputTypes
  /**
   * friends findUnique
   */
  export type friendsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the friends
     */
    select?: friendsSelect<ExtArgs> | null
    /**
     * Filter, which friends to fetch.
     */
    where: friendsWhereUniqueInput
  }

  /**
   * friends findUniqueOrThrow
   */
  export type friendsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the friends
     */
    select?: friendsSelect<ExtArgs> | null
    /**
     * Filter, which friends to fetch.
     */
    where: friendsWhereUniqueInput
  }

  /**
   * friends findFirst
   */
  export type friendsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the friends
     */
    select?: friendsSelect<ExtArgs> | null
    /**
     * Filter, which friends to fetch.
     */
    where?: friendsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of friends to fetch.
     */
    orderBy?: friendsOrderByWithRelationInput | friendsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for friends.
     */
    cursor?: friendsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` friends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` friends.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of friends.
     */
    distinct?: FriendsScalarFieldEnum | FriendsScalarFieldEnum[]
  }

  /**
   * friends findFirstOrThrow
   */
  export type friendsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the friends
     */
    select?: friendsSelect<ExtArgs> | null
    /**
     * Filter, which friends to fetch.
     */
    where?: friendsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of friends to fetch.
     */
    orderBy?: friendsOrderByWithRelationInput | friendsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for friends.
     */
    cursor?: friendsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` friends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` friends.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of friends.
     */
    distinct?: FriendsScalarFieldEnum | FriendsScalarFieldEnum[]
  }

  /**
   * friends findMany
   */
  export type friendsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the friends
     */
    select?: friendsSelect<ExtArgs> | null
    /**
     * Filter, which friends to fetch.
     */
    where?: friendsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of friends to fetch.
     */
    orderBy?: friendsOrderByWithRelationInput | friendsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing friends.
     */
    cursor?: friendsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` friends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` friends.
     */
    skip?: number
    distinct?: FriendsScalarFieldEnum | FriendsScalarFieldEnum[]
  }

  /**
   * friends create
   */
  export type friendsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the friends
     */
    select?: friendsSelect<ExtArgs> | null
    /**
     * The data needed to create a friends.
     */
    data?: XOR<friendsCreateInput, friendsUncheckedCreateInput>
  }

  /**
   * friends createMany
   */
  export type friendsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many friends.
     */
    data: friendsCreateManyInput | friendsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * friends update
   */
  export type friendsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the friends
     */
    select?: friendsSelect<ExtArgs> | null
    /**
     * The data needed to update a friends.
     */
    data: XOR<friendsUpdateInput, friendsUncheckedUpdateInput>
    /**
     * Choose, which friends to update.
     */
    where: friendsWhereUniqueInput
  }

  /**
   * friends updateMany
   */
  export type friendsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update friends.
     */
    data: XOR<friendsUpdateManyMutationInput, friendsUncheckedUpdateManyInput>
    /**
     * Filter which friends to update
     */
    where?: friendsWhereInput
  }

  /**
   * friends upsert
   */
  export type friendsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the friends
     */
    select?: friendsSelect<ExtArgs> | null
    /**
     * The filter to search for the friends to update in case it exists.
     */
    where: friendsWhereUniqueInput
    /**
     * In case the friends found by the `where` argument doesn't exist, create a new friends with this data.
     */
    create: XOR<friendsCreateInput, friendsUncheckedCreateInput>
    /**
     * In case the friends was found with the provided `where` argument, update it with this data.
     */
    update: XOR<friendsUpdateInput, friendsUncheckedUpdateInput>
  }

  /**
   * friends delete
   */
  export type friendsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the friends
     */
    select?: friendsSelect<ExtArgs> | null
    /**
     * Filter which friends to delete.
     */
    where: friendsWhereUniqueInput
  }

  /**
   * friends deleteMany
   */
  export type friendsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which friends to delete
     */
    where?: friendsWhereInput
  }

  /**
   * friends without action
   */
  export type friendsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the friends
     */
    select?: friendsSelect<ExtArgs> | null
  }


  /**
   * Model funckeymap
   */

  export type AggregateFunckeymap = {
    _count: FunckeymapCountAggregateOutputType | null
    _avg: FunckeymapAvgAggregateOutputType | null
    _sum: FunckeymapSumAggregateOutputType | null
    _min: FunckeymapMinAggregateOutputType | null
    _max: FunckeymapMaxAggregateOutputType | null
  }

  export type FunckeymapAvgAggregateOutputType = {
    id: number | null
    charId: number | null
    ord: number | null
  }

  export type FunckeymapSumAggregateOutputType = {
    id: number | null
    charId: number | null
    ord: number | null
  }

  export type FunckeymapMinAggregateOutputType = {
    id: number | null
    charId: number | null
    ord: number | null
  }

  export type FunckeymapMaxAggregateOutputType = {
    id: number | null
    charId: number | null
    ord: number | null
  }

  export type FunckeymapCountAggregateOutputType = {
    id: number
    charId: number
    ord: number
    _all: number
  }


  export type FunckeymapAvgAggregateInputType = {
    id?: true
    charId?: true
    ord?: true
  }

  export type FunckeymapSumAggregateInputType = {
    id?: true
    charId?: true
    ord?: true
  }

  export type FunckeymapMinAggregateInputType = {
    id?: true
    charId?: true
    ord?: true
  }

  export type FunckeymapMaxAggregateInputType = {
    id?: true
    charId?: true
    ord?: true
  }

  export type FunckeymapCountAggregateInputType = {
    id?: true
    charId?: true
    ord?: true
    _all?: true
  }

  export type FunckeymapAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which funckeymap to aggregate.
     */
    where?: funckeymapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of funckeymaps to fetch.
     */
    orderBy?: funckeymapOrderByWithRelationInput | funckeymapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: funckeymapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` funckeymaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` funckeymaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned funckeymaps
    **/
    _count?: true | FunckeymapCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FunckeymapAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FunckeymapSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FunckeymapMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FunckeymapMaxAggregateInputType
  }

  export type GetFunckeymapAggregateType<T extends FunckeymapAggregateArgs> = {
        [P in keyof T & keyof AggregateFunckeymap]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFunckeymap[P]>
      : GetScalarType<T[P], AggregateFunckeymap[P]>
  }




  export type funckeymapGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: funckeymapWhereInput
    orderBy?: funckeymapOrderByWithAggregationInput | funckeymapOrderByWithAggregationInput[]
    by: FunckeymapScalarFieldEnum[] | FunckeymapScalarFieldEnum
    having?: funckeymapScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FunckeymapCountAggregateInputType | true
    _avg?: FunckeymapAvgAggregateInputType
    _sum?: FunckeymapSumAggregateInputType
    _min?: FunckeymapMinAggregateInputType
    _max?: FunckeymapMaxAggregateInputType
  }

  export type FunckeymapGroupByOutputType = {
    id: number
    charId: number | null
    ord: number | null
    _count: FunckeymapCountAggregateOutputType | null
    _avg: FunckeymapAvgAggregateOutputType | null
    _sum: FunckeymapSumAggregateOutputType | null
    _min: FunckeymapMinAggregateOutputType | null
    _max: FunckeymapMaxAggregateOutputType | null
  }

  type GetFunckeymapGroupByPayload<T extends funckeymapGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FunckeymapGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FunckeymapGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FunckeymapGroupByOutputType[P]>
            : GetScalarType<T[P], FunckeymapGroupByOutputType[P]>
        }
      >
    >


  export type funckeymapSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    charId?: boolean
    ord?: boolean
  }, ExtArgs["result"]["funckeymap"]>


  export type funckeymapSelectScalar = {
    id?: boolean
    charId?: boolean
    ord?: boolean
  }


  export type $funckeymapPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "funckeymap"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      charId: number | null
      ord: number | null
    }, ExtArgs["result"]["funckeymap"]>
    composites: {}
  }

  type funckeymapGetPayload<S extends boolean | null | undefined | funckeymapDefaultArgs> = $Result.GetResult<Prisma.$funckeymapPayload, S>

  type funckeymapCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<funckeymapFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FunckeymapCountAggregateInputType | true
    }

  export interface funckeymapDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['funckeymap'], meta: { name: 'funckeymap' } }
    /**
     * Find zero or one Funckeymap that matches the filter.
     * @param {funckeymapFindUniqueArgs} args - Arguments to find a Funckeymap
     * @example
     * // Get one Funckeymap
     * const funckeymap = await prisma.funckeymap.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends funckeymapFindUniqueArgs>(args: SelectSubset<T, funckeymapFindUniqueArgs<ExtArgs>>): Prisma__funckeymapClient<$Result.GetResult<Prisma.$funckeymapPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Funckeymap that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {funckeymapFindUniqueOrThrowArgs} args - Arguments to find a Funckeymap
     * @example
     * // Get one Funckeymap
     * const funckeymap = await prisma.funckeymap.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends funckeymapFindUniqueOrThrowArgs>(args: SelectSubset<T, funckeymapFindUniqueOrThrowArgs<ExtArgs>>): Prisma__funckeymapClient<$Result.GetResult<Prisma.$funckeymapPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Funckeymap that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {funckeymapFindFirstArgs} args - Arguments to find a Funckeymap
     * @example
     * // Get one Funckeymap
     * const funckeymap = await prisma.funckeymap.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends funckeymapFindFirstArgs>(args?: SelectSubset<T, funckeymapFindFirstArgs<ExtArgs>>): Prisma__funckeymapClient<$Result.GetResult<Prisma.$funckeymapPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Funckeymap that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {funckeymapFindFirstOrThrowArgs} args - Arguments to find a Funckeymap
     * @example
     * // Get one Funckeymap
     * const funckeymap = await prisma.funckeymap.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends funckeymapFindFirstOrThrowArgs>(args?: SelectSubset<T, funckeymapFindFirstOrThrowArgs<ExtArgs>>): Prisma__funckeymapClient<$Result.GetResult<Prisma.$funckeymapPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Funckeymaps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {funckeymapFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Funckeymaps
     * const funckeymaps = await prisma.funckeymap.findMany()
     * 
     * // Get first 10 Funckeymaps
     * const funckeymaps = await prisma.funckeymap.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const funckeymapWithIdOnly = await prisma.funckeymap.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends funckeymapFindManyArgs>(args?: SelectSubset<T, funckeymapFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$funckeymapPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Funckeymap.
     * @param {funckeymapCreateArgs} args - Arguments to create a Funckeymap.
     * @example
     * // Create one Funckeymap
     * const Funckeymap = await prisma.funckeymap.create({
     *   data: {
     *     // ... data to create a Funckeymap
     *   }
     * })
     * 
     */
    create<T extends funckeymapCreateArgs>(args: SelectSubset<T, funckeymapCreateArgs<ExtArgs>>): Prisma__funckeymapClient<$Result.GetResult<Prisma.$funckeymapPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Funckeymaps.
     * @param {funckeymapCreateManyArgs} args - Arguments to create many Funckeymaps.
     * @example
     * // Create many Funckeymaps
     * const funckeymap = await prisma.funckeymap.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends funckeymapCreateManyArgs>(args?: SelectSubset<T, funckeymapCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Funckeymap.
     * @param {funckeymapDeleteArgs} args - Arguments to delete one Funckeymap.
     * @example
     * // Delete one Funckeymap
     * const Funckeymap = await prisma.funckeymap.delete({
     *   where: {
     *     // ... filter to delete one Funckeymap
     *   }
     * })
     * 
     */
    delete<T extends funckeymapDeleteArgs>(args: SelectSubset<T, funckeymapDeleteArgs<ExtArgs>>): Prisma__funckeymapClient<$Result.GetResult<Prisma.$funckeymapPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Funckeymap.
     * @param {funckeymapUpdateArgs} args - Arguments to update one Funckeymap.
     * @example
     * // Update one Funckeymap
     * const funckeymap = await prisma.funckeymap.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends funckeymapUpdateArgs>(args: SelectSubset<T, funckeymapUpdateArgs<ExtArgs>>): Prisma__funckeymapClient<$Result.GetResult<Prisma.$funckeymapPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Funckeymaps.
     * @param {funckeymapDeleteManyArgs} args - Arguments to filter Funckeymaps to delete.
     * @example
     * // Delete a few Funckeymaps
     * const { count } = await prisma.funckeymap.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends funckeymapDeleteManyArgs>(args?: SelectSubset<T, funckeymapDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Funckeymaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {funckeymapUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Funckeymaps
     * const funckeymap = await prisma.funckeymap.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends funckeymapUpdateManyArgs>(args: SelectSubset<T, funckeymapUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Funckeymap.
     * @param {funckeymapUpsertArgs} args - Arguments to update or create a Funckeymap.
     * @example
     * // Update or create a Funckeymap
     * const funckeymap = await prisma.funckeymap.upsert({
     *   create: {
     *     // ... data to create a Funckeymap
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Funckeymap we want to update
     *   }
     * })
     */
    upsert<T extends funckeymapUpsertArgs>(args: SelectSubset<T, funckeymapUpsertArgs<ExtArgs>>): Prisma__funckeymapClient<$Result.GetResult<Prisma.$funckeymapPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Funckeymaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {funckeymapCountArgs} args - Arguments to filter Funckeymaps to count.
     * @example
     * // Count the number of Funckeymaps
     * const count = await prisma.funckeymap.count({
     *   where: {
     *     // ... the filter for the Funckeymaps we want to count
     *   }
     * })
    **/
    count<T extends funckeymapCountArgs>(
      args?: Subset<T, funckeymapCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FunckeymapCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Funckeymap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunckeymapAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FunckeymapAggregateArgs>(args: Subset<T, FunckeymapAggregateArgs>): Prisma.PrismaPromise<GetFunckeymapAggregateType<T>>

    /**
     * Group by Funckeymap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {funckeymapGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends funckeymapGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: funckeymapGroupByArgs['orderBy'] }
        : { orderBy?: funckeymapGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, funckeymapGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFunckeymapGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the funckeymap model
   */
  readonly fields: funckeymapFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for funckeymap.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__funckeymapClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the funckeymap model
   */ 
  interface funckeymapFieldRefs {
    readonly id: FieldRef<"funckeymap", 'Int'>
    readonly charId: FieldRef<"funckeymap", 'Int'>
    readonly ord: FieldRef<"funckeymap", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * funckeymap findUnique
   */
  export type funckeymapFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the funckeymap
     */
    select?: funckeymapSelect<ExtArgs> | null
    /**
     * Filter, which funckeymap to fetch.
     */
    where: funckeymapWhereUniqueInput
  }

  /**
   * funckeymap findUniqueOrThrow
   */
  export type funckeymapFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the funckeymap
     */
    select?: funckeymapSelect<ExtArgs> | null
    /**
     * Filter, which funckeymap to fetch.
     */
    where: funckeymapWhereUniqueInput
  }

  /**
   * funckeymap findFirst
   */
  export type funckeymapFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the funckeymap
     */
    select?: funckeymapSelect<ExtArgs> | null
    /**
     * Filter, which funckeymap to fetch.
     */
    where?: funckeymapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of funckeymaps to fetch.
     */
    orderBy?: funckeymapOrderByWithRelationInput | funckeymapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for funckeymaps.
     */
    cursor?: funckeymapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` funckeymaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` funckeymaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of funckeymaps.
     */
    distinct?: FunckeymapScalarFieldEnum | FunckeymapScalarFieldEnum[]
  }

  /**
   * funckeymap findFirstOrThrow
   */
  export type funckeymapFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the funckeymap
     */
    select?: funckeymapSelect<ExtArgs> | null
    /**
     * Filter, which funckeymap to fetch.
     */
    where?: funckeymapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of funckeymaps to fetch.
     */
    orderBy?: funckeymapOrderByWithRelationInput | funckeymapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for funckeymaps.
     */
    cursor?: funckeymapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` funckeymaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` funckeymaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of funckeymaps.
     */
    distinct?: FunckeymapScalarFieldEnum | FunckeymapScalarFieldEnum[]
  }

  /**
   * funckeymap findMany
   */
  export type funckeymapFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the funckeymap
     */
    select?: funckeymapSelect<ExtArgs> | null
    /**
     * Filter, which funckeymaps to fetch.
     */
    where?: funckeymapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of funckeymaps to fetch.
     */
    orderBy?: funckeymapOrderByWithRelationInput | funckeymapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing funckeymaps.
     */
    cursor?: funckeymapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` funckeymaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` funckeymaps.
     */
    skip?: number
    distinct?: FunckeymapScalarFieldEnum | FunckeymapScalarFieldEnum[]
  }

  /**
   * funckeymap create
   */
  export type funckeymapCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the funckeymap
     */
    select?: funckeymapSelect<ExtArgs> | null
    /**
     * The data needed to create a funckeymap.
     */
    data?: XOR<funckeymapCreateInput, funckeymapUncheckedCreateInput>
  }

  /**
   * funckeymap createMany
   */
  export type funckeymapCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many funckeymaps.
     */
    data: funckeymapCreateManyInput | funckeymapCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * funckeymap update
   */
  export type funckeymapUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the funckeymap
     */
    select?: funckeymapSelect<ExtArgs> | null
    /**
     * The data needed to update a funckeymap.
     */
    data: XOR<funckeymapUpdateInput, funckeymapUncheckedUpdateInput>
    /**
     * Choose, which funckeymap to update.
     */
    where: funckeymapWhereUniqueInput
  }

  /**
   * funckeymap updateMany
   */
  export type funckeymapUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update funckeymaps.
     */
    data: XOR<funckeymapUpdateManyMutationInput, funckeymapUncheckedUpdateManyInput>
    /**
     * Filter which funckeymaps to update
     */
    where?: funckeymapWhereInput
  }

  /**
   * funckeymap upsert
   */
  export type funckeymapUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the funckeymap
     */
    select?: funckeymapSelect<ExtArgs> | null
    /**
     * The filter to search for the funckeymap to update in case it exists.
     */
    where: funckeymapWhereUniqueInput
    /**
     * In case the funckeymap found by the `where` argument doesn't exist, create a new funckeymap with this data.
     */
    create: XOR<funckeymapCreateInput, funckeymapUncheckedCreateInput>
    /**
     * In case the funckeymap was found with the provided `where` argument, update it with this data.
     */
    update: XOR<funckeymapUpdateInput, funckeymapUncheckedUpdateInput>
  }

  /**
   * funckeymap delete
   */
  export type funckeymapDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the funckeymap
     */
    select?: funckeymapSelect<ExtArgs> | null
    /**
     * Filter which funckeymap to delete.
     */
    where: funckeymapWhereUniqueInput
  }

  /**
   * funckeymap deleteMany
   */
  export type funckeymapDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which funckeymaps to delete
     */
    where?: funckeymapWhereInput
  }

  /**
   * funckeymap without action
   */
  export type funckeymapDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the funckeymap
     */
    select?: funckeymapSelect<ExtArgs> | null
  }


  /**
   * Model gradenames
   */

  export type AggregateGradenames = {
    _count: GradenamesCountAggregateOutputType | null
    _avg: GradenamesAvgAggregateOutputType | null
    _sum: GradenamesSumAggregateOutputType | null
    _min: GradenamesMinAggregateOutputType | null
    _max: GradenamesMaxAggregateOutputType | null
  }

  export type GradenamesAvgAggregateOutputType = {
    id: number | null
    guildid: number | null
  }

  export type GradenamesSumAggregateOutputType = {
    id: number | null
    guildid: number | null
  }

  export type GradenamesMinAggregateOutputType = {
    id: number | null
    gradename: string | null
    guildid: number | null
  }

  export type GradenamesMaxAggregateOutputType = {
    id: number | null
    gradename: string | null
    guildid: number | null
  }

  export type GradenamesCountAggregateOutputType = {
    id: number
    gradename: number
    guildid: number
    _all: number
  }


  export type GradenamesAvgAggregateInputType = {
    id?: true
    guildid?: true
  }

  export type GradenamesSumAggregateInputType = {
    id?: true
    guildid?: true
  }

  export type GradenamesMinAggregateInputType = {
    id?: true
    gradename?: true
    guildid?: true
  }

  export type GradenamesMaxAggregateInputType = {
    id?: true
    gradename?: true
    guildid?: true
  }

  export type GradenamesCountAggregateInputType = {
    id?: true
    gradename?: true
    guildid?: true
    _all?: true
  }

  export type GradenamesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which gradenames to aggregate.
     */
    where?: gradenamesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gradenames to fetch.
     */
    orderBy?: gradenamesOrderByWithRelationInput | gradenamesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: gradenamesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gradenames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gradenames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned gradenames
    **/
    _count?: true | GradenamesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GradenamesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GradenamesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GradenamesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GradenamesMaxAggregateInputType
  }

  export type GetGradenamesAggregateType<T extends GradenamesAggregateArgs> = {
        [P in keyof T & keyof AggregateGradenames]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGradenames[P]>
      : GetScalarType<T[P], AggregateGradenames[P]>
  }




  export type gradenamesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: gradenamesWhereInput
    orderBy?: gradenamesOrderByWithAggregationInput | gradenamesOrderByWithAggregationInput[]
    by: GradenamesScalarFieldEnum[] | GradenamesScalarFieldEnum
    having?: gradenamesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GradenamesCountAggregateInputType | true
    _avg?: GradenamesAvgAggregateInputType
    _sum?: GradenamesSumAggregateInputType
    _min?: GradenamesMinAggregateInputType
    _max?: GradenamesMaxAggregateInputType
  }

  export type GradenamesGroupByOutputType = {
    id: number
    gradename: string | null
    guildid: number | null
    _count: GradenamesCountAggregateOutputType | null
    _avg: GradenamesAvgAggregateOutputType | null
    _sum: GradenamesSumAggregateOutputType | null
    _min: GradenamesMinAggregateOutputType | null
    _max: GradenamesMaxAggregateOutputType | null
  }

  type GetGradenamesGroupByPayload<T extends gradenamesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GradenamesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GradenamesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GradenamesGroupByOutputType[P]>
            : GetScalarType<T[P], GradenamesGroupByOutputType[P]>
        }
      >
    >


  export type gradenamesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gradename?: boolean
    guildid?: boolean
  }, ExtArgs["result"]["gradenames"]>


  export type gradenamesSelectScalar = {
    id?: boolean
    gradename?: boolean
    guildid?: boolean
  }


  export type $gradenamesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "gradenames"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      gradename: string | null
      guildid: number | null
    }, ExtArgs["result"]["gradenames"]>
    composites: {}
  }

  type gradenamesGetPayload<S extends boolean | null | undefined | gradenamesDefaultArgs> = $Result.GetResult<Prisma.$gradenamesPayload, S>

  type gradenamesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<gradenamesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GradenamesCountAggregateInputType | true
    }

  export interface gradenamesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['gradenames'], meta: { name: 'gradenames' } }
    /**
     * Find zero or one Gradenames that matches the filter.
     * @param {gradenamesFindUniqueArgs} args - Arguments to find a Gradenames
     * @example
     * // Get one Gradenames
     * const gradenames = await prisma.gradenames.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends gradenamesFindUniqueArgs>(args: SelectSubset<T, gradenamesFindUniqueArgs<ExtArgs>>): Prisma__gradenamesClient<$Result.GetResult<Prisma.$gradenamesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Gradenames that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {gradenamesFindUniqueOrThrowArgs} args - Arguments to find a Gradenames
     * @example
     * // Get one Gradenames
     * const gradenames = await prisma.gradenames.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends gradenamesFindUniqueOrThrowArgs>(args: SelectSubset<T, gradenamesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__gradenamesClient<$Result.GetResult<Prisma.$gradenamesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Gradenames that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gradenamesFindFirstArgs} args - Arguments to find a Gradenames
     * @example
     * // Get one Gradenames
     * const gradenames = await prisma.gradenames.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends gradenamesFindFirstArgs>(args?: SelectSubset<T, gradenamesFindFirstArgs<ExtArgs>>): Prisma__gradenamesClient<$Result.GetResult<Prisma.$gradenamesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Gradenames that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gradenamesFindFirstOrThrowArgs} args - Arguments to find a Gradenames
     * @example
     * // Get one Gradenames
     * const gradenames = await prisma.gradenames.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends gradenamesFindFirstOrThrowArgs>(args?: SelectSubset<T, gradenamesFindFirstOrThrowArgs<ExtArgs>>): Prisma__gradenamesClient<$Result.GetResult<Prisma.$gradenamesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Gradenames that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gradenamesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Gradenames
     * const gradenames = await prisma.gradenames.findMany()
     * 
     * // Get first 10 Gradenames
     * const gradenames = await prisma.gradenames.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gradenamesWithIdOnly = await prisma.gradenames.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends gradenamesFindManyArgs>(args?: SelectSubset<T, gradenamesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$gradenamesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Gradenames.
     * @param {gradenamesCreateArgs} args - Arguments to create a Gradenames.
     * @example
     * // Create one Gradenames
     * const Gradenames = await prisma.gradenames.create({
     *   data: {
     *     // ... data to create a Gradenames
     *   }
     * })
     * 
     */
    create<T extends gradenamesCreateArgs>(args: SelectSubset<T, gradenamesCreateArgs<ExtArgs>>): Prisma__gradenamesClient<$Result.GetResult<Prisma.$gradenamesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Gradenames.
     * @param {gradenamesCreateManyArgs} args - Arguments to create many Gradenames.
     * @example
     * // Create many Gradenames
     * const gradenames = await prisma.gradenames.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends gradenamesCreateManyArgs>(args?: SelectSubset<T, gradenamesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Gradenames.
     * @param {gradenamesDeleteArgs} args - Arguments to delete one Gradenames.
     * @example
     * // Delete one Gradenames
     * const Gradenames = await prisma.gradenames.delete({
     *   where: {
     *     // ... filter to delete one Gradenames
     *   }
     * })
     * 
     */
    delete<T extends gradenamesDeleteArgs>(args: SelectSubset<T, gradenamesDeleteArgs<ExtArgs>>): Prisma__gradenamesClient<$Result.GetResult<Prisma.$gradenamesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Gradenames.
     * @param {gradenamesUpdateArgs} args - Arguments to update one Gradenames.
     * @example
     * // Update one Gradenames
     * const gradenames = await prisma.gradenames.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends gradenamesUpdateArgs>(args: SelectSubset<T, gradenamesUpdateArgs<ExtArgs>>): Prisma__gradenamesClient<$Result.GetResult<Prisma.$gradenamesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Gradenames.
     * @param {gradenamesDeleteManyArgs} args - Arguments to filter Gradenames to delete.
     * @example
     * // Delete a few Gradenames
     * const { count } = await prisma.gradenames.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends gradenamesDeleteManyArgs>(args?: SelectSubset<T, gradenamesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gradenames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gradenamesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Gradenames
     * const gradenames = await prisma.gradenames.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends gradenamesUpdateManyArgs>(args: SelectSubset<T, gradenamesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Gradenames.
     * @param {gradenamesUpsertArgs} args - Arguments to update or create a Gradenames.
     * @example
     * // Update or create a Gradenames
     * const gradenames = await prisma.gradenames.upsert({
     *   create: {
     *     // ... data to create a Gradenames
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Gradenames we want to update
     *   }
     * })
     */
    upsert<T extends gradenamesUpsertArgs>(args: SelectSubset<T, gradenamesUpsertArgs<ExtArgs>>): Prisma__gradenamesClient<$Result.GetResult<Prisma.$gradenamesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Gradenames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gradenamesCountArgs} args - Arguments to filter Gradenames to count.
     * @example
     * // Count the number of Gradenames
     * const count = await prisma.gradenames.count({
     *   where: {
     *     // ... the filter for the Gradenames we want to count
     *   }
     * })
    **/
    count<T extends gradenamesCountArgs>(
      args?: Subset<T, gradenamesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GradenamesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Gradenames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradenamesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GradenamesAggregateArgs>(args: Subset<T, GradenamesAggregateArgs>): Prisma.PrismaPromise<GetGradenamesAggregateType<T>>

    /**
     * Group by Gradenames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gradenamesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends gradenamesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: gradenamesGroupByArgs['orderBy'] }
        : { orderBy?: gradenamesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, gradenamesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGradenamesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the gradenames model
   */
  readonly fields: gradenamesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for gradenames.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__gradenamesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the gradenames model
   */ 
  interface gradenamesFieldRefs {
    readonly id: FieldRef<"gradenames", 'Int'>
    readonly gradename: FieldRef<"gradenames", 'String'>
    readonly guildid: FieldRef<"gradenames", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * gradenames findUnique
   */
  export type gradenamesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gradenames
     */
    select?: gradenamesSelect<ExtArgs> | null
    /**
     * Filter, which gradenames to fetch.
     */
    where: gradenamesWhereUniqueInput
  }

  /**
   * gradenames findUniqueOrThrow
   */
  export type gradenamesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gradenames
     */
    select?: gradenamesSelect<ExtArgs> | null
    /**
     * Filter, which gradenames to fetch.
     */
    where: gradenamesWhereUniqueInput
  }

  /**
   * gradenames findFirst
   */
  export type gradenamesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gradenames
     */
    select?: gradenamesSelect<ExtArgs> | null
    /**
     * Filter, which gradenames to fetch.
     */
    where?: gradenamesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gradenames to fetch.
     */
    orderBy?: gradenamesOrderByWithRelationInput | gradenamesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for gradenames.
     */
    cursor?: gradenamesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gradenames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gradenames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of gradenames.
     */
    distinct?: GradenamesScalarFieldEnum | GradenamesScalarFieldEnum[]
  }

  /**
   * gradenames findFirstOrThrow
   */
  export type gradenamesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gradenames
     */
    select?: gradenamesSelect<ExtArgs> | null
    /**
     * Filter, which gradenames to fetch.
     */
    where?: gradenamesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gradenames to fetch.
     */
    orderBy?: gradenamesOrderByWithRelationInput | gradenamesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for gradenames.
     */
    cursor?: gradenamesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gradenames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gradenames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of gradenames.
     */
    distinct?: GradenamesScalarFieldEnum | GradenamesScalarFieldEnum[]
  }

  /**
   * gradenames findMany
   */
  export type gradenamesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gradenames
     */
    select?: gradenamesSelect<ExtArgs> | null
    /**
     * Filter, which gradenames to fetch.
     */
    where?: gradenamesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gradenames to fetch.
     */
    orderBy?: gradenamesOrderByWithRelationInput | gradenamesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing gradenames.
     */
    cursor?: gradenamesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gradenames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gradenames.
     */
    skip?: number
    distinct?: GradenamesScalarFieldEnum | GradenamesScalarFieldEnum[]
  }

  /**
   * gradenames create
   */
  export type gradenamesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gradenames
     */
    select?: gradenamesSelect<ExtArgs> | null
    /**
     * The data needed to create a gradenames.
     */
    data?: XOR<gradenamesCreateInput, gradenamesUncheckedCreateInput>
  }

  /**
   * gradenames createMany
   */
  export type gradenamesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many gradenames.
     */
    data: gradenamesCreateManyInput | gradenamesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * gradenames update
   */
  export type gradenamesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gradenames
     */
    select?: gradenamesSelect<ExtArgs> | null
    /**
     * The data needed to update a gradenames.
     */
    data: XOR<gradenamesUpdateInput, gradenamesUncheckedUpdateInput>
    /**
     * Choose, which gradenames to update.
     */
    where: gradenamesWhereUniqueInput
  }

  /**
   * gradenames updateMany
   */
  export type gradenamesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update gradenames.
     */
    data: XOR<gradenamesUpdateManyMutationInput, gradenamesUncheckedUpdateManyInput>
    /**
     * Filter which gradenames to update
     */
    where?: gradenamesWhereInput
  }

  /**
   * gradenames upsert
   */
  export type gradenamesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gradenames
     */
    select?: gradenamesSelect<ExtArgs> | null
    /**
     * The filter to search for the gradenames to update in case it exists.
     */
    where: gradenamesWhereUniqueInput
    /**
     * In case the gradenames found by the `where` argument doesn't exist, create a new gradenames with this data.
     */
    create: XOR<gradenamesCreateInput, gradenamesUncheckedCreateInput>
    /**
     * In case the gradenames was found with the provided `where` argument, update it with this data.
     */
    update: XOR<gradenamesUpdateInput, gradenamesUncheckedUpdateInput>
  }

  /**
   * gradenames delete
   */
  export type gradenamesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gradenames
     */
    select?: gradenamesSelect<ExtArgs> | null
    /**
     * Filter which gradenames to delete.
     */
    where: gradenamesWhereUniqueInput
  }

  /**
   * gradenames deleteMany
   */
  export type gradenamesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which gradenames to delete
     */
    where?: gradenamesWhereInput
  }

  /**
   * gradenames without action
   */
  export type gradenamesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gradenames
     */
    select?: gradenamesSelect<ExtArgs> | null
  }


  /**
   * Model guildmembers
   */

  export type AggregateGuildmembers = {
    _count: GuildmembersCountAggregateOutputType | null
    _avg: GuildmembersAvgAggregateOutputType | null
    _sum: GuildmembersSumAggregateOutputType | null
    _min: GuildmembersMinAggregateOutputType | null
    _max: GuildmembersMaxAggregateOutputType | null
  }

  export type GuildmembersAvgAggregateOutputType = {
    id: number | null
    charid: number | null
    guildid: number | null
    grade: number | null
    alliancegrade: number | null
    commitment: number | null
    daycommitment: number | null
    igp: number | null
    job: number | null
    level: number | null
  }

  export type GuildmembersSumAggregateOutputType = {
    id: number | null
    charid: number | null
    guildid: number | null
    grade: number | null
    alliancegrade: number | null
    commitment: number | null
    daycommitment: number | null
    igp: number | null
    job: number | null
    level: number | null
  }

  export type GuildmembersMinAggregateOutputType = {
    id: number | null
    charid: number | null
    guildid: number | null
    grade: number | null
    alliancegrade: number | null
    commitment: number | null
    daycommitment: number | null
    igp: number | null
    commitmentinctime: Date | null
    name: string | null
    job: number | null
    level: number | null
    loggedin: boolean | null
  }

  export type GuildmembersMaxAggregateOutputType = {
    id: number | null
    charid: number | null
    guildid: number | null
    grade: number | null
    alliancegrade: number | null
    commitment: number | null
    daycommitment: number | null
    igp: number | null
    commitmentinctime: Date | null
    name: string | null
    job: number | null
    level: number | null
    loggedin: boolean | null
  }

  export type GuildmembersCountAggregateOutputType = {
    id: number
    charid: number
    guildid: number
    grade: number
    alliancegrade: number
    commitment: number
    daycommitment: number
    igp: number
    commitmentinctime: number
    name: number
    job: number
    level: number
    loggedin: number
    _all: number
  }


  export type GuildmembersAvgAggregateInputType = {
    id?: true
    charid?: true
    guildid?: true
    grade?: true
    alliancegrade?: true
    commitment?: true
    daycommitment?: true
    igp?: true
    job?: true
    level?: true
  }

  export type GuildmembersSumAggregateInputType = {
    id?: true
    charid?: true
    guildid?: true
    grade?: true
    alliancegrade?: true
    commitment?: true
    daycommitment?: true
    igp?: true
    job?: true
    level?: true
  }

  export type GuildmembersMinAggregateInputType = {
    id?: true
    charid?: true
    guildid?: true
    grade?: true
    alliancegrade?: true
    commitment?: true
    daycommitment?: true
    igp?: true
    commitmentinctime?: true
    name?: true
    job?: true
    level?: true
    loggedin?: true
  }

  export type GuildmembersMaxAggregateInputType = {
    id?: true
    charid?: true
    guildid?: true
    grade?: true
    alliancegrade?: true
    commitment?: true
    daycommitment?: true
    igp?: true
    commitmentinctime?: true
    name?: true
    job?: true
    level?: true
    loggedin?: true
  }

  export type GuildmembersCountAggregateInputType = {
    id?: true
    charid?: true
    guildid?: true
    grade?: true
    alliancegrade?: true
    commitment?: true
    daycommitment?: true
    igp?: true
    commitmentinctime?: true
    name?: true
    job?: true
    level?: true
    loggedin?: true
    _all?: true
  }

  export type GuildmembersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which guildmembers to aggregate.
     */
    where?: guildmembersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of guildmembers to fetch.
     */
    orderBy?: guildmembersOrderByWithRelationInput | guildmembersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: guildmembersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` guildmembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` guildmembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned guildmembers
    **/
    _count?: true | GuildmembersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GuildmembersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GuildmembersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GuildmembersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GuildmembersMaxAggregateInputType
  }

  export type GetGuildmembersAggregateType<T extends GuildmembersAggregateArgs> = {
        [P in keyof T & keyof AggregateGuildmembers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGuildmembers[P]>
      : GetScalarType<T[P], AggregateGuildmembers[P]>
  }




  export type guildmembersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: guildmembersWhereInput
    orderBy?: guildmembersOrderByWithAggregationInput | guildmembersOrderByWithAggregationInput[]
    by: GuildmembersScalarFieldEnum[] | GuildmembersScalarFieldEnum
    having?: guildmembersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GuildmembersCountAggregateInputType | true
    _avg?: GuildmembersAvgAggregateInputType
    _sum?: GuildmembersSumAggregateInputType
    _min?: GuildmembersMinAggregateInputType
    _max?: GuildmembersMaxAggregateInputType
  }

  export type GuildmembersGroupByOutputType = {
    id: number
    charid: number | null
    guildid: number | null
    grade: number | null
    alliancegrade: number | null
    commitment: number | null
    daycommitment: number | null
    igp: number | null
    commitmentinctime: Date | null
    name: string | null
    job: number | null
    level: number | null
    loggedin: boolean | null
    _count: GuildmembersCountAggregateOutputType | null
    _avg: GuildmembersAvgAggregateOutputType | null
    _sum: GuildmembersSumAggregateOutputType | null
    _min: GuildmembersMinAggregateOutputType | null
    _max: GuildmembersMaxAggregateOutputType | null
  }

  type GetGuildmembersGroupByPayload<T extends guildmembersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GuildmembersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GuildmembersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GuildmembersGroupByOutputType[P]>
            : GetScalarType<T[P], GuildmembersGroupByOutputType[P]>
        }
      >
    >


  export type guildmembersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    charid?: boolean
    guildid?: boolean
    grade?: boolean
    alliancegrade?: boolean
    commitment?: boolean
    daycommitment?: boolean
    igp?: boolean
    commitmentinctime?: boolean
    name?: boolean
    job?: boolean
    level?: boolean
    loggedin?: boolean
  }, ExtArgs["result"]["guildmembers"]>


  export type guildmembersSelectScalar = {
    id?: boolean
    charid?: boolean
    guildid?: boolean
    grade?: boolean
    alliancegrade?: boolean
    commitment?: boolean
    daycommitment?: boolean
    igp?: boolean
    commitmentinctime?: boolean
    name?: boolean
    job?: boolean
    level?: boolean
    loggedin?: boolean
  }


  export type $guildmembersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "guildmembers"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      charid: number | null
      guildid: number | null
      grade: number | null
      alliancegrade: number | null
      commitment: number | null
      daycommitment: number | null
      igp: number | null
      commitmentinctime: Date | null
      name: string | null
      job: number | null
      level: number | null
      loggedin: boolean | null
    }, ExtArgs["result"]["guildmembers"]>
    composites: {}
  }

  type guildmembersGetPayload<S extends boolean | null | undefined | guildmembersDefaultArgs> = $Result.GetResult<Prisma.$guildmembersPayload, S>

  type guildmembersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<guildmembersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GuildmembersCountAggregateInputType | true
    }

  export interface guildmembersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['guildmembers'], meta: { name: 'guildmembers' } }
    /**
     * Find zero or one Guildmembers that matches the filter.
     * @param {guildmembersFindUniqueArgs} args - Arguments to find a Guildmembers
     * @example
     * // Get one Guildmembers
     * const guildmembers = await prisma.guildmembers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends guildmembersFindUniqueArgs>(args: SelectSubset<T, guildmembersFindUniqueArgs<ExtArgs>>): Prisma__guildmembersClient<$Result.GetResult<Prisma.$guildmembersPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Guildmembers that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {guildmembersFindUniqueOrThrowArgs} args - Arguments to find a Guildmembers
     * @example
     * // Get one Guildmembers
     * const guildmembers = await prisma.guildmembers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends guildmembersFindUniqueOrThrowArgs>(args: SelectSubset<T, guildmembersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__guildmembersClient<$Result.GetResult<Prisma.$guildmembersPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Guildmembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guildmembersFindFirstArgs} args - Arguments to find a Guildmembers
     * @example
     * // Get one Guildmembers
     * const guildmembers = await prisma.guildmembers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends guildmembersFindFirstArgs>(args?: SelectSubset<T, guildmembersFindFirstArgs<ExtArgs>>): Prisma__guildmembersClient<$Result.GetResult<Prisma.$guildmembersPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Guildmembers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guildmembersFindFirstOrThrowArgs} args - Arguments to find a Guildmembers
     * @example
     * // Get one Guildmembers
     * const guildmembers = await prisma.guildmembers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends guildmembersFindFirstOrThrowArgs>(args?: SelectSubset<T, guildmembersFindFirstOrThrowArgs<ExtArgs>>): Prisma__guildmembersClient<$Result.GetResult<Prisma.$guildmembersPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Guildmembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guildmembersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Guildmembers
     * const guildmembers = await prisma.guildmembers.findMany()
     * 
     * // Get first 10 Guildmembers
     * const guildmembers = await prisma.guildmembers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const guildmembersWithIdOnly = await prisma.guildmembers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends guildmembersFindManyArgs>(args?: SelectSubset<T, guildmembersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$guildmembersPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Guildmembers.
     * @param {guildmembersCreateArgs} args - Arguments to create a Guildmembers.
     * @example
     * // Create one Guildmembers
     * const Guildmembers = await prisma.guildmembers.create({
     *   data: {
     *     // ... data to create a Guildmembers
     *   }
     * })
     * 
     */
    create<T extends guildmembersCreateArgs>(args: SelectSubset<T, guildmembersCreateArgs<ExtArgs>>): Prisma__guildmembersClient<$Result.GetResult<Prisma.$guildmembersPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Guildmembers.
     * @param {guildmembersCreateManyArgs} args - Arguments to create many Guildmembers.
     * @example
     * // Create many Guildmembers
     * const guildmembers = await prisma.guildmembers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends guildmembersCreateManyArgs>(args?: SelectSubset<T, guildmembersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Guildmembers.
     * @param {guildmembersDeleteArgs} args - Arguments to delete one Guildmembers.
     * @example
     * // Delete one Guildmembers
     * const Guildmembers = await prisma.guildmembers.delete({
     *   where: {
     *     // ... filter to delete one Guildmembers
     *   }
     * })
     * 
     */
    delete<T extends guildmembersDeleteArgs>(args: SelectSubset<T, guildmembersDeleteArgs<ExtArgs>>): Prisma__guildmembersClient<$Result.GetResult<Prisma.$guildmembersPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Guildmembers.
     * @param {guildmembersUpdateArgs} args - Arguments to update one Guildmembers.
     * @example
     * // Update one Guildmembers
     * const guildmembers = await prisma.guildmembers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends guildmembersUpdateArgs>(args: SelectSubset<T, guildmembersUpdateArgs<ExtArgs>>): Prisma__guildmembersClient<$Result.GetResult<Prisma.$guildmembersPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Guildmembers.
     * @param {guildmembersDeleteManyArgs} args - Arguments to filter Guildmembers to delete.
     * @example
     * // Delete a few Guildmembers
     * const { count } = await prisma.guildmembers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends guildmembersDeleteManyArgs>(args?: SelectSubset<T, guildmembersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Guildmembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guildmembersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Guildmembers
     * const guildmembers = await prisma.guildmembers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends guildmembersUpdateManyArgs>(args: SelectSubset<T, guildmembersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Guildmembers.
     * @param {guildmembersUpsertArgs} args - Arguments to update or create a Guildmembers.
     * @example
     * // Update or create a Guildmembers
     * const guildmembers = await prisma.guildmembers.upsert({
     *   create: {
     *     // ... data to create a Guildmembers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Guildmembers we want to update
     *   }
     * })
     */
    upsert<T extends guildmembersUpsertArgs>(args: SelectSubset<T, guildmembersUpsertArgs<ExtArgs>>): Prisma__guildmembersClient<$Result.GetResult<Prisma.$guildmembersPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Guildmembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guildmembersCountArgs} args - Arguments to filter Guildmembers to count.
     * @example
     * // Count the number of Guildmembers
     * const count = await prisma.guildmembers.count({
     *   where: {
     *     // ... the filter for the Guildmembers we want to count
     *   }
     * })
    **/
    count<T extends guildmembersCountArgs>(
      args?: Subset<T, guildmembersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GuildmembersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Guildmembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildmembersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GuildmembersAggregateArgs>(args: Subset<T, GuildmembersAggregateArgs>): Prisma.PrismaPromise<GetGuildmembersAggregateType<T>>

    /**
     * Group by Guildmembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guildmembersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends guildmembersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: guildmembersGroupByArgs['orderBy'] }
        : { orderBy?: guildmembersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, guildmembersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGuildmembersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the guildmembers model
   */
  readonly fields: guildmembersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for guildmembers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__guildmembersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the guildmembers model
   */ 
  interface guildmembersFieldRefs {
    readonly id: FieldRef<"guildmembers", 'Int'>
    readonly charid: FieldRef<"guildmembers", 'Int'>
    readonly guildid: FieldRef<"guildmembers", 'Int'>
    readonly grade: FieldRef<"guildmembers", 'Int'>
    readonly alliancegrade: FieldRef<"guildmembers", 'Int'>
    readonly commitment: FieldRef<"guildmembers", 'Int'>
    readonly daycommitment: FieldRef<"guildmembers", 'Int'>
    readonly igp: FieldRef<"guildmembers", 'Int'>
    readonly commitmentinctime: FieldRef<"guildmembers", 'DateTime'>
    readonly name: FieldRef<"guildmembers", 'String'>
    readonly job: FieldRef<"guildmembers", 'Int'>
    readonly level: FieldRef<"guildmembers", 'Int'>
    readonly loggedin: FieldRef<"guildmembers", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * guildmembers findUnique
   */
  export type guildmembersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guildmembers
     */
    select?: guildmembersSelect<ExtArgs> | null
    /**
     * Filter, which guildmembers to fetch.
     */
    where: guildmembersWhereUniqueInput
  }

  /**
   * guildmembers findUniqueOrThrow
   */
  export type guildmembersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guildmembers
     */
    select?: guildmembersSelect<ExtArgs> | null
    /**
     * Filter, which guildmembers to fetch.
     */
    where: guildmembersWhereUniqueInput
  }

  /**
   * guildmembers findFirst
   */
  export type guildmembersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guildmembers
     */
    select?: guildmembersSelect<ExtArgs> | null
    /**
     * Filter, which guildmembers to fetch.
     */
    where?: guildmembersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of guildmembers to fetch.
     */
    orderBy?: guildmembersOrderByWithRelationInput | guildmembersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for guildmembers.
     */
    cursor?: guildmembersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` guildmembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` guildmembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of guildmembers.
     */
    distinct?: GuildmembersScalarFieldEnum | GuildmembersScalarFieldEnum[]
  }

  /**
   * guildmembers findFirstOrThrow
   */
  export type guildmembersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guildmembers
     */
    select?: guildmembersSelect<ExtArgs> | null
    /**
     * Filter, which guildmembers to fetch.
     */
    where?: guildmembersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of guildmembers to fetch.
     */
    orderBy?: guildmembersOrderByWithRelationInput | guildmembersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for guildmembers.
     */
    cursor?: guildmembersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` guildmembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` guildmembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of guildmembers.
     */
    distinct?: GuildmembersScalarFieldEnum | GuildmembersScalarFieldEnum[]
  }

  /**
   * guildmembers findMany
   */
  export type guildmembersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guildmembers
     */
    select?: guildmembersSelect<ExtArgs> | null
    /**
     * Filter, which guildmembers to fetch.
     */
    where?: guildmembersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of guildmembers to fetch.
     */
    orderBy?: guildmembersOrderByWithRelationInput | guildmembersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing guildmembers.
     */
    cursor?: guildmembersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` guildmembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` guildmembers.
     */
    skip?: number
    distinct?: GuildmembersScalarFieldEnum | GuildmembersScalarFieldEnum[]
  }

  /**
   * guildmembers create
   */
  export type guildmembersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guildmembers
     */
    select?: guildmembersSelect<ExtArgs> | null
    /**
     * The data needed to create a guildmembers.
     */
    data?: XOR<guildmembersCreateInput, guildmembersUncheckedCreateInput>
  }

  /**
   * guildmembers createMany
   */
  export type guildmembersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many guildmembers.
     */
    data: guildmembersCreateManyInput | guildmembersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * guildmembers update
   */
  export type guildmembersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guildmembers
     */
    select?: guildmembersSelect<ExtArgs> | null
    /**
     * The data needed to update a guildmembers.
     */
    data: XOR<guildmembersUpdateInput, guildmembersUncheckedUpdateInput>
    /**
     * Choose, which guildmembers to update.
     */
    where: guildmembersWhereUniqueInput
  }

  /**
   * guildmembers updateMany
   */
  export type guildmembersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update guildmembers.
     */
    data: XOR<guildmembersUpdateManyMutationInput, guildmembersUncheckedUpdateManyInput>
    /**
     * Filter which guildmembers to update
     */
    where?: guildmembersWhereInput
  }

  /**
   * guildmembers upsert
   */
  export type guildmembersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guildmembers
     */
    select?: guildmembersSelect<ExtArgs> | null
    /**
     * The filter to search for the guildmembers to update in case it exists.
     */
    where: guildmembersWhereUniqueInput
    /**
     * In case the guildmembers found by the `where` argument doesn't exist, create a new guildmembers with this data.
     */
    create: XOR<guildmembersCreateInput, guildmembersUncheckedCreateInput>
    /**
     * In case the guildmembers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<guildmembersUpdateInput, guildmembersUncheckedUpdateInput>
  }

  /**
   * guildmembers delete
   */
  export type guildmembersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guildmembers
     */
    select?: guildmembersSelect<ExtArgs> | null
    /**
     * Filter which guildmembers to delete.
     */
    where: guildmembersWhereUniqueInput
  }

  /**
   * guildmembers deleteMany
   */
  export type guildmembersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which guildmembers to delete
     */
    where?: guildmembersWhereInput
  }

  /**
   * guildmembers without action
   */
  export type guildmembersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guildmembers
     */
    select?: guildmembersSelect<ExtArgs> | null
  }


  /**
   * Model guildrequestors
   */

  export type AggregateGuildrequestors = {
    _count: GuildrequestorsCountAggregateOutputType | null
    _avg: GuildrequestorsAvgAggregateOutputType | null
    _sum: GuildrequestorsSumAggregateOutputType | null
    _min: GuildrequestorsMinAggregateOutputType | null
    _max: GuildrequestorsMaxAggregateOutputType | null
  }

  export type GuildrequestorsAvgAggregateOutputType = {
    id: number | null
    requestors_id: number | null
    charid: number | null
    guildid: number | null
    job: number | null
    level: number | null
  }

  export type GuildrequestorsSumAggregateOutputType = {
    id: number | null
    requestors_id: number | null
    charid: number | null
    guildid: number | null
    job: number | null
    level: number | null
  }

  export type GuildrequestorsMinAggregateOutputType = {
    id: number | null
    requestors_id: number | null
    charid: number | null
    guildid: number | null
    name: string | null
    job: number | null
    level: number | null
    loggedin: boolean | null
  }

  export type GuildrequestorsMaxAggregateOutputType = {
    id: number | null
    requestors_id: number | null
    charid: number | null
    guildid: number | null
    name: string | null
    job: number | null
    level: number | null
    loggedin: boolean | null
  }

  export type GuildrequestorsCountAggregateOutputType = {
    id: number
    requestors_id: number
    charid: number
    guildid: number
    name: number
    job: number
    level: number
    loggedin: number
    _all: number
  }


  export type GuildrequestorsAvgAggregateInputType = {
    id?: true
    requestors_id?: true
    charid?: true
    guildid?: true
    job?: true
    level?: true
  }

  export type GuildrequestorsSumAggregateInputType = {
    id?: true
    requestors_id?: true
    charid?: true
    guildid?: true
    job?: true
    level?: true
  }

  export type GuildrequestorsMinAggregateInputType = {
    id?: true
    requestors_id?: true
    charid?: true
    guildid?: true
    name?: true
    job?: true
    level?: true
    loggedin?: true
  }

  export type GuildrequestorsMaxAggregateInputType = {
    id?: true
    requestors_id?: true
    charid?: true
    guildid?: true
    name?: true
    job?: true
    level?: true
    loggedin?: true
  }

  export type GuildrequestorsCountAggregateInputType = {
    id?: true
    requestors_id?: true
    charid?: true
    guildid?: true
    name?: true
    job?: true
    level?: true
    loggedin?: true
    _all?: true
  }

  export type GuildrequestorsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which guildrequestors to aggregate.
     */
    where?: guildrequestorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of guildrequestors to fetch.
     */
    orderBy?: guildrequestorsOrderByWithRelationInput | guildrequestorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: guildrequestorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` guildrequestors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` guildrequestors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned guildrequestors
    **/
    _count?: true | GuildrequestorsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GuildrequestorsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GuildrequestorsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GuildrequestorsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GuildrequestorsMaxAggregateInputType
  }

  export type GetGuildrequestorsAggregateType<T extends GuildrequestorsAggregateArgs> = {
        [P in keyof T & keyof AggregateGuildrequestors]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGuildrequestors[P]>
      : GetScalarType<T[P], AggregateGuildrequestors[P]>
  }




  export type guildrequestorsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: guildrequestorsWhereInput
    orderBy?: guildrequestorsOrderByWithAggregationInput | guildrequestorsOrderByWithAggregationInput[]
    by: GuildrequestorsScalarFieldEnum[] | GuildrequestorsScalarFieldEnum
    having?: guildrequestorsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GuildrequestorsCountAggregateInputType | true
    _avg?: GuildrequestorsAvgAggregateInputType
    _sum?: GuildrequestorsSumAggregateInputType
    _min?: GuildrequestorsMinAggregateInputType
    _max?: GuildrequestorsMaxAggregateInputType
  }

  export type GuildrequestorsGroupByOutputType = {
    id: number
    requestors_id: number | null
    charid: number | null
    guildid: number | null
    name: string | null
    job: number | null
    level: number | null
    loggedin: boolean | null
    _count: GuildrequestorsCountAggregateOutputType | null
    _avg: GuildrequestorsAvgAggregateOutputType | null
    _sum: GuildrequestorsSumAggregateOutputType | null
    _min: GuildrequestorsMinAggregateOutputType | null
    _max: GuildrequestorsMaxAggregateOutputType | null
  }

  type GetGuildrequestorsGroupByPayload<T extends guildrequestorsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GuildrequestorsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GuildrequestorsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GuildrequestorsGroupByOutputType[P]>
            : GetScalarType<T[P], GuildrequestorsGroupByOutputType[P]>
        }
      >
    >


  export type guildrequestorsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestors_id?: boolean
    charid?: boolean
    guildid?: boolean
    name?: boolean
    job?: boolean
    level?: boolean
    loggedin?: boolean
  }, ExtArgs["result"]["guildrequestors"]>


  export type guildrequestorsSelectScalar = {
    id?: boolean
    requestors_id?: boolean
    charid?: boolean
    guildid?: boolean
    name?: boolean
    job?: boolean
    level?: boolean
    loggedin?: boolean
  }


  export type $guildrequestorsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "guildrequestors"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      requestors_id: number | null
      charid: number | null
      guildid: number | null
      name: string | null
      job: number | null
      level: number | null
      loggedin: boolean | null
    }, ExtArgs["result"]["guildrequestors"]>
    composites: {}
  }

  type guildrequestorsGetPayload<S extends boolean | null | undefined | guildrequestorsDefaultArgs> = $Result.GetResult<Prisma.$guildrequestorsPayload, S>

  type guildrequestorsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<guildrequestorsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GuildrequestorsCountAggregateInputType | true
    }

  export interface guildrequestorsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['guildrequestors'], meta: { name: 'guildrequestors' } }
    /**
     * Find zero or one Guildrequestors that matches the filter.
     * @param {guildrequestorsFindUniqueArgs} args - Arguments to find a Guildrequestors
     * @example
     * // Get one Guildrequestors
     * const guildrequestors = await prisma.guildrequestors.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends guildrequestorsFindUniqueArgs>(args: SelectSubset<T, guildrequestorsFindUniqueArgs<ExtArgs>>): Prisma__guildrequestorsClient<$Result.GetResult<Prisma.$guildrequestorsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Guildrequestors that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {guildrequestorsFindUniqueOrThrowArgs} args - Arguments to find a Guildrequestors
     * @example
     * // Get one Guildrequestors
     * const guildrequestors = await prisma.guildrequestors.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends guildrequestorsFindUniqueOrThrowArgs>(args: SelectSubset<T, guildrequestorsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__guildrequestorsClient<$Result.GetResult<Prisma.$guildrequestorsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Guildrequestors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guildrequestorsFindFirstArgs} args - Arguments to find a Guildrequestors
     * @example
     * // Get one Guildrequestors
     * const guildrequestors = await prisma.guildrequestors.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends guildrequestorsFindFirstArgs>(args?: SelectSubset<T, guildrequestorsFindFirstArgs<ExtArgs>>): Prisma__guildrequestorsClient<$Result.GetResult<Prisma.$guildrequestorsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Guildrequestors that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guildrequestorsFindFirstOrThrowArgs} args - Arguments to find a Guildrequestors
     * @example
     * // Get one Guildrequestors
     * const guildrequestors = await prisma.guildrequestors.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends guildrequestorsFindFirstOrThrowArgs>(args?: SelectSubset<T, guildrequestorsFindFirstOrThrowArgs<ExtArgs>>): Prisma__guildrequestorsClient<$Result.GetResult<Prisma.$guildrequestorsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Guildrequestors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guildrequestorsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Guildrequestors
     * const guildrequestors = await prisma.guildrequestors.findMany()
     * 
     * // Get first 10 Guildrequestors
     * const guildrequestors = await prisma.guildrequestors.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const guildrequestorsWithIdOnly = await prisma.guildrequestors.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends guildrequestorsFindManyArgs>(args?: SelectSubset<T, guildrequestorsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$guildrequestorsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Guildrequestors.
     * @param {guildrequestorsCreateArgs} args - Arguments to create a Guildrequestors.
     * @example
     * // Create one Guildrequestors
     * const Guildrequestors = await prisma.guildrequestors.create({
     *   data: {
     *     // ... data to create a Guildrequestors
     *   }
     * })
     * 
     */
    create<T extends guildrequestorsCreateArgs>(args: SelectSubset<T, guildrequestorsCreateArgs<ExtArgs>>): Prisma__guildrequestorsClient<$Result.GetResult<Prisma.$guildrequestorsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Guildrequestors.
     * @param {guildrequestorsCreateManyArgs} args - Arguments to create many Guildrequestors.
     * @example
     * // Create many Guildrequestors
     * const guildrequestors = await prisma.guildrequestors.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends guildrequestorsCreateManyArgs>(args?: SelectSubset<T, guildrequestorsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Guildrequestors.
     * @param {guildrequestorsDeleteArgs} args - Arguments to delete one Guildrequestors.
     * @example
     * // Delete one Guildrequestors
     * const Guildrequestors = await prisma.guildrequestors.delete({
     *   where: {
     *     // ... filter to delete one Guildrequestors
     *   }
     * })
     * 
     */
    delete<T extends guildrequestorsDeleteArgs>(args: SelectSubset<T, guildrequestorsDeleteArgs<ExtArgs>>): Prisma__guildrequestorsClient<$Result.GetResult<Prisma.$guildrequestorsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Guildrequestors.
     * @param {guildrequestorsUpdateArgs} args - Arguments to update one Guildrequestors.
     * @example
     * // Update one Guildrequestors
     * const guildrequestors = await prisma.guildrequestors.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends guildrequestorsUpdateArgs>(args: SelectSubset<T, guildrequestorsUpdateArgs<ExtArgs>>): Prisma__guildrequestorsClient<$Result.GetResult<Prisma.$guildrequestorsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Guildrequestors.
     * @param {guildrequestorsDeleteManyArgs} args - Arguments to filter Guildrequestors to delete.
     * @example
     * // Delete a few Guildrequestors
     * const { count } = await prisma.guildrequestors.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends guildrequestorsDeleteManyArgs>(args?: SelectSubset<T, guildrequestorsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Guildrequestors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guildrequestorsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Guildrequestors
     * const guildrequestors = await prisma.guildrequestors.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends guildrequestorsUpdateManyArgs>(args: SelectSubset<T, guildrequestorsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Guildrequestors.
     * @param {guildrequestorsUpsertArgs} args - Arguments to update or create a Guildrequestors.
     * @example
     * // Update or create a Guildrequestors
     * const guildrequestors = await prisma.guildrequestors.upsert({
     *   create: {
     *     // ... data to create a Guildrequestors
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Guildrequestors we want to update
     *   }
     * })
     */
    upsert<T extends guildrequestorsUpsertArgs>(args: SelectSubset<T, guildrequestorsUpsertArgs<ExtArgs>>): Prisma__guildrequestorsClient<$Result.GetResult<Prisma.$guildrequestorsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Guildrequestors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guildrequestorsCountArgs} args - Arguments to filter Guildrequestors to count.
     * @example
     * // Count the number of Guildrequestors
     * const count = await prisma.guildrequestors.count({
     *   where: {
     *     // ... the filter for the Guildrequestors we want to count
     *   }
     * })
    **/
    count<T extends guildrequestorsCountArgs>(
      args?: Subset<T, guildrequestorsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GuildrequestorsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Guildrequestors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildrequestorsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GuildrequestorsAggregateArgs>(args: Subset<T, GuildrequestorsAggregateArgs>): Prisma.PrismaPromise<GetGuildrequestorsAggregateType<T>>

    /**
     * Group by Guildrequestors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guildrequestorsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends guildrequestorsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: guildrequestorsGroupByArgs['orderBy'] }
        : { orderBy?: guildrequestorsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, guildrequestorsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGuildrequestorsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the guildrequestors model
   */
  readonly fields: guildrequestorsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for guildrequestors.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__guildrequestorsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the guildrequestors model
   */ 
  interface guildrequestorsFieldRefs {
    readonly id: FieldRef<"guildrequestors", 'Int'>
    readonly requestors_id: FieldRef<"guildrequestors", 'Int'>
    readonly charid: FieldRef<"guildrequestors", 'Int'>
    readonly guildid: FieldRef<"guildrequestors", 'Int'>
    readonly name: FieldRef<"guildrequestors", 'String'>
    readonly job: FieldRef<"guildrequestors", 'Int'>
    readonly level: FieldRef<"guildrequestors", 'Int'>
    readonly loggedin: FieldRef<"guildrequestors", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * guildrequestors findUnique
   */
  export type guildrequestorsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guildrequestors
     */
    select?: guildrequestorsSelect<ExtArgs> | null
    /**
     * Filter, which guildrequestors to fetch.
     */
    where: guildrequestorsWhereUniqueInput
  }

  /**
   * guildrequestors findUniqueOrThrow
   */
  export type guildrequestorsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guildrequestors
     */
    select?: guildrequestorsSelect<ExtArgs> | null
    /**
     * Filter, which guildrequestors to fetch.
     */
    where: guildrequestorsWhereUniqueInput
  }

  /**
   * guildrequestors findFirst
   */
  export type guildrequestorsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guildrequestors
     */
    select?: guildrequestorsSelect<ExtArgs> | null
    /**
     * Filter, which guildrequestors to fetch.
     */
    where?: guildrequestorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of guildrequestors to fetch.
     */
    orderBy?: guildrequestorsOrderByWithRelationInput | guildrequestorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for guildrequestors.
     */
    cursor?: guildrequestorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` guildrequestors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` guildrequestors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of guildrequestors.
     */
    distinct?: GuildrequestorsScalarFieldEnum | GuildrequestorsScalarFieldEnum[]
  }

  /**
   * guildrequestors findFirstOrThrow
   */
  export type guildrequestorsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guildrequestors
     */
    select?: guildrequestorsSelect<ExtArgs> | null
    /**
     * Filter, which guildrequestors to fetch.
     */
    where?: guildrequestorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of guildrequestors to fetch.
     */
    orderBy?: guildrequestorsOrderByWithRelationInput | guildrequestorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for guildrequestors.
     */
    cursor?: guildrequestorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` guildrequestors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` guildrequestors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of guildrequestors.
     */
    distinct?: GuildrequestorsScalarFieldEnum | GuildrequestorsScalarFieldEnum[]
  }

  /**
   * guildrequestors findMany
   */
  export type guildrequestorsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guildrequestors
     */
    select?: guildrequestorsSelect<ExtArgs> | null
    /**
     * Filter, which guildrequestors to fetch.
     */
    where?: guildrequestorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of guildrequestors to fetch.
     */
    orderBy?: guildrequestorsOrderByWithRelationInput | guildrequestorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing guildrequestors.
     */
    cursor?: guildrequestorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` guildrequestors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` guildrequestors.
     */
    skip?: number
    distinct?: GuildrequestorsScalarFieldEnum | GuildrequestorsScalarFieldEnum[]
  }

  /**
   * guildrequestors create
   */
  export type guildrequestorsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guildrequestors
     */
    select?: guildrequestorsSelect<ExtArgs> | null
    /**
     * The data needed to create a guildrequestors.
     */
    data?: XOR<guildrequestorsCreateInput, guildrequestorsUncheckedCreateInput>
  }

  /**
   * guildrequestors createMany
   */
  export type guildrequestorsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many guildrequestors.
     */
    data: guildrequestorsCreateManyInput | guildrequestorsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * guildrequestors update
   */
  export type guildrequestorsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guildrequestors
     */
    select?: guildrequestorsSelect<ExtArgs> | null
    /**
     * The data needed to update a guildrequestors.
     */
    data: XOR<guildrequestorsUpdateInput, guildrequestorsUncheckedUpdateInput>
    /**
     * Choose, which guildrequestors to update.
     */
    where: guildrequestorsWhereUniqueInput
  }

  /**
   * guildrequestors updateMany
   */
  export type guildrequestorsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update guildrequestors.
     */
    data: XOR<guildrequestorsUpdateManyMutationInput, guildrequestorsUncheckedUpdateManyInput>
    /**
     * Filter which guildrequestors to update
     */
    where?: guildrequestorsWhereInput
  }

  /**
   * guildrequestors upsert
   */
  export type guildrequestorsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guildrequestors
     */
    select?: guildrequestorsSelect<ExtArgs> | null
    /**
     * The filter to search for the guildrequestors to update in case it exists.
     */
    where: guildrequestorsWhereUniqueInput
    /**
     * In case the guildrequestors found by the `where` argument doesn't exist, create a new guildrequestors with this data.
     */
    create: XOR<guildrequestorsCreateInput, guildrequestorsUncheckedCreateInput>
    /**
     * In case the guildrequestors was found with the provided `where` argument, update it with this data.
     */
    update: XOR<guildrequestorsUpdateInput, guildrequestorsUncheckedUpdateInput>
  }

  /**
   * guildrequestors delete
   */
  export type guildrequestorsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guildrequestors
     */
    select?: guildrequestorsSelect<ExtArgs> | null
    /**
     * Filter which guildrequestors to delete.
     */
    where: guildrequestorsWhereUniqueInput
  }

  /**
   * guildrequestors deleteMany
   */
  export type guildrequestorsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which guildrequestors to delete
     */
    where?: guildrequestorsWhereInput
  }

  /**
   * guildrequestors without action
   */
  export type guildrequestorsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guildrequestors
     */
    select?: guildrequestorsSelect<ExtArgs> | null
  }


  /**
   * Model guilds
   */

  export type AggregateGuilds = {
    _count: GuildsCountAggregateOutputType | null
    _avg: GuildsAvgAggregateOutputType | null
    _sum: GuildsSumAggregateOutputType | null
    _min: GuildsMinAggregateOutputType | null
    _max: GuildsMaxAggregateOutputType | null
  }

  export type GuildsAvgAggregateOutputType = {
    id: number | null
    leaderid: number | null
    worldid: number | null
    markbg: number | null
    markbgcolor: number | null
    mark: number | null
    markcolor: number | null
    maxmembers: number | null
    points: number | null
    seasonpoints: number | null
    allianceid: number | null
    level: number | null
    guildrank: number | null
    ggp: number | null
    joinsetting: number | null
    reqlevel: number | null
    bbsNotice: number | null
    battleSp: number | null
    fk_allianceid: number | null
  }

  export type GuildsSumAggregateOutputType = {
    id: number | null
    leaderid: number | null
    worldid: number | null
    markbg: number | null
    markbgcolor: number | null
    mark: number | null
    markcolor: number | null
    maxmembers: number | null
    points: number | null
    seasonpoints: number | null
    allianceid: number | null
    level: number | null
    guildrank: number | null
    ggp: number | null
    joinsetting: number | null
    reqlevel: number | null
    bbsNotice: number | null
    battleSp: number | null
    fk_allianceid: number | null
  }

  export type GuildsMinAggregateOutputType = {
    id: number | null
    name: string | null
    leaderid: number | null
    worldid: number | null
    markbg: number | null
    markbgcolor: number | null
    mark: number | null
    markcolor: number | null
    maxmembers: number | null
    notice: string | null
    points: number | null
    seasonpoints: number | null
    allianceid: number | null
    level: number | null
    guildrank: number | null
    ggp: number | null
    appliable: boolean | null
    joinsetting: number | null
    reqlevel: number | null
    bbsNotice: number | null
    battleSp: number | null
    fk_allianceid: number | null
  }

  export type GuildsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    leaderid: number | null
    worldid: number | null
    markbg: number | null
    markbgcolor: number | null
    mark: number | null
    markcolor: number | null
    maxmembers: number | null
    notice: string | null
    points: number | null
    seasonpoints: number | null
    allianceid: number | null
    level: number | null
    guildrank: number | null
    ggp: number | null
    appliable: boolean | null
    joinsetting: number | null
    reqlevel: number | null
    bbsNotice: number | null
    battleSp: number | null
    fk_allianceid: number | null
  }

  export type GuildsCountAggregateOutputType = {
    id: number
    name: number
    leaderid: number
    worldid: number
    markbg: number
    markbgcolor: number
    mark: number
    markcolor: number
    maxmembers: number
    notice: number
    points: number
    seasonpoints: number
    allianceid: number
    level: number
    guildrank: number
    ggp: number
    appliable: number
    joinsetting: number
    reqlevel: number
    bbsNotice: number
    battleSp: number
    fk_allianceid: number
    _all: number
  }


  export type GuildsAvgAggregateInputType = {
    id?: true
    leaderid?: true
    worldid?: true
    markbg?: true
    markbgcolor?: true
    mark?: true
    markcolor?: true
    maxmembers?: true
    points?: true
    seasonpoints?: true
    allianceid?: true
    level?: true
    guildrank?: true
    ggp?: true
    joinsetting?: true
    reqlevel?: true
    bbsNotice?: true
    battleSp?: true
    fk_allianceid?: true
  }

  export type GuildsSumAggregateInputType = {
    id?: true
    leaderid?: true
    worldid?: true
    markbg?: true
    markbgcolor?: true
    mark?: true
    markcolor?: true
    maxmembers?: true
    points?: true
    seasonpoints?: true
    allianceid?: true
    level?: true
    guildrank?: true
    ggp?: true
    joinsetting?: true
    reqlevel?: true
    bbsNotice?: true
    battleSp?: true
    fk_allianceid?: true
  }

  export type GuildsMinAggregateInputType = {
    id?: true
    name?: true
    leaderid?: true
    worldid?: true
    markbg?: true
    markbgcolor?: true
    mark?: true
    markcolor?: true
    maxmembers?: true
    notice?: true
    points?: true
    seasonpoints?: true
    allianceid?: true
    level?: true
    guildrank?: true
    ggp?: true
    appliable?: true
    joinsetting?: true
    reqlevel?: true
    bbsNotice?: true
    battleSp?: true
    fk_allianceid?: true
  }

  export type GuildsMaxAggregateInputType = {
    id?: true
    name?: true
    leaderid?: true
    worldid?: true
    markbg?: true
    markbgcolor?: true
    mark?: true
    markcolor?: true
    maxmembers?: true
    notice?: true
    points?: true
    seasonpoints?: true
    allianceid?: true
    level?: true
    guildrank?: true
    ggp?: true
    appliable?: true
    joinsetting?: true
    reqlevel?: true
    bbsNotice?: true
    battleSp?: true
    fk_allianceid?: true
  }

  export type GuildsCountAggregateInputType = {
    id?: true
    name?: true
    leaderid?: true
    worldid?: true
    markbg?: true
    markbgcolor?: true
    mark?: true
    markcolor?: true
    maxmembers?: true
    notice?: true
    points?: true
    seasonpoints?: true
    allianceid?: true
    level?: true
    guildrank?: true
    ggp?: true
    appliable?: true
    joinsetting?: true
    reqlevel?: true
    bbsNotice?: true
    battleSp?: true
    fk_allianceid?: true
    _all?: true
  }

  export type GuildsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which guilds to aggregate.
     */
    where?: guildsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of guilds to fetch.
     */
    orderBy?: guildsOrderByWithRelationInput | guildsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: guildsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` guilds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` guilds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned guilds
    **/
    _count?: true | GuildsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GuildsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GuildsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GuildsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GuildsMaxAggregateInputType
  }

  export type GetGuildsAggregateType<T extends GuildsAggregateArgs> = {
        [P in keyof T & keyof AggregateGuilds]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGuilds[P]>
      : GetScalarType<T[P], AggregateGuilds[P]>
  }




  export type guildsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: guildsWhereInput
    orderBy?: guildsOrderByWithAggregationInput | guildsOrderByWithAggregationInput[]
    by: GuildsScalarFieldEnum[] | GuildsScalarFieldEnum
    having?: guildsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GuildsCountAggregateInputType | true
    _avg?: GuildsAvgAggregateInputType
    _sum?: GuildsSumAggregateInputType
    _min?: GuildsMinAggregateInputType
    _max?: GuildsMaxAggregateInputType
  }

  export type GuildsGroupByOutputType = {
    id: number
    name: string | null
    leaderid: number | null
    worldid: number | null
    markbg: number | null
    markbgcolor: number | null
    mark: number | null
    markcolor: number | null
    maxmembers: number | null
    notice: string | null
    points: number | null
    seasonpoints: number | null
    allianceid: number | null
    level: number | null
    guildrank: number | null
    ggp: number | null
    appliable: boolean | null
    joinsetting: number | null
    reqlevel: number | null
    bbsNotice: number | null
    battleSp: number | null
    fk_allianceid: number | null
    _count: GuildsCountAggregateOutputType | null
    _avg: GuildsAvgAggregateOutputType | null
    _sum: GuildsSumAggregateOutputType | null
    _min: GuildsMinAggregateOutputType | null
    _max: GuildsMaxAggregateOutputType | null
  }

  type GetGuildsGroupByPayload<T extends guildsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GuildsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GuildsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GuildsGroupByOutputType[P]>
            : GetScalarType<T[P], GuildsGroupByOutputType[P]>
        }
      >
    >


  export type guildsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    leaderid?: boolean
    worldid?: boolean
    markbg?: boolean
    markbgcolor?: boolean
    mark?: boolean
    markcolor?: boolean
    maxmembers?: boolean
    notice?: boolean
    points?: boolean
    seasonpoints?: boolean
    allianceid?: boolean
    level?: boolean
    guildrank?: boolean
    ggp?: boolean
    appliable?: boolean
    joinsetting?: boolean
    reqlevel?: boolean
    bbsNotice?: boolean
    battleSp?: boolean
    fk_allianceid?: boolean
  }, ExtArgs["result"]["guilds"]>


  export type guildsSelectScalar = {
    id?: boolean
    name?: boolean
    leaderid?: boolean
    worldid?: boolean
    markbg?: boolean
    markbgcolor?: boolean
    mark?: boolean
    markcolor?: boolean
    maxmembers?: boolean
    notice?: boolean
    points?: boolean
    seasonpoints?: boolean
    allianceid?: boolean
    level?: boolean
    guildrank?: boolean
    ggp?: boolean
    appliable?: boolean
    joinsetting?: boolean
    reqlevel?: boolean
    bbsNotice?: boolean
    battleSp?: boolean
    fk_allianceid?: boolean
  }


  export type $guildsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "guilds"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string | null
      leaderid: number | null
      worldid: number | null
      markbg: number | null
      markbgcolor: number | null
      mark: number | null
      markcolor: number | null
      maxmembers: number | null
      notice: string | null
      points: number | null
      seasonpoints: number | null
      allianceid: number | null
      level: number | null
      guildrank: number | null
      ggp: number | null
      appliable: boolean | null
      joinsetting: number | null
      reqlevel: number | null
      bbsNotice: number | null
      battleSp: number | null
      fk_allianceid: number | null
    }, ExtArgs["result"]["guilds"]>
    composites: {}
  }

  type guildsGetPayload<S extends boolean | null | undefined | guildsDefaultArgs> = $Result.GetResult<Prisma.$guildsPayload, S>

  type guildsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<guildsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GuildsCountAggregateInputType | true
    }

  export interface guildsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['guilds'], meta: { name: 'guilds' } }
    /**
     * Find zero or one Guilds that matches the filter.
     * @param {guildsFindUniqueArgs} args - Arguments to find a Guilds
     * @example
     * // Get one Guilds
     * const guilds = await prisma.guilds.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends guildsFindUniqueArgs>(args: SelectSubset<T, guildsFindUniqueArgs<ExtArgs>>): Prisma__guildsClient<$Result.GetResult<Prisma.$guildsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Guilds that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {guildsFindUniqueOrThrowArgs} args - Arguments to find a Guilds
     * @example
     * // Get one Guilds
     * const guilds = await prisma.guilds.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends guildsFindUniqueOrThrowArgs>(args: SelectSubset<T, guildsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__guildsClient<$Result.GetResult<Prisma.$guildsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Guilds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guildsFindFirstArgs} args - Arguments to find a Guilds
     * @example
     * // Get one Guilds
     * const guilds = await prisma.guilds.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends guildsFindFirstArgs>(args?: SelectSubset<T, guildsFindFirstArgs<ExtArgs>>): Prisma__guildsClient<$Result.GetResult<Prisma.$guildsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Guilds that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guildsFindFirstOrThrowArgs} args - Arguments to find a Guilds
     * @example
     * // Get one Guilds
     * const guilds = await prisma.guilds.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends guildsFindFirstOrThrowArgs>(args?: SelectSubset<T, guildsFindFirstOrThrowArgs<ExtArgs>>): Prisma__guildsClient<$Result.GetResult<Prisma.$guildsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Guilds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guildsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Guilds
     * const guilds = await prisma.guilds.findMany()
     * 
     * // Get first 10 Guilds
     * const guilds = await prisma.guilds.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const guildsWithIdOnly = await prisma.guilds.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends guildsFindManyArgs>(args?: SelectSubset<T, guildsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$guildsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Guilds.
     * @param {guildsCreateArgs} args - Arguments to create a Guilds.
     * @example
     * // Create one Guilds
     * const Guilds = await prisma.guilds.create({
     *   data: {
     *     // ... data to create a Guilds
     *   }
     * })
     * 
     */
    create<T extends guildsCreateArgs>(args: SelectSubset<T, guildsCreateArgs<ExtArgs>>): Prisma__guildsClient<$Result.GetResult<Prisma.$guildsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Guilds.
     * @param {guildsCreateManyArgs} args - Arguments to create many Guilds.
     * @example
     * // Create many Guilds
     * const guilds = await prisma.guilds.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends guildsCreateManyArgs>(args?: SelectSubset<T, guildsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Guilds.
     * @param {guildsDeleteArgs} args - Arguments to delete one Guilds.
     * @example
     * // Delete one Guilds
     * const Guilds = await prisma.guilds.delete({
     *   where: {
     *     // ... filter to delete one Guilds
     *   }
     * })
     * 
     */
    delete<T extends guildsDeleteArgs>(args: SelectSubset<T, guildsDeleteArgs<ExtArgs>>): Prisma__guildsClient<$Result.GetResult<Prisma.$guildsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Guilds.
     * @param {guildsUpdateArgs} args - Arguments to update one Guilds.
     * @example
     * // Update one Guilds
     * const guilds = await prisma.guilds.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends guildsUpdateArgs>(args: SelectSubset<T, guildsUpdateArgs<ExtArgs>>): Prisma__guildsClient<$Result.GetResult<Prisma.$guildsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Guilds.
     * @param {guildsDeleteManyArgs} args - Arguments to filter Guilds to delete.
     * @example
     * // Delete a few Guilds
     * const { count } = await prisma.guilds.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends guildsDeleteManyArgs>(args?: SelectSubset<T, guildsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Guilds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guildsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Guilds
     * const guilds = await prisma.guilds.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends guildsUpdateManyArgs>(args: SelectSubset<T, guildsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Guilds.
     * @param {guildsUpsertArgs} args - Arguments to update or create a Guilds.
     * @example
     * // Update or create a Guilds
     * const guilds = await prisma.guilds.upsert({
     *   create: {
     *     // ... data to create a Guilds
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Guilds we want to update
     *   }
     * })
     */
    upsert<T extends guildsUpsertArgs>(args: SelectSubset<T, guildsUpsertArgs<ExtArgs>>): Prisma__guildsClient<$Result.GetResult<Prisma.$guildsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Guilds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guildsCountArgs} args - Arguments to filter Guilds to count.
     * @example
     * // Count the number of Guilds
     * const count = await prisma.guilds.count({
     *   where: {
     *     // ... the filter for the Guilds we want to count
     *   }
     * })
    **/
    count<T extends guildsCountArgs>(
      args?: Subset<T, guildsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GuildsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Guilds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GuildsAggregateArgs>(args: Subset<T, GuildsAggregateArgs>): Prisma.PrismaPromise<GetGuildsAggregateType<T>>

    /**
     * Group by Guilds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guildsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends guildsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: guildsGroupByArgs['orderBy'] }
        : { orderBy?: guildsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, guildsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGuildsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the guilds model
   */
  readonly fields: guildsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for guilds.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__guildsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the guilds model
   */ 
  interface guildsFieldRefs {
    readonly id: FieldRef<"guilds", 'Int'>
    readonly name: FieldRef<"guilds", 'String'>
    readonly leaderid: FieldRef<"guilds", 'Int'>
    readonly worldid: FieldRef<"guilds", 'Int'>
    readonly markbg: FieldRef<"guilds", 'Int'>
    readonly markbgcolor: FieldRef<"guilds", 'Int'>
    readonly mark: FieldRef<"guilds", 'Int'>
    readonly markcolor: FieldRef<"guilds", 'Int'>
    readonly maxmembers: FieldRef<"guilds", 'Int'>
    readonly notice: FieldRef<"guilds", 'String'>
    readonly points: FieldRef<"guilds", 'Int'>
    readonly seasonpoints: FieldRef<"guilds", 'Int'>
    readonly allianceid: FieldRef<"guilds", 'Int'>
    readonly level: FieldRef<"guilds", 'Int'>
    readonly guildrank: FieldRef<"guilds", 'Int'>
    readonly ggp: FieldRef<"guilds", 'Int'>
    readonly appliable: FieldRef<"guilds", 'Boolean'>
    readonly joinsetting: FieldRef<"guilds", 'Int'>
    readonly reqlevel: FieldRef<"guilds", 'Int'>
    readonly bbsNotice: FieldRef<"guilds", 'Int'>
    readonly battleSp: FieldRef<"guilds", 'Int'>
    readonly fk_allianceid: FieldRef<"guilds", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * guilds findUnique
   */
  export type guildsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guilds
     */
    select?: guildsSelect<ExtArgs> | null
    /**
     * Filter, which guilds to fetch.
     */
    where: guildsWhereUniqueInput
  }

  /**
   * guilds findUniqueOrThrow
   */
  export type guildsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guilds
     */
    select?: guildsSelect<ExtArgs> | null
    /**
     * Filter, which guilds to fetch.
     */
    where: guildsWhereUniqueInput
  }

  /**
   * guilds findFirst
   */
  export type guildsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guilds
     */
    select?: guildsSelect<ExtArgs> | null
    /**
     * Filter, which guilds to fetch.
     */
    where?: guildsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of guilds to fetch.
     */
    orderBy?: guildsOrderByWithRelationInput | guildsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for guilds.
     */
    cursor?: guildsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` guilds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` guilds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of guilds.
     */
    distinct?: GuildsScalarFieldEnum | GuildsScalarFieldEnum[]
  }

  /**
   * guilds findFirstOrThrow
   */
  export type guildsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guilds
     */
    select?: guildsSelect<ExtArgs> | null
    /**
     * Filter, which guilds to fetch.
     */
    where?: guildsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of guilds to fetch.
     */
    orderBy?: guildsOrderByWithRelationInput | guildsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for guilds.
     */
    cursor?: guildsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` guilds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` guilds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of guilds.
     */
    distinct?: GuildsScalarFieldEnum | GuildsScalarFieldEnum[]
  }

  /**
   * guilds findMany
   */
  export type guildsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guilds
     */
    select?: guildsSelect<ExtArgs> | null
    /**
     * Filter, which guilds to fetch.
     */
    where?: guildsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of guilds to fetch.
     */
    orderBy?: guildsOrderByWithRelationInput | guildsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing guilds.
     */
    cursor?: guildsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` guilds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` guilds.
     */
    skip?: number
    distinct?: GuildsScalarFieldEnum | GuildsScalarFieldEnum[]
  }

  /**
   * guilds create
   */
  export type guildsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guilds
     */
    select?: guildsSelect<ExtArgs> | null
    /**
     * The data needed to create a guilds.
     */
    data?: XOR<guildsCreateInput, guildsUncheckedCreateInput>
  }

  /**
   * guilds createMany
   */
  export type guildsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many guilds.
     */
    data: guildsCreateManyInput | guildsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * guilds update
   */
  export type guildsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guilds
     */
    select?: guildsSelect<ExtArgs> | null
    /**
     * The data needed to update a guilds.
     */
    data: XOR<guildsUpdateInput, guildsUncheckedUpdateInput>
    /**
     * Choose, which guilds to update.
     */
    where: guildsWhereUniqueInput
  }

  /**
   * guilds updateMany
   */
  export type guildsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update guilds.
     */
    data: XOR<guildsUpdateManyMutationInput, guildsUncheckedUpdateManyInput>
    /**
     * Filter which guilds to update
     */
    where?: guildsWhereInput
  }

  /**
   * guilds upsert
   */
  export type guildsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guilds
     */
    select?: guildsSelect<ExtArgs> | null
    /**
     * The filter to search for the guilds to update in case it exists.
     */
    where: guildsWhereUniqueInput
    /**
     * In case the guilds found by the `where` argument doesn't exist, create a new guilds with this data.
     */
    create: XOR<guildsCreateInput, guildsUncheckedCreateInput>
    /**
     * In case the guilds was found with the provided `where` argument, update it with this data.
     */
    update: XOR<guildsUpdateInput, guildsUncheckedUpdateInput>
  }

  /**
   * guilds delete
   */
  export type guildsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guilds
     */
    select?: guildsSelect<ExtArgs> | null
    /**
     * Filter which guilds to delete.
     */
    where: guildsWhereUniqueInput
  }

  /**
   * guilds deleteMany
   */
  export type guildsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which guilds to delete
     */
    where?: guildsWhereInput
  }

  /**
   * guilds without action
   */
  export type guildsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guilds
     */
    select?: guildsSelect<ExtArgs> | null
  }


  /**
   * Model guildskill
   */

  export type AggregateGuildskill = {
    _count: GuildskillCountAggregateOutputType | null
    _avg: GuildskillAvgAggregateOutputType | null
    _sum: GuildskillSumAggregateOutputType | null
    _min: GuildskillMinAggregateOutputType | null
    _max: GuildskillMaxAggregateOutputType | null
  }

  export type GuildskillAvgAggregateOutputType = {
    id: number | null
    skillid: number | null
    level: number | null
  }

  export type GuildskillSumAggregateOutputType = {
    id: number | null
    skillid: number | null
    level: number | null
  }

  export type GuildskillMinAggregateOutputType = {
    id: number | null
    skillid: number | null
    level: number | null
    expiredate: Date | null
    buycharactername: string | null
    extendcharactername: string | null
  }

  export type GuildskillMaxAggregateOutputType = {
    id: number | null
    skillid: number | null
    level: number | null
    expiredate: Date | null
    buycharactername: string | null
    extendcharactername: string | null
  }

  export type GuildskillCountAggregateOutputType = {
    id: number
    skillid: number
    level: number
    expiredate: number
    buycharactername: number
    extendcharactername: number
    _all: number
  }


  export type GuildskillAvgAggregateInputType = {
    id?: true
    skillid?: true
    level?: true
  }

  export type GuildskillSumAggregateInputType = {
    id?: true
    skillid?: true
    level?: true
  }

  export type GuildskillMinAggregateInputType = {
    id?: true
    skillid?: true
    level?: true
    expiredate?: true
    buycharactername?: true
    extendcharactername?: true
  }

  export type GuildskillMaxAggregateInputType = {
    id?: true
    skillid?: true
    level?: true
    expiredate?: true
    buycharactername?: true
    extendcharactername?: true
  }

  export type GuildskillCountAggregateInputType = {
    id?: true
    skillid?: true
    level?: true
    expiredate?: true
    buycharactername?: true
    extendcharactername?: true
    _all?: true
  }

  export type GuildskillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which guildskill to aggregate.
     */
    where?: guildskillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of guildskills to fetch.
     */
    orderBy?: guildskillOrderByWithRelationInput | guildskillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: guildskillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` guildskills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` guildskills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned guildskills
    **/
    _count?: true | GuildskillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GuildskillAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GuildskillSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GuildskillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GuildskillMaxAggregateInputType
  }

  export type GetGuildskillAggregateType<T extends GuildskillAggregateArgs> = {
        [P in keyof T & keyof AggregateGuildskill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGuildskill[P]>
      : GetScalarType<T[P], AggregateGuildskill[P]>
  }




  export type guildskillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: guildskillWhereInput
    orderBy?: guildskillOrderByWithAggregationInput | guildskillOrderByWithAggregationInput[]
    by: GuildskillScalarFieldEnum[] | GuildskillScalarFieldEnum
    having?: guildskillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GuildskillCountAggregateInputType | true
    _avg?: GuildskillAvgAggregateInputType
    _sum?: GuildskillSumAggregateInputType
    _min?: GuildskillMinAggregateInputType
    _max?: GuildskillMaxAggregateInputType
  }

  export type GuildskillGroupByOutputType = {
    id: number
    skillid: number | null
    level: number | null
    expiredate: Date | null
    buycharactername: string | null
    extendcharactername: string | null
    _count: GuildskillCountAggregateOutputType | null
    _avg: GuildskillAvgAggregateOutputType | null
    _sum: GuildskillSumAggregateOutputType | null
    _min: GuildskillMinAggregateOutputType | null
    _max: GuildskillMaxAggregateOutputType | null
  }

  type GetGuildskillGroupByPayload<T extends guildskillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GuildskillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GuildskillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GuildskillGroupByOutputType[P]>
            : GetScalarType<T[P], GuildskillGroupByOutputType[P]>
        }
      >
    >


  export type guildskillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    skillid?: boolean
    level?: boolean
    expiredate?: boolean
    buycharactername?: boolean
    extendcharactername?: boolean
  }, ExtArgs["result"]["guildskill"]>


  export type guildskillSelectScalar = {
    id?: boolean
    skillid?: boolean
    level?: boolean
    expiredate?: boolean
    buycharactername?: boolean
    extendcharactername?: boolean
  }


  export type $guildskillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "guildskill"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      skillid: number | null
      level: number | null
      expiredate: Date | null
      buycharactername: string | null
      extendcharactername: string | null
    }, ExtArgs["result"]["guildskill"]>
    composites: {}
  }

  type guildskillGetPayload<S extends boolean | null | undefined | guildskillDefaultArgs> = $Result.GetResult<Prisma.$guildskillPayload, S>

  type guildskillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<guildskillFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GuildskillCountAggregateInputType | true
    }

  export interface guildskillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['guildskill'], meta: { name: 'guildskill' } }
    /**
     * Find zero or one Guildskill that matches the filter.
     * @param {guildskillFindUniqueArgs} args - Arguments to find a Guildskill
     * @example
     * // Get one Guildskill
     * const guildskill = await prisma.guildskill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends guildskillFindUniqueArgs>(args: SelectSubset<T, guildskillFindUniqueArgs<ExtArgs>>): Prisma__guildskillClient<$Result.GetResult<Prisma.$guildskillPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Guildskill that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {guildskillFindUniqueOrThrowArgs} args - Arguments to find a Guildskill
     * @example
     * // Get one Guildskill
     * const guildskill = await prisma.guildskill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends guildskillFindUniqueOrThrowArgs>(args: SelectSubset<T, guildskillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__guildskillClient<$Result.GetResult<Prisma.$guildskillPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Guildskill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guildskillFindFirstArgs} args - Arguments to find a Guildskill
     * @example
     * // Get one Guildskill
     * const guildskill = await prisma.guildskill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends guildskillFindFirstArgs>(args?: SelectSubset<T, guildskillFindFirstArgs<ExtArgs>>): Prisma__guildskillClient<$Result.GetResult<Prisma.$guildskillPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Guildskill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guildskillFindFirstOrThrowArgs} args - Arguments to find a Guildskill
     * @example
     * // Get one Guildskill
     * const guildskill = await prisma.guildskill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends guildskillFindFirstOrThrowArgs>(args?: SelectSubset<T, guildskillFindFirstOrThrowArgs<ExtArgs>>): Prisma__guildskillClient<$Result.GetResult<Prisma.$guildskillPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Guildskills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guildskillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Guildskills
     * const guildskills = await prisma.guildskill.findMany()
     * 
     * // Get first 10 Guildskills
     * const guildskills = await prisma.guildskill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const guildskillWithIdOnly = await prisma.guildskill.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends guildskillFindManyArgs>(args?: SelectSubset<T, guildskillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$guildskillPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Guildskill.
     * @param {guildskillCreateArgs} args - Arguments to create a Guildskill.
     * @example
     * // Create one Guildskill
     * const Guildskill = await prisma.guildskill.create({
     *   data: {
     *     // ... data to create a Guildskill
     *   }
     * })
     * 
     */
    create<T extends guildskillCreateArgs>(args: SelectSubset<T, guildskillCreateArgs<ExtArgs>>): Prisma__guildskillClient<$Result.GetResult<Prisma.$guildskillPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Guildskills.
     * @param {guildskillCreateManyArgs} args - Arguments to create many Guildskills.
     * @example
     * // Create many Guildskills
     * const guildskill = await prisma.guildskill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends guildskillCreateManyArgs>(args?: SelectSubset<T, guildskillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Guildskill.
     * @param {guildskillDeleteArgs} args - Arguments to delete one Guildskill.
     * @example
     * // Delete one Guildskill
     * const Guildskill = await prisma.guildskill.delete({
     *   where: {
     *     // ... filter to delete one Guildskill
     *   }
     * })
     * 
     */
    delete<T extends guildskillDeleteArgs>(args: SelectSubset<T, guildskillDeleteArgs<ExtArgs>>): Prisma__guildskillClient<$Result.GetResult<Prisma.$guildskillPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Guildskill.
     * @param {guildskillUpdateArgs} args - Arguments to update one Guildskill.
     * @example
     * // Update one Guildskill
     * const guildskill = await prisma.guildskill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends guildskillUpdateArgs>(args: SelectSubset<T, guildskillUpdateArgs<ExtArgs>>): Prisma__guildskillClient<$Result.GetResult<Prisma.$guildskillPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Guildskills.
     * @param {guildskillDeleteManyArgs} args - Arguments to filter Guildskills to delete.
     * @example
     * // Delete a few Guildskills
     * const { count } = await prisma.guildskill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends guildskillDeleteManyArgs>(args?: SelectSubset<T, guildskillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Guildskills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guildskillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Guildskills
     * const guildskill = await prisma.guildskill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends guildskillUpdateManyArgs>(args: SelectSubset<T, guildskillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Guildskill.
     * @param {guildskillUpsertArgs} args - Arguments to update or create a Guildskill.
     * @example
     * // Update or create a Guildskill
     * const guildskill = await prisma.guildskill.upsert({
     *   create: {
     *     // ... data to create a Guildskill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Guildskill we want to update
     *   }
     * })
     */
    upsert<T extends guildskillUpsertArgs>(args: SelectSubset<T, guildskillUpsertArgs<ExtArgs>>): Prisma__guildskillClient<$Result.GetResult<Prisma.$guildskillPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Guildskills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guildskillCountArgs} args - Arguments to filter Guildskills to count.
     * @example
     * // Count the number of Guildskills
     * const count = await prisma.guildskill.count({
     *   where: {
     *     // ... the filter for the Guildskills we want to count
     *   }
     * })
    **/
    count<T extends guildskillCountArgs>(
      args?: Subset<T, guildskillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GuildskillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Guildskill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildskillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GuildskillAggregateArgs>(args: Subset<T, GuildskillAggregateArgs>): Prisma.PrismaPromise<GetGuildskillAggregateType<T>>

    /**
     * Group by Guildskill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guildskillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends guildskillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: guildskillGroupByArgs['orderBy'] }
        : { orderBy?: guildskillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, guildskillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGuildskillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the guildskill model
   */
  readonly fields: guildskillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for guildskill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__guildskillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the guildskill model
   */ 
  interface guildskillFieldRefs {
    readonly id: FieldRef<"guildskill", 'Int'>
    readonly skillid: FieldRef<"guildskill", 'Int'>
    readonly level: FieldRef<"guildskill", 'Int'>
    readonly expiredate: FieldRef<"guildskill", 'DateTime'>
    readonly buycharactername: FieldRef<"guildskill", 'String'>
    readonly extendcharactername: FieldRef<"guildskill", 'String'>
  }
    

  // Custom InputTypes
  /**
   * guildskill findUnique
   */
  export type guildskillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guildskill
     */
    select?: guildskillSelect<ExtArgs> | null
    /**
     * Filter, which guildskill to fetch.
     */
    where: guildskillWhereUniqueInput
  }

  /**
   * guildskill findUniqueOrThrow
   */
  export type guildskillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guildskill
     */
    select?: guildskillSelect<ExtArgs> | null
    /**
     * Filter, which guildskill to fetch.
     */
    where: guildskillWhereUniqueInput
  }

  /**
   * guildskill findFirst
   */
  export type guildskillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guildskill
     */
    select?: guildskillSelect<ExtArgs> | null
    /**
     * Filter, which guildskill to fetch.
     */
    where?: guildskillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of guildskills to fetch.
     */
    orderBy?: guildskillOrderByWithRelationInput | guildskillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for guildskills.
     */
    cursor?: guildskillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` guildskills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` guildskills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of guildskills.
     */
    distinct?: GuildskillScalarFieldEnum | GuildskillScalarFieldEnum[]
  }

  /**
   * guildskill findFirstOrThrow
   */
  export type guildskillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guildskill
     */
    select?: guildskillSelect<ExtArgs> | null
    /**
     * Filter, which guildskill to fetch.
     */
    where?: guildskillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of guildskills to fetch.
     */
    orderBy?: guildskillOrderByWithRelationInput | guildskillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for guildskills.
     */
    cursor?: guildskillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` guildskills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` guildskills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of guildskills.
     */
    distinct?: GuildskillScalarFieldEnum | GuildskillScalarFieldEnum[]
  }

  /**
   * guildskill findMany
   */
  export type guildskillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guildskill
     */
    select?: guildskillSelect<ExtArgs> | null
    /**
     * Filter, which guildskills to fetch.
     */
    where?: guildskillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of guildskills to fetch.
     */
    orderBy?: guildskillOrderByWithRelationInput | guildskillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing guildskills.
     */
    cursor?: guildskillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` guildskills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` guildskills.
     */
    skip?: number
    distinct?: GuildskillScalarFieldEnum | GuildskillScalarFieldEnum[]
  }

  /**
   * guildskill create
   */
  export type guildskillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guildskill
     */
    select?: guildskillSelect<ExtArgs> | null
    /**
     * The data needed to create a guildskill.
     */
    data?: XOR<guildskillCreateInput, guildskillUncheckedCreateInput>
  }

  /**
   * guildskill createMany
   */
  export type guildskillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many guildskills.
     */
    data: guildskillCreateManyInput | guildskillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * guildskill update
   */
  export type guildskillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guildskill
     */
    select?: guildskillSelect<ExtArgs> | null
    /**
     * The data needed to update a guildskill.
     */
    data: XOR<guildskillUpdateInput, guildskillUncheckedUpdateInput>
    /**
     * Choose, which guildskill to update.
     */
    where: guildskillWhereUniqueInput
  }

  /**
   * guildskill updateMany
   */
  export type guildskillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update guildskills.
     */
    data: XOR<guildskillUpdateManyMutationInput, guildskillUncheckedUpdateManyInput>
    /**
     * Filter which guildskills to update
     */
    where?: guildskillWhereInput
  }

  /**
   * guildskill upsert
   */
  export type guildskillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guildskill
     */
    select?: guildskillSelect<ExtArgs> | null
    /**
     * The filter to search for the guildskill to update in case it exists.
     */
    where: guildskillWhereUniqueInput
    /**
     * In case the guildskill found by the `where` argument doesn't exist, create a new guildskill with this data.
     */
    create: XOR<guildskillCreateInput, guildskillUncheckedCreateInput>
    /**
     * In case the guildskill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<guildskillUpdateInput, guildskillUncheckedUpdateInput>
  }

  /**
   * guildskill delete
   */
  export type guildskillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guildskill
     */
    select?: guildskillSelect<ExtArgs> | null
    /**
     * Filter which guildskill to delete.
     */
    where: guildskillWhereUniqueInput
  }

  /**
   * guildskill deleteMany
   */
  export type guildskillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which guildskills to delete
     */
    where?: guildskillWhereInput
  }

  /**
   * guildskill without action
   */
  export type guildskillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guildskill
     */
    select?: guildskillSelect<ExtArgs> | null
  }


  /**
   * Model guildskills
   */

  export type AggregateGuildskills = {
    _count: GuildskillsCountAggregateOutputType | null
    _avg: GuildskillsAvgAggregateOutputType | null
    _sum: GuildskillsSumAggregateOutputType | null
    _min: GuildskillsMinAggregateOutputType | null
    _max: GuildskillsMaxAggregateOutputType | null
  }

  export type GuildskillsAvgAggregateOutputType = {
    guildskill_id: number | null
    skills_id: number | null
    guild_id: number | null
    skillid: number | null
    fk_guildskillid: number | null
  }

  export type GuildskillsSumAggregateOutputType = {
    guildskill_id: number | null
    skills_id: number | null
    guild_id: number | null
    skillid: number | null
    fk_guildskillid: number | null
  }

  export type GuildskillsMinAggregateOutputType = {
    guildskill_id: number | null
    skills_id: number | null
    guild_id: number | null
    skillid: number | null
    fk_guildskillid: number | null
  }

  export type GuildskillsMaxAggregateOutputType = {
    guildskill_id: number | null
    skills_id: number | null
    guild_id: number | null
    skillid: number | null
    fk_guildskillid: number | null
  }

  export type GuildskillsCountAggregateOutputType = {
    guildskill_id: number
    skills_id: number
    guild_id: number
    skillid: number
    fk_guildskillid: number
    _all: number
  }


  export type GuildskillsAvgAggregateInputType = {
    guildskill_id?: true
    skills_id?: true
    guild_id?: true
    skillid?: true
    fk_guildskillid?: true
  }

  export type GuildskillsSumAggregateInputType = {
    guildskill_id?: true
    skills_id?: true
    guild_id?: true
    skillid?: true
    fk_guildskillid?: true
  }

  export type GuildskillsMinAggregateInputType = {
    guildskill_id?: true
    skills_id?: true
    guild_id?: true
    skillid?: true
    fk_guildskillid?: true
  }

  export type GuildskillsMaxAggregateInputType = {
    guildskill_id?: true
    skills_id?: true
    guild_id?: true
    skillid?: true
    fk_guildskillid?: true
  }

  export type GuildskillsCountAggregateInputType = {
    guildskill_id?: true
    skills_id?: true
    guild_id?: true
    skillid?: true
    fk_guildskillid?: true
    _all?: true
  }

  export type GuildskillsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which guildskills to aggregate.
     */
    where?: guildskillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of guildskills to fetch.
     */
    orderBy?: guildskillsOrderByWithRelationInput | guildskillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: guildskillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` guildskills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` guildskills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned guildskills
    **/
    _count?: true | GuildskillsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GuildskillsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GuildskillsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GuildskillsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GuildskillsMaxAggregateInputType
  }

  export type GetGuildskillsAggregateType<T extends GuildskillsAggregateArgs> = {
        [P in keyof T & keyof AggregateGuildskills]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGuildskills[P]>
      : GetScalarType<T[P], AggregateGuildskills[P]>
  }




  export type guildskillsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: guildskillsWhereInput
    orderBy?: guildskillsOrderByWithAggregationInput | guildskillsOrderByWithAggregationInput[]
    by: GuildskillsScalarFieldEnum[] | GuildskillsScalarFieldEnum
    having?: guildskillsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GuildskillsCountAggregateInputType | true
    _avg?: GuildskillsAvgAggregateInputType
    _sum?: GuildskillsSumAggregateInputType
    _min?: GuildskillsMinAggregateInputType
    _max?: GuildskillsMaxAggregateInputType
  }

  export type GuildskillsGroupByOutputType = {
    guildskill_id: number
    skills_id: number | null
    guild_id: number | null
    skillid: number | null
    fk_guildskillid: number | null
    _count: GuildskillsCountAggregateOutputType | null
    _avg: GuildskillsAvgAggregateOutputType | null
    _sum: GuildskillsSumAggregateOutputType | null
    _min: GuildskillsMinAggregateOutputType | null
    _max: GuildskillsMaxAggregateOutputType | null
  }

  type GetGuildskillsGroupByPayload<T extends guildskillsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GuildskillsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GuildskillsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GuildskillsGroupByOutputType[P]>
            : GetScalarType<T[P], GuildskillsGroupByOutputType[P]>
        }
      >
    >


  export type guildskillsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    guildskill_id?: boolean
    skills_id?: boolean
    guild_id?: boolean
    skillid?: boolean
    fk_guildskillid?: boolean
  }, ExtArgs["result"]["guildskills"]>


  export type guildskillsSelectScalar = {
    guildskill_id?: boolean
    skills_id?: boolean
    guild_id?: boolean
    skillid?: boolean
    fk_guildskillid?: boolean
  }


  export type $guildskillsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "guildskills"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      guildskill_id: number
      skills_id: number | null
      guild_id: number | null
      skillid: number | null
      fk_guildskillid: number | null
    }, ExtArgs["result"]["guildskills"]>
    composites: {}
  }

  type guildskillsGetPayload<S extends boolean | null | undefined | guildskillsDefaultArgs> = $Result.GetResult<Prisma.$guildskillsPayload, S>

  type guildskillsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<guildskillsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GuildskillsCountAggregateInputType | true
    }

  export interface guildskillsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['guildskills'], meta: { name: 'guildskills' } }
    /**
     * Find zero or one Guildskills that matches the filter.
     * @param {guildskillsFindUniqueArgs} args - Arguments to find a Guildskills
     * @example
     * // Get one Guildskills
     * const guildskills = await prisma.guildskills.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends guildskillsFindUniqueArgs>(args: SelectSubset<T, guildskillsFindUniqueArgs<ExtArgs>>): Prisma__guildskillsClient<$Result.GetResult<Prisma.$guildskillsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Guildskills that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {guildskillsFindUniqueOrThrowArgs} args - Arguments to find a Guildskills
     * @example
     * // Get one Guildskills
     * const guildskills = await prisma.guildskills.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends guildskillsFindUniqueOrThrowArgs>(args: SelectSubset<T, guildskillsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__guildskillsClient<$Result.GetResult<Prisma.$guildskillsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Guildskills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guildskillsFindFirstArgs} args - Arguments to find a Guildskills
     * @example
     * // Get one Guildskills
     * const guildskills = await prisma.guildskills.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends guildskillsFindFirstArgs>(args?: SelectSubset<T, guildskillsFindFirstArgs<ExtArgs>>): Prisma__guildskillsClient<$Result.GetResult<Prisma.$guildskillsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Guildskills that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guildskillsFindFirstOrThrowArgs} args - Arguments to find a Guildskills
     * @example
     * // Get one Guildskills
     * const guildskills = await prisma.guildskills.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends guildskillsFindFirstOrThrowArgs>(args?: SelectSubset<T, guildskillsFindFirstOrThrowArgs<ExtArgs>>): Prisma__guildskillsClient<$Result.GetResult<Prisma.$guildskillsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Guildskills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guildskillsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Guildskills
     * const guildskills = await prisma.guildskills.findMany()
     * 
     * // Get first 10 Guildskills
     * const guildskills = await prisma.guildskills.findMany({ take: 10 })
     * 
     * // Only select the `guildskill_id`
     * const guildskillsWithGuildskill_idOnly = await prisma.guildskills.findMany({ select: { guildskill_id: true } })
     * 
     */
    findMany<T extends guildskillsFindManyArgs>(args?: SelectSubset<T, guildskillsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$guildskillsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Guildskills.
     * @param {guildskillsCreateArgs} args - Arguments to create a Guildskills.
     * @example
     * // Create one Guildskills
     * const Guildskills = await prisma.guildskills.create({
     *   data: {
     *     // ... data to create a Guildskills
     *   }
     * })
     * 
     */
    create<T extends guildskillsCreateArgs>(args: SelectSubset<T, guildskillsCreateArgs<ExtArgs>>): Prisma__guildskillsClient<$Result.GetResult<Prisma.$guildskillsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Guildskills.
     * @param {guildskillsCreateManyArgs} args - Arguments to create many Guildskills.
     * @example
     * // Create many Guildskills
     * const guildskills = await prisma.guildskills.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends guildskillsCreateManyArgs>(args?: SelectSubset<T, guildskillsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Guildskills.
     * @param {guildskillsDeleteArgs} args - Arguments to delete one Guildskills.
     * @example
     * // Delete one Guildskills
     * const Guildskills = await prisma.guildskills.delete({
     *   where: {
     *     // ... filter to delete one Guildskills
     *   }
     * })
     * 
     */
    delete<T extends guildskillsDeleteArgs>(args: SelectSubset<T, guildskillsDeleteArgs<ExtArgs>>): Prisma__guildskillsClient<$Result.GetResult<Prisma.$guildskillsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Guildskills.
     * @param {guildskillsUpdateArgs} args - Arguments to update one Guildskills.
     * @example
     * // Update one Guildskills
     * const guildskills = await prisma.guildskills.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends guildskillsUpdateArgs>(args: SelectSubset<T, guildskillsUpdateArgs<ExtArgs>>): Prisma__guildskillsClient<$Result.GetResult<Prisma.$guildskillsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Guildskills.
     * @param {guildskillsDeleteManyArgs} args - Arguments to filter Guildskills to delete.
     * @example
     * // Delete a few Guildskills
     * const { count } = await prisma.guildskills.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends guildskillsDeleteManyArgs>(args?: SelectSubset<T, guildskillsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Guildskills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guildskillsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Guildskills
     * const guildskills = await prisma.guildskills.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends guildskillsUpdateManyArgs>(args: SelectSubset<T, guildskillsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Guildskills.
     * @param {guildskillsUpsertArgs} args - Arguments to update or create a Guildskills.
     * @example
     * // Update or create a Guildskills
     * const guildskills = await prisma.guildskills.upsert({
     *   create: {
     *     // ... data to create a Guildskills
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Guildskills we want to update
     *   }
     * })
     */
    upsert<T extends guildskillsUpsertArgs>(args: SelectSubset<T, guildskillsUpsertArgs<ExtArgs>>): Prisma__guildskillsClient<$Result.GetResult<Prisma.$guildskillsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Guildskills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guildskillsCountArgs} args - Arguments to filter Guildskills to count.
     * @example
     * // Count the number of Guildskills
     * const count = await prisma.guildskills.count({
     *   where: {
     *     // ... the filter for the Guildskills we want to count
     *   }
     * })
    **/
    count<T extends guildskillsCountArgs>(
      args?: Subset<T, guildskillsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GuildskillsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Guildskills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildskillsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GuildskillsAggregateArgs>(args: Subset<T, GuildskillsAggregateArgs>): Prisma.PrismaPromise<GetGuildskillsAggregateType<T>>

    /**
     * Group by Guildskills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guildskillsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends guildskillsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: guildskillsGroupByArgs['orderBy'] }
        : { orderBy?: guildskillsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, guildskillsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGuildskillsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the guildskills model
   */
  readonly fields: guildskillsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for guildskills.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__guildskillsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the guildskills model
   */ 
  interface guildskillsFieldRefs {
    readonly guildskill_id: FieldRef<"guildskills", 'Int'>
    readonly skills_id: FieldRef<"guildskills", 'Int'>
    readonly guild_id: FieldRef<"guildskills", 'Int'>
    readonly skillid: FieldRef<"guildskills", 'Int'>
    readonly fk_guildskillid: FieldRef<"guildskills", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * guildskills findUnique
   */
  export type guildskillsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guildskills
     */
    select?: guildskillsSelect<ExtArgs> | null
    /**
     * Filter, which guildskills to fetch.
     */
    where: guildskillsWhereUniqueInput
  }

  /**
   * guildskills findUniqueOrThrow
   */
  export type guildskillsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guildskills
     */
    select?: guildskillsSelect<ExtArgs> | null
    /**
     * Filter, which guildskills to fetch.
     */
    where: guildskillsWhereUniqueInput
  }

  /**
   * guildskills findFirst
   */
  export type guildskillsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guildskills
     */
    select?: guildskillsSelect<ExtArgs> | null
    /**
     * Filter, which guildskills to fetch.
     */
    where?: guildskillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of guildskills to fetch.
     */
    orderBy?: guildskillsOrderByWithRelationInput | guildskillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for guildskills.
     */
    cursor?: guildskillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` guildskills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` guildskills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of guildskills.
     */
    distinct?: GuildskillsScalarFieldEnum | GuildskillsScalarFieldEnum[]
  }

  /**
   * guildskills findFirstOrThrow
   */
  export type guildskillsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guildskills
     */
    select?: guildskillsSelect<ExtArgs> | null
    /**
     * Filter, which guildskills to fetch.
     */
    where?: guildskillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of guildskills to fetch.
     */
    orderBy?: guildskillsOrderByWithRelationInput | guildskillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for guildskills.
     */
    cursor?: guildskillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` guildskills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` guildskills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of guildskills.
     */
    distinct?: GuildskillsScalarFieldEnum | GuildskillsScalarFieldEnum[]
  }

  /**
   * guildskills findMany
   */
  export type guildskillsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guildskills
     */
    select?: guildskillsSelect<ExtArgs> | null
    /**
     * Filter, which guildskills to fetch.
     */
    where?: guildskillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of guildskills to fetch.
     */
    orderBy?: guildskillsOrderByWithRelationInput | guildskillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing guildskills.
     */
    cursor?: guildskillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` guildskills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` guildskills.
     */
    skip?: number
    distinct?: GuildskillsScalarFieldEnum | GuildskillsScalarFieldEnum[]
  }

  /**
   * guildskills create
   */
  export type guildskillsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guildskills
     */
    select?: guildskillsSelect<ExtArgs> | null
    /**
     * The data needed to create a guildskills.
     */
    data?: XOR<guildskillsCreateInput, guildskillsUncheckedCreateInput>
  }

  /**
   * guildskills createMany
   */
  export type guildskillsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many guildskills.
     */
    data: guildskillsCreateManyInput | guildskillsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * guildskills update
   */
  export type guildskillsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guildskills
     */
    select?: guildskillsSelect<ExtArgs> | null
    /**
     * The data needed to update a guildskills.
     */
    data: XOR<guildskillsUpdateInput, guildskillsUncheckedUpdateInput>
    /**
     * Choose, which guildskills to update.
     */
    where: guildskillsWhereUniqueInput
  }

  /**
   * guildskills updateMany
   */
  export type guildskillsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update guildskills.
     */
    data: XOR<guildskillsUpdateManyMutationInput, guildskillsUncheckedUpdateManyInput>
    /**
     * Filter which guildskills to update
     */
    where?: guildskillsWhereInput
  }

  /**
   * guildskills upsert
   */
  export type guildskillsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guildskills
     */
    select?: guildskillsSelect<ExtArgs> | null
    /**
     * The filter to search for the guildskills to update in case it exists.
     */
    where: guildskillsWhereUniqueInput
    /**
     * In case the guildskills found by the `where` argument doesn't exist, create a new guildskills with this data.
     */
    create: XOR<guildskillsCreateInput, guildskillsUncheckedCreateInput>
    /**
     * In case the guildskills was found with the provided `where` argument, update it with this data.
     */
    update: XOR<guildskillsUpdateInput, guildskillsUncheckedUpdateInput>
  }

  /**
   * guildskills delete
   */
  export type guildskillsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guildskills
     */
    select?: guildskillsSelect<ExtArgs> | null
    /**
     * Filter which guildskills to delete.
     */
    where: guildskillsWhereUniqueInput
  }

  /**
   * guildskills deleteMany
   */
  export type guildskillsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which guildskills to delete
     */
    where?: guildskillsWhereInput
  }

  /**
   * guildskills without action
   */
  export type guildskillsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guildskills
     */
    select?: guildskillsSelect<ExtArgs> | null
  }


  /**
   * Model hairequips
   */

  export type AggregateHairequips = {
    _count: HairequipsCountAggregateOutputType | null
    _avg: HairequipsAvgAggregateOutputType | null
    _sum: HairequipsSumAggregateOutputType | null
    _min: HairequipsMinAggregateOutputType | null
    _max: HairequipsMaxAggregateOutputType | null
  }

  export type HairequipsAvgAggregateOutputType = {
    id: number | null
    alid: number | null
    equipid: number | null
  }

  export type HairequipsSumAggregateOutputType = {
    id: number | null
    alid: number | null
    equipid: number | null
  }

  export type HairequipsMinAggregateOutputType = {
    id: number | null
    alid: number | null
    equipid: number | null
  }

  export type HairequipsMaxAggregateOutputType = {
    id: number | null
    alid: number | null
    equipid: number | null
  }

  export type HairequipsCountAggregateOutputType = {
    id: number
    alid: number
    equipid: number
    _all: number
  }


  export type HairequipsAvgAggregateInputType = {
    id?: true
    alid?: true
    equipid?: true
  }

  export type HairequipsSumAggregateInputType = {
    id?: true
    alid?: true
    equipid?: true
  }

  export type HairequipsMinAggregateInputType = {
    id?: true
    alid?: true
    equipid?: true
  }

  export type HairequipsMaxAggregateInputType = {
    id?: true
    alid?: true
    equipid?: true
  }

  export type HairequipsCountAggregateInputType = {
    id?: true
    alid?: true
    equipid?: true
    _all?: true
  }

  export type HairequipsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which hairequips to aggregate.
     */
    where?: hairequipsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hairequips to fetch.
     */
    orderBy?: hairequipsOrderByWithRelationInput | hairequipsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: hairequipsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hairequips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hairequips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned hairequips
    **/
    _count?: true | HairequipsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HairequipsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HairequipsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HairequipsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HairequipsMaxAggregateInputType
  }

  export type GetHairequipsAggregateType<T extends HairequipsAggregateArgs> = {
        [P in keyof T & keyof AggregateHairequips]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHairequips[P]>
      : GetScalarType<T[P], AggregateHairequips[P]>
  }




  export type hairequipsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: hairequipsWhereInput
    orderBy?: hairequipsOrderByWithAggregationInput | hairequipsOrderByWithAggregationInput[]
    by: HairequipsScalarFieldEnum[] | HairequipsScalarFieldEnum
    having?: hairequipsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HairequipsCountAggregateInputType | true
    _avg?: HairequipsAvgAggregateInputType
    _sum?: HairequipsSumAggregateInputType
    _min?: HairequipsMinAggregateInputType
    _max?: HairequipsMaxAggregateInputType
  }

  export type HairequipsGroupByOutputType = {
    id: number
    alid: number | null
    equipid: number | null
    _count: HairequipsCountAggregateOutputType | null
    _avg: HairequipsAvgAggregateOutputType | null
    _sum: HairequipsSumAggregateOutputType | null
    _min: HairequipsMinAggregateOutputType | null
    _max: HairequipsMaxAggregateOutputType | null
  }

  type GetHairequipsGroupByPayload<T extends hairequipsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HairequipsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HairequipsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HairequipsGroupByOutputType[P]>
            : GetScalarType<T[P], HairequipsGroupByOutputType[P]>
        }
      >
    >


  export type hairequipsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    alid?: boolean
    equipid?: boolean
  }, ExtArgs["result"]["hairequips"]>


  export type hairequipsSelectScalar = {
    id?: boolean
    alid?: boolean
    equipid?: boolean
  }


  export type $hairequipsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "hairequips"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      alid: number | null
      equipid: number | null
    }, ExtArgs["result"]["hairequips"]>
    composites: {}
  }

  type hairequipsGetPayload<S extends boolean | null | undefined | hairequipsDefaultArgs> = $Result.GetResult<Prisma.$hairequipsPayload, S>

  type hairequipsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<hairequipsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HairequipsCountAggregateInputType | true
    }

  export interface hairequipsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['hairequips'], meta: { name: 'hairequips' } }
    /**
     * Find zero or one Hairequips that matches the filter.
     * @param {hairequipsFindUniqueArgs} args - Arguments to find a Hairequips
     * @example
     * // Get one Hairequips
     * const hairequips = await prisma.hairequips.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends hairequipsFindUniqueArgs>(args: SelectSubset<T, hairequipsFindUniqueArgs<ExtArgs>>): Prisma__hairequipsClient<$Result.GetResult<Prisma.$hairequipsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Hairequips that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {hairequipsFindUniqueOrThrowArgs} args - Arguments to find a Hairequips
     * @example
     * // Get one Hairequips
     * const hairequips = await prisma.hairequips.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends hairequipsFindUniqueOrThrowArgs>(args: SelectSubset<T, hairequipsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__hairequipsClient<$Result.GetResult<Prisma.$hairequipsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Hairequips that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hairequipsFindFirstArgs} args - Arguments to find a Hairequips
     * @example
     * // Get one Hairequips
     * const hairequips = await prisma.hairequips.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends hairequipsFindFirstArgs>(args?: SelectSubset<T, hairequipsFindFirstArgs<ExtArgs>>): Prisma__hairequipsClient<$Result.GetResult<Prisma.$hairequipsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Hairequips that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hairequipsFindFirstOrThrowArgs} args - Arguments to find a Hairequips
     * @example
     * // Get one Hairequips
     * const hairequips = await prisma.hairequips.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends hairequipsFindFirstOrThrowArgs>(args?: SelectSubset<T, hairequipsFindFirstOrThrowArgs<ExtArgs>>): Prisma__hairequipsClient<$Result.GetResult<Prisma.$hairequipsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Hairequips that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hairequipsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Hairequips
     * const hairequips = await prisma.hairequips.findMany()
     * 
     * // Get first 10 Hairequips
     * const hairequips = await prisma.hairequips.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hairequipsWithIdOnly = await prisma.hairequips.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends hairequipsFindManyArgs>(args?: SelectSubset<T, hairequipsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$hairequipsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Hairequips.
     * @param {hairequipsCreateArgs} args - Arguments to create a Hairequips.
     * @example
     * // Create one Hairequips
     * const Hairequips = await prisma.hairequips.create({
     *   data: {
     *     // ... data to create a Hairequips
     *   }
     * })
     * 
     */
    create<T extends hairequipsCreateArgs>(args: SelectSubset<T, hairequipsCreateArgs<ExtArgs>>): Prisma__hairequipsClient<$Result.GetResult<Prisma.$hairequipsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Hairequips.
     * @param {hairequipsCreateManyArgs} args - Arguments to create many Hairequips.
     * @example
     * // Create many Hairequips
     * const hairequips = await prisma.hairequips.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends hairequipsCreateManyArgs>(args?: SelectSubset<T, hairequipsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Hairequips.
     * @param {hairequipsDeleteArgs} args - Arguments to delete one Hairequips.
     * @example
     * // Delete one Hairequips
     * const Hairequips = await prisma.hairequips.delete({
     *   where: {
     *     // ... filter to delete one Hairequips
     *   }
     * })
     * 
     */
    delete<T extends hairequipsDeleteArgs>(args: SelectSubset<T, hairequipsDeleteArgs<ExtArgs>>): Prisma__hairequipsClient<$Result.GetResult<Prisma.$hairequipsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Hairequips.
     * @param {hairequipsUpdateArgs} args - Arguments to update one Hairequips.
     * @example
     * // Update one Hairequips
     * const hairequips = await prisma.hairequips.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends hairequipsUpdateArgs>(args: SelectSubset<T, hairequipsUpdateArgs<ExtArgs>>): Prisma__hairequipsClient<$Result.GetResult<Prisma.$hairequipsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Hairequips.
     * @param {hairequipsDeleteManyArgs} args - Arguments to filter Hairequips to delete.
     * @example
     * // Delete a few Hairequips
     * const { count } = await prisma.hairequips.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends hairequipsDeleteManyArgs>(args?: SelectSubset<T, hairequipsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hairequips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hairequipsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Hairequips
     * const hairequips = await prisma.hairequips.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends hairequipsUpdateManyArgs>(args: SelectSubset<T, hairequipsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Hairequips.
     * @param {hairequipsUpsertArgs} args - Arguments to update or create a Hairequips.
     * @example
     * // Update or create a Hairequips
     * const hairequips = await prisma.hairequips.upsert({
     *   create: {
     *     // ... data to create a Hairequips
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Hairequips we want to update
     *   }
     * })
     */
    upsert<T extends hairequipsUpsertArgs>(args: SelectSubset<T, hairequipsUpsertArgs<ExtArgs>>): Prisma__hairequipsClient<$Result.GetResult<Prisma.$hairequipsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Hairequips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hairequipsCountArgs} args - Arguments to filter Hairequips to count.
     * @example
     * // Count the number of Hairequips
     * const count = await prisma.hairequips.count({
     *   where: {
     *     // ... the filter for the Hairequips we want to count
     *   }
     * })
    **/
    count<T extends hairequipsCountArgs>(
      args?: Subset<T, hairequipsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HairequipsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Hairequips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HairequipsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HairequipsAggregateArgs>(args: Subset<T, HairequipsAggregateArgs>): Prisma.PrismaPromise<GetHairequipsAggregateType<T>>

    /**
     * Group by Hairequips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hairequipsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends hairequipsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: hairequipsGroupByArgs['orderBy'] }
        : { orderBy?: hairequipsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, hairequipsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHairequipsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the hairequips model
   */
  readonly fields: hairequipsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for hairequips.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__hairequipsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the hairequips model
   */ 
  interface hairequipsFieldRefs {
    readonly id: FieldRef<"hairequips", 'Int'>
    readonly alid: FieldRef<"hairequips", 'Int'>
    readonly equipid: FieldRef<"hairequips", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * hairequips findUnique
   */
  export type hairequipsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hairequips
     */
    select?: hairequipsSelect<ExtArgs> | null
    /**
     * Filter, which hairequips to fetch.
     */
    where: hairequipsWhereUniqueInput
  }

  /**
   * hairequips findUniqueOrThrow
   */
  export type hairequipsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hairequips
     */
    select?: hairequipsSelect<ExtArgs> | null
    /**
     * Filter, which hairequips to fetch.
     */
    where: hairequipsWhereUniqueInput
  }

  /**
   * hairequips findFirst
   */
  export type hairequipsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hairequips
     */
    select?: hairequipsSelect<ExtArgs> | null
    /**
     * Filter, which hairequips to fetch.
     */
    where?: hairequipsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hairequips to fetch.
     */
    orderBy?: hairequipsOrderByWithRelationInput | hairequipsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for hairequips.
     */
    cursor?: hairequipsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hairequips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hairequips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of hairequips.
     */
    distinct?: HairequipsScalarFieldEnum | HairequipsScalarFieldEnum[]
  }

  /**
   * hairequips findFirstOrThrow
   */
  export type hairequipsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hairequips
     */
    select?: hairequipsSelect<ExtArgs> | null
    /**
     * Filter, which hairequips to fetch.
     */
    where?: hairequipsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hairequips to fetch.
     */
    orderBy?: hairequipsOrderByWithRelationInput | hairequipsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for hairequips.
     */
    cursor?: hairequipsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hairequips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hairequips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of hairequips.
     */
    distinct?: HairequipsScalarFieldEnum | HairequipsScalarFieldEnum[]
  }

  /**
   * hairequips findMany
   */
  export type hairequipsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hairequips
     */
    select?: hairequipsSelect<ExtArgs> | null
    /**
     * Filter, which hairequips to fetch.
     */
    where?: hairequipsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hairequips to fetch.
     */
    orderBy?: hairequipsOrderByWithRelationInput | hairequipsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing hairequips.
     */
    cursor?: hairequipsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hairequips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hairequips.
     */
    skip?: number
    distinct?: HairequipsScalarFieldEnum | HairequipsScalarFieldEnum[]
  }

  /**
   * hairequips create
   */
  export type hairequipsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hairequips
     */
    select?: hairequipsSelect<ExtArgs> | null
    /**
     * The data needed to create a hairequips.
     */
    data?: XOR<hairequipsCreateInput, hairequipsUncheckedCreateInput>
  }

  /**
   * hairequips createMany
   */
  export type hairequipsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many hairequips.
     */
    data: hairequipsCreateManyInput | hairequipsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * hairequips update
   */
  export type hairequipsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hairequips
     */
    select?: hairequipsSelect<ExtArgs> | null
    /**
     * The data needed to update a hairequips.
     */
    data: XOR<hairequipsUpdateInput, hairequipsUncheckedUpdateInput>
    /**
     * Choose, which hairequips to update.
     */
    where: hairequipsWhereUniqueInput
  }

  /**
   * hairequips updateMany
   */
  export type hairequipsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update hairequips.
     */
    data: XOR<hairequipsUpdateManyMutationInput, hairequipsUncheckedUpdateManyInput>
    /**
     * Filter which hairequips to update
     */
    where?: hairequipsWhereInput
  }

  /**
   * hairequips upsert
   */
  export type hairequipsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hairequips
     */
    select?: hairequipsSelect<ExtArgs> | null
    /**
     * The filter to search for the hairequips to update in case it exists.
     */
    where: hairequipsWhereUniqueInput
    /**
     * In case the hairequips found by the `where` argument doesn't exist, create a new hairequips with this data.
     */
    create: XOR<hairequipsCreateInput, hairequipsUncheckedCreateInput>
    /**
     * In case the hairequips was found with the provided `where` argument, update it with this data.
     */
    update: XOR<hairequipsUpdateInput, hairequipsUncheckedUpdateInput>
  }

  /**
   * hairequips delete
   */
  export type hairequipsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hairequips
     */
    select?: hairequipsSelect<ExtArgs> | null
    /**
     * Filter which hairequips to delete.
     */
    where: hairequipsWhereUniqueInput
  }

  /**
   * hairequips deleteMany
   */
  export type hairequipsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which hairequips to delete
     */
    where?: hairequipsWhereInput
  }

  /**
   * hairequips without action
   */
  export type hairequipsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hairequips
     */
    select?: hairequipsSelect<ExtArgs> | null
  }


  /**
   * Model hyperrockfields
   */

  export type AggregateHyperrockfields = {
    _count: HyperrockfieldsCountAggregateOutputType | null
    _avg: HyperrockfieldsAvgAggregateOutputType | null
    _sum: HyperrockfieldsSumAggregateOutputType | null
    _min: HyperrockfieldsMinAggregateOutputType | null
    _max: HyperrockfieldsMaxAggregateOutputType | null
  }

  export type HyperrockfieldsAvgAggregateOutputType = {
    id: number | null
    charid: number | null
    ord: number | null
    fieldid: number | null
  }

  export type HyperrockfieldsSumAggregateOutputType = {
    id: bigint | null
    charid: number | null
    ord: number | null
    fieldid: number | null
  }

  export type HyperrockfieldsMinAggregateOutputType = {
    id: bigint | null
    charid: number | null
    ord: number | null
    fieldid: number | null
  }

  export type HyperrockfieldsMaxAggregateOutputType = {
    id: bigint | null
    charid: number | null
    ord: number | null
    fieldid: number | null
  }

  export type HyperrockfieldsCountAggregateOutputType = {
    id: number
    charid: number
    ord: number
    fieldid: number
    _all: number
  }


  export type HyperrockfieldsAvgAggregateInputType = {
    id?: true
    charid?: true
    ord?: true
    fieldid?: true
  }

  export type HyperrockfieldsSumAggregateInputType = {
    id?: true
    charid?: true
    ord?: true
    fieldid?: true
  }

  export type HyperrockfieldsMinAggregateInputType = {
    id?: true
    charid?: true
    ord?: true
    fieldid?: true
  }

  export type HyperrockfieldsMaxAggregateInputType = {
    id?: true
    charid?: true
    ord?: true
    fieldid?: true
  }

  export type HyperrockfieldsCountAggregateInputType = {
    id?: true
    charid?: true
    ord?: true
    fieldid?: true
    _all?: true
  }

  export type HyperrockfieldsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which hyperrockfields to aggregate.
     */
    where?: hyperrockfieldsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hyperrockfields to fetch.
     */
    orderBy?: hyperrockfieldsOrderByWithRelationInput | hyperrockfieldsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: hyperrockfieldsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hyperrockfields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hyperrockfields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned hyperrockfields
    **/
    _count?: true | HyperrockfieldsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HyperrockfieldsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HyperrockfieldsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HyperrockfieldsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HyperrockfieldsMaxAggregateInputType
  }

  export type GetHyperrockfieldsAggregateType<T extends HyperrockfieldsAggregateArgs> = {
        [P in keyof T & keyof AggregateHyperrockfields]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHyperrockfields[P]>
      : GetScalarType<T[P], AggregateHyperrockfields[P]>
  }




  export type hyperrockfieldsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: hyperrockfieldsWhereInput
    orderBy?: hyperrockfieldsOrderByWithAggregationInput | hyperrockfieldsOrderByWithAggregationInput[]
    by: HyperrockfieldsScalarFieldEnum[] | HyperrockfieldsScalarFieldEnum
    having?: hyperrockfieldsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HyperrockfieldsCountAggregateInputType | true
    _avg?: HyperrockfieldsAvgAggregateInputType
    _sum?: HyperrockfieldsSumAggregateInputType
    _min?: HyperrockfieldsMinAggregateInputType
    _max?: HyperrockfieldsMaxAggregateInputType
  }

  export type HyperrockfieldsGroupByOutputType = {
    id: bigint
    charid: number | null
    ord: number | null
    fieldid: number | null
    _count: HyperrockfieldsCountAggregateOutputType | null
    _avg: HyperrockfieldsAvgAggregateOutputType | null
    _sum: HyperrockfieldsSumAggregateOutputType | null
    _min: HyperrockfieldsMinAggregateOutputType | null
    _max: HyperrockfieldsMaxAggregateOutputType | null
  }

  type GetHyperrockfieldsGroupByPayload<T extends hyperrockfieldsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HyperrockfieldsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HyperrockfieldsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HyperrockfieldsGroupByOutputType[P]>
            : GetScalarType<T[P], HyperrockfieldsGroupByOutputType[P]>
        }
      >
    >


  export type hyperrockfieldsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    charid?: boolean
    ord?: boolean
    fieldid?: boolean
  }, ExtArgs["result"]["hyperrockfields"]>


  export type hyperrockfieldsSelectScalar = {
    id?: boolean
    charid?: boolean
    ord?: boolean
    fieldid?: boolean
  }


  export type $hyperrockfieldsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "hyperrockfields"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      charid: number | null
      ord: number | null
      fieldid: number | null
    }, ExtArgs["result"]["hyperrockfields"]>
    composites: {}
  }

  type hyperrockfieldsGetPayload<S extends boolean | null | undefined | hyperrockfieldsDefaultArgs> = $Result.GetResult<Prisma.$hyperrockfieldsPayload, S>

  type hyperrockfieldsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<hyperrockfieldsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HyperrockfieldsCountAggregateInputType | true
    }

  export interface hyperrockfieldsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['hyperrockfields'], meta: { name: 'hyperrockfields' } }
    /**
     * Find zero or one Hyperrockfields that matches the filter.
     * @param {hyperrockfieldsFindUniqueArgs} args - Arguments to find a Hyperrockfields
     * @example
     * // Get one Hyperrockfields
     * const hyperrockfields = await prisma.hyperrockfields.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends hyperrockfieldsFindUniqueArgs>(args: SelectSubset<T, hyperrockfieldsFindUniqueArgs<ExtArgs>>): Prisma__hyperrockfieldsClient<$Result.GetResult<Prisma.$hyperrockfieldsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Hyperrockfields that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {hyperrockfieldsFindUniqueOrThrowArgs} args - Arguments to find a Hyperrockfields
     * @example
     * // Get one Hyperrockfields
     * const hyperrockfields = await prisma.hyperrockfields.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends hyperrockfieldsFindUniqueOrThrowArgs>(args: SelectSubset<T, hyperrockfieldsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__hyperrockfieldsClient<$Result.GetResult<Prisma.$hyperrockfieldsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Hyperrockfields that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hyperrockfieldsFindFirstArgs} args - Arguments to find a Hyperrockfields
     * @example
     * // Get one Hyperrockfields
     * const hyperrockfields = await prisma.hyperrockfields.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends hyperrockfieldsFindFirstArgs>(args?: SelectSubset<T, hyperrockfieldsFindFirstArgs<ExtArgs>>): Prisma__hyperrockfieldsClient<$Result.GetResult<Prisma.$hyperrockfieldsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Hyperrockfields that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hyperrockfieldsFindFirstOrThrowArgs} args - Arguments to find a Hyperrockfields
     * @example
     * // Get one Hyperrockfields
     * const hyperrockfields = await prisma.hyperrockfields.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends hyperrockfieldsFindFirstOrThrowArgs>(args?: SelectSubset<T, hyperrockfieldsFindFirstOrThrowArgs<ExtArgs>>): Prisma__hyperrockfieldsClient<$Result.GetResult<Prisma.$hyperrockfieldsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Hyperrockfields that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hyperrockfieldsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Hyperrockfields
     * const hyperrockfields = await prisma.hyperrockfields.findMany()
     * 
     * // Get first 10 Hyperrockfields
     * const hyperrockfields = await prisma.hyperrockfields.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hyperrockfieldsWithIdOnly = await prisma.hyperrockfields.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends hyperrockfieldsFindManyArgs>(args?: SelectSubset<T, hyperrockfieldsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$hyperrockfieldsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Hyperrockfields.
     * @param {hyperrockfieldsCreateArgs} args - Arguments to create a Hyperrockfields.
     * @example
     * // Create one Hyperrockfields
     * const Hyperrockfields = await prisma.hyperrockfields.create({
     *   data: {
     *     // ... data to create a Hyperrockfields
     *   }
     * })
     * 
     */
    create<T extends hyperrockfieldsCreateArgs>(args: SelectSubset<T, hyperrockfieldsCreateArgs<ExtArgs>>): Prisma__hyperrockfieldsClient<$Result.GetResult<Prisma.$hyperrockfieldsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Hyperrockfields.
     * @param {hyperrockfieldsCreateManyArgs} args - Arguments to create many Hyperrockfields.
     * @example
     * // Create many Hyperrockfields
     * const hyperrockfields = await prisma.hyperrockfields.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends hyperrockfieldsCreateManyArgs>(args?: SelectSubset<T, hyperrockfieldsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Hyperrockfields.
     * @param {hyperrockfieldsDeleteArgs} args - Arguments to delete one Hyperrockfields.
     * @example
     * // Delete one Hyperrockfields
     * const Hyperrockfields = await prisma.hyperrockfields.delete({
     *   where: {
     *     // ... filter to delete one Hyperrockfields
     *   }
     * })
     * 
     */
    delete<T extends hyperrockfieldsDeleteArgs>(args: SelectSubset<T, hyperrockfieldsDeleteArgs<ExtArgs>>): Prisma__hyperrockfieldsClient<$Result.GetResult<Prisma.$hyperrockfieldsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Hyperrockfields.
     * @param {hyperrockfieldsUpdateArgs} args - Arguments to update one Hyperrockfields.
     * @example
     * // Update one Hyperrockfields
     * const hyperrockfields = await prisma.hyperrockfields.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends hyperrockfieldsUpdateArgs>(args: SelectSubset<T, hyperrockfieldsUpdateArgs<ExtArgs>>): Prisma__hyperrockfieldsClient<$Result.GetResult<Prisma.$hyperrockfieldsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Hyperrockfields.
     * @param {hyperrockfieldsDeleteManyArgs} args - Arguments to filter Hyperrockfields to delete.
     * @example
     * // Delete a few Hyperrockfields
     * const { count } = await prisma.hyperrockfields.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends hyperrockfieldsDeleteManyArgs>(args?: SelectSubset<T, hyperrockfieldsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hyperrockfields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hyperrockfieldsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Hyperrockfields
     * const hyperrockfields = await prisma.hyperrockfields.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends hyperrockfieldsUpdateManyArgs>(args: SelectSubset<T, hyperrockfieldsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Hyperrockfields.
     * @param {hyperrockfieldsUpsertArgs} args - Arguments to update or create a Hyperrockfields.
     * @example
     * // Update or create a Hyperrockfields
     * const hyperrockfields = await prisma.hyperrockfields.upsert({
     *   create: {
     *     // ... data to create a Hyperrockfields
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Hyperrockfields we want to update
     *   }
     * })
     */
    upsert<T extends hyperrockfieldsUpsertArgs>(args: SelectSubset<T, hyperrockfieldsUpsertArgs<ExtArgs>>): Prisma__hyperrockfieldsClient<$Result.GetResult<Prisma.$hyperrockfieldsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Hyperrockfields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hyperrockfieldsCountArgs} args - Arguments to filter Hyperrockfields to count.
     * @example
     * // Count the number of Hyperrockfields
     * const count = await prisma.hyperrockfields.count({
     *   where: {
     *     // ... the filter for the Hyperrockfields we want to count
     *   }
     * })
    **/
    count<T extends hyperrockfieldsCountArgs>(
      args?: Subset<T, hyperrockfieldsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HyperrockfieldsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Hyperrockfields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HyperrockfieldsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HyperrockfieldsAggregateArgs>(args: Subset<T, HyperrockfieldsAggregateArgs>): Prisma.PrismaPromise<GetHyperrockfieldsAggregateType<T>>

    /**
     * Group by Hyperrockfields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hyperrockfieldsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends hyperrockfieldsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: hyperrockfieldsGroupByArgs['orderBy'] }
        : { orderBy?: hyperrockfieldsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, hyperrockfieldsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHyperrockfieldsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the hyperrockfields model
   */
  readonly fields: hyperrockfieldsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for hyperrockfields.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__hyperrockfieldsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the hyperrockfields model
   */ 
  interface hyperrockfieldsFieldRefs {
    readonly id: FieldRef<"hyperrockfields", 'BigInt'>
    readonly charid: FieldRef<"hyperrockfields", 'Int'>
    readonly ord: FieldRef<"hyperrockfields", 'Int'>
    readonly fieldid: FieldRef<"hyperrockfields", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * hyperrockfields findUnique
   */
  export type hyperrockfieldsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hyperrockfields
     */
    select?: hyperrockfieldsSelect<ExtArgs> | null
    /**
     * Filter, which hyperrockfields to fetch.
     */
    where: hyperrockfieldsWhereUniqueInput
  }

  /**
   * hyperrockfields findUniqueOrThrow
   */
  export type hyperrockfieldsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hyperrockfields
     */
    select?: hyperrockfieldsSelect<ExtArgs> | null
    /**
     * Filter, which hyperrockfields to fetch.
     */
    where: hyperrockfieldsWhereUniqueInput
  }

  /**
   * hyperrockfields findFirst
   */
  export type hyperrockfieldsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hyperrockfields
     */
    select?: hyperrockfieldsSelect<ExtArgs> | null
    /**
     * Filter, which hyperrockfields to fetch.
     */
    where?: hyperrockfieldsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hyperrockfields to fetch.
     */
    orderBy?: hyperrockfieldsOrderByWithRelationInput | hyperrockfieldsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for hyperrockfields.
     */
    cursor?: hyperrockfieldsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hyperrockfields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hyperrockfields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of hyperrockfields.
     */
    distinct?: HyperrockfieldsScalarFieldEnum | HyperrockfieldsScalarFieldEnum[]
  }

  /**
   * hyperrockfields findFirstOrThrow
   */
  export type hyperrockfieldsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hyperrockfields
     */
    select?: hyperrockfieldsSelect<ExtArgs> | null
    /**
     * Filter, which hyperrockfields to fetch.
     */
    where?: hyperrockfieldsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hyperrockfields to fetch.
     */
    orderBy?: hyperrockfieldsOrderByWithRelationInput | hyperrockfieldsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for hyperrockfields.
     */
    cursor?: hyperrockfieldsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hyperrockfields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hyperrockfields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of hyperrockfields.
     */
    distinct?: HyperrockfieldsScalarFieldEnum | HyperrockfieldsScalarFieldEnum[]
  }

  /**
   * hyperrockfields findMany
   */
  export type hyperrockfieldsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hyperrockfields
     */
    select?: hyperrockfieldsSelect<ExtArgs> | null
    /**
     * Filter, which hyperrockfields to fetch.
     */
    where?: hyperrockfieldsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hyperrockfields to fetch.
     */
    orderBy?: hyperrockfieldsOrderByWithRelationInput | hyperrockfieldsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing hyperrockfields.
     */
    cursor?: hyperrockfieldsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hyperrockfields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hyperrockfields.
     */
    skip?: number
    distinct?: HyperrockfieldsScalarFieldEnum | HyperrockfieldsScalarFieldEnum[]
  }

  /**
   * hyperrockfields create
   */
  export type hyperrockfieldsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hyperrockfields
     */
    select?: hyperrockfieldsSelect<ExtArgs> | null
    /**
     * The data needed to create a hyperrockfields.
     */
    data?: XOR<hyperrockfieldsCreateInput, hyperrockfieldsUncheckedCreateInput>
  }

  /**
   * hyperrockfields createMany
   */
  export type hyperrockfieldsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many hyperrockfields.
     */
    data: hyperrockfieldsCreateManyInput | hyperrockfieldsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * hyperrockfields update
   */
  export type hyperrockfieldsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hyperrockfields
     */
    select?: hyperrockfieldsSelect<ExtArgs> | null
    /**
     * The data needed to update a hyperrockfields.
     */
    data: XOR<hyperrockfieldsUpdateInput, hyperrockfieldsUncheckedUpdateInput>
    /**
     * Choose, which hyperrockfields to update.
     */
    where: hyperrockfieldsWhereUniqueInput
  }

  /**
   * hyperrockfields updateMany
   */
  export type hyperrockfieldsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update hyperrockfields.
     */
    data: XOR<hyperrockfieldsUpdateManyMutationInput, hyperrockfieldsUncheckedUpdateManyInput>
    /**
     * Filter which hyperrockfields to update
     */
    where?: hyperrockfieldsWhereInput
  }

  /**
   * hyperrockfields upsert
   */
  export type hyperrockfieldsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hyperrockfields
     */
    select?: hyperrockfieldsSelect<ExtArgs> | null
    /**
     * The filter to search for the hyperrockfields to update in case it exists.
     */
    where: hyperrockfieldsWhereUniqueInput
    /**
     * In case the hyperrockfields found by the `where` argument doesn't exist, create a new hyperrockfields with this data.
     */
    create: XOR<hyperrockfieldsCreateInput, hyperrockfieldsUncheckedCreateInput>
    /**
     * In case the hyperrockfields was found with the provided `where` argument, update it with this data.
     */
    update: XOR<hyperrockfieldsUpdateInput, hyperrockfieldsUncheckedUpdateInput>
  }

  /**
   * hyperrockfields delete
   */
  export type hyperrockfieldsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hyperrockfields
     */
    select?: hyperrockfieldsSelect<ExtArgs> | null
    /**
     * Filter which hyperrockfields to delete.
     */
    where: hyperrockfieldsWhereUniqueInput
  }

  /**
   * hyperrockfields deleteMany
   */
  export type hyperrockfieldsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which hyperrockfields to delete
     */
    where?: hyperrockfieldsWhereInput
  }

  /**
   * hyperrockfields without action
   */
  export type hyperrockfieldsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hyperrockfields
     */
    select?: hyperrockfieldsSelect<ExtArgs> | null
  }


  /**
   * Model inventories
   */

  export type AggregateInventories = {
    _count: InventoriesCountAggregateOutputType | null
    _avg: InventoriesAvgAggregateOutputType | null
    _sum: InventoriesSumAggregateOutputType | null
    _min: InventoriesMinAggregateOutputType | null
    _max: InventoriesMaxAggregateOutputType | null
  }

  export type InventoriesAvgAggregateOutputType = {
    id: number | null
    type: number | null
    slots: number | null
  }

  export type InventoriesSumAggregateOutputType = {
    id: number | null
    type: number | null
    slots: number | null
  }

  export type InventoriesMinAggregateOutputType = {
    id: number | null
    type: number | null
    slots: number | null
  }

  export type InventoriesMaxAggregateOutputType = {
    id: number | null
    type: number | null
    slots: number | null
  }

  export type InventoriesCountAggregateOutputType = {
    id: number
    type: number
    slots: number
    _all: number
  }


  export type InventoriesAvgAggregateInputType = {
    id?: true
    type?: true
    slots?: true
  }

  export type InventoriesSumAggregateInputType = {
    id?: true
    type?: true
    slots?: true
  }

  export type InventoriesMinAggregateInputType = {
    id?: true
    type?: true
    slots?: true
  }

  export type InventoriesMaxAggregateInputType = {
    id?: true
    type?: true
    slots?: true
  }

  export type InventoriesCountAggregateInputType = {
    id?: true
    type?: true
    slots?: true
    _all?: true
  }

  export type InventoriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which inventories to aggregate.
     */
    where?: inventoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inventories to fetch.
     */
    orderBy?: inventoriesOrderByWithRelationInput | inventoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inventoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inventories
    **/
    _count?: true | InventoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventoriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoriesMaxAggregateInputType
  }

  export type GetInventoriesAggregateType<T extends InventoriesAggregateArgs> = {
        [P in keyof T & keyof AggregateInventories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventories[P]>
      : GetScalarType<T[P], AggregateInventories[P]>
  }




  export type inventoriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: inventoriesWhereInput
    orderBy?: inventoriesOrderByWithAggregationInput | inventoriesOrderByWithAggregationInput[]
    by: InventoriesScalarFieldEnum[] | InventoriesScalarFieldEnum
    having?: inventoriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoriesCountAggregateInputType | true
    _avg?: InventoriesAvgAggregateInputType
    _sum?: InventoriesSumAggregateInputType
    _min?: InventoriesMinAggregateInputType
    _max?: InventoriesMaxAggregateInputType
  }

  export type InventoriesGroupByOutputType = {
    id: number
    type: number | null
    slots: number | null
    _count: InventoriesCountAggregateOutputType | null
    _avg: InventoriesAvgAggregateOutputType | null
    _sum: InventoriesSumAggregateOutputType | null
    _min: InventoriesMinAggregateOutputType | null
    _max: InventoriesMaxAggregateOutputType | null
  }

  type GetInventoriesGroupByPayload<T extends inventoriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoriesGroupByOutputType[P]>
            : GetScalarType<T[P], InventoriesGroupByOutputType[P]>
        }
      >
    >


  export type inventoriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    slots?: boolean
  }, ExtArgs["result"]["inventories"]>


  export type inventoriesSelectScalar = {
    id?: boolean
    type?: boolean
    slots?: boolean
  }


  export type $inventoriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "inventories"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: number | null
      slots: number | null
    }, ExtArgs["result"]["inventories"]>
    composites: {}
  }

  type inventoriesGetPayload<S extends boolean | null | undefined | inventoriesDefaultArgs> = $Result.GetResult<Prisma.$inventoriesPayload, S>

  type inventoriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<inventoriesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InventoriesCountAggregateInputType | true
    }

  export interface inventoriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inventories'], meta: { name: 'inventories' } }
    /**
     * Find zero or one Inventories that matches the filter.
     * @param {inventoriesFindUniqueArgs} args - Arguments to find a Inventories
     * @example
     * // Get one Inventories
     * const inventories = await prisma.inventories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends inventoriesFindUniqueArgs>(args: SelectSubset<T, inventoriesFindUniqueArgs<ExtArgs>>): Prisma__inventoriesClient<$Result.GetResult<Prisma.$inventoriesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Inventories that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {inventoriesFindUniqueOrThrowArgs} args - Arguments to find a Inventories
     * @example
     * // Get one Inventories
     * const inventories = await prisma.inventories.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends inventoriesFindUniqueOrThrowArgs>(args: SelectSubset<T, inventoriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__inventoriesClient<$Result.GetResult<Prisma.$inventoriesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Inventories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventoriesFindFirstArgs} args - Arguments to find a Inventories
     * @example
     * // Get one Inventories
     * const inventories = await prisma.inventories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends inventoriesFindFirstArgs>(args?: SelectSubset<T, inventoriesFindFirstArgs<ExtArgs>>): Prisma__inventoriesClient<$Result.GetResult<Prisma.$inventoriesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Inventories that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventoriesFindFirstOrThrowArgs} args - Arguments to find a Inventories
     * @example
     * // Get one Inventories
     * const inventories = await prisma.inventories.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends inventoriesFindFirstOrThrowArgs>(args?: SelectSubset<T, inventoriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__inventoriesClient<$Result.GetResult<Prisma.$inventoriesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Inventories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventoriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inventories
     * const inventories = await prisma.inventories.findMany()
     * 
     * // Get first 10 Inventories
     * const inventories = await prisma.inventories.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoriesWithIdOnly = await prisma.inventories.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends inventoriesFindManyArgs>(args?: SelectSubset<T, inventoriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inventoriesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Inventories.
     * @param {inventoriesCreateArgs} args - Arguments to create a Inventories.
     * @example
     * // Create one Inventories
     * const Inventories = await prisma.inventories.create({
     *   data: {
     *     // ... data to create a Inventories
     *   }
     * })
     * 
     */
    create<T extends inventoriesCreateArgs>(args: SelectSubset<T, inventoriesCreateArgs<ExtArgs>>): Prisma__inventoriesClient<$Result.GetResult<Prisma.$inventoriesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Inventories.
     * @param {inventoriesCreateManyArgs} args - Arguments to create many Inventories.
     * @example
     * // Create many Inventories
     * const inventories = await prisma.inventories.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends inventoriesCreateManyArgs>(args?: SelectSubset<T, inventoriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inventories.
     * @param {inventoriesDeleteArgs} args - Arguments to delete one Inventories.
     * @example
     * // Delete one Inventories
     * const Inventories = await prisma.inventories.delete({
     *   where: {
     *     // ... filter to delete one Inventories
     *   }
     * })
     * 
     */
    delete<T extends inventoriesDeleteArgs>(args: SelectSubset<T, inventoriesDeleteArgs<ExtArgs>>): Prisma__inventoriesClient<$Result.GetResult<Prisma.$inventoriesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Inventories.
     * @param {inventoriesUpdateArgs} args - Arguments to update one Inventories.
     * @example
     * // Update one Inventories
     * const inventories = await prisma.inventories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends inventoriesUpdateArgs>(args: SelectSubset<T, inventoriesUpdateArgs<ExtArgs>>): Prisma__inventoriesClient<$Result.GetResult<Prisma.$inventoriesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Inventories.
     * @param {inventoriesDeleteManyArgs} args - Arguments to filter Inventories to delete.
     * @example
     * // Delete a few Inventories
     * const { count } = await prisma.inventories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends inventoriesDeleteManyArgs>(args?: SelectSubset<T, inventoriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventoriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inventories
     * const inventories = await prisma.inventories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends inventoriesUpdateManyArgs>(args: SelectSubset<T, inventoriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inventories.
     * @param {inventoriesUpsertArgs} args - Arguments to update or create a Inventories.
     * @example
     * // Update or create a Inventories
     * const inventories = await prisma.inventories.upsert({
     *   create: {
     *     // ... data to create a Inventories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inventories we want to update
     *   }
     * })
     */
    upsert<T extends inventoriesUpsertArgs>(args: SelectSubset<T, inventoriesUpsertArgs<ExtArgs>>): Prisma__inventoriesClient<$Result.GetResult<Prisma.$inventoriesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventoriesCountArgs} args - Arguments to filter Inventories to count.
     * @example
     * // Count the number of Inventories
     * const count = await prisma.inventories.count({
     *   where: {
     *     // ... the filter for the Inventories we want to count
     *   }
     * })
    **/
    count<T extends inventoriesCountArgs>(
      args?: Subset<T, inventoriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoriesAggregateArgs>(args: Subset<T, InventoriesAggregateArgs>): Prisma.PrismaPromise<GetInventoriesAggregateType<T>>

    /**
     * Group by Inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventoriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inventoriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inventoriesGroupByArgs['orderBy'] }
        : { orderBy?: inventoriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inventoriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inventories model
   */
  readonly fields: inventoriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inventories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inventoriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the inventories model
   */ 
  interface inventoriesFieldRefs {
    readonly id: FieldRef<"inventories", 'Int'>
    readonly type: FieldRef<"inventories", 'Int'>
    readonly slots: FieldRef<"inventories", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * inventories findUnique
   */
  export type inventoriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventories
     */
    select?: inventoriesSelect<ExtArgs> | null
    /**
     * Filter, which inventories to fetch.
     */
    where: inventoriesWhereUniqueInput
  }

  /**
   * inventories findUniqueOrThrow
   */
  export type inventoriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventories
     */
    select?: inventoriesSelect<ExtArgs> | null
    /**
     * Filter, which inventories to fetch.
     */
    where: inventoriesWhereUniqueInput
  }

  /**
   * inventories findFirst
   */
  export type inventoriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventories
     */
    select?: inventoriesSelect<ExtArgs> | null
    /**
     * Filter, which inventories to fetch.
     */
    where?: inventoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inventories to fetch.
     */
    orderBy?: inventoriesOrderByWithRelationInput | inventoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inventories.
     */
    cursor?: inventoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inventories.
     */
    distinct?: InventoriesScalarFieldEnum | InventoriesScalarFieldEnum[]
  }

  /**
   * inventories findFirstOrThrow
   */
  export type inventoriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventories
     */
    select?: inventoriesSelect<ExtArgs> | null
    /**
     * Filter, which inventories to fetch.
     */
    where?: inventoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inventories to fetch.
     */
    orderBy?: inventoriesOrderByWithRelationInput | inventoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inventories.
     */
    cursor?: inventoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inventories.
     */
    distinct?: InventoriesScalarFieldEnum | InventoriesScalarFieldEnum[]
  }

  /**
   * inventories findMany
   */
  export type inventoriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventories
     */
    select?: inventoriesSelect<ExtArgs> | null
    /**
     * Filter, which inventories to fetch.
     */
    where?: inventoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inventories to fetch.
     */
    orderBy?: inventoriesOrderByWithRelationInput | inventoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inventories.
     */
    cursor?: inventoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inventories.
     */
    skip?: number
    distinct?: InventoriesScalarFieldEnum | InventoriesScalarFieldEnum[]
  }

  /**
   * inventories create
   */
  export type inventoriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventories
     */
    select?: inventoriesSelect<ExtArgs> | null
    /**
     * The data needed to create a inventories.
     */
    data?: XOR<inventoriesCreateInput, inventoriesUncheckedCreateInput>
  }

  /**
   * inventories createMany
   */
  export type inventoriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inventories.
     */
    data: inventoriesCreateManyInput | inventoriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * inventories update
   */
  export type inventoriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventories
     */
    select?: inventoriesSelect<ExtArgs> | null
    /**
     * The data needed to update a inventories.
     */
    data: XOR<inventoriesUpdateInput, inventoriesUncheckedUpdateInput>
    /**
     * Choose, which inventories to update.
     */
    where: inventoriesWhereUniqueInput
  }

  /**
   * inventories updateMany
   */
  export type inventoriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inventories.
     */
    data: XOR<inventoriesUpdateManyMutationInput, inventoriesUncheckedUpdateManyInput>
    /**
     * Filter which inventories to update
     */
    where?: inventoriesWhereInput
  }

  /**
   * inventories upsert
   */
  export type inventoriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventories
     */
    select?: inventoriesSelect<ExtArgs> | null
    /**
     * The filter to search for the inventories to update in case it exists.
     */
    where: inventoriesWhereUniqueInput
    /**
     * In case the inventories found by the `where` argument doesn't exist, create a new inventories with this data.
     */
    create: XOR<inventoriesCreateInput, inventoriesUncheckedCreateInput>
    /**
     * In case the inventories was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inventoriesUpdateInput, inventoriesUncheckedUpdateInput>
  }

  /**
   * inventories delete
   */
  export type inventoriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventories
     */
    select?: inventoriesSelect<ExtArgs> | null
    /**
     * Filter which inventories to delete.
     */
    where: inventoriesWhereUniqueInput
  }

  /**
   * inventories deleteMany
   */
  export type inventoriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which inventories to delete
     */
    where?: inventoriesWhereInput
  }

  /**
   * inventories without action
   */
  export type inventoriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventories
     */
    select?: inventoriesSelect<ExtArgs> | null
  }


  /**
   * Model items
   */

  export type AggregateItems = {
    _count: ItemsCountAggregateOutputType | null
    _avg: ItemsAvgAggregateOutputType | null
    _sum: ItemsSumAggregateOutputType | null
    _min: ItemsMinAggregateOutputType | null
    _max: ItemsMaxAggregateOutputType | null
  }

  export type ItemsAvgAggregateOutputType = {
    id: number | null
    inventoryid: number | null
    trunkid: number | null
    itemid: number | null
    bagindex: number | null
    cashitemserialnumber: number | null
    invtype: number | null
    type: number | null
    quantity: number | null
    zeroShareItemID: number | null
    attribute: number | null
  }

  export type ItemsSumAggregateOutputType = {
    id: bigint | null
    inventoryid: number | null
    trunkid: number | null
    itemid: number | null
    bagindex: number | null
    cashitemserialnumber: bigint | null
    invtype: number | null
    type: number | null
    quantity: number | null
    zeroShareItemID: bigint | null
    attribute: number | null
  }

  export type ItemsMinAggregateOutputType = {
    id: bigint | null
    inventoryid: number | null
    trunkid: number | null
    auctionHouseStatus: boolean | null
    itemid: number | null
    bagindex: number | null
    cashitemserialnumber: bigint | null
    dateexpire: Date | null
    invtype: number | null
    type: number | null
    iscash: boolean | null
    quantity: number | null
    expireonlogout: boolean | null
    owner: string | null
    obtainedonce: boolean | null
    zeroShareItemID: bigint | null
    attribute: number | null
  }

  export type ItemsMaxAggregateOutputType = {
    id: bigint | null
    inventoryid: number | null
    trunkid: number | null
    auctionHouseStatus: boolean | null
    itemid: number | null
    bagindex: number | null
    cashitemserialnumber: bigint | null
    dateexpire: Date | null
    invtype: number | null
    type: number | null
    iscash: boolean | null
    quantity: number | null
    expireonlogout: boolean | null
    owner: string | null
    obtainedonce: boolean | null
    zeroShareItemID: bigint | null
    attribute: number | null
  }

  export type ItemsCountAggregateOutputType = {
    id: number
    inventoryid: number
    trunkid: number
    auctionHouseStatus: number
    itemid: number
    bagindex: number
    cashitemserialnumber: number
    dateexpire: number
    invtype: number
    type: number
    iscash: number
    quantity: number
    expireonlogout: number
    owner: number
    obtainedonce: number
    zeroShareItemID: number
    attribute: number
    _all: number
  }


  export type ItemsAvgAggregateInputType = {
    id?: true
    inventoryid?: true
    trunkid?: true
    itemid?: true
    bagindex?: true
    cashitemserialnumber?: true
    invtype?: true
    type?: true
    quantity?: true
    zeroShareItemID?: true
    attribute?: true
  }

  export type ItemsSumAggregateInputType = {
    id?: true
    inventoryid?: true
    trunkid?: true
    itemid?: true
    bagindex?: true
    cashitemserialnumber?: true
    invtype?: true
    type?: true
    quantity?: true
    zeroShareItemID?: true
    attribute?: true
  }

  export type ItemsMinAggregateInputType = {
    id?: true
    inventoryid?: true
    trunkid?: true
    auctionHouseStatus?: true
    itemid?: true
    bagindex?: true
    cashitemserialnumber?: true
    dateexpire?: true
    invtype?: true
    type?: true
    iscash?: true
    quantity?: true
    expireonlogout?: true
    owner?: true
    obtainedonce?: true
    zeroShareItemID?: true
    attribute?: true
  }

  export type ItemsMaxAggregateInputType = {
    id?: true
    inventoryid?: true
    trunkid?: true
    auctionHouseStatus?: true
    itemid?: true
    bagindex?: true
    cashitemserialnumber?: true
    dateexpire?: true
    invtype?: true
    type?: true
    iscash?: true
    quantity?: true
    expireonlogout?: true
    owner?: true
    obtainedonce?: true
    zeroShareItemID?: true
    attribute?: true
  }

  export type ItemsCountAggregateInputType = {
    id?: true
    inventoryid?: true
    trunkid?: true
    auctionHouseStatus?: true
    itemid?: true
    bagindex?: true
    cashitemserialnumber?: true
    dateexpire?: true
    invtype?: true
    type?: true
    iscash?: true
    quantity?: true
    expireonlogout?: true
    owner?: true
    obtainedonce?: true
    zeroShareItemID?: true
    attribute?: true
    _all?: true
  }

  export type ItemsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which items to aggregate.
     */
    where?: itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of items to fetch.
     */
    orderBy?: itemsOrderByWithRelationInput | itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned items
    **/
    _count?: true | ItemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemsMaxAggregateInputType
  }

  export type GetItemsAggregateType<T extends ItemsAggregateArgs> = {
        [P in keyof T & keyof AggregateItems]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItems[P]>
      : GetScalarType<T[P], AggregateItems[P]>
  }




  export type itemsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: itemsWhereInput
    orderBy?: itemsOrderByWithAggregationInput | itemsOrderByWithAggregationInput[]
    by: ItemsScalarFieldEnum[] | ItemsScalarFieldEnum
    having?: itemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemsCountAggregateInputType | true
    _avg?: ItemsAvgAggregateInputType
    _sum?: ItemsSumAggregateInputType
    _min?: ItemsMinAggregateInputType
    _max?: ItemsMaxAggregateInputType
  }

  export type ItemsGroupByOutputType = {
    id: bigint
    inventoryid: number | null
    trunkid: number | null
    auctionHouseStatus: boolean | null
    itemid: number | null
    bagindex: number | null
    cashitemserialnumber: bigint | null
    dateexpire: Date | null
    invtype: number | null
    type: number | null
    iscash: boolean | null
    quantity: number | null
    expireonlogout: boolean | null
    owner: string | null
    obtainedonce: boolean | null
    zeroShareItemID: bigint
    attribute: number | null
    _count: ItemsCountAggregateOutputType | null
    _avg: ItemsAvgAggregateOutputType | null
    _sum: ItemsSumAggregateOutputType | null
    _min: ItemsMinAggregateOutputType | null
    _max: ItemsMaxAggregateOutputType | null
  }

  type GetItemsGroupByPayload<T extends itemsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemsGroupByOutputType[P]>
            : GetScalarType<T[P], ItemsGroupByOutputType[P]>
        }
      >
    >


  export type itemsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inventoryid?: boolean
    trunkid?: boolean
    auctionHouseStatus?: boolean
    itemid?: boolean
    bagindex?: boolean
    cashitemserialnumber?: boolean
    dateexpire?: boolean
    invtype?: boolean
    type?: boolean
    iscash?: boolean
    quantity?: boolean
    expireonlogout?: boolean
    owner?: boolean
    obtainedonce?: boolean
    zeroShareItemID?: boolean
    attribute?: boolean
  }, ExtArgs["result"]["items"]>


  export type itemsSelectScalar = {
    id?: boolean
    inventoryid?: boolean
    trunkid?: boolean
    auctionHouseStatus?: boolean
    itemid?: boolean
    bagindex?: boolean
    cashitemserialnumber?: boolean
    dateexpire?: boolean
    invtype?: boolean
    type?: boolean
    iscash?: boolean
    quantity?: boolean
    expireonlogout?: boolean
    owner?: boolean
    obtainedonce?: boolean
    zeroShareItemID?: boolean
    attribute?: boolean
  }


  export type $itemsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "items"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      inventoryid: number | null
      trunkid: number | null
      auctionHouseStatus: boolean | null
      itemid: number | null
      bagindex: number | null
      cashitemserialnumber: bigint | null
      dateexpire: Date | null
      invtype: number | null
      type: number | null
      iscash: boolean | null
      quantity: number | null
      expireonlogout: boolean | null
      owner: string | null
      obtainedonce: boolean | null
      zeroShareItemID: bigint
      attribute: number | null
    }, ExtArgs["result"]["items"]>
    composites: {}
  }

  type itemsGetPayload<S extends boolean | null | undefined | itemsDefaultArgs> = $Result.GetResult<Prisma.$itemsPayload, S>

  type itemsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<itemsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ItemsCountAggregateInputType | true
    }

  export interface itemsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['items'], meta: { name: 'items' } }
    /**
     * Find zero or one Items that matches the filter.
     * @param {itemsFindUniqueArgs} args - Arguments to find a Items
     * @example
     * // Get one Items
     * const items = await prisma.items.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends itemsFindUniqueArgs>(args: SelectSubset<T, itemsFindUniqueArgs<ExtArgs>>): Prisma__itemsClient<$Result.GetResult<Prisma.$itemsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Items that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {itemsFindUniqueOrThrowArgs} args - Arguments to find a Items
     * @example
     * // Get one Items
     * const items = await prisma.items.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends itemsFindUniqueOrThrowArgs>(args: SelectSubset<T, itemsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__itemsClient<$Result.GetResult<Prisma.$itemsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemsFindFirstArgs} args - Arguments to find a Items
     * @example
     * // Get one Items
     * const items = await prisma.items.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends itemsFindFirstArgs>(args?: SelectSubset<T, itemsFindFirstArgs<ExtArgs>>): Prisma__itemsClient<$Result.GetResult<Prisma.$itemsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Items that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemsFindFirstOrThrowArgs} args - Arguments to find a Items
     * @example
     * // Get one Items
     * const items = await prisma.items.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends itemsFindFirstOrThrowArgs>(args?: SelectSubset<T, itemsFindFirstOrThrowArgs<ExtArgs>>): Prisma__itemsClient<$Result.GetResult<Prisma.$itemsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Items
     * const items = await prisma.items.findMany()
     * 
     * // Get first 10 Items
     * const items = await prisma.items.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemsWithIdOnly = await prisma.items.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends itemsFindManyArgs>(args?: SelectSubset<T, itemsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$itemsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Items.
     * @param {itemsCreateArgs} args - Arguments to create a Items.
     * @example
     * // Create one Items
     * const Items = await prisma.items.create({
     *   data: {
     *     // ... data to create a Items
     *   }
     * })
     * 
     */
    create<T extends itemsCreateArgs>(args: SelectSubset<T, itemsCreateArgs<ExtArgs>>): Prisma__itemsClient<$Result.GetResult<Prisma.$itemsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Items.
     * @param {itemsCreateManyArgs} args - Arguments to create many Items.
     * @example
     * // Create many Items
     * const items = await prisma.items.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends itemsCreateManyArgs>(args?: SelectSubset<T, itemsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Items.
     * @param {itemsDeleteArgs} args - Arguments to delete one Items.
     * @example
     * // Delete one Items
     * const Items = await prisma.items.delete({
     *   where: {
     *     // ... filter to delete one Items
     *   }
     * })
     * 
     */
    delete<T extends itemsDeleteArgs>(args: SelectSubset<T, itemsDeleteArgs<ExtArgs>>): Prisma__itemsClient<$Result.GetResult<Prisma.$itemsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Items.
     * @param {itemsUpdateArgs} args - Arguments to update one Items.
     * @example
     * // Update one Items
     * const items = await prisma.items.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends itemsUpdateArgs>(args: SelectSubset<T, itemsUpdateArgs<ExtArgs>>): Prisma__itemsClient<$Result.GetResult<Prisma.$itemsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Items.
     * @param {itemsDeleteManyArgs} args - Arguments to filter Items to delete.
     * @example
     * // Delete a few Items
     * const { count } = await prisma.items.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends itemsDeleteManyArgs>(args?: SelectSubset<T, itemsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Items
     * const items = await prisma.items.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends itemsUpdateManyArgs>(args: SelectSubset<T, itemsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Items.
     * @param {itemsUpsertArgs} args - Arguments to update or create a Items.
     * @example
     * // Update or create a Items
     * const items = await prisma.items.upsert({
     *   create: {
     *     // ... data to create a Items
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Items we want to update
     *   }
     * })
     */
    upsert<T extends itemsUpsertArgs>(args: SelectSubset<T, itemsUpsertArgs<ExtArgs>>): Prisma__itemsClient<$Result.GetResult<Prisma.$itemsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemsCountArgs} args - Arguments to filter Items to count.
     * @example
     * // Count the number of Items
     * const count = await prisma.items.count({
     *   where: {
     *     // ... the filter for the Items we want to count
     *   }
     * })
    **/
    count<T extends itemsCountArgs>(
      args?: Subset<T, itemsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemsAggregateArgs>(args: Subset<T, ItemsAggregateArgs>): Prisma.PrismaPromise<GetItemsAggregateType<T>>

    /**
     * Group by Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends itemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: itemsGroupByArgs['orderBy'] }
        : { orderBy?: itemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, itemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the items model
   */
  readonly fields: itemsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for items.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__itemsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the items model
   */ 
  interface itemsFieldRefs {
    readonly id: FieldRef<"items", 'BigInt'>
    readonly inventoryid: FieldRef<"items", 'Int'>
    readonly trunkid: FieldRef<"items", 'Int'>
    readonly auctionHouseStatus: FieldRef<"items", 'Boolean'>
    readonly itemid: FieldRef<"items", 'Int'>
    readonly bagindex: FieldRef<"items", 'Int'>
    readonly cashitemserialnumber: FieldRef<"items", 'BigInt'>
    readonly dateexpire: FieldRef<"items", 'DateTime'>
    readonly invtype: FieldRef<"items", 'Int'>
    readonly type: FieldRef<"items", 'Int'>
    readonly iscash: FieldRef<"items", 'Boolean'>
    readonly quantity: FieldRef<"items", 'Int'>
    readonly expireonlogout: FieldRef<"items", 'Boolean'>
    readonly owner: FieldRef<"items", 'String'>
    readonly obtainedonce: FieldRef<"items", 'Boolean'>
    readonly zeroShareItemID: FieldRef<"items", 'BigInt'>
    readonly attribute: FieldRef<"items", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * items findUnique
   */
  export type itemsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect<ExtArgs> | null
    /**
     * Filter, which items to fetch.
     */
    where: itemsWhereUniqueInput
  }

  /**
   * items findUniqueOrThrow
   */
  export type itemsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect<ExtArgs> | null
    /**
     * Filter, which items to fetch.
     */
    where: itemsWhereUniqueInput
  }

  /**
   * items findFirst
   */
  export type itemsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect<ExtArgs> | null
    /**
     * Filter, which items to fetch.
     */
    where?: itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of items to fetch.
     */
    orderBy?: itemsOrderByWithRelationInput | itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for items.
     */
    cursor?: itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of items.
     */
    distinct?: ItemsScalarFieldEnum | ItemsScalarFieldEnum[]
  }

  /**
   * items findFirstOrThrow
   */
  export type itemsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect<ExtArgs> | null
    /**
     * Filter, which items to fetch.
     */
    where?: itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of items to fetch.
     */
    orderBy?: itemsOrderByWithRelationInput | itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for items.
     */
    cursor?: itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of items.
     */
    distinct?: ItemsScalarFieldEnum | ItemsScalarFieldEnum[]
  }

  /**
   * items findMany
   */
  export type itemsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect<ExtArgs> | null
    /**
     * Filter, which items to fetch.
     */
    where?: itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of items to fetch.
     */
    orderBy?: itemsOrderByWithRelationInput | itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing items.
     */
    cursor?: itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` items.
     */
    skip?: number
    distinct?: ItemsScalarFieldEnum | ItemsScalarFieldEnum[]
  }

  /**
   * items create
   */
  export type itemsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect<ExtArgs> | null
    /**
     * The data needed to create a items.
     */
    data?: XOR<itemsCreateInput, itemsUncheckedCreateInput>
  }

  /**
   * items createMany
   */
  export type itemsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many items.
     */
    data: itemsCreateManyInput | itemsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * items update
   */
  export type itemsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect<ExtArgs> | null
    /**
     * The data needed to update a items.
     */
    data: XOR<itemsUpdateInput, itemsUncheckedUpdateInput>
    /**
     * Choose, which items to update.
     */
    where: itemsWhereUniqueInput
  }

  /**
   * items updateMany
   */
  export type itemsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update items.
     */
    data: XOR<itemsUpdateManyMutationInput, itemsUncheckedUpdateManyInput>
    /**
     * Filter which items to update
     */
    where?: itemsWhereInput
  }

  /**
   * items upsert
   */
  export type itemsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect<ExtArgs> | null
    /**
     * The filter to search for the items to update in case it exists.
     */
    where: itemsWhereUniqueInput
    /**
     * In case the items found by the `where` argument doesn't exist, create a new items with this data.
     */
    create: XOR<itemsCreateInput, itemsUncheckedCreateInput>
    /**
     * In case the items was found with the provided `where` argument, update it with this data.
     */
    update: XOR<itemsUpdateInput, itemsUncheckedUpdateInput>
  }

  /**
   * items delete
   */
  export type itemsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect<ExtArgs> | null
    /**
     * Filter which items to delete.
     */
    where: itemsWhereUniqueInput
  }

  /**
   * items deleteMany
   */
  export type itemsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which items to delete
     */
    where?: itemsWhereInput
  }

  /**
   * items without action
   */
  export type itemsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect<ExtArgs> | null
  }


  /**
   * Model itemsbuylimit
   */

  export type AggregateItemsbuylimit = {
    _count: ItemsbuylimitCountAggregateOutputType | null
    _avg: ItemsbuylimitAvgAggregateOutputType | null
    _sum: ItemsbuylimitSumAggregateOutputType | null
    _min: ItemsbuylimitMinAggregateOutputType | null
    _max: ItemsbuylimitMaxAggregateOutputType | null
  }

  export type ItemsbuylimitAvgAggregateOutputType = {
    id: number | null
    shopitemid: number | null
    charid: number | null
    amountbought: number | null
  }

  export type ItemsbuylimitSumAggregateOutputType = {
    id: number | null
    shopitemid: bigint | null
    charid: number | null
    amountbought: number | null
  }

  export type ItemsbuylimitMinAggregateOutputType = {
    id: number | null
    shopitemid: bigint | null
    charid: number | null
    amountbought: number | null
  }

  export type ItemsbuylimitMaxAggregateOutputType = {
    id: number | null
    shopitemid: bigint | null
    charid: number | null
    amountbought: number | null
  }

  export type ItemsbuylimitCountAggregateOutputType = {
    id: number
    shopitemid: number
    charid: number
    amountbought: number
    _all: number
  }


  export type ItemsbuylimitAvgAggregateInputType = {
    id?: true
    shopitemid?: true
    charid?: true
    amountbought?: true
  }

  export type ItemsbuylimitSumAggregateInputType = {
    id?: true
    shopitemid?: true
    charid?: true
    amountbought?: true
  }

  export type ItemsbuylimitMinAggregateInputType = {
    id?: true
    shopitemid?: true
    charid?: true
    amountbought?: true
  }

  export type ItemsbuylimitMaxAggregateInputType = {
    id?: true
    shopitemid?: true
    charid?: true
    amountbought?: true
  }

  export type ItemsbuylimitCountAggregateInputType = {
    id?: true
    shopitemid?: true
    charid?: true
    amountbought?: true
    _all?: true
  }

  export type ItemsbuylimitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which itemsbuylimit to aggregate.
     */
    where?: itemsbuylimitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of itemsbuylimits to fetch.
     */
    orderBy?: itemsbuylimitOrderByWithRelationInput | itemsbuylimitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: itemsbuylimitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` itemsbuylimits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` itemsbuylimits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned itemsbuylimits
    **/
    _count?: true | ItemsbuylimitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemsbuylimitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemsbuylimitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemsbuylimitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemsbuylimitMaxAggregateInputType
  }

  export type GetItemsbuylimitAggregateType<T extends ItemsbuylimitAggregateArgs> = {
        [P in keyof T & keyof AggregateItemsbuylimit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItemsbuylimit[P]>
      : GetScalarType<T[P], AggregateItemsbuylimit[P]>
  }




  export type itemsbuylimitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: itemsbuylimitWhereInput
    orderBy?: itemsbuylimitOrderByWithAggregationInput | itemsbuylimitOrderByWithAggregationInput[]
    by: ItemsbuylimitScalarFieldEnum[] | ItemsbuylimitScalarFieldEnum
    having?: itemsbuylimitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemsbuylimitCountAggregateInputType | true
    _avg?: ItemsbuylimitAvgAggregateInputType
    _sum?: ItemsbuylimitSumAggregateInputType
    _min?: ItemsbuylimitMinAggregateInputType
    _max?: ItemsbuylimitMaxAggregateInputType
  }

  export type ItemsbuylimitGroupByOutputType = {
    id: number
    shopitemid: bigint | null
    charid: number | null
    amountbought: number | null
    _count: ItemsbuylimitCountAggregateOutputType | null
    _avg: ItemsbuylimitAvgAggregateOutputType | null
    _sum: ItemsbuylimitSumAggregateOutputType | null
    _min: ItemsbuylimitMinAggregateOutputType | null
    _max: ItemsbuylimitMaxAggregateOutputType | null
  }

  type GetItemsbuylimitGroupByPayload<T extends itemsbuylimitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemsbuylimitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemsbuylimitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemsbuylimitGroupByOutputType[P]>
            : GetScalarType<T[P], ItemsbuylimitGroupByOutputType[P]>
        }
      >
    >


  export type itemsbuylimitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shopitemid?: boolean
    charid?: boolean
    amountbought?: boolean
  }, ExtArgs["result"]["itemsbuylimit"]>


  export type itemsbuylimitSelectScalar = {
    id?: boolean
    shopitemid?: boolean
    charid?: boolean
    amountbought?: boolean
  }


  export type $itemsbuylimitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "itemsbuylimit"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      shopitemid: bigint | null
      charid: number | null
      amountbought: number | null
    }, ExtArgs["result"]["itemsbuylimit"]>
    composites: {}
  }

  type itemsbuylimitGetPayload<S extends boolean | null | undefined | itemsbuylimitDefaultArgs> = $Result.GetResult<Prisma.$itemsbuylimitPayload, S>

  type itemsbuylimitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<itemsbuylimitFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ItemsbuylimitCountAggregateInputType | true
    }

  export interface itemsbuylimitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['itemsbuylimit'], meta: { name: 'itemsbuylimit' } }
    /**
     * Find zero or one Itemsbuylimit that matches the filter.
     * @param {itemsbuylimitFindUniqueArgs} args - Arguments to find a Itemsbuylimit
     * @example
     * // Get one Itemsbuylimit
     * const itemsbuylimit = await prisma.itemsbuylimit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends itemsbuylimitFindUniqueArgs>(args: SelectSubset<T, itemsbuylimitFindUniqueArgs<ExtArgs>>): Prisma__itemsbuylimitClient<$Result.GetResult<Prisma.$itemsbuylimitPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Itemsbuylimit that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {itemsbuylimitFindUniqueOrThrowArgs} args - Arguments to find a Itemsbuylimit
     * @example
     * // Get one Itemsbuylimit
     * const itemsbuylimit = await prisma.itemsbuylimit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends itemsbuylimitFindUniqueOrThrowArgs>(args: SelectSubset<T, itemsbuylimitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__itemsbuylimitClient<$Result.GetResult<Prisma.$itemsbuylimitPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Itemsbuylimit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemsbuylimitFindFirstArgs} args - Arguments to find a Itemsbuylimit
     * @example
     * // Get one Itemsbuylimit
     * const itemsbuylimit = await prisma.itemsbuylimit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends itemsbuylimitFindFirstArgs>(args?: SelectSubset<T, itemsbuylimitFindFirstArgs<ExtArgs>>): Prisma__itemsbuylimitClient<$Result.GetResult<Prisma.$itemsbuylimitPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Itemsbuylimit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemsbuylimitFindFirstOrThrowArgs} args - Arguments to find a Itemsbuylimit
     * @example
     * // Get one Itemsbuylimit
     * const itemsbuylimit = await prisma.itemsbuylimit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends itemsbuylimitFindFirstOrThrowArgs>(args?: SelectSubset<T, itemsbuylimitFindFirstOrThrowArgs<ExtArgs>>): Prisma__itemsbuylimitClient<$Result.GetResult<Prisma.$itemsbuylimitPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Itemsbuylimits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemsbuylimitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Itemsbuylimits
     * const itemsbuylimits = await prisma.itemsbuylimit.findMany()
     * 
     * // Get first 10 Itemsbuylimits
     * const itemsbuylimits = await prisma.itemsbuylimit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemsbuylimitWithIdOnly = await prisma.itemsbuylimit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends itemsbuylimitFindManyArgs>(args?: SelectSubset<T, itemsbuylimitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$itemsbuylimitPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Itemsbuylimit.
     * @param {itemsbuylimitCreateArgs} args - Arguments to create a Itemsbuylimit.
     * @example
     * // Create one Itemsbuylimit
     * const Itemsbuylimit = await prisma.itemsbuylimit.create({
     *   data: {
     *     // ... data to create a Itemsbuylimit
     *   }
     * })
     * 
     */
    create<T extends itemsbuylimitCreateArgs>(args: SelectSubset<T, itemsbuylimitCreateArgs<ExtArgs>>): Prisma__itemsbuylimitClient<$Result.GetResult<Prisma.$itemsbuylimitPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Itemsbuylimits.
     * @param {itemsbuylimitCreateManyArgs} args - Arguments to create many Itemsbuylimits.
     * @example
     * // Create many Itemsbuylimits
     * const itemsbuylimit = await prisma.itemsbuylimit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends itemsbuylimitCreateManyArgs>(args?: SelectSubset<T, itemsbuylimitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Itemsbuylimit.
     * @param {itemsbuylimitDeleteArgs} args - Arguments to delete one Itemsbuylimit.
     * @example
     * // Delete one Itemsbuylimit
     * const Itemsbuylimit = await prisma.itemsbuylimit.delete({
     *   where: {
     *     // ... filter to delete one Itemsbuylimit
     *   }
     * })
     * 
     */
    delete<T extends itemsbuylimitDeleteArgs>(args: SelectSubset<T, itemsbuylimitDeleteArgs<ExtArgs>>): Prisma__itemsbuylimitClient<$Result.GetResult<Prisma.$itemsbuylimitPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Itemsbuylimit.
     * @param {itemsbuylimitUpdateArgs} args - Arguments to update one Itemsbuylimit.
     * @example
     * // Update one Itemsbuylimit
     * const itemsbuylimit = await prisma.itemsbuylimit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends itemsbuylimitUpdateArgs>(args: SelectSubset<T, itemsbuylimitUpdateArgs<ExtArgs>>): Prisma__itemsbuylimitClient<$Result.GetResult<Prisma.$itemsbuylimitPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Itemsbuylimits.
     * @param {itemsbuylimitDeleteManyArgs} args - Arguments to filter Itemsbuylimits to delete.
     * @example
     * // Delete a few Itemsbuylimits
     * const { count } = await prisma.itemsbuylimit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends itemsbuylimitDeleteManyArgs>(args?: SelectSubset<T, itemsbuylimitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Itemsbuylimits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemsbuylimitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Itemsbuylimits
     * const itemsbuylimit = await prisma.itemsbuylimit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends itemsbuylimitUpdateManyArgs>(args: SelectSubset<T, itemsbuylimitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Itemsbuylimit.
     * @param {itemsbuylimitUpsertArgs} args - Arguments to update or create a Itemsbuylimit.
     * @example
     * // Update or create a Itemsbuylimit
     * const itemsbuylimit = await prisma.itemsbuylimit.upsert({
     *   create: {
     *     // ... data to create a Itemsbuylimit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Itemsbuylimit we want to update
     *   }
     * })
     */
    upsert<T extends itemsbuylimitUpsertArgs>(args: SelectSubset<T, itemsbuylimitUpsertArgs<ExtArgs>>): Prisma__itemsbuylimitClient<$Result.GetResult<Prisma.$itemsbuylimitPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Itemsbuylimits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemsbuylimitCountArgs} args - Arguments to filter Itemsbuylimits to count.
     * @example
     * // Count the number of Itemsbuylimits
     * const count = await prisma.itemsbuylimit.count({
     *   where: {
     *     // ... the filter for the Itemsbuylimits we want to count
     *   }
     * })
    **/
    count<T extends itemsbuylimitCountArgs>(
      args?: Subset<T, itemsbuylimitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemsbuylimitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Itemsbuylimit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemsbuylimitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemsbuylimitAggregateArgs>(args: Subset<T, ItemsbuylimitAggregateArgs>): Prisma.PrismaPromise<GetItemsbuylimitAggregateType<T>>

    /**
     * Group by Itemsbuylimit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemsbuylimitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends itemsbuylimitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: itemsbuylimitGroupByArgs['orderBy'] }
        : { orderBy?: itemsbuylimitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, itemsbuylimitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemsbuylimitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the itemsbuylimit model
   */
  readonly fields: itemsbuylimitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for itemsbuylimit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__itemsbuylimitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the itemsbuylimit model
   */ 
  interface itemsbuylimitFieldRefs {
    readonly id: FieldRef<"itemsbuylimit", 'Int'>
    readonly shopitemid: FieldRef<"itemsbuylimit", 'BigInt'>
    readonly charid: FieldRef<"itemsbuylimit", 'Int'>
    readonly amountbought: FieldRef<"itemsbuylimit", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * itemsbuylimit findUnique
   */
  export type itemsbuylimitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itemsbuylimit
     */
    select?: itemsbuylimitSelect<ExtArgs> | null
    /**
     * Filter, which itemsbuylimit to fetch.
     */
    where: itemsbuylimitWhereUniqueInput
  }

  /**
   * itemsbuylimit findUniqueOrThrow
   */
  export type itemsbuylimitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itemsbuylimit
     */
    select?: itemsbuylimitSelect<ExtArgs> | null
    /**
     * Filter, which itemsbuylimit to fetch.
     */
    where: itemsbuylimitWhereUniqueInput
  }

  /**
   * itemsbuylimit findFirst
   */
  export type itemsbuylimitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itemsbuylimit
     */
    select?: itemsbuylimitSelect<ExtArgs> | null
    /**
     * Filter, which itemsbuylimit to fetch.
     */
    where?: itemsbuylimitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of itemsbuylimits to fetch.
     */
    orderBy?: itemsbuylimitOrderByWithRelationInput | itemsbuylimitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for itemsbuylimits.
     */
    cursor?: itemsbuylimitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` itemsbuylimits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` itemsbuylimits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of itemsbuylimits.
     */
    distinct?: ItemsbuylimitScalarFieldEnum | ItemsbuylimitScalarFieldEnum[]
  }

  /**
   * itemsbuylimit findFirstOrThrow
   */
  export type itemsbuylimitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itemsbuylimit
     */
    select?: itemsbuylimitSelect<ExtArgs> | null
    /**
     * Filter, which itemsbuylimit to fetch.
     */
    where?: itemsbuylimitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of itemsbuylimits to fetch.
     */
    orderBy?: itemsbuylimitOrderByWithRelationInput | itemsbuylimitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for itemsbuylimits.
     */
    cursor?: itemsbuylimitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` itemsbuylimits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` itemsbuylimits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of itemsbuylimits.
     */
    distinct?: ItemsbuylimitScalarFieldEnum | ItemsbuylimitScalarFieldEnum[]
  }

  /**
   * itemsbuylimit findMany
   */
  export type itemsbuylimitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itemsbuylimit
     */
    select?: itemsbuylimitSelect<ExtArgs> | null
    /**
     * Filter, which itemsbuylimits to fetch.
     */
    where?: itemsbuylimitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of itemsbuylimits to fetch.
     */
    orderBy?: itemsbuylimitOrderByWithRelationInput | itemsbuylimitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing itemsbuylimits.
     */
    cursor?: itemsbuylimitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` itemsbuylimits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` itemsbuylimits.
     */
    skip?: number
    distinct?: ItemsbuylimitScalarFieldEnum | ItemsbuylimitScalarFieldEnum[]
  }

  /**
   * itemsbuylimit create
   */
  export type itemsbuylimitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itemsbuylimit
     */
    select?: itemsbuylimitSelect<ExtArgs> | null
    /**
     * The data needed to create a itemsbuylimit.
     */
    data?: XOR<itemsbuylimitCreateInput, itemsbuylimitUncheckedCreateInput>
  }

  /**
   * itemsbuylimit createMany
   */
  export type itemsbuylimitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many itemsbuylimits.
     */
    data: itemsbuylimitCreateManyInput | itemsbuylimitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * itemsbuylimit update
   */
  export type itemsbuylimitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itemsbuylimit
     */
    select?: itemsbuylimitSelect<ExtArgs> | null
    /**
     * The data needed to update a itemsbuylimit.
     */
    data: XOR<itemsbuylimitUpdateInput, itemsbuylimitUncheckedUpdateInput>
    /**
     * Choose, which itemsbuylimit to update.
     */
    where: itemsbuylimitWhereUniqueInput
  }

  /**
   * itemsbuylimit updateMany
   */
  export type itemsbuylimitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update itemsbuylimits.
     */
    data: XOR<itemsbuylimitUpdateManyMutationInput, itemsbuylimitUncheckedUpdateManyInput>
    /**
     * Filter which itemsbuylimits to update
     */
    where?: itemsbuylimitWhereInput
  }

  /**
   * itemsbuylimit upsert
   */
  export type itemsbuylimitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itemsbuylimit
     */
    select?: itemsbuylimitSelect<ExtArgs> | null
    /**
     * The filter to search for the itemsbuylimit to update in case it exists.
     */
    where: itemsbuylimitWhereUniqueInput
    /**
     * In case the itemsbuylimit found by the `where` argument doesn't exist, create a new itemsbuylimit with this data.
     */
    create: XOR<itemsbuylimitCreateInput, itemsbuylimitUncheckedCreateInput>
    /**
     * In case the itemsbuylimit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<itemsbuylimitUpdateInput, itemsbuylimitUncheckedUpdateInput>
  }

  /**
   * itemsbuylimit delete
   */
  export type itemsbuylimitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itemsbuylimit
     */
    select?: itemsbuylimitSelect<ExtArgs> | null
    /**
     * Filter which itemsbuylimit to delete.
     */
    where: itemsbuylimitWhereUniqueInput
  }

  /**
   * itemsbuylimit deleteMany
   */
  export type itemsbuylimitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which itemsbuylimits to delete
     */
    where?: itemsbuylimitWhereInput
  }

  /**
   * itemsbuylimit without action
   */
  export type itemsbuylimitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itemsbuylimit
     */
    select?: itemsbuylimitSelect<ExtArgs> | null
  }


  /**
   * Model keymaps
   */

  export type AggregateKeymaps = {
    _count: KeymapsCountAggregateOutputType | null
    _avg: KeymapsAvgAggregateOutputType | null
    _sum: KeymapsSumAggregateOutputType | null
    _min: KeymapsMinAggregateOutputType | null
    _max: KeymapsMaxAggregateOutputType | null
  }

  export type KeymapsAvgAggregateOutputType = {
    id: number | null
    fkmapid: number | null
    idx: number | null
    type: number | null
    val: number | null
  }

  export type KeymapsSumAggregateOutputType = {
    id: number | null
    fkmapid: number | null
    idx: number | null
    type: number | null
    val: number | null
  }

  export type KeymapsMinAggregateOutputType = {
    id: number | null
    fkmapid: number | null
    idx: number | null
    type: number | null
    val: number | null
  }

  export type KeymapsMaxAggregateOutputType = {
    id: number | null
    fkmapid: number | null
    idx: number | null
    type: number | null
    val: number | null
  }

  export type KeymapsCountAggregateOutputType = {
    id: number
    fkmapid: number
    idx: number
    type: number
    val: number
    _all: number
  }


  export type KeymapsAvgAggregateInputType = {
    id?: true
    fkmapid?: true
    idx?: true
    type?: true
    val?: true
  }

  export type KeymapsSumAggregateInputType = {
    id?: true
    fkmapid?: true
    idx?: true
    type?: true
    val?: true
  }

  export type KeymapsMinAggregateInputType = {
    id?: true
    fkmapid?: true
    idx?: true
    type?: true
    val?: true
  }

  export type KeymapsMaxAggregateInputType = {
    id?: true
    fkmapid?: true
    idx?: true
    type?: true
    val?: true
  }

  export type KeymapsCountAggregateInputType = {
    id?: true
    fkmapid?: true
    idx?: true
    type?: true
    val?: true
    _all?: true
  }

  export type KeymapsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which keymaps to aggregate.
     */
    where?: keymapsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of keymaps to fetch.
     */
    orderBy?: keymapsOrderByWithRelationInput | keymapsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: keymapsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` keymaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` keymaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned keymaps
    **/
    _count?: true | KeymapsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KeymapsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KeymapsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KeymapsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KeymapsMaxAggregateInputType
  }

  export type GetKeymapsAggregateType<T extends KeymapsAggregateArgs> = {
        [P in keyof T & keyof AggregateKeymaps]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKeymaps[P]>
      : GetScalarType<T[P], AggregateKeymaps[P]>
  }




  export type keymapsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: keymapsWhereInput
    orderBy?: keymapsOrderByWithAggregationInput | keymapsOrderByWithAggregationInput[]
    by: KeymapsScalarFieldEnum[] | KeymapsScalarFieldEnum
    having?: keymapsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KeymapsCountAggregateInputType | true
    _avg?: KeymapsAvgAggregateInputType
    _sum?: KeymapsSumAggregateInputType
    _min?: KeymapsMinAggregateInputType
    _max?: KeymapsMaxAggregateInputType
  }

  export type KeymapsGroupByOutputType = {
    id: number
    fkmapid: number | null
    idx: number | null
    type: number | null
    val: number | null
    _count: KeymapsCountAggregateOutputType | null
    _avg: KeymapsAvgAggregateOutputType | null
    _sum: KeymapsSumAggregateOutputType | null
    _min: KeymapsMinAggregateOutputType | null
    _max: KeymapsMaxAggregateOutputType | null
  }

  type GetKeymapsGroupByPayload<T extends keymapsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KeymapsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KeymapsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KeymapsGroupByOutputType[P]>
            : GetScalarType<T[P], KeymapsGroupByOutputType[P]>
        }
      >
    >


  export type keymapsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fkmapid?: boolean
    idx?: boolean
    type?: boolean
    val?: boolean
  }, ExtArgs["result"]["keymaps"]>


  export type keymapsSelectScalar = {
    id?: boolean
    fkmapid?: boolean
    idx?: boolean
    type?: boolean
    val?: boolean
  }


  export type $keymapsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "keymaps"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      fkmapid: number | null
      idx: number | null
      type: number | null
      val: number | null
    }, ExtArgs["result"]["keymaps"]>
    composites: {}
  }

  type keymapsGetPayload<S extends boolean | null | undefined | keymapsDefaultArgs> = $Result.GetResult<Prisma.$keymapsPayload, S>

  type keymapsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<keymapsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: KeymapsCountAggregateInputType | true
    }

  export interface keymapsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['keymaps'], meta: { name: 'keymaps' } }
    /**
     * Find zero or one Keymaps that matches the filter.
     * @param {keymapsFindUniqueArgs} args - Arguments to find a Keymaps
     * @example
     * // Get one Keymaps
     * const keymaps = await prisma.keymaps.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends keymapsFindUniqueArgs>(args: SelectSubset<T, keymapsFindUniqueArgs<ExtArgs>>): Prisma__keymapsClient<$Result.GetResult<Prisma.$keymapsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Keymaps that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {keymapsFindUniqueOrThrowArgs} args - Arguments to find a Keymaps
     * @example
     * // Get one Keymaps
     * const keymaps = await prisma.keymaps.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends keymapsFindUniqueOrThrowArgs>(args: SelectSubset<T, keymapsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__keymapsClient<$Result.GetResult<Prisma.$keymapsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Keymaps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {keymapsFindFirstArgs} args - Arguments to find a Keymaps
     * @example
     * // Get one Keymaps
     * const keymaps = await prisma.keymaps.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends keymapsFindFirstArgs>(args?: SelectSubset<T, keymapsFindFirstArgs<ExtArgs>>): Prisma__keymapsClient<$Result.GetResult<Prisma.$keymapsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Keymaps that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {keymapsFindFirstOrThrowArgs} args - Arguments to find a Keymaps
     * @example
     * // Get one Keymaps
     * const keymaps = await prisma.keymaps.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends keymapsFindFirstOrThrowArgs>(args?: SelectSubset<T, keymapsFindFirstOrThrowArgs<ExtArgs>>): Prisma__keymapsClient<$Result.GetResult<Prisma.$keymapsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Keymaps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {keymapsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Keymaps
     * const keymaps = await prisma.keymaps.findMany()
     * 
     * // Get first 10 Keymaps
     * const keymaps = await prisma.keymaps.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const keymapsWithIdOnly = await prisma.keymaps.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends keymapsFindManyArgs>(args?: SelectSubset<T, keymapsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$keymapsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Keymaps.
     * @param {keymapsCreateArgs} args - Arguments to create a Keymaps.
     * @example
     * // Create one Keymaps
     * const Keymaps = await prisma.keymaps.create({
     *   data: {
     *     // ... data to create a Keymaps
     *   }
     * })
     * 
     */
    create<T extends keymapsCreateArgs>(args: SelectSubset<T, keymapsCreateArgs<ExtArgs>>): Prisma__keymapsClient<$Result.GetResult<Prisma.$keymapsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Keymaps.
     * @param {keymapsCreateManyArgs} args - Arguments to create many Keymaps.
     * @example
     * // Create many Keymaps
     * const keymaps = await prisma.keymaps.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends keymapsCreateManyArgs>(args?: SelectSubset<T, keymapsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Keymaps.
     * @param {keymapsDeleteArgs} args - Arguments to delete one Keymaps.
     * @example
     * // Delete one Keymaps
     * const Keymaps = await prisma.keymaps.delete({
     *   where: {
     *     // ... filter to delete one Keymaps
     *   }
     * })
     * 
     */
    delete<T extends keymapsDeleteArgs>(args: SelectSubset<T, keymapsDeleteArgs<ExtArgs>>): Prisma__keymapsClient<$Result.GetResult<Prisma.$keymapsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Keymaps.
     * @param {keymapsUpdateArgs} args - Arguments to update one Keymaps.
     * @example
     * // Update one Keymaps
     * const keymaps = await prisma.keymaps.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends keymapsUpdateArgs>(args: SelectSubset<T, keymapsUpdateArgs<ExtArgs>>): Prisma__keymapsClient<$Result.GetResult<Prisma.$keymapsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Keymaps.
     * @param {keymapsDeleteManyArgs} args - Arguments to filter Keymaps to delete.
     * @example
     * // Delete a few Keymaps
     * const { count } = await prisma.keymaps.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends keymapsDeleteManyArgs>(args?: SelectSubset<T, keymapsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Keymaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {keymapsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Keymaps
     * const keymaps = await prisma.keymaps.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends keymapsUpdateManyArgs>(args: SelectSubset<T, keymapsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Keymaps.
     * @param {keymapsUpsertArgs} args - Arguments to update or create a Keymaps.
     * @example
     * // Update or create a Keymaps
     * const keymaps = await prisma.keymaps.upsert({
     *   create: {
     *     // ... data to create a Keymaps
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Keymaps we want to update
     *   }
     * })
     */
    upsert<T extends keymapsUpsertArgs>(args: SelectSubset<T, keymapsUpsertArgs<ExtArgs>>): Prisma__keymapsClient<$Result.GetResult<Prisma.$keymapsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Keymaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {keymapsCountArgs} args - Arguments to filter Keymaps to count.
     * @example
     * // Count the number of Keymaps
     * const count = await prisma.keymaps.count({
     *   where: {
     *     // ... the filter for the Keymaps we want to count
     *   }
     * })
    **/
    count<T extends keymapsCountArgs>(
      args?: Subset<T, keymapsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KeymapsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Keymaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeymapsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KeymapsAggregateArgs>(args: Subset<T, KeymapsAggregateArgs>): Prisma.PrismaPromise<GetKeymapsAggregateType<T>>

    /**
     * Group by Keymaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {keymapsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends keymapsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: keymapsGroupByArgs['orderBy'] }
        : { orderBy?: keymapsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, keymapsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKeymapsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the keymaps model
   */
  readonly fields: keymapsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for keymaps.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__keymapsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the keymaps model
   */ 
  interface keymapsFieldRefs {
    readonly id: FieldRef<"keymaps", 'Int'>
    readonly fkmapid: FieldRef<"keymaps", 'Int'>
    readonly idx: FieldRef<"keymaps", 'Int'>
    readonly type: FieldRef<"keymaps", 'Int'>
    readonly val: FieldRef<"keymaps", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * keymaps findUnique
   */
  export type keymapsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the keymaps
     */
    select?: keymapsSelect<ExtArgs> | null
    /**
     * Filter, which keymaps to fetch.
     */
    where: keymapsWhereUniqueInput
  }

  /**
   * keymaps findUniqueOrThrow
   */
  export type keymapsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the keymaps
     */
    select?: keymapsSelect<ExtArgs> | null
    /**
     * Filter, which keymaps to fetch.
     */
    where: keymapsWhereUniqueInput
  }

  /**
   * keymaps findFirst
   */
  export type keymapsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the keymaps
     */
    select?: keymapsSelect<ExtArgs> | null
    /**
     * Filter, which keymaps to fetch.
     */
    where?: keymapsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of keymaps to fetch.
     */
    orderBy?: keymapsOrderByWithRelationInput | keymapsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for keymaps.
     */
    cursor?: keymapsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` keymaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` keymaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of keymaps.
     */
    distinct?: KeymapsScalarFieldEnum | KeymapsScalarFieldEnum[]
  }

  /**
   * keymaps findFirstOrThrow
   */
  export type keymapsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the keymaps
     */
    select?: keymapsSelect<ExtArgs> | null
    /**
     * Filter, which keymaps to fetch.
     */
    where?: keymapsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of keymaps to fetch.
     */
    orderBy?: keymapsOrderByWithRelationInput | keymapsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for keymaps.
     */
    cursor?: keymapsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` keymaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` keymaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of keymaps.
     */
    distinct?: KeymapsScalarFieldEnum | KeymapsScalarFieldEnum[]
  }

  /**
   * keymaps findMany
   */
  export type keymapsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the keymaps
     */
    select?: keymapsSelect<ExtArgs> | null
    /**
     * Filter, which keymaps to fetch.
     */
    where?: keymapsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of keymaps to fetch.
     */
    orderBy?: keymapsOrderByWithRelationInput | keymapsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing keymaps.
     */
    cursor?: keymapsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` keymaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` keymaps.
     */
    skip?: number
    distinct?: KeymapsScalarFieldEnum | KeymapsScalarFieldEnum[]
  }

  /**
   * keymaps create
   */
  export type keymapsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the keymaps
     */
    select?: keymapsSelect<ExtArgs> | null
    /**
     * The data needed to create a keymaps.
     */
    data?: XOR<keymapsCreateInput, keymapsUncheckedCreateInput>
  }

  /**
   * keymaps createMany
   */
  export type keymapsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many keymaps.
     */
    data: keymapsCreateManyInput | keymapsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * keymaps update
   */
  export type keymapsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the keymaps
     */
    select?: keymapsSelect<ExtArgs> | null
    /**
     * The data needed to update a keymaps.
     */
    data: XOR<keymapsUpdateInput, keymapsUncheckedUpdateInput>
    /**
     * Choose, which keymaps to update.
     */
    where: keymapsWhereUniqueInput
  }

  /**
   * keymaps updateMany
   */
  export type keymapsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update keymaps.
     */
    data: XOR<keymapsUpdateManyMutationInput, keymapsUncheckedUpdateManyInput>
    /**
     * Filter which keymaps to update
     */
    where?: keymapsWhereInput
  }

  /**
   * keymaps upsert
   */
  export type keymapsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the keymaps
     */
    select?: keymapsSelect<ExtArgs> | null
    /**
     * The filter to search for the keymaps to update in case it exists.
     */
    where: keymapsWhereUniqueInput
    /**
     * In case the keymaps found by the `where` argument doesn't exist, create a new keymaps with this data.
     */
    create: XOR<keymapsCreateInput, keymapsUncheckedCreateInput>
    /**
     * In case the keymaps was found with the provided `where` argument, update it with this data.
     */
    update: XOR<keymapsUpdateInput, keymapsUncheckedUpdateInput>
  }

  /**
   * keymaps delete
   */
  export type keymapsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the keymaps
     */
    select?: keymapsSelect<ExtArgs> | null
    /**
     * Filter which keymaps to delete.
     */
    where: keymapsWhereUniqueInput
  }

  /**
   * keymaps deleteMany
   */
  export type keymapsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which keymaps to delete
     */
    where?: keymapsWhereInput
  }

  /**
   * keymaps without action
   */
  export type keymapsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the keymaps
     */
    select?: keymapsSelect<ExtArgs> | null
  }


  /**
   * Model linkskills
   */

  export type AggregateLinkskills = {
    _count: LinkskillsCountAggregateOutputType | null
    _avg: LinkskillsAvgAggregateOutputType | null
    _sum: LinkskillsSumAggregateOutputType | null
    _min: LinkskillsMinAggregateOutputType | null
    _max: LinkskillsMaxAggregateOutputType | null
  }

  export type LinkskillsAvgAggregateOutputType = {
    id: number | null
    accid: number | null
    ownerid: number | null
    linkedcharid: number | null
    linkskillid: number | null
    level: number | null
  }

  export type LinkskillsSumAggregateOutputType = {
    id: number | null
    accid: number | null
    ownerid: number | null
    linkedcharid: number | null
    linkskillid: number | null
    level: number | null
  }

  export type LinkskillsMinAggregateOutputType = {
    id: number | null
    accid: number | null
    ownerid: number | null
    linkedcharid: number | null
    linkskillid: number | null
    level: number | null
    addeddate: Date | null
  }

  export type LinkskillsMaxAggregateOutputType = {
    id: number | null
    accid: number | null
    ownerid: number | null
    linkedcharid: number | null
    linkskillid: number | null
    level: number | null
    addeddate: Date | null
  }

  export type LinkskillsCountAggregateOutputType = {
    id: number
    accid: number
    ownerid: number
    linkedcharid: number
    linkskillid: number
    level: number
    addeddate: number
    _all: number
  }


  export type LinkskillsAvgAggregateInputType = {
    id?: true
    accid?: true
    ownerid?: true
    linkedcharid?: true
    linkskillid?: true
    level?: true
  }

  export type LinkskillsSumAggregateInputType = {
    id?: true
    accid?: true
    ownerid?: true
    linkedcharid?: true
    linkskillid?: true
    level?: true
  }

  export type LinkskillsMinAggregateInputType = {
    id?: true
    accid?: true
    ownerid?: true
    linkedcharid?: true
    linkskillid?: true
    level?: true
    addeddate?: true
  }

  export type LinkskillsMaxAggregateInputType = {
    id?: true
    accid?: true
    ownerid?: true
    linkedcharid?: true
    linkskillid?: true
    level?: true
    addeddate?: true
  }

  export type LinkskillsCountAggregateInputType = {
    id?: true
    accid?: true
    ownerid?: true
    linkedcharid?: true
    linkskillid?: true
    level?: true
    addeddate?: true
    _all?: true
  }

  export type LinkskillsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which linkskills to aggregate.
     */
    where?: linkskillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of linkskills to fetch.
     */
    orderBy?: linkskillsOrderByWithRelationInput | linkskillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: linkskillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` linkskills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` linkskills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned linkskills
    **/
    _count?: true | LinkskillsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LinkskillsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LinkskillsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LinkskillsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LinkskillsMaxAggregateInputType
  }

  export type GetLinkskillsAggregateType<T extends LinkskillsAggregateArgs> = {
        [P in keyof T & keyof AggregateLinkskills]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLinkskills[P]>
      : GetScalarType<T[P], AggregateLinkskills[P]>
  }




  export type linkskillsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: linkskillsWhereInput
    orderBy?: linkskillsOrderByWithAggregationInput | linkskillsOrderByWithAggregationInput[]
    by: LinkskillsScalarFieldEnum[] | LinkskillsScalarFieldEnum
    having?: linkskillsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LinkskillsCountAggregateInputType | true
    _avg?: LinkskillsAvgAggregateInputType
    _sum?: LinkskillsSumAggregateInputType
    _min?: LinkskillsMinAggregateInputType
    _max?: LinkskillsMaxAggregateInputType
  }

  export type LinkskillsGroupByOutputType = {
    id: number
    accid: number | null
    ownerid: number | null
    linkedcharid: number | null
    linkskillid: number | null
    level: number | null
    addeddate: Date | null
    _count: LinkskillsCountAggregateOutputType | null
    _avg: LinkskillsAvgAggregateOutputType | null
    _sum: LinkskillsSumAggregateOutputType | null
    _min: LinkskillsMinAggregateOutputType | null
    _max: LinkskillsMaxAggregateOutputType | null
  }

  type GetLinkskillsGroupByPayload<T extends linkskillsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LinkskillsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LinkskillsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LinkskillsGroupByOutputType[P]>
            : GetScalarType<T[P], LinkskillsGroupByOutputType[P]>
        }
      >
    >


  export type linkskillsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accid?: boolean
    ownerid?: boolean
    linkedcharid?: boolean
    linkskillid?: boolean
    level?: boolean
    addeddate?: boolean
  }, ExtArgs["result"]["linkskills"]>


  export type linkskillsSelectScalar = {
    id?: boolean
    accid?: boolean
    ownerid?: boolean
    linkedcharid?: boolean
    linkskillid?: boolean
    level?: boolean
    addeddate?: boolean
  }


  export type $linkskillsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "linkskills"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      accid: number | null
      ownerid: number | null
      linkedcharid: number | null
      linkskillid: number | null
      level: number | null
      addeddate: Date | null
    }, ExtArgs["result"]["linkskills"]>
    composites: {}
  }

  type linkskillsGetPayload<S extends boolean | null | undefined | linkskillsDefaultArgs> = $Result.GetResult<Prisma.$linkskillsPayload, S>

  type linkskillsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<linkskillsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LinkskillsCountAggregateInputType | true
    }

  export interface linkskillsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['linkskills'], meta: { name: 'linkskills' } }
    /**
     * Find zero or one Linkskills that matches the filter.
     * @param {linkskillsFindUniqueArgs} args - Arguments to find a Linkskills
     * @example
     * // Get one Linkskills
     * const linkskills = await prisma.linkskills.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends linkskillsFindUniqueArgs>(args: SelectSubset<T, linkskillsFindUniqueArgs<ExtArgs>>): Prisma__linkskillsClient<$Result.GetResult<Prisma.$linkskillsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Linkskills that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {linkskillsFindUniqueOrThrowArgs} args - Arguments to find a Linkskills
     * @example
     * // Get one Linkskills
     * const linkskills = await prisma.linkskills.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends linkskillsFindUniqueOrThrowArgs>(args: SelectSubset<T, linkskillsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__linkskillsClient<$Result.GetResult<Prisma.$linkskillsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Linkskills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {linkskillsFindFirstArgs} args - Arguments to find a Linkskills
     * @example
     * // Get one Linkskills
     * const linkskills = await prisma.linkskills.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends linkskillsFindFirstArgs>(args?: SelectSubset<T, linkskillsFindFirstArgs<ExtArgs>>): Prisma__linkskillsClient<$Result.GetResult<Prisma.$linkskillsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Linkskills that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {linkskillsFindFirstOrThrowArgs} args - Arguments to find a Linkskills
     * @example
     * // Get one Linkskills
     * const linkskills = await prisma.linkskills.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends linkskillsFindFirstOrThrowArgs>(args?: SelectSubset<T, linkskillsFindFirstOrThrowArgs<ExtArgs>>): Prisma__linkskillsClient<$Result.GetResult<Prisma.$linkskillsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Linkskills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {linkskillsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Linkskills
     * const linkskills = await prisma.linkskills.findMany()
     * 
     * // Get first 10 Linkskills
     * const linkskills = await prisma.linkskills.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const linkskillsWithIdOnly = await prisma.linkskills.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends linkskillsFindManyArgs>(args?: SelectSubset<T, linkskillsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$linkskillsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Linkskills.
     * @param {linkskillsCreateArgs} args - Arguments to create a Linkskills.
     * @example
     * // Create one Linkskills
     * const Linkskills = await prisma.linkskills.create({
     *   data: {
     *     // ... data to create a Linkskills
     *   }
     * })
     * 
     */
    create<T extends linkskillsCreateArgs>(args: SelectSubset<T, linkskillsCreateArgs<ExtArgs>>): Prisma__linkskillsClient<$Result.GetResult<Prisma.$linkskillsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Linkskills.
     * @param {linkskillsCreateManyArgs} args - Arguments to create many Linkskills.
     * @example
     * // Create many Linkskills
     * const linkskills = await prisma.linkskills.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends linkskillsCreateManyArgs>(args?: SelectSubset<T, linkskillsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Linkskills.
     * @param {linkskillsDeleteArgs} args - Arguments to delete one Linkskills.
     * @example
     * // Delete one Linkskills
     * const Linkskills = await prisma.linkskills.delete({
     *   where: {
     *     // ... filter to delete one Linkskills
     *   }
     * })
     * 
     */
    delete<T extends linkskillsDeleteArgs>(args: SelectSubset<T, linkskillsDeleteArgs<ExtArgs>>): Prisma__linkskillsClient<$Result.GetResult<Prisma.$linkskillsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Linkskills.
     * @param {linkskillsUpdateArgs} args - Arguments to update one Linkskills.
     * @example
     * // Update one Linkskills
     * const linkskills = await prisma.linkskills.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends linkskillsUpdateArgs>(args: SelectSubset<T, linkskillsUpdateArgs<ExtArgs>>): Prisma__linkskillsClient<$Result.GetResult<Prisma.$linkskillsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Linkskills.
     * @param {linkskillsDeleteManyArgs} args - Arguments to filter Linkskills to delete.
     * @example
     * // Delete a few Linkskills
     * const { count } = await prisma.linkskills.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends linkskillsDeleteManyArgs>(args?: SelectSubset<T, linkskillsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Linkskills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {linkskillsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Linkskills
     * const linkskills = await prisma.linkskills.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends linkskillsUpdateManyArgs>(args: SelectSubset<T, linkskillsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Linkskills.
     * @param {linkskillsUpsertArgs} args - Arguments to update or create a Linkskills.
     * @example
     * // Update or create a Linkskills
     * const linkskills = await prisma.linkskills.upsert({
     *   create: {
     *     // ... data to create a Linkskills
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Linkskills we want to update
     *   }
     * })
     */
    upsert<T extends linkskillsUpsertArgs>(args: SelectSubset<T, linkskillsUpsertArgs<ExtArgs>>): Prisma__linkskillsClient<$Result.GetResult<Prisma.$linkskillsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Linkskills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {linkskillsCountArgs} args - Arguments to filter Linkskills to count.
     * @example
     * // Count the number of Linkskills
     * const count = await prisma.linkskills.count({
     *   where: {
     *     // ... the filter for the Linkskills we want to count
     *   }
     * })
    **/
    count<T extends linkskillsCountArgs>(
      args?: Subset<T, linkskillsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LinkskillsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Linkskills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkskillsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LinkskillsAggregateArgs>(args: Subset<T, LinkskillsAggregateArgs>): Prisma.PrismaPromise<GetLinkskillsAggregateType<T>>

    /**
     * Group by Linkskills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {linkskillsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends linkskillsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: linkskillsGroupByArgs['orderBy'] }
        : { orderBy?: linkskillsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, linkskillsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLinkskillsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the linkskills model
   */
  readonly fields: linkskillsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for linkskills.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__linkskillsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the linkskills model
   */ 
  interface linkskillsFieldRefs {
    readonly id: FieldRef<"linkskills", 'Int'>
    readonly accid: FieldRef<"linkskills", 'Int'>
    readonly ownerid: FieldRef<"linkskills", 'Int'>
    readonly linkedcharid: FieldRef<"linkskills", 'Int'>
    readonly linkskillid: FieldRef<"linkskills", 'Int'>
    readonly level: FieldRef<"linkskills", 'Int'>
    readonly addeddate: FieldRef<"linkskills", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * linkskills findUnique
   */
  export type linkskillsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the linkskills
     */
    select?: linkskillsSelect<ExtArgs> | null
    /**
     * Filter, which linkskills to fetch.
     */
    where: linkskillsWhereUniqueInput
  }

  /**
   * linkskills findUniqueOrThrow
   */
  export type linkskillsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the linkskills
     */
    select?: linkskillsSelect<ExtArgs> | null
    /**
     * Filter, which linkskills to fetch.
     */
    where: linkskillsWhereUniqueInput
  }

  /**
   * linkskills findFirst
   */
  export type linkskillsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the linkskills
     */
    select?: linkskillsSelect<ExtArgs> | null
    /**
     * Filter, which linkskills to fetch.
     */
    where?: linkskillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of linkskills to fetch.
     */
    orderBy?: linkskillsOrderByWithRelationInput | linkskillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for linkskills.
     */
    cursor?: linkskillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` linkskills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` linkskills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of linkskills.
     */
    distinct?: LinkskillsScalarFieldEnum | LinkskillsScalarFieldEnum[]
  }

  /**
   * linkskills findFirstOrThrow
   */
  export type linkskillsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the linkskills
     */
    select?: linkskillsSelect<ExtArgs> | null
    /**
     * Filter, which linkskills to fetch.
     */
    where?: linkskillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of linkskills to fetch.
     */
    orderBy?: linkskillsOrderByWithRelationInput | linkskillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for linkskills.
     */
    cursor?: linkskillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` linkskills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` linkskills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of linkskills.
     */
    distinct?: LinkskillsScalarFieldEnum | LinkskillsScalarFieldEnum[]
  }

  /**
   * linkskills findMany
   */
  export type linkskillsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the linkskills
     */
    select?: linkskillsSelect<ExtArgs> | null
    /**
     * Filter, which linkskills to fetch.
     */
    where?: linkskillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of linkskills to fetch.
     */
    orderBy?: linkskillsOrderByWithRelationInput | linkskillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing linkskills.
     */
    cursor?: linkskillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` linkskills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` linkskills.
     */
    skip?: number
    distinct?: LinkskillsScalarFieldEnum | LinkskillsScalarFieldEnum[]
  }

  /**
   * linkskills create
   */
  export type linkskillsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the linkskills
     */
    select?: linkskillsSelect<ExtArgs> | null
    /**
     * The data needed to create a linkskills.
     */
    data?: XOR<linkskillsCreateInput, linkskillsUncheckedCreateInput>
  }

  /**
   * linkskills createMany
   */
  export type linkskillsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many linkskills.
     */
    data: linkskillsCreateManyInput | linkskillsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * linkskills update
   */
  export type linkskillsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the linkskills
     */
    select?: linkskillsSelect<ExtArgs> | null
    /**
     * The data needed to update a linkskills.
     */
    data: XOR<linkskillsUpdateInput, linkskillsUncheckedUpdateInput>
    /**
     * Choose, which linkskills to update.
     */
    where: linkskillsWhereUniqueInput
  }

  /**
   * linkskills updateMany
   */
  export type linkskillsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update linkskills.
     */
    data: XOR<linkskillsUpdateManyMutationInput, linkskillsUncheckedUpdateManyInput>
    /**
     * Filter which linkskills to update
     */
    where?: linkskillsWhereInput
  }

  /**
   * linkskills upsert
   */
  export type linkskillsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the linkskills
     */
    select?: linkskillsSelect<ExtArgs> | null
    /**
     * The filter to search for the linkskills to update in case it exists.
     */
    where: linkskillsWhereUniqueInput
    /**
     * In case the linkskills found by the `where` argument doesn't exist, create a new linkskills with this data.
     */
    create: XOR<linkskillsCreateInput, linkskillsUncheckedCreateInput>
    /**
     * In case the linkskills was found with the provided `where` argument, update it with this data.
     */
    update: XOR<linkskillsUpdateInput, linkskillsUncheckedUpdateInput>
  }

  /**
   * linkskills delete
   */
  export type linkskillsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the linkskills
     */
    select?: linkskillsSelect<ExtArgs> | null
    /**
     * Filter which linkskills to delete.
     */
    where: linkskillsWhereUniqueInput
  }

  /**
   * linkskills deleteMany
   */
  export type linkskillsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which linkskills to delete
     */
    where?: linkskillsWhereInput
  }

  /**
   * linkskills without action
   */
  export type linkskillsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the linkskills
     */
    select?: linkskillsSelect<ExtArgs> | null
  }


  /**
   * Model macros
   */

  export type AggregateMacros = {
    _count: MacrosCountAggregateOutputType | null
    _avg: MacrosAvgAggregateOutputType | null
    _sum: MacrosSumAggregateOutputType | null
    _min: MacrosMinAggregateOutputType | null
    _max: MacrosMaxAggregateOutputType | null
  }

  export type MacrosAvgAggregateOutputType = {
    id: number | null
    charid: number | null
  }

  export type MacrosSumAggregateOutputType = {
    id: bigint | null
    charid: number | null
  }

  export type MacrosMinAggregateOutputType = {
    id: bigint | null
    charid: number | null
    muted: boolean | null
    name: string | null
  }

  export type MacrosMaxAggregateOutputType = {
    id: bigint | null
    charid: number | null
    muted: boolean | null
    name: string | null
  }

  export type MacrosCountAggregateOutputType = {
    id: number
    charid: number
    muted: number
    name: number
    _all: number
  }


  export type MacrosAvgAggregateInputType = {
    id?: true
    charid?: true
  }

  export type MacrosSumAggregateInputType = {
    id?: true
    charid?: true
  }

  export type MacrosMinAggregateInputType = {
    id?: true
    charid?: true
    muted?: true
    name?: true
  }

  export type MacrosMaxAggregateInputType = {
    id?: true
    charid?: true
    muted?: true
    name?: true
  }

  export type MacrosCountAggregateInputType = {
    id?: true
    charid?: true
    muted?: true
    name?: true
    _all?: true
  }

  export type MacrosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which macros to aggregate.
     */
    where?: macrosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of macros to fetch.
     */
    orderBy?: macrosOrderByWithRelationInput | macrosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: macrosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` macros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` macros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned macros
    **/
    _count?: true | MacrosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MacrosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MacrosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MacrosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MacrosMaxAggregateInputType
  }

  export type GetMacrosAggregateType<T extends MacrosAggregateArgs> = {
        [P in keyof T & keyof AggregateMacros]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMacros[P]>
      : GetScalarType<T[P], AggregateMacros[P]>
  }




  export type macrosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: macrosWhereInput
    orderBy?: macrosOrderByWithAggregationInput | macrosOrderByWithAggregationInput[]
    by: MacrosScalarFieldEnum[] | MacrosScalarFieldEnum
    having?: macrosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MacrosCountAggregateInputType | true
    _avg?: MacrosAvgAggregateInputType
    _sum?: MacrosSumAggregateInputType
    _min?: MacrosMinAggregateInputType
    _max?: MacrosMaxAggregateInputType
  }

  export type MacrosGroupByOutputType = {
    id: bigint
    charid: number | null
    muted: boolean | null
    name: string | null
    _count: MacrosCountAggregateOutputType | null
    _avg: MacrosAvgAggregateOutputType | null
    _sum: MacrosSumAggregateOutputType | null
    _min: MacrosMinAggregateOutputType | null
    _max: MacrosMaxAggregateOutputType | null
  }

  type GetMacrosGroupByPayload<T extends macrosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MacrosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MacrosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MacrosGroupByOutputType[P]>
            : GetScalarType<T[P], MacrosGroupByOutputType[P]>
        }
      >
    >


  export type macrosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    charid?: boolean
    muted?: boolean
    name?: boolean
  }, ExtArgs["result"]["macros"]>


  export type macrosSelectScalar = {
    id?: boolean
    charid?: boolean
    muted?: boolean
    name?: boolean
  }


  export type $macrosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "macros"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      charid: number | null
      muted: boolean | null
      name: string | null
    }, ExtArgs["result"]["macros"]>
    composites: {}
  }

  type macrosGetPayload<S extends boolean | null | undefined | macrosDefaultArgs> = $Result.GetResult<Prisma.$macrosPayload, S>

  type macrosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<macrosFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MacrosCountAggregateInputType | true
    }

  export interface macrosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['macros'], meta: { name: 'macros' } }
    /**
     * Find zero or one Macros that matches the filter.
     * @param {macrosFindUniqueArgs} args - Arguments to find a Macros
     * @example
     * // Get one Macros
     * const macros = await prisma.macros.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends macrosFindUniqueArgs>(args: SelectSubset<T, macrosFindUniqueArgs<ExtArgs>>): Prisma__macrosClient<$Result.GetResult<Prisma.$macrosPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Macros that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {macrosFindUniqueOrThrowArgs} args - Arguments to find a Macros
     * @example
     * // Get one Macros
     * const macros = await prisma.macros.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends macrosFindUniqueOrThrowArgs>(args: SelectSubset<T, macrosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__macrosClient<$Result.GetResult<Prisma.$macrosPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Macros that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {macrosFindFirstArgs} args - Arguments to find a Macros
     * @example
     * // Get one Macros
     * const macros = await prisma.macros.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends macrosFindFirstArgs>(args?: SelectSubset<T, macrosFindFirstArgs<ExtArgs>>): Prisma__macrosClient<$Result.GetResult<Prisma.$macrosPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Macros that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {macrosFindFirstOrThrowArgs} args - Arguments to find a Macros
     * @example
     * // Get one Macros
     * const macros = await prisma.macros.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends macrosFindFirstOrThrowArgs>(args?: SelectSubset<T, macrosFindFirstOrThrowArgs<ExtArgs>>): Prisma__macrosClient<$Result.GetResult<Prisma.$macrosPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Macros that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {macrosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Macros
     * const macros = await prisma.macros.findMany()
     * 
     * // Get first 10 Macros
     * const macros = await prisma.macros.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const macrosWithIdOnly = await prisma.macros.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends macrosFindManyArgs>(args?: SelectSubset<T, macrosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$macrosPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Macros.
     * @param {macrosCreateArgs} args - Arguments to create a Macros.
     * @example
     * // Create one Macros
     * const Macros = await prisma.macros.create({
     *   data: {
     *     // ... data to create a Macros
     *   }
     * })
     * 
     */
    create<T extends macrosCreateArgs>(args: SelectSubset<T, macrosCreateArgs<ExtArgs>>): Prisma__macrosClient<$Result.GetResult<Prisma.$macrosPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Macros.
     * @param {macrosCreateManyArgs} args - Arguments to create many Macros.
     * @example
     * // Create many Macros
     * const macros = await prisma.macros.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends macrosCreateManyArgs>(args?: SelectSubset<T, macrosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Macros.
     * @param {macrosDeleteArgs} args - Arguments to delete one Macros.
     * @example
     * // Delete one Macros
     * const Macros = await prisma.macros.delete({
     *   where: {
     *     // ... filter to delete one Macros
     *   }
     * })
     * 
     */
    delete<T extends macrosDeleteArgs>(args: SelectSubset<T, macrosDeleteArgs<ExtArgs>>): Prisma__macrosClient<$Result.GetResult<Prisma.$macrosPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Macros.
     * @param {macrosUpdateArgs} args - Arguments to update one Macros.
     * @example
     * // Update one Macros
     * const macros = await prisma.macros.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends macrosUpdateArgs>(args: SelectSubset<T, macrosUpdateArgs<ExtArgs>>): Prisma__macrosClient<$Result.GetResult<Prisma.$macrosPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Macros.
     * @param {macrosDeleteManyArgs} args - Arguments to filter Macros to delete.
     * @example
     * // Delete a few Macros
     * const { count } = await prisma.macros.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends macrosDeleteManyArgs>(args?: SelectSubset<T, macrosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Macros.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {macrosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Macros
     * const macros = await prisma.macros.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends macrosUpdateManyArgs>(args: SelectSubset<T, macrosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Macros.
     * @param {macrosUpsertArgs} args - Arguments to update or create a Macros.
     * @example
     * // Update or create a Macros
     * const macros = await prisma.macros.upsert({
     *   create: {
     *     // ... data to create a Macros
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Macros we want to update
     *   }
     * })
     */
    upsert<T extends macrosUpsertArgs>(args: SelectSubset<T, macrosUpsertArgs<ExtArgs>>): Prisma__macrosClient<$Result.GetResult<Prisma.$macrosPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Macros.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {macrosCountArgs} args - Arguments to filter Macros to count.
     * @example
     * // Count the number of Macros
     * const count = await prisma.macros.count({
     *   where: {
     *     // ... the filter for the Macros we want to count
     *   }
     * })
    **/
    count<T extends macrosCountArgs>(
      args?: Subset<T, macrosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MacrosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Macros.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MacrosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MacrosAggregateArgs>(args: Subset<T, MacrosAggregateArgs>): Prisma.PrismaPromise<GetMacrosAggregateType<T>>

    /**
     * Group by Macros.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {macrosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends macrosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: macrosGroupByArgs['orderBy'] }
        : { orderBy?: macrosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, macrosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMacrosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the macros model
   */
  readonly fields: macrosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for macros.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__macrosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the macros model
   */ 
  interface macrosFieldRefs {
    readonly id: FieldRef<"macros", 'BigInt'>
    readonly charid: FieldRef<"macros", 'Int'>
    readonly muted: FieldRef<"macros", 'Boolean'>
    readonly name: FieldRef<"macros", 'String'>
  }
    

  // Custom InputTypes
  /**
   * macros findUnique
   */
  export type macrosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the macros
     */
    select?: macrosSelect<ExtArgs> | null
    /**
     * Filter, which macros to fetch.
     */
    where: macrosWhereUniqueInput
  }

  /**
   * macros findUniqueOrThrow
   */
  export type macrosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the macros
     */
    select?: macrosSelect<ExtArgs> | null
    /**
     * Filter, which macros to fetch.
     */
    where: macrosWhereUniqueInput
  }

  /**
   * macros findFirst
   */
  export type macrosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the macros
     */
    select?: macrosSelect<ExtArgs> | null
    /**
     * Filter, which macros to fetch.
     */
    where?: macrosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of macros to fetch.
     */
    orderBy?: macrosOrderByWithRelationInput | macrosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for macros.
     */
    cursor?: macrosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` macros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` macros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of macros.
     */
    distinct?: MacrosScalarFieldEnum | MacrosScalarFieldEnum[]
  }

  /**
   * macros findFirstOrThrow
   */
  export type macrosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the macros
     */
    select?: macrosSelect<ExtArgs> | null
    /**
     * Filter, which macros to fetch.
     */
    where?: macrosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of macros to fetch.
     */
    orderBy?: macrosOrderByWithRelationInput | macrosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for macros.
     */
    cursor?: macrosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` macros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` macros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of macros.
     */
    distinct?: MacrosScalarFieldEnum | MacrosScalarFieldEnum[]
  }

  /**
   * macros findMany
   */
  export type macrosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the macros
     */
    select?: macrosSelect<ExtArgs> | null
    /**
     * Filter, which macros to fetch.
     */
    where?: macrosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of macros to fetch.
     */
    orderBy?: macrosOrderByWithRelationInput | macrosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing macros.
     */
    cursor?: macrosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` macros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` macros.
     */
    skip?: number
    distinct?: MacrosScalarFieldEnum | MacrosScalarFieldEnum[]
  }

  /**
   * macros create
   */
  export type macrosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the macros
     */
    select?: macrosSelect<ExtArgs> | null
    /**
     * The data needed to create a macros.
     */
    data?: XOR<macrosCreateInput, macrosUncheckedCreateInput>
  }

  /**
   * macros createMany
   */
  export type macrosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many macros.
     */
    data: macrosCreateManyInput | macrosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * macros update
   */
  export type macrosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the macros
     */
    select?: macrosSelect<ExtArgs> | null
    /**
     * The data needed to update a macros.
     */
    data: XOR<macrosUpdateInput, macrosUncheckedUpdateInput>
    /**
     * Choose, which macros to update.
     */
    where: macrosWhereUniqueInput
  }

  /**
   * macros updateMany
   */
  export type macrosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update macros.
     */
    data: XOR<macrosUpdateManyMutationInput, macrosUncheckedUpdateManyInput>
    /**
     * Filter which macros to update
     */
    where?: macrosWhereInput
  }

  /**
   * macros upsert
   */
  export type macrosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the macros
     */
    select?: macrosSelect<ExtArgs> | null
    /**
     * The filter to search for the macros to update in case it exists.
     */
    where: macrosWhereUniqueInput
    /**
     * In case the macros found by the `where` argument doesn't exist, create a new macros with this data.
     */
    create: XOR<macrosCreateInput, macrosUncheckedCreateInput>
    /**
     * In case the macros was found with the provided `where` argument, update it with this data.
     */
    update: XOR<macrosUpdateInput, macrosUncheckedUpdateInput>
  }

  /**
   * macros delete
   */
  export type macrosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the macros
     */
    select?: macrosSelect<ExtArgs> | null
    /**
     * Filter which macros to delete.
     */
    where: macrosWhereUniqueInput
  }

  /**
   * macros deleteMany
   */
  export type macrosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which macros to delete
     */
    where?: macrosWhereInput
  }

  /**
   * macros without action
   */
  export type macrosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the macros
     */
    select?: macrosSelect<ExtArgs> | null
  }


  /**
   * Model macroskills
   */

  export type AggregateMacroskills = {
    _count: MacroskillsCountAggregateOutputType | null
    _avg: MacroskillsAvgAggregateOutputType | null
    _sum: MacroskillsSumAggregateOutputType | null
    _min: MacroskillsMinAggregateOutputType | null
    _max: MacroskillsMaxAggregateOutputType | null
  }

  export type MacroskillsAvgAggregateOutputType = {
    id: number | null
    ordercol: number | null
    skillid: number | null
    macroid: number | null
  }

  export type MacroskillsSumAggregateOutputType = {
    id: bigint | null
    ordercol: number | null
    skillid: number | null
    macroid: bigint | null
  }

  export type MacroskillsMinAggregateOutputType = {
    id: bigint | null
    ordercol: number | null
    skillid: number | null
    macroid: bigint | null
  }

  export type MacroskillsMaxAggregateOutputType = {
    id: bigint | null
    ordercol: number | null
    skillid: number | null
    macroid: bigint | null
  }

  export type MacroskillsCountAggregateOutputType = {
    id: number
    ordercol: number
    skillid: number
    macroid: number
    _all: number
  }


  export type MacroskillsAvgAggregateInputType = {
    id?: true
    ordercol?: true
    skillid?: true
    macroid?: true
  }

  export type MacroskillsSumAggregateInputType = {
    id?: true
    ordercol?: true
    skillid?: true
    macroid?: true
  }

  export type MacroskillsMinAggregateInputType = {
    id?: true
    ordercol?: true
    skillid?: true
    macroid?: true
  }

  export type MacroskillsMaxAggregateInputType = {
    id?: true
    ordercol?: true
    skillid?: true
    macroid?: true
  }

  export type MacroskillsCountAggregateInputType = {
    id?: true
    ordercol?: true
    skillid?: true
    macroid?: true
    _all?: true
  }

  export type MacroskillsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which macroskills to aggregate.
     */
    where?: macroskillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of macroskills to fetch.
     */
    orderBy?: macroskillsOrderByWithRelationInput | macroskillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: macroskillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` macroskills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` macroskills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned macroskills
    **/
    _count?: true | MacroskillsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MacroskillsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MacroskillsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MacroskillsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MacroskillsMaxAggregateInputType
  }

  export type GetMacroskillsAggregateType<T extends MacroskillsAggregateArgs> = {
        [P in keyof T & keyof AggregateMacroskills]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMacroskills[P]>
      : GetScalarType<T[P], AggregateMacroskills[P]>
  }




  export type macroskillsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: macroskillsWhereInput
    orderBy?: macroskillsOrderByWithAggregationInput | macroskillsOrderByWithAggregationInput[]
    by: MacroskillsScalarFieldEnum[] | MacroskillsScalarFieldEnum
    having?: macroskillsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MacroskillsCountAggregateInputType | true
    _avg?: MacroskillsAvgAggregateInputType
    _sum?: MacroskillsSumAggregateInputType
    _min?: MacroskillsMinAggregateInputType
    _max?: MacroskillsMaxAggregateInputType
  }

  export type MacroskillsGroupByOutputType = {
    id: bigint
    ordercol: number | null
    skillid: number | null
    macroid: bigint | null
    _count: MacroskillsCountAggregateOutputType | null
    _avg: MacroskillsAvgAggregateOutputType | null
    _sum: MacroskillsSumAggregateOutputType | null
    _min: MacroskillsMinAggregateOutputType | null
    _max: MacroskillsMaxAggregateOutputType | null
  }

  type GetMacroskillsGroupByPayload<T extends macroskillsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MacroskillsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MacroskillsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MacroskillsGroupByOutputType[P]>
            : GetScalarType<T[P], MacroskillsGroupByOutputType[P]>
        }
      >
    >


  export type macroskillsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ordercol?: boolean
    skillid?: boolean
    macroid?: boolean
  }, ExtArgs["result"]["macroskills"]>


  export type macroskillsSelectScalar = {
    id?: boolean
    ordercol?: boolean
    skillid?: boolean
    macroid?: boolean
  }


  export type $macroskillsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "macroskills"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      ordercol: number | null
      skillid: number | null
      macroid: bigint | null
    }, ExtArgs["result"]["macroskills"]>
    composites: {}
  }

  type macroskillsGetPayload<S extends boolean | null | undefined | macroskillsDefaultArgs> = $Result.GetResult<Prisma.$macroskillsPayload, S>

  type macroskillsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<macroskillsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MacroskillsCountAggregateInputType | true
    }

  export interface macroskillsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['macroskills'], meta: { name: 'macroskills' } }
    /**
     * Find zero or one Macroskills that matches the filter.
     * @param {macroskillsFindUniqueArgs} args - Arguments to find a Macroskills
     * @example
     * // Get one Macroskills
     * const macroskills = await prisma.macroskills.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends macroskillsFindUniqueArgs>(args: SelectSubset<T, macroskillsFindUniqueArgs<ExtArgs>>): Prisma__macroskillsClient<$Result.GetResult<Prisma.$macroskillsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Macroskills that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {macroskillsFindUniqueOrThrowArgs} args - Arguments to find a Macroskills
     * @example
     * // Get one Macroskills
     * const macroskills = await prisma.macroskills.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends macroskillsFindUniqueOrThrowArgs>(args: SelectSubset<T, macroskillsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__macroskillsClient<$Result.GetResult<Prisma.$macroskillsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Macroskills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {macroskillsFindFirstArgs} args - Arguments to find a Macroskills
     * @example
     * // Get one Macroskills
     * const macroskills = await prisma.macroskills.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends macroskillsFindFirstArgs>(args?: SelectSubset<T, macroskillsFindFirstArgs<ExtArgs>>): Prisma__macroskillsClient<$Result.GetResult<Prisma.$macroskillsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Macroskills that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {macroskillsFindFirstOrThrowArgs} args - Arguments to find a Macroskills
     * @example
     * // Get one Macroskills
     * const macroskills = await prisma.macroskills.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends macroskillsFindFirstOrThrowArgs>(args?: SelectSubset<T, macroskillsFindFirstOrThrowArgs<ExtArgs>>): Prisma__macroskillsClient<$Result.GetResult<Prisma.$macroskillsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Macroskills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {macroskillsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Macroskills
     * const macroskills = await prisma.macroskills.findMany()
     * 
     * // Get first 10 Macroskills
     * const macroskills = await prisma.macroskills.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const macroskillsWithIdOnly = await prisma.macroskills.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends macroskillsFindManyArgs>(args?: SelectSubset<T, macroskillsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$macroskillsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Macroskills.
     * @param {macroskillsCreateArgs} args - Arguments to create a Macroskills.
     * @example
     * // Create one Macroskills
     * const Macroskills = await prisma.macroskills.create({
     *   data: {
     *     // ... data to create a Macroskills
     *   }
     * })
     * 
     */
    create<T extends macroskillsCreateArgs>(args: SelectSubset<T, macroskillsCreateArgs<ExtArgs>>): Prisma__macroskillsClient<$Result.GetResult<Prisma.$macroskillsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Macroskills.
     * @param {macroskillsCreateManyArgs} args - Arguments to create many Macroskills.
     * @example
     * // Create many Macroskills
     * const macroskills = await prisma.macroskills.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends macroskillsCreateManyArgs>(args?: SelectSubset<T, macroskillsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Macroskills.
     * @param {macroskillsDeleteArgs} args - Arguments to delete one Macroskills.
     * @example
     * // Delete one Macroskills
     * const Macroskills = await prisma.macroskills.delete({
     *   where: {
     *     // ... filter to delete one Macroskills
     *   }
     * })
     * 
     */
    delete<T extends macroskillsDeleteArgs>(args: SelectSubset<T, macroskillsDeleteArgs<ExtArgs>>): Prisma__macroskillsClient<$Result.GetResult<Prisma.$macroskillsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Macroskills.
     * @param {macroskillsUpdateArgs} args - Arguments to update one Macroskills.
     * @example
     * // Update one Macroskills
     * const macroskills = await prisma.macroskills.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends macroskillsUpdateArgs>(args: SelectSubset<T, macroskillsUpdateArgs<ExtArgs>>): Prisma__macroskillsClient<$Result.GetResult<Prisma.$macroskillsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Macroskills.
     * @param {macroskillsDeleteManyArgs} args - Arguments to filter Macroskills to delete.
     * @example
     * // Delete a few Macroskills
     * const { count } = await prisma.macroskills.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends macroskillsDeleteManyArgs>(args?: SelectSubset<T, macroskillsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Macroskills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {macroskillsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Macroskills
     * const macroskills = await prisma.macroskills.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends macroskillsUpdateManyArgs>(args: SelectSubset<T, macroskillsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Macroskills.
     * @param {macroskillsUpsertArgs} args - Arguments to update or create a Macroskills.
     * @example
     * // Update or create a Macroskills
     * const macroskills = await prisma.macroskills.upsert({
     *   create: {
     *     // ... data to create a Macroskills
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Macroskills we want to update
     *   }
     * })
     */
    upsert<T extends macroskillsUpsertArgs>(args: SelectSubset<T, macroskillsUpsertArgs<ExtArgs>>): Prisma__macroskillsClient<$Result.GetResult<Prisma.$macroskillsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Macroskills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {macroskillsCountArgs} args - Arguments to filter Macroskills to count.
     * @example
     * // Count the number of Macroskills
     * const count = await prisma.macroskills.count({
     *   where: {
     *     // ... the filter for the Macroskills we want to count
     *   }
     * })
    **/
    count<T extends macroskillsCountArgs>(
      args?: Subset<T, macroskillsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MacroskillsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Macroskills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MacroskillsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MacroskillsAggregateArgs>(args: Subset<T, MacroskillsAggregateArgs>): Prisma.PrismaPromise<GetMacroskillsAggregateType<T>>

    /**
     * Group by Macroskills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {macroskillsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends macroskillsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: macroskillsGroupByArgs['orderBy'] }
        : { orderBy?: macroskillsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, macroskillsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMacroskillsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the macroskills model
   */
  readonly fields: macroskillsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for macroskills.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__macroskillsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the macroskills model
   */ 
  interface macroskillsFieldRefs {
    readonly id: FieldRef<"macroskills", 'BigInt'>
    readonly ordercol: FieldRef<"macroskills", 'Int'>
    readonly skillid: FieldRef<"macroskills", 'Int'>
    readonly macroid: FieldRef<"macroskills", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * macroskills findUnique
   */
  export type macroskillsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the macroskills
     */
    select?: macroskillsSelect<ExtArgs> | null
    /**
     * Filter, which macroskills to fetch.
     */
    where: macroskillsWhereUniqueInput
  }

  /**
   * macroskills findUniqueOrThrow
   */
  export type macroskillsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the macroskills
     */
    select?: macroskillsSelect<ExtArgs> | null
    /**
     * Filter, which macroskills to fetch.
     */
    where: macroskillsWhereUniqueInput
  }

  /**
   * macroskills findFirst
   */
  export type macroskillsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the macroskills
     */
    select?: macroskillsSelect<ExtArgs> | null
    /**
     * Filter, which macroskills to fetch.
     */
    where?: macroskillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of macroskills to fetch.
     */
    orderBy?: macroskillsOrderByWithRelationInput | macroskillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for macroskills.
     */
    cursor?: macroskillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` macroskills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` macroskills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of macroskills.
     */
    distinct?: MacroskillsScalarFieldEnum | MacroskillsScalarFieldEnum[]
  }

  /**
   * macroskills findFirstOrThrow
   */
  export type macroskillsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the macroskills
     */
    select?: macroskillsSelect<ExtArgs> | null
    /**
     * Filter, which macroskills to fetch.
     */
    where?: macroskillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of macroskills to fetch.
     */
    orderBy?: macroskillsOrderByWithRelationInput | macroskillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for macroskills.
     */
    cursor?: macroskillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` macroskills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` macroskills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of macroskills.
     */
    distinct?: MacroskillsScalarFieldEnum | MacroskillsScalarFieldEnum[]
  }

  /**
   * macroskills findMany
   */
  export type macroskillsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the macroskills
     */
    select?: macroskillsSelect<ExtArgs> | null
    /**
     * Filter, which macroskills to fetch.
     */
    where?: macroskillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of macroskills to fetch.
     */
    orderBy?: macroskillsOrderByWithRelationInput | macroskillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing macroskills.
     */
    cursor?: macroskillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` macroskills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` macroskills.
     */
    skip?: number
    distinct?: MacroskillsScalarFieldEnum | MacroskillsScalarFieldEnum[]
  }

  /**
   * macroskills create
   */
  export type macroskillsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the macroskills
     */
    select?: macroskillsSelect<ExtArgs> | null
    /**
     * The data needed to create a macroskills.
     */
    data?: XOR<macroskillsCreateInput, macroskillsUncheckedCreateInput>
  }

  /**
   * macroskills createMany
   */
  export type macroskillsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many macroskills.
     */
    data: macroskillsCreateManyInput | macroskillsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * macroskills update
   */
  export type macroskillsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the macroskills
     */
    select?: macroskillsSelect<ExtArgs> | null
    /**
     * The data needed to update a macroskills.
     */
    data: XOR<macroskillsUpdateInput, macroskillsUncheckedUpdateInput>
    /**
     * Choose, which macroskills to update.
     */
    where: macroskillsWhereUniqueInput
  }

  /**
   * macroskills updateMany
   */
  export type macroskillsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update macroskills.
     */
    data: XOR<macroskillsUpdateManyMutationInput, macroskillsUncheckedUpdateManyInput>
    /**
     * Filter which macroskills to update
     */
    where?: macroskillsWhereInput
  }

  /**
   * macroskills upsert
   */
  export type macroskillsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the macroskills
     */
    select?: macroskillsSelect<ExtArgs> | null
    /**
     * The filter to search for the macroskills to update in case it exists.
     */
    where: macroskillsWhereUniqueInput
    /**
     * In case the macroskills found by the `where` argument doesn't exist, create a new macroskills with this data.
     */
    create: XOR<macroskillsCreateInput, macroskillsUncheckedCreateInput>
    /**
     * In case the macroskills was found with the provided `where` argument, update it with this data.
     */
    update: XOR<macroskillsUpdateInput, macroskillsUncheckedUpdateInput>
  }

  /**
   * macroskills delete
   */
  export type macroskillsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the macroskills
     */
    select?: macroskillsSelect<ExtArgs> | null
    /**
     * Filter which macroskills to delete.
     */
    where: macroskillsWhereUniqueInput
  }

  /**
   * macroskills deleteMany
   */
  export type macroskillsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which macroskills to delete
     */
    where?: macroskillsWhereInput
  }

  /**
   * macroskills without action
   */
  export type macroskillsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the macroskills
     */
    select?: macroskillsSelect<ExtArgs> | null
  }


  /**
   * Model matrixskill
   */

  export type AggregateMatrixskill = {
    _count: MatrixskillCountAggregateOutputType | null
    _avg: MatrixskillAvgAggregateOutputType | null
    _sum: MatrixskillSumAggregateOutputType | null
    _min: MatrixskillMinAggregateOutputType | null
    _max: MatrixskillMaxAggregateOutputType | null
  }

  export type MatrixskillAvgAggregateOutputType = {
    id: number | null
    charid: number | null
    coreID: number | null
    skillID1: number | null
    skillID2: number | null
    skillID3: number | null
    level: number | null
    maxLevel: number | null
    experience: number | null
    crc: number | null
    slot: number | null
  }

  export type MatrixskillSumAggregateOutputType = {
    id: number | null
    charid: number | null
    coreID: number | null
    skillID1: number | null
    skillID2: number | null
    skillID3: number | null
    level: number | null
    maxLevel: number | null
    experience: number | null
    crc: bigint | null
    slot: number | null
  }

  export type MatrixskillMinAggregateOutputType = {
    id: number | null
    charid: number | null
    state: boolean | null
    coreID: number | null
    skillID1: number | null
    skillID2: number | null
    skillID3: number | null
    level: number | null
    maxLevel: number | null
    experience: number | null
    crc: bigint | null
    slot: number | null
  }

  export type MatrixskillMaxAggregateOutputType = {
    id: number | null
    charid: number | null
    state: boolean | null
    coreID: number | null
    skillID1: number | null
    skillID2: number | null
    skillID3: number | null
    level: number | null
    maxLevel: number | null
    experience: number | null
    crc: bigint | null
    slot: number | null
  }

  export type MatrixskillCountAggregateOutputType = {
    id: number
    charid: number
    state: number
    coreID: number
    skillID1: number
    skillID2: number
    skillID3: number
    level: number
    maxLevel: number
    experience: number
    crc: number
    slot: number
    _all: number
  }


  export type MatrixskillAvgAggregateInputType = {
    id?: true
    charid?: true
    coreID?: true
    skillID1?: true
    skillID2?: true
    skillID3?: true
    level?: true
    maxLevel?: true
    experience?: true
    crc?: true
    slot?: true
  }

  export type MatrixskillSumAggregateInputType = {
    id?: true
    charid?: true
    coreID?: true
    skillID1?: true
    skillID2?: true
    skillID3?: true
    level?: true
    maxLevel?: true
    experience?: true
    crc?: true
    slot?: true
  }

  export type MatrixskillMinAggregateInputType = {
    id?: true
    charid?: true
    state?: true
    coreID?: true
    skillID1?: true
    skillID2?: true
    skillID3?: true
    level?: true
    maxLevel?: true
    experience?: true
    crc?: true
    slot?: true
  }

  export type MatrixskillMaxAggregateInputType = {
    id?: true
    charid?: true
    state?: true
    coreID?: true
    skillID1?: true
    skillID2?: true
    skillID3?: true
    level?: true
    maxLevel?: true
    experience?: true
    crc?: true
    slot?: true
  }

  export type MatrixskillCountAggregateInputType = {
    id?: true
    charid?: true
    state?: true
    coreID?: true
    skillID1?: true
    skillID2?: true
    skillID3?: true
    level?: true
    maxLevel?: true
    experience?: true
    crc?: true
    slot?: true
    _all?: true
  }

  export type MatrixskillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which matrixskill to aggregate.
     */
    where?: matrixskillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of matrixskills to fetch.
     */
    orderBy?: matrixskillOrderByWithRelationInput | matrixskillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: matrixskillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` matrixskills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` matrixskills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned matrixskills
    **/
    _count?: true | MatrixskillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MatrixskillAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MatrixskillSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MatrixskillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MatrixskillMaxAggregateInputType
  }

  export type GetMatrixskillAggregateType<T extends MatrixskillAggregateArgs> = {
        [P in keyof T & keyof AggregateMatrixskill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMatrixskill[P]>
      : GetScalarType<T[P], AggregateMatrixskill[P]>
  }




  export type matrixskillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: matrixskillWhereInput
    orderBy?: matrixskillOrderByWithAggregationInput | matrixskillOrderByWithAggregationInput[]
    by: MatrixskillScalarFieldEnum[] | MatrixskillScalarFieldEnum
    having?: matrixskillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MatrixskillCountAggregateInputType | true
    _avg?: MatrixskillAvgAggregateInputType
    _sum?: MatrixskillSumAggregateInputType
    _min?: MatrixskillMinAggregateInputType
    _max?: MatrixskillMaxAggregateInputType
  }

  export type MatrixskillGroupByOutputType = {
    id: number
    charid: number
    state: boolean
    coreID: number
    skillID1: number
    skillID2: number
    skillID3: number
    level: number
    maxLevel: number
    experience: number
    crc: bigint
    slot: number
    _count: MatrixskillCountAggregateOutputType | null
    _avg: MatrixskillAvgAggregateOutputType | null
    _sum: MatrixskillSumAggregateOutputType | null
    _min: MatrixskillMinAggregateOutputType | null
    _max: MatrixskillMaxAggregateOutputType | null
  }

  type GetMatrixskillGroupByPayload<T extends matrixskillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MatrixskillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MatrixskillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MatrixskillGroupByOutputType[P]>
            : GetScalarType<T[P], MatrixskillGroupByOutputType[P]>
        }
      >
    >


  export type matrixskillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    charid?: boolean
    state?: boolean
    coreID?: boolean
    skillID1?: boolean
    skillID2?: boolean
    skillID3?: boolean
    level?: boolean
    maxLevel?: boolean
    experience?: boolean
    crc?: boolean
    slot?: boolean
  }, ExtArgs["result"]["matrixskill"]>


  export type matrixskillSelectScalar = {
    id?: boolean
    charid?: boolean
    state?: boolean
    coreID?: boolean
    skillID1?: boolean
    skillID2?: boolean
    skillID3?: boolean
    level?: boolean
    maxLevel?: boolean
    experience?: boolean
    crc?: boolean
    slot?: boolean
  }


  export type $matrixskillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "matrixskill"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      charid: number
      state: boolean
      coreID: number
      skillID1: number
      skillID2: number
      skillID3: number
      level: number
      maxLevel: number
      experience: number
      crc: bigint
      slot: number
    }, ExtArgs["result"]["matrixskill"]>
    composites: {}
  }

  type matrixskillGetPayload<S extends boolean | null | undefined | matrixskillDefaultArgs> = $Result.GetResult<Prisma.$matrixskillPayload, S>

  type matrixskillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<matrixskillFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MatrixskillCountAggregateInputType | true
    }

  export interface matrixskillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['matrixskill'], meta: { name: 'matrixskill' } }
    /**
     * Find zero or one Matrixskill that matches the filter.
     * @param {matrixskillFindUniqueArgs} args - Arguments to find a Matrixskill
     * @example
     * // Get one Matrixskill
     * const matrixskill = await prisma.matrixskill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends matrixskillFindUniqueArgs>(args: SelectSubset<T, matrixskillFindUniqueArgs<ExtArgs>>): Prisma__matrixskillClient<$Result.GetResult<Prisma.$matrixskillPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Matrixskill that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {matrixskillFindUniqueOrThrowArgs} args - Arguments to find a Matrixskill
     * @example
     * // Get one Matrixskill
     * const matrixskill = await prisma.matrixskill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends matrixskillFindUniqueOrThrowArgs>(args: SelectSubset<T, matrixskillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__matrixskillClient<$Result.GetResult<Prisma.$matrixskillPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Matrixskill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {matrixskillFindFirstArgs} args - Arguments to find a Matrixskill
     * @example
     * // Get one Matrixskill
     * const matrixskill = await prisma.matrixskill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends matrixskillFindFirstArgs>(args?: SelectSubset<T, matrixskillFindFirstArgs<ExtArgs>>): Prisma__matrixskillClient<$Result.GetResult<Prisma.$matrixskillPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Matrixskill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {matrixskillFindFirstOrThrowArgs} args - Arguments to find a Matrixskill
     * @example
     * // Get one Matrixskill
     * const matrixskill = await prisma.matrixskill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends matrixskillFindFirstOrThrowArgs>(args?: SelectSubset<T, matrixskillFindFirstOrThrowArgs<ExtArgs>>): Prisma__matrixskillClient<$Result.GetResult<Prisma.$matrixskillPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Matrixskills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {matrixskillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Matrixskills
     * const matrixskills = await prisma.matrixskill.findMany()
     * 
     * // Get first 10 Matrixskills
     * const matrixskills = await prisma.matrixskill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const matrixskillWithIdOnly = await prisma.matrixskill.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends matrixskillFindManyArgs>(args?: SelectSubset<T, matrixskillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$matrixskillPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Matrixskill.
     * @param {matrixskillCreateArgs} args - Arguments to create a Matrixskill.
     * @example
     * // Create one Matrixskill
     * const Matrixskill = await prisma.matrixskill.create({
     *   data: {
     *     // ... data to create a Matrixskill
     *   }
     * })
     * 
     */
    create<T extends matrixskillCreateArgs>(args: SelectSubset<T, matrixskillCreateArgs<ExtArgs>>): Prisma__matrixskillClient<$Result.GetResult<Prisma.$matrixskillPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Matrixskills.
     * @param {matrixskillCreateManyArgs} args - Arguments to create many Matrixskills.
     * @example
     * // Create many Matrixskills
     * const matrixskill = await prisma.matrixskill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends matrixskillCreateManyArgs>(args?: SelectSubset<T, matrixskillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Matrixskill.
     * @param {matrixskillDeleteArgs} args - Arguments to delete one Matrixskill.
     * @example
     * // Delete one Matrixskill
     * const Matrixskill = await prisma.matrixskill.delete({
     *   where: {
     *     // ... filter to delete one Matrixskill
     *   }
     * })
     * 
     */
    delete<T extends matrixskillDeleteArgs>(args: SelectSubset<T, matrixskillDeleteArgs<ExtArgs>>): Prisma__matrixskillClient<$Result.GetResult<Prisma.$matrixskillPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Matrixskill.
     * @param {matrixskillUpdateArgs} args - Arguments to update one Matrixskill.
     * @example
     * // Update one Matrixskill
     * const matrixskill = await prisma.matrixskill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends matrixskillUpdateArgs>(args: SelectSubset<T, matrixskillUpdateArgs<ExtArgs>>): Prisma__matrixskillClient<$Result.GetResult<Prisma.$matrixskillPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Matrixskills.
     * @param {matrixskillDeleteManyArgs} args - Arguments to filter Matrixskills to delete.
     * @example
     * // Delete a few Matrixskills
     * const { count } = await prisma.matrixskill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends matrixskillDeleteManyArgs>(args?: SelectSubset<T, matrixskillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Matrixskills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {matrixskillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Matrixskills
     * const matrixskill = await prisma.matrixskill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends matrixskillUpdateManyArgs>(args: SelectSubset<T, matrixskillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Matrixskill.
     * @param {matrixskillUpsertArgs} args - Arguments to update or create a Matrixskill.
     * @example
     * // Update or create a Matrixskill
     * const matrixskill = await prisma.matrixskill.upsert({
     *   create: {
     *     // ... data to create a Matrixskill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Matrixskill we want to update
     *   }
     * })
     */
    upsert<T extends matrixskillUpsertArgs>(args: SelectSubset<T, matrixskillUpsertArgs<ExtArgs>>): Prisma__matrixskillClient<$Result.GetResult<Prisma.$matrixskillPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Matrixskills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {matrixskillCountArgs} args - Arguments to filter Matrixskills to count.
     * @example
     * // Count the number of Matrixskills
     * const count = await prisma.matrixskill.count({
     *   where: {
     *     // ... the filter for the Matrixskills we want to count
     *   }
     * })
    **/
    count<T extends matrixskillCountArgs>(
      args?: Subset<T, matrixskillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MatrixskillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Matrixskill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatrixskillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MatrixskillAggregateArgs>(args: Subset<T, MatrixskillAggregateArgs>): Prisma.PrismaPromise<GetMatrixskillAggregateType<T>>

    /**
     * Group by Matrixskill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {matrixskillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends matrixskillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: matrixskillGroupByArgs['orderBy'] }
        : { orderBy?: matrixskillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, matrixskillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMatrixskillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the matrixskill model
   */
  readonly fields: matrixskillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for matrixskill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__matrixskillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the matrixskill model
   */ 
  interface matrixskillFieldRefs {
    readonly id: FieldRef<"matrixskill", 'Int'>
    readonly charid: FieldRef<"matrixskill", 'Int'>
    readonly state: FieldRef<"matrixskill", 'Boolean'>
    readonly coreID: FieldRef<"matrixskill", 'Int'>
    readonly skillID1: FieldRef<"matrixskill", 'Int'>
    readonly skillID2: FieldRef<"matrixskill", 'Int'>
    readonly skillID3: FieldRef<"matrixskill", 'Int'>
    readonly level: FieldRef<"matrixskill", 'Int'>
    readonly maxLevel: FieldRef<"matrixskill", 'Int'>
    readonly experience: FieldRef<"matrixskill", 'Int'>
    readonly crc: FieldRef<"matrixskill", 'BigInt'>
    readonly slot: FieldRef<"matrixskill", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * matrixskill findUnique
   */
  export type matrixskillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the matrixskill
     */
    select?: matrixskillSelect<ExtArgs> | null
    /**
     * Filter, which matrixskill to fetch.
     */
    where: matrixskillWhereUniqueInput
  }

  /**
   * matrixskill findUniqueOrThrow
   */
  export type matrixskillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the matrixskill
     */
    select?: matrixskillSelect<ExtArgs> | null
    /**
     * Filter, which matrixskill to fetch.
     */
    where: matrixskillWhereUniqueInput
  }

  /**
   * matrixskill findFirst
   */
  export type matrixskillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the matrixskill
     */
    select?: matrixskillSelect<ExtArgs> | null
    /**
     * Filter, which matrixskill to fetch.
     */
    where?: matrixskillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of matrixskills to fetch.
     */
    orderBy?: matrixskillOrderByWithRelationInput | matrixskillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for matrixskills.
     */
    cursor?: matrixskillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` matrixskills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` matrixskills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of matrixskills.
     */
    distinct?: MatrixskillScalarFieldEnum | MatrixskillScalarFieldEnum[]
  }

  /**
   * matrixskill findFirstOrThrow
   */
  export type matrixskillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the matrixskill
     */
    select?: matrixskillSelect<ExtArgs> | null
    /**
     * Filter, which matrixskill to fetch.
     */
    where?: matrixskillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of matrixskills to fetch.
     */
    orderBy?: matrixskillOrderByWithRelationInput | matrixskillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for matrixskills.
     */
    cursor?: matrixskillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` matrixskills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` matrixskills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of matrixskills.
     */
    distinct?: MatrixskillScalarFieldEnum | MatrixskillScalarFieldEnum[]
  }

  /**
   * matrixskill findMany
   */
  export type matrixskillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the matrixskill
     */
    select?: matrixskillSelect<ExtArgs> | null
    /**
     * Filter, which matrixskills to fetch.
     */
    where?: matrixskillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of matrixskills to fetch.
     */
    orderBy?: matrixskillOrderByWithRelationInput | matrixskillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing matrixskills.
     */
    cursor?: matrixskillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` matrixskills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` matrixskills.
     */
    skip?: number
    distinct?: MatrixskillScalarFieldEnum | MatrixskillScalarFieldEnum[]
  }

  /**
   * matrixskill create
   */
  export type matrixskillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the matrixskill
     */
    select?: matrixskillSelect<ExtArgs> | null
    /**
     * The data needed to create a matrixskill.
     */
    data?: XOR<matrixskillCreateInput, matrixskillUncheckedCreateInput>
  }

  /**
   * matrixskill createMany
   */
  export type matrixskillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many matrixskills.
     */
    data: matrixskillCreateManyInput | matrixskillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * matrixskill update
   */
  export type matrixskillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the matrixskill
     */
    select?: matrixskillSelect<ExtArgs> | null
    /**
     * The data needed to update a matrixskill.
     */
    data: XOR<matrixskillUpdateInput, matrixskillUncheckedUpdateInput>
    /**
     * Choose, which matrixskill to update.
     */
    where: matrixskillWhereUniqueInput
  }

  /**
   * matrixskill updateMany
   */
  export type matrixskillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update matrixskills.
     */
    data: XOR<matrixskillUpdateManyMutationInput, matrixskillUncheckedUpdateManyInput>
    /**
     * Filter which matrixskills to update
     */
    where?: matrixskillWhereInput
  }

  /**
   * matrixskill upsert
   */
  export type matrixskillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the matrixskill
     */
    select?: matrixskillSelect<ExtArgs> | null
    /**
     * The filter to search for the matrixskill to update in case it exists.
     */
    where: matrixskillWhereUniqueInput
    /**
     * In case the matrixskill found by the `where` argument doesn't exist, create a new matrixskill with this data.
     */
    create: XOR<matrixskillCreateInput, matrixskillUncheckedCreateInput>
    /**
     * In case the matrixskill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<matrixskillUpdateInput, matrixskillUncheckedUpdateInput>
  }

  /**
   * matrixskill delete
   */
  export type matrixskillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the matrixskill
     */
    select?: matrixskillSelect<ExtArgs> | null
    /**
     * Filter which matrixskill to delete.
     */
    where: matrixskillWhereUniqueInput
  }

  /**
   * matrixskill deleteMany
   */
  export type matrixskillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which matrixskills to delete
     */
    where?: matrixskillWhereInput
  }

  /**
   * matrixskill without action
   */
  export type matrixskillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the matrixskill
     */
    select?: matrixskillSelect<ExtArgs> | null
  }


  /**
   * Model medals
   */

  export type AggregateMedals = {
    _count: MedalsCountAggregateOutputType | null
    _avg: MedalsAvgAggregateOutputType | null
    _sum: MedalsSumAggregateOutputType | null
    _min: MedalsMinAggregateOutputType | null
    _max: MedalsMaxAggregateOutputType | null
  }

  export type MedalsAvgAggregateOutputType = {
    id: number | null
    charid: number | null
    questid: number | null
    itemid: number | null
  }

  export type MedalsSumAggregateOutputType = {
    id: bigint | null
    charid: number | null
    questid: number | null
    itemid: number | null
  }

  export type MedalsMinAggregateOutputType = {
    id: bigint | null
    charid: number | null
    questid: number | null
    itemid: number | null
    completedtime: Date | null
  }

  export type MedalsMaxAggregateOutputType = {
    id: bigint | null
    charid: number | null
    questid: number | null
    itemid: number | null
    completedtime: Date | null
  }

  export type MedalsCountAggregateOutputType = {
    id: number
    charid: number
    questid: number
    itemid: number
    completedtime: number
    _all: number
  }


  export type MedalsAvgAggregateInputType = {
    id?: true
    charid?: true
    questid?: true
    itemid?: true
  }

  export type MedalsSumAggregateInputType = {
    id?: true
    charid?: true
    questid?: true
    itemid?: true
  }

  export type MedalsMinAggregateInputType = {
    id?: true
    charid?: true
    questid?: true
    itemid?: true
    completedtime?: true
  }

  export type MedalsMaxAggregateInputType = {
    id?: true
    charid?: true
    questid?: true
    itemid?: true
    completedtime?: true
  }

  export type MedalsCountAggregateInputType = {
    id?: true
    charid?: true
    questid?: true
    itemid?: true
    completedtime?: true
    _all?: true
  }

  export type MedalsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which medals to aggregate.
     */
    where?: medalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of medals to fetch.
     */
    orderBy?: medalsOrderByWithRelationInput | medalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: medalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` medals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` medals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned medals
    **/
    _count?: true | MedalsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MedalsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MedalsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MedalsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MedalsMaxAggregateInputType
  }

  export type GetMedalsAggregateType<T extends MedalsAggregateArgs> = {
        [P in keyof T & keyof AggregateMedals]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedals[P]>
      : GetScalarType<T[P], AggregateMedals[P]>
  }




  export type medalsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: medalsWhereInput
    orderBy?: medalsOrderByWithAggregationInput | medalsOrderByWithAggregationInput[]
    by: MedalsScalarFieldEnum[] | MedalsScalarFieldEnum
    having?: medalsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MedalsCountAggregateInputType | true
    _avg?: MedalsAvgAggregateInputType
    _sum?: MedalsSumAggregateInputType
    _min?: MedalsMinAggregateInputType
    _max?: MedalsMaxAggregateInputType
  }

  export type MedalsGroupByOutputType = {
    id: bigint
    charid: number | null
    questid: number | null
    itemid: number | null
    completedtime: Date | null
    _count: MedalsCountAggregateOutputType | null
    _avg: MedalsAvgAggregateOutputType | null
    _sum: MedalsSumAggregateOutputType | null
    _min: MedalsMinAggregateOutputType | null
    _max: MedalsMaxAggregateOutputType | null
  }

  type GetMedalsGroupByPayload<T extends medalsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MedalsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MedalsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MedalsGroupByOutputType[P]>
            : GetScalarType<T[P], MedalsGroupByOutputType[P]>
        }
      >
    >


  export type medalsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    charid?: boolean
    questid?: boolean
    itemid?: boolean
    completedtime?: boolean
  }, ExtArgs["result"]["medals"]>


  export type medalsSelectScalar = {
    id?: boolean
    charid?: boolean
    questid?: boolean
    itemid?: boolean
    completedtime?: boolean
  }


  export type $medalsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "medals"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      charid: number | null
      questid: number | null
      itemid: number | null
      completedtime: Date | null
    }, ExtArgs["result"]["medals"]>
    composites: {}
  }

  type medalsGetPayload<S extends boolean | null | undefined | medalsDefaultArgs> = $Result.GetResult<Prisma.$medalsPayload, S>

  type medalsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<medalsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MedalsCountAggregateInputType | true
    }

  export interface medalsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['medals'], meta: { name: 'medals' } }
    /**
     * Find zero or one Medals that matches the filter.
     * @param {medalsFindUniqueArgs} args - Arguments to find a Medals
     * @example
     * // Get one Medals
     * const medals = await prisma.medals.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends medalsFindUniqueArgs>(args: SelectSubset<T, medalsFindUniqueArgs<ExtArgs>>): Prisma__medalsClient<$Result.GetResult<Prisma.$medalsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Medals that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {medalsFindUniqueOrThrowArgs} args - Arguments to find a Medals
     * @example
     * // Get one Medals
     * const medals = await prisma.medals.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends medalsFindUniqueOrThrowArgs>(args: SelectSubset<T, medalsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__medalsClient<$Result.GetResult<Prisma.$medalsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Medals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medalsFindFirstArgs} args - Arguments to find a Medals
     * @example
     * // Get one Medals
     * const medals = await prisma.medals.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends medalsFindFirstArgs>(args?: SelectSubset<T, medalsFindFirstArgs<ExtArgs>>): Prisma__medalsClient<$Result.GetResult<Prisma.$medalsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Medals that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medalsFindFirstOrThrowArgs} args - Arguments to find a Medals
     * @example
     * // Get one Medals
     * const medals = await prisma.medals.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends medalsFindFirstOrThrowArgs>(args?: SelectSubset<T, medalsFindFirstOrThrowArgs<ExtArgs>>): Prisma__medalsClient<$Result.GetResult<Prisma.$medalsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Medals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medalsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Medals
     * const medals = await prisma.medals.findMany()
     * 
     * // Get first 10 Medals
     * const medals = await prisma.medals.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const medalsWithIdOnly = await prisma.medals.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends medalsFindManyArgs>(args?: SelectSubset<T, medalsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$medalsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Medals.
     * @param {medalsCreateArgs} args - Arguments to create a Medals.
     * @example
     * // Create one Medals
     * const Medals = await prisma.medals.create({
     *   data: {
     *     // ... data to create a Medals
     *   }
     * })
     * 
     */
    create<T extends medalsCreateArgs>(args: SelectSubset<T, medalsCreateArgs<ExtArgs>>): Prisma__medalsClient<$Result.GetResult<Prisma.$medalsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Medals.
     * @param {medalsCreateManyArgs} args - Arguments to create many Medals.
     * @example
     * // Create many Medals
     * const medals = await prisma.medals.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends medalsCreateManyArgs>(args?: SelectSubset<T, medalsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Medals.
     * @param {medalsDeleteArgs} args - Arguments to delete one Medals.
     * @example
     * // Delete one Medals
     * const Medals = await prisma.medals.delete({
     *   where: {
     *     // ... filter to delete one Medals
     *   }
     * })
     * 
     */
    delete<T extends medalsDeleteArgs>(args: SelectSubset<T, medalsDeleteArgs<ExtArgs>>): Prisma__medalsClient<$Result.GetResult<Prisma.$medalsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Medals.
     * @param {medalsUpdateArgs} args - Arguments to update one Medals.
     * @example
     * // Update one Medals
     * const medals = await prisma.medals.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends medalsUpdateArgs>(args: SelectSubset<T, medalsUpdateArgs<ExtArgs>>): Prisma__medalsClient<$Result.GetResult<Prisma.$medalsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Medals.
     * @param {medalsDeleteManyArgs} args - Arguments to filter Medals to delete.
     * @example
     * // Delete a few Medals
     * const { count } = await prisma.medals.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends medalsDeleteManyArgs>(args?: SelectSubset<T, medalsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Medals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medalsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Medals
     * const medals = await prisma.medals.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends medalsUpdateManyArgs>(args: SelectSubset<T, medalsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Medals.
     * @param {medalsUpsertArgs} args - Arguments to update or create a Medals.
     * @example
     * // Update or create a Medals
     * const medals = await prisma.medals.upsert({
     *   create: {
     *     // ... data to create a Medals
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Medals we want to update
     *   }
     * })
     */
    upsert<T extends medalsUpsertArgs>(args: SelectSubset<T, medalsUpsertArgs<ExtArgs>>): Prisma__medalsClient<$Result.GetResult<Prisma.$medalsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Medals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medalsCountArgs} args - Arguments to filter Medals to count.
     * @example
     * // Count the number of Medals
     * const count = await prisma.medals.count({
     *   where: {
     *     // ... the filter for the Medals we want to count
     *   }
     * })
    **/
    count<T extends medalsCountArgs>(
      args?: Subset<T, medalsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MedalsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Medals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedalsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MedalsAggregateArgs>(args: Subset<T, MedalsAggregateArgs>): Prisma.PrismaPromise<GetMedalsAggregateType<T>>

    /**
     * Group by Medals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medalsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends medalsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: medalsGroupByArgs['orderBy'] }
        : { orderBy?: medalsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, medalsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedalsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the medals model
   */
  readonly fields: medalsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for medals.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__medalsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the medals model
   */ 
  interface medalsFieldRefs {
    readonly id: FieldRef<"medals", 'BigInt'>
    readonly charid: FieldRef<"medals", 'Int'>
    readonly questid: FieldRef<"medals", 'Int'>
    readonly itemid: FieldRef<"medals", 'Int'>
    readonly completedtime: FieldRef<"medals", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * medals findUnique
   */
  export type medalsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medals
     */
    select?: medalsSelect<ExtArgs> | null
    /**
     * Filter, which medals to fetch.
     */
    where: medalsWhereUniqueInput
  }

  /**
   * medals findUniqueOrThrow
   */
  export type medalsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medals
     */
    select?: medalsSelect<ExtArgs> | null
    /**
     * Filter, which medals to fetch.
     */
    where: medalsWhereUniqueInput
  }

  /**
   * medals findFirst
   */
  export type medalsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medals
     */
    select?: medalsSelect<ExtArgs> | null
    /**
     * Filter, which medals to fetch.
     */
    where?: medalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of medals to fetch.
     */
    orderBy?: medalsOrderByWithRelationInput | medalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for medals.
     */
    cursor?: medalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` medals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` medals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of medals.
     */
    distinct?: MedalsScalarFieldEnum | MedalsScalarFieldEnum[]
  }

  /**
   * medals findFirstOrThrow
   */
  export type medalsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medals
     */
    select?: medalsSelect<ExtArgs> | null
    /**
     * Filter, which medals to fetch.
     */
    where?: medalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of medals to fetch.
     */
    orderBy?: medalsOrderByWithRelationInput | medalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for medals.
     */
    cursor?: medalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` medals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` medals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of medals.
     */
    distinct?: MedalsScalarFieldEnum | MedalsScalarFieldEnum[]
  }

  /**
   * medals findMany
   */
  export type medalsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medals
     */
    select?: medalsSelect<ExtArgs> | null
    /**
     * Filter, which medals to fetch.
     */
    where?: medalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of medals to fetch.
     */
    orderBy?: medalsOrderByWithRelationInput | medalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing medals.
     */
    cursor?: medalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` medals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` medals.
     */
    skip?: number
    distinct?: MedalsScalarFieldEnum | MedalsScalarFieldEnum[]
  }

  /**
   * medals create
   */
  export type medalsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medals
     */
    select?: medalsSelect<ExtArgs> | null
    /**
     * The data needed to create a medals.
     */
    data?: XOR<medalsCreateInput, medalsUncheckedCreateInput>
  }

  /**
   * medals createMany
   */
  export type medalsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many medals.
     */
    data: medalsCreateManyInput | medalsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * medals update
   */
  export type medalsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medals
     */
    select?: medalsSelect<ExtArgs> | null
    /**
     * The data needed to update a medals.
     */
    data: XOR<medalsUpdateInput, medalsUncheckedUpdateInput>
    /**
     * Choose, which medals to update.
     */
    where: medalsWhereUniqueInput
  }

  /**
   * medals updateMany
   */
  export type medalsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update medals.
     */
    data: XOR<medalsUpdateManyMutationInput, medalsUncheckedUpdateManyInput>
    /**
     * Filter which medals to update
     */
    where?: medalsWhereInput
  }

  /**
   * medals upsert
   */
  export type medalsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medals
     */
    select?: medalsSelect<ExtArgs> | null
    /**
     * The filter to search for the medals to update in case it exists.
     */
    where: medalsWhereUniqueInput
    /**
     * In case the medals found by the `where` argument doesn't exist, create a new medals with this data.
     */
    create: XOR<medalsCreateInput, medalsUncheckedCreateInput>
    /**
     * In case the medals was found with the provided `where` argument, update it with this data.
     */
    update: XOR<medalsUpdateInput, medalsUncheckedUpdateInput>
  }

  /**
   * medals delete
   */
  export type medalsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medals
     */
    select?: medalsSelect<ExtArgs> | null
    /**
     * Filter which medals to delete.
     */
    where: medalsWhereUniqueInput
  }

  /**
   * medals deleteMany
   */
  export type medalsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which medals to delete
     */
    where?: medalsWhereInput
  }

  /**
   * medals without action
   */
  export type medalsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medals
     */
    select?: medalsSelect<ExtArgs> | null
  }


  /**
   * Model mob_drops
   */

  export type AggregateMob_drops = {
    _count: Mob_dropsCountAggregateOutputType | null
    _avg: Mob_dropsAvgAggregateOutputType | null
    _sum: Mob_dropsSumAggregateOutputType | null
    _min: Mob_dropsMinAggregateOutputType | null
    _max: Mob_dropsMaxAggregateOutputType | null
  }

  export type Mob_dropsAvgAggregateOutputType = {
    id: number | null
    mobid: number | null
    itemid: number | null
    chance: number | null
    minquant: number | null
    maxquant: number | null
    reactordrop: number | null
  }

  export type Mob_dropsSumAggregateOutputType = {
    id: bigint | null
    mobid: number | null
    itemid: number | null
    chance: number | null
    minquant: number | null
    maxquant: number | null
    reactordrop: number | null
  }

  export type Mob_dropsMinAggregateOutputType = {
    id: bigint | null
    mobid: number | null
    itemid: number | null
    chance: number | null
    minquant: number | null
    maxquant: number | null
    reactordrop: number | null
  }

  export type Mob_dropsMaxAggregateOutputType = {
    id: bigint | null
    mobid: number | null
    itemid: number | null
    chance: number | null
    minquant: number | null
    maxquant: number | null
    reactordrop: number | null
  }

  export type Mob_dropsCountAggregateOutputType = {
    id: number
    mobid: number
    itemid: number
    chance: number
    minquant: number
    maxquant: number
    reactordrop: number
    _all: number
  }


  export type Mob_dropsAvgAggregateInputType = {
    id?: true
    mobid?: true
    itemid?: true
    chance?: true
    minquant?: true
    maxquant?: true
    reactordrop?: true
  }

  export type Mob_dropsSumAggregateInputType = {
    id?: true
    mobid?: true
    itemid?: true
    chance?: true
    minquant?: true
    maxquant?: true
    reactordrop?: true
  }

  export type Mob_dropsMinAggregateInputType = {
    id?: true
    mobid?: true
    itemid?: true
    chance?: true
    minquant?: true
    maxquant?: true
    reactordrop?: true
  }

  export type Mob_dropsMaxAggregateInputType = {
    id?: true
    mobid?: true
    itemid?: true
    chance?: true
    minquant?: true
    maxquant?: true
    reactordrop?: true
  }

  export type Mob_dropsCountAggregateInputType = {
    id?: true
    mobid?: true
    itemid?: true
    chance?: true
    minquant?: true
    maxquant?: true
    reactordrop?: true
    _all?: true
  }

  export type Mob_dropsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which mob_drops to aggregate.
     */
    where?: mob_dropsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mob_drops to fetch.
     */
    orderBy?: mob_dropsOrderByWithRelationInput | mob_dropsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: mob_dropsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mob_drops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mob_drops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned mob_drops
    **/
    _count?: true | Mob_dropsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Mob_dropsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Mob_dropsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Mob_dropsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Mob_dropsMaxAggregateInputType
  }

  export type GetMob_dropsAggregateType<T extends Mob_dropsAggregateArgs> = {
        [P in keyof T & keyof AggregateMob_drops]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMob_drops[P]>
      : GetScalarType<T[P], AggregateMob_drops[P]>
  }




  export type mob_dropsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: mob_dropsWhereInput
    orderBy?: mob_dropsOrderByWithAggregationInput | mob_dropsOrderByWithAggregationInput[]
    by: Mob_dropsScalarFieldEnum[] | Mob_dropsScalarFieldEnum
    having?: mob_dropsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Mob_dropsCountAggregateInputType | true
    _avg?: Mob_dropsAvgAggregateInputType
    _sum?: Mob_dropsSumAggregateInputType
    _min?: Mob_dropsMinAggregateInputType
    _max?: Mob_dropsMaxAggregateInputType
  }

  export type Mob_dropsGroupByOutputType = {
    id: bigint
    mobid: number | null
    itemid: number | null
    chance: number | null
    minquant: number | null
    maxquant: number | null
    reactordrop: number | null
    _count: Mob_dropsCountAggregateOutputType | null
    _avg: Mob_dropsAvgAggregateOutputType | null
    _sum: Mob_dropsSumAggregateOutputType | null
    _min: Mob_dropsMinAggregateOutputType | null
    _max: Mob_dropsMaxAggregateOutputType | null
  }

  type GetMob_dropsGroupByPayload<T extends mob_dropsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Mob_dropsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Mob_dropsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Mob_dropsGroupByOutputType[P]>
            : GetScalarType<T[P], Mob_dropsGroupByOutputType[P]>
        }
      >
    >


  export type mob_dropsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mobid?: boolean
    itemid?: boolean
    chance?: boolean
    minquant?: boolean
    maxquant?: boolean
    reactordrop?: boolean
  }, ExtArgs["result"]["mob_drops"]>


  export type mob_dropsSelectScalar = {
    id?: boolean
    mobid?: boolean
    itemid?: boolean
    chance?: boolean
    minquant?: boolean
    maxquant?: boolean
    reactordrop?: boolean
  }


  export type $mob_dropsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "mob_drops"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      mobid: number | null
      itemid: number | null
      chance: number | null
      minquant: number | null
      maxquant: number | null
      reactordrop: number | null
    }, ExtArgs["result"]["mob_drops"]>
    composites: {}
  }

  type mob_dropsGetPayload<S extends boolean | null | undefined | mob_dropsDefaultArgs> = $Result.GetResult<Prisma.$mob_dropsPayload, S>

  type mob_dropsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<mob_dropsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Mob_dropsCountAggregateInputType | true
    }

  export interface mob_dropsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['mob_drops'], meta: { name: 'mob_drops' } }
    /**
     * Find zero or one Mob_drops that matches the filter.
     * @param {mob_dropsFindUniqueArgs} args - Arguments to find a Mob_drops
     * @example
     * // Get one Mob_drops
     * const mob_drops = await prisma.mob_drops.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends mob_dropsFindUniqueArgs>(args: SelectSubset<T, mob_dropsFindUniqueArgs<ExtArgs>>): Prisma__mob_dropsClient<$Result.GetResult<Prisma.$mob_dropsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Mob_drops that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {mob_dropsFindUniqueOrThrowArgs} args - Arguments to find a Mob_drops
     * @example
     * // Get one Mob_drops
     * const mob_drops = await prisma.mob_drops.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends mob_dropsFindUniqueOrThrowArgs>(args: SelectSubset<T, mob_dropsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__mob_dropsClient<$Result.GetResult<Prisma.$mob_dropsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Mob_drops that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mob_dropsFindFirstArgs} args - Arguments to find a Mob_drops
     * @example
     * // Get one Mob_drops
     * const mob_drops = await prisma.mob_drops.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends mob_dropsFindFirstArgs>(args?: SelectSubset<T, mob_dropsFindFirstArgs<ExtArgs>>): Prisma__mob_dropsClient<$Result.GetResult<Prisma.$mob_dropsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Mob_drops that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mob_dropsFindFirstOrThrowArgs} args - Arguments to find a Mob_drops
     * @example
     * // Get one Mob_drops
     * const mob_drops = await prisma.mob_drops.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends mob_dropsFindFirstOrThrowArgs>(args?: SelectSubset<T, mob_dropsFindFirstOrThrowArgs<ExtArgs>>): Prisma__mob_dropsClient<$Result.GetResult<Prisma.$mob_dropsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Mob_drops that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mob_dropsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mob_drops
     * const mob_drops = await prisma.mob_drops.findMany()
     * 
     * // Get first 10 Mob_drops
     * const mob_drops = await prisma.mob_drops.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mob_dropsWithIdOnly = await prisma.mob_drops.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends mob_dropsFindManyArgs>(args?: SelectSubset<T, mob_dropsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mob_dropsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Mob_drops.
     * @param {mob_dropsCreateArgs} args - Arguments to create a Mob_drops.
     * @example
     * // Create one Mob_drops
     * const Mob_drops = await prisma.mob_drops.create({
     *   data: {
     *     // ... data to create a Mob_drops
     *   }
     * })
     * 
     */
    create<T extends mob_dropsCreateArgs>(args: SelectSubset<T, mob_dropsCreateArgs<ExtArgs>>): Prisma__mob_dropsClient<$Result.GetResult<Prisma.$mob_dropsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Mob_drops.
     * @param {mob_dropsCreateManyArgs} args - Arguments to create many Mob_drops.
     * @example
     * // Create many Mob_drops
     * const mob_drops = await prisma.mob_drops.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends mob_dropsCreateManyArgs>(args?: SelectSubset<T, mob_dropsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Mob_drops.
     * @param {mob_dropsDeleteArgs} args - Arguments to delete one Mob_drops.
     * @example
     * // Delete one Mob_drops
     * const Mob_drops = await prisma.mob_drops.delete({
     *   where: {
     *     // ... filter to delete one Mob_drops
     *   }
     * })
     * 
     */
    delete<T extends mob_dropsDeleteArgs>(args: SelectSubset<T, mob_dropsDeleteArgs<ExtArgs>>): Prisma__mob_dropsClient<$Result.GetResult<Prisma.$mob_dropsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Mob_drops.
     * @param {mob_dropsUpdateArgs} args - Arguments to update one Mob_drops.
     * @example
     * // Update one Mob_drops
     * const mob_drops = await prisma.mob_drops.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends mob_dropsUpdateArgs>(args: SelectSubset<T, mob_dropsUpdateArgs<ExtArgs>>): Prisma__mob_dropsClient<$Result.GetResult<Prisma.$mob_dropsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Mob_drops.
     * @param {mob_dropsDeleteManyArgs} args - Arguments to filter Mob_drops to delete.
     * @example
     * // Delete a few Mob_drops
     * const { count } = await prisma.mob_drops.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends mob_dropsDeleteManyArgs>(args?: SelectSubset<T, mob_dropsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mob_drops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mob_dropsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mob_drops
     * const mob_drops = await prisma.mob_drops.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends mob_dropsUpdateManyArgs>(args: SelectSubset<T, mob_dropsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Mob_drops.
     * @param {mob_dropsUpsertArgs} args - Arguments to update or create a Mob_drops.
     * @example
     * // Update or create a Mob_drops
     * const mob_drops = await prisma.mob_drops.upsert({
     *   create: {
     *     // ... data to create a Mob_drops
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mob_drops we want to update
     *   }
     * })
     */
    upsert<T extends mob_dropsUpsertArgs>(args: SelectSubset<T, mob_dropsUpsertArgs<ExtArgs>>): Prisma__mob_dropsClient<$Result.GetResult<Prisma.$mob_dropsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Mob_drops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mob_dropsCountArgs} args - Arguments to filter Mob_drops to count.
     * @example
     * // Count the number of Mob_drops
     * const count = await prisma.mob_drops.count({
     *   where: {
     *     // ... the filter for the Mob_drops we want to count
     *   }
     * })
    **/
    count<T extends mob_dropsCountArgs>(
      args?: Subset<T, mob_dropsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Mob_dropsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mob_drops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Mob_dropsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Mob_dropsAggregateArgs>(args: Subset<T, Mob_dropsAggregateArgs>): Prisma.PrismaPromise<GetMob_dropsAggregateType<T>>

    /**
     * Group by Mob_drops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mob_dropsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends mob_dropsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: mob_dropsGroupByArgs['orderBy'] }
        : { orderBy?: mob_dropsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, mob_dropsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMob_dropsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the mob_drops model
   */
  readonly fields: mob_dropsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for mob_drops.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__mob_dropsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the mob_drops model
   */ 
  interface mob_dropsFieldRefs {
    readonly id: FieldRef<"mob_drops", 'BigInt'>
    readonly mobid: FieldRef<"mob_drops", 'Int'>
    readonly itemid: FieldRef<"mob_drops", 'Int'>
    readonly chance: FieldRef<"mob_drops", 'Int'>
    readonly minquant: FieldRef<"mob_drops", 'Int'>
    readonly maxquant: FieldRef<"mob_drops", 'Int'>
    readonly reactordrop: FieldRef<"mob_drops", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * mob_drops findUnique
   */
  export type mob_dropsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mob_drops
     */
    select?: mob_dropsSelect<ExtArgs> | null
    /**
     * Filter, which mob_drops to fetch.
     */
    where: mob_dropsWhereUniqueInput
  }

  /**
   * mob_drops findUniqueOrThrow
   */
  export type mob_dropsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mob_drops
     */
    select?: mob_dropsSelect<ExtArgs> | null
    /**
     * Filter, which mob_drops to fetch.
     */
    where: mob_dropsWhereUniqueInput
  }

  /**
   * mob_drops findFirst
   */
  export type mob_dropsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mob_drops
     */
    select?: mob_dropsSelect<ExtArgs> | null
    /**
     * Filter, which mob_drops to fetch.
     */
    where?: mob_dropsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mob_drops to fetch.
     */
    orderBy?: mob_dropsOrderByWithRelationInput | mob_dropsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mob_drops.
     */
    cursor?: mob_dropsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mob_drops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mob_drops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mob_drops.
     */
    distinct?: Mob_dropsScalarFieldEnum | Mob_dropsScalarFieldEnum[]
  }

  /**
   * mob_drops findFirstOrThrow
   */
  export type mob_dropsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mob_drops
     */
    select?: mob_dropsSelect<ExtArgs> | null
    /**
     * Filter, which mob_drops to fetch.
     */
    where?: mob_dropsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mob_drops to fetch.
     */
    orderBy?: mob_dropsOrderByWithRelationInput | mob_dropsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mob_drops.
     */
    cursor?: mob_dropsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mob_drops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mob_drops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mob_drops.
     */
    distinct?: Mob_dropsScalarFieldEnum | Mob_dropsScalarFieldEnum[]
  }

  /**
   * mob_drops findMany
   */
  export type mob_dropsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mob_drops
     */
    select?: mob_dropsSelect<ExtArgs> | null
    /**
     * Filter, which mob_drops to fetch.
     */
    where?: mob_dropsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mob_drops to fetch.
     */
    orderBy?: mob_dropsOrderByWithRelationInput | mob_dropsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing mob_drops.
     */
    cursor?: mob_dropsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mob_drops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mob_drops.
     */
    skip?: number
    distinct?: Mob_dropsScalarFieldEnum | Mob_dropsScalarFieldEnum[]
  }

  /**
   * mob_drops create
   */
  export type mob_dropsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mob_drops
     */
    select?: mob_dropsSelect<ExtArgs> | null
    /**
     * The data needed to create a mob_drops.
     */
    data?: XOR<mob_dropsCreateInput, mob_dropsUncheckedCreateInput>
  }

  /**
   * mob_drops createMany
   */
  export type mob_dropsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many mob_drops.
     */
    data: mob_dropsCreateManyInput | mob_dropsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * mob_drops update
   */
  export type mob_dropsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mob_drops
     */
    select?: mob_dropsSelect<ExtArgs> | null
    /**
     * The data needed to update a mob_drops.
     */
    data: XOR<mob_dropsUpdateInput, mob_dropsUncheckedUpdateInput>
    /**
     * Choose, which mob_drops to update.
     */
    where: mob_dropsWhereUniqueInput
  }

  /**
   * mob_drops updateMany
   */
  export type mob_dropsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update mob_drops.
     */
    data: XOR<mob_dropsUpdateManyMutationInput, mob_dropsUncheckedUpdateManyInput>
    /**
     * Filter which mob_drops to update
     */
    where?: mob_dropsWhereInput
  }

  /**
   * mob_drops upsert
   */
  export type mob_dropsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mob_drops
     */
    select?: mob_dropsSelect<ExtArgs> | null
    /**
     * The filter to search for the mob_drops to update in case it exists.
     */
    where: mob_dropsWhereUniqueInput
    /**
     * In case the mob_drops found by the `where` argument doesn't exist, create a new mob_drops with this data.
     */
    create: XOR<mob_dropsCreateInput, mob_dropsUncheckedCreateInput>
    /**
     * In case the mob_drops was found with the provided `where` argument, update it with this data.
     */
    update: XOR<mob_dropsUpdateInput, mob_dropsUncheckedUpdateInput>
  }

  /**
   * mob_drops delete
   */
  export type mob_dropsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mob_drops
     */
    select?: mob_dropsSelect<ExtArgs> | null
    /**
     * Filter which mob_drops to delete.
     */
    where: mob_dropsWhereUniqueInput
  }

  /**
   * mob_drops deleteMany
   */
  export type mob_dropsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which mob_drops to delete
     */
    where?: mob_dropsWhereInput
  }

  /**
   * mob_drops without action
   */
  export type mob_dropsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mob_drops
     */
    select?: mob_dropsSelect<ExtArgs> | null
  }


  /**
   * Model monster_collection
   */

  export type AggregateMonster_collection = {
    _count: Monster_collectionCountAggregateOutputType | null
    _avg: Monster_collectionAvgAggregateOutputType | null
    _sum: Monster_collectionSumAggregateOutputType | null
    _min: Monster_collectionMinAggregateOutputType | null
    _max: Monster_collectionMaxAggregateOutputType | null
  }

  export type Monster_collectionAvgAggregateOutputType = {
    id: number | null
    mobid: number | null
    region: number | null
    session: number | null
    position: number | null
  }

  export type Monster_collectionSumAggregateOutputType = {
    id: number | null
    mobid: number | null
    region: number | null
    session: number | null
    position: number | null
  }

  export type Monster_collectionMinAggregateOutputType = {
    id: number | null
    mobid: number | null
    region: number | null
    session: number | null
    position: number | null
  }

  export type Monster_collectionMaxAggregateOutputType = {
    id: number | null
    mobid: number | null
    region: number | null
    session: number | null
    position: number | null
  }

  export type Monster_collectionCountAggregateOutputType = {
    id: number
    mobid: number
    region: number
    session: number
    position: number
    _all: number
  }


  export type Monster_collectionAvgAggregateInputType = {
    id?: true
    mobid?: true
    region?: true
    session?: true
    position?: true
  }

  export type Monster_collectionSumAggregateInputType = {
    id?: true
    mobid?: true
    region?: true
    session?: true
    position?: true
  }

  export type Monster_collectionMinAggregateInputType = {
    id?: true
    mobid?: true
    region?: true
    session?: true
    position?: true
  }

  export type Monster_collectionMaxAggregateInputType = {
    id?: true
    mobid?: true
    region?: true
    session?: true
    position?: true
  }

  export type Monster_collectionCountAggregateInputType = {
    id?: true
    mobid?: true
    region?: true
    session?: true
    position?: true
    _all?: true
  }

  export type Monster_collectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which monster_collection to aggregate.
     */
    where?: monster_collectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of monster_collections to fetch.
     */
    orderBy?: monster_collectionOrderByWithRelationInput | monster_collectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: monster_collectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` monster_collections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` monster_collections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned monster_collections
    **/
    _count?: true | Monster_collectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Monster_collectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Monster_collectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Monster_collectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Monster_collectionMaxAggregateInputType
  }

  export type GetMonster_collectionAggregateType<T extends Monster_collectionAggregateArgs> = {
        [P in keyof T & keyof AggregateMonster_collection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMonster_collection[P]>
      : GetScalarType<T[P], AggregateMonster_collection[P]>
  }




  export type monster_collectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: monster_collectionWhereInput
    orderBy?: monster_collectionOrderByWithAggregationInput | monster_collectionOrderByWithAggregationInput[]
    by: Monster_collectionScalarFieldEnum[] | Monster_collectionScalarFieldEnum
    having?: monster_collectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Monster_collectionCountAggregateInputType | true
    _avg?: Monster_collectionAvgAggregateInputType
    _sum?: Monster_collectionSumAggregateInputType
    _min?: Monster_collectionMinAggregateInputType
    _max?: Monster_collectionMaxAggregateInputType
  }

  export type Monster_collectionGroupByOutputType = {
    id: number
    mobid: number | null
    region: number | null
    session: number | null
    position: number | null
    _count: Monster_collectionCountAggregateOutputType | null
    _avg: Monster_collectionAvgAggregateOutputType | null
    _sum: Monster_collectionSumAggregateOutputType | null
    _min: Monster_collectionMinAggregateOutputType | null
    _max: Monster_collectionMaxAggregateOutputType | null
  }

  type GetMonster_collectionGroupByPayload<T extends monster_collectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Monster_collectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Monster_collectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Monster_collectionGroupByOutputType[P]>
            : GetScalarType<T[P], Monster_collectionGroupByOutputType[P]>
        }
      >
    >


  export type monster_collectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mobid?: boolean
    region?: boolean
    session?: boolean
    position?: boolean
  }, ExtArgs["result"]["monster_collection"]>


  export type monster_collectionSelectScalar = {
    id?: boolean
    mobid?: boolean
    region?: boolean
    session?: boolean
    position?: boolean
  }


  export type $monster_collectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "monster_collection"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      mobid: number | null
      region: number | null
      session: number | null
      position: number | null
    }, ExtArgs["result"]["monster_collection"]>
    composites: {}
  }

  type monster_collectionGetPayload<S extends boolean | null | undefined | monster_collectionDefaultArgs> = $Result.GetResult<Prisma.$monster_collectionPayload, S>

  type monster_collectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<monster_collectionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Monster_collectionCountAggregateInputType | true
    }

  export interface monster_collectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['monster_collection'], meta: { name: 'monster_collection' } }
    /**
     * Find zero or one Monster_collection that matches the filter.
     * @param {monster_collectionFindUniqueArgs} args - Arguments to find a Monster_collection
     * @example
     * // Get one Monster_collection
     * const monster_collection = await prisma.monster_collection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends monster_collectionFindUniqueArgs>(args: SelectSubset<T, monster_collectionFindUniqueArgs<ExtArgs>>): Prisma__monster_collectionClient<$Result.GetResult<Prisma.$monster_collectionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Monster_collection that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {monster_collectionFindUniqueOrThrowArgs} args - Arguments to find a Monster_collection
     * @example
     * // Get one Monster_collection
     * const monster_collection = await prisma.monster_collection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends monster_collectionFindUniqueOrThrowArgs>(args: SelectSubset<T, monster_collectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__monster_collectionClient<$Result.GetResult<Prisma.$monster_collectionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Monster_collection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monster_collectionFindFirstArgs} args - Arguments to find a Monster_collection
     * @example
     * // Get one Monster_collection
     * const monster_collection = await prisma.monster_collection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends monster_collectionFindFirstArgs>(args?: SelectSubset<T, monster_collectionFindFirstArgs<ExtArgs>>): Prisma__monster_collectionClient<$Result.GetResult<Prisma.$monster_collectionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Monster_collection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monster_collectionFindFirstOrThrowArgs} args - Arguments to find a Monster_collection
     * @example
     * // Get one Monster_collection
     * const monster_collection = await prisma.monster_collection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends monster_collectionFindFirstOrThrowArgs>(args?: SelectSubset<T, monster_collectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__monster_collectionClient<$Result.GetResult<Prisma.$monster_collectionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Monster_collections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monster_collectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Monster_collections
     * const monster_collections = await prisma.monster_collection.findMany()
     * 
     * // Get first 10 Monster_collections
     * const monster_collections = await prisma.monster_collection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const monster_collectionWithIdOnly = await prisma.monster_collection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends monster_collectionFindManyArgs>(args?: SelectSubset<T, monster_collectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$monster_collectionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Monster_collection.
     * @param {monster_collectionCreateArgs} args - Arguments to create a Monster_collection.
     * @example
     * // Create one Monster_collection
     * const Monster_collection = await prisma.monster_collection.create({
     *   data: {
     *     // ... data to create a Monster_collection
     *   }
     * })
     * 
     */
    create<T extends monster_collectionCreateArgs>(args: SelectSubset<T, monster_collectionCreateArgs<ExtArgs>>): Prisma__monster_collectionClient<$Result.GetResult<Prisma.$monster_collectionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Monster_collections.
     * @param {monster_collectionCreateManyArgs} args - Arguments to create many Monster_collections.
     * @example
     * // Create many Monster_collections
     * const monster_collection = await prisma.monster_collection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends monster_collectionCreateManyArgs>(args?: SelectSubset<T, monster_collectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Monster_collection.
     * @param {monster_collectionDeleteArgs} args - Arguments to delete one Monster_collection.
     * @example
     * // Delete one Monster_collection
     * const Monster_collection = await prisma.monster_collection.delete({
     *   where: {
     *     // ... filter to delete one Monster_collection
     *   }
     * })
     * 
     */
    delete<T extends monster_collectionDeleteArgs>(args: SelectSubset<T, monster_collectionDeleteArgs<ExtArgs>>): Prisma__monster_collectionClient<$Result.GetResult<Prisma.$monster_collectionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Monster_collection.
     * @param {monster_collectionUpdateArgs} args - Arguments to update one Monster_collection.
     * @example
     * // Update one Monster_collection
     * const monster_collection = await prisma.monster_collection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends monster_collectionUpdateArgs>(args: SelectSubset<T, monster_collectionUpdateArgs<ExtArgs>>): Prisma__monster_collectionClient<$Result.GetResult<Prisma.$monster_collectionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Monster_collections.
     * @param {monster_collectionDeleteManyArgs} args - Arguments to filter Monster_collections to delete.
     * @example
     * // Delete a few Monster_collections
     * const { count } = await prisma.monster_collection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends monster_collectionDeleteManyArgs>(args?: SelectSubset<T, monster_collectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Monster_collections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monster_collectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Monster_collections
     * const monster_collection = await prisma.monster_collection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends monster_collectionUpdateManyArgs>(args: SelectSubset<T, monster_collectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Monster_collection.
     * @param {monster_collectionUpsertArgs} args - Arguments to update or create a Monster_collection.
     * @example
     * // Update or create a Monster_collection
     * const monster_collection = await prisma.monster_collection.upsert({
     *   create: {
     *     // ... data to create a Monster_collection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Monster_collection we want to update
     *   }
     * })
     */
    upsert<T extends monster_collectionUpsertArgs>(args: SelectSubset<T, monster_collectionUpsertArgs<ExtArgs>>): Prisma__monster_collectionClient<$Result.GetResult<Prisma.$monster_collectionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Monster_collections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monster_collectionCountArgs} args - Arguments to filter Monster_collections to count.
     * @example
     * // Count the number of Monster_collections
     * const count = await prisma.monster_collection.count({
     *   where: {
     *     // ... the filter for the Monster_collections we want to count
     *   }
     * })
    **/
    count<T extends monster_collectionCountArgs>(
      args?: Subset<T, monster_collectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Monster_collectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Monster_collection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Monster_collectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Monster_collectionAggregateArgs>(args: Subset<T, Monster_collectionAggregateArgs>): Prisma.PrismaPromise<GetMonster_collectionAggregateType<T>>

    /**
     * Group by Monster_collection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monster_collectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends monster_collectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: monster_collectionGroupByArgs['orderBy'] }
        : { orderBy?: monster_collectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, monster_collectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMonster_collectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the monster_collection model
   */
  readonly fields: monster_collectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for monster_collection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__monster_collectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the monster_collection model
   */ 
  interface monster_collectionFieldRefs {
    readonly id: FieldRef<"monster_collection", 'Int'>
    readonly mobid: FieldRef<"monster_collection", 'Int'>
    readonly region: FieldRef<"monster_collection", 'Int'>
    readonly session: FieldRef<"monster_collection", 'Int'>
    readonly position: FieldRef<"monster_collection", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * monster_collection findUnique
   */
  export type monster_collectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collection
     */
    select?: monster_collectionSelect<ExtArgs> | null
    /**
     * Filter, which monster_collection to fetch.
     */
    where: monster_collectionWhereUniqueInput
  }

  /**
   * monster_collection findUniqueOrThrow
   */
  export type monster_collectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collection
     */
    select?: monster_collectionSelect<ExtArgs> | null
    /**
     * Filter, which monster_collection to fetch.
     */
    where: monster_collectionWhereUniqueInput
  }

  /**
   * monster_collection findFirst
   */
  export type monster_collectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collection
     */
    select?: monster_collectionSelect<ExtArgs> | null
    /**
     * Filter, which monster_collection to fetch.
     */
    where?: monster_collectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of monster_collections to fetch.
     */
    orderBy?: monster_collectionOrderByWithRelationInput | monster_collectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for monster_collections.
     */
    cursor?: monster_collectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` monster_collections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` monster_collections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of monster_collections.
     */
    distinct?: Monster_collectionScalarFieldEnum | Monster_collectionScalarFieldEnum[]
  }

  /**
   * monster_collection findFirstOrThrow
   */
  export type monster_collectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collection
     */
    select?: monster_collectionSelect<ExtArgs> | null
    /**
     * Filter, which monster_collection to fetch.
     */
    where?: monster_collectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of monster_collections to fetch.
     */
    orderBy?: monster_collectionOrderByWithRelationInput | monster_collectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for monster_collections.
     */
    cursor?: monster_collectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` monster_collections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` monster_collections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of monster_collections.
     */
    distinct?: Monster_collectionScalarFieldEnum | Monster_collectionScalarFieldEnum[]
  }

  /**
   * monster_collection findMany
   */
  export type monster_collectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collection
     */
    select?: monster_collectionSelect<ExtArgs> | null
    /**
     * Filter, which monster_collections to fetch.
     */
    where?: monster_collectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of monster_collections to fetch.
     */
    orderBy?: monster_collectionOrderByWithRelationInput | monster_collectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing monster_collections.
     */
    cursor?: monster_collectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` monster_collections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` monster_collections.
     */
    skip?: number
    distinct?: Monster_collectionScalarFieldEnum | Monster_collectionScalarFieldEnum[]
  }

  /**
   * monster_collection create
   */
  export type monster_collectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collection
     */
    select?: monster_collectionSelect<ExtArgs> | null
    /**
     * The data needed to create a monster_collection.
     */
    data?: XOR<monster_collectionCreateInput, monster_collectionUncheckedCreateInput>
  }

  /**
   * monster_collection createMany
   */
  export type monster_collectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many monster_collections.
     */
    data: monster_collectionCreateManyInput | monster_collectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * monster_collection update
   */
  export type monster_collectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collection
     */
    select?: monster_collectionSelect<ExtArgs> | null
    /**
     * The data needed to update a monster_collection.
     */
    data: XOR<monster_collectionUpdateInput, monster_collectionUncheckedUpdateInput>
    /**
     * Choose, which monster_collection to update.
     */
    where: monster_collectionWhereUniqueInput
  }

  /**
   * monster_collection updateMany
   */
  export type monster_collectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update monster_collections.
     */
    data: XOR<monster_collectionUpdateManyMutationInput, monster_collectionUncheckedUpdateManyInput>
    /**
     * Filter which monster_collections to update
     */
    where?: monster_collectionWhereInput
  }

  /**
   * monster_collection upsert
   */
  export type monster_collectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collection
     */
    select?: monster_collectionSelect<ExtArgs> | null
    /**
     * The filter to search for the monster_collection to update in case it exists.
     */
    where: monster_collectionWhereUniqueInput
    /**
     * In case the monster_collection found by the `where` argument doesn't exist, create a new monster_collection with this data.
     */
    create: XOR<monster_collectionCreateInput, monster_collectionUncheckedCreateInput>
    /**
     * In case the monster_collection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<monster_collectionUpdateInput, monster_collectionUncheckedUpdateInput>
  }

  /**
   * monster_collection delete
   */
  export type monster_collectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collection
     */
    select?: monster_collectionSelect<ExtArgs> | null
    /**
     * Filter which monster_collection to delete.
     */
    where: monster_collectionWhereUniqueInput
  }

  /**
   * monster_collection deleteMany
   */
  export type monster_collectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which monster_collections to delete
     */
    where?: monster_collectionWhereInput
  }

  /**
   * monster_collection without action
   */
  export type monster_collectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collection
     */
    select?: monster_collectionSelect<ExtArgs> | null
  }


  /**
   * Model monster_collection_explorations
   */

  export type AggregateMonster_collection_explorations = {
    _count: Monster_collection_explorationsCountAggregateOutputType | null
    _avg: Monster_collection_explorationsAvgAggregateOutputType | null
    _sum: Monster_collection_explorationsSumAggregateOutputType | null
    _min: Monster_collection_explorationsMinAggregateOutputType | null
    _max: Monster_collection_explorationsMaxAggregateOutputType | null
  }

  export type Monster_collection_explorationsAvgAggregateOutputType = {
    id: number | null
    collectionid: number | null
    collectionkey: number | null
    position: number | null
  }

  export type Monster_collection_explorationsSumAggregateOutputType = {
    id: bigint | null
    collectionid: number | null
    collectionkey: number | null
    position: number | null
  }

  export type Monster_collection_explorationsMinAggregateOutputType = {
    id: bigint | null
    collectionid: number | null
    collectionkey: number | null
    monsterkey: string | null
    endDate: Date | null
    position: number | null
  }

  export type Monster_collection_explorationsMaxAggregateOutputType = {
    id: bigint | null
    collectionid: number | null
    collectionkey: number | null
    monsterkey: string | null
    endDate: Date | null
    position: number | null
  }

  export type Monster_collection_explorationsCountAggregateOutputType = {
    id: number
    collectionid: number
    collectionkey: number
    monsterkey: number
    endDate: number
    position: number
    _all: number
  }


  export type Monster_collection_explorationsAvgAggregateInputType = {
    id?: true
    collectionid?: true
    collectionkey?: true
    position?: true
  }

  export type Monster_collection_explorationsSumAggregateInputType = {
    id?: true
    collectionid?: true
    collectionkey?: true
    position?: true
  }

  export type Monster_collection_explorationsMinAggregateInputType = {
    id?: true
    collectionid?: true
    collectionkey?: true
    monsterkey?: true
    endDate?: true
    position?: true
  }

  export type Monster_collection_explorationsMaxAggregateInputType = {
    id?: true
    collectionid?: true
    collectionkey?: true
    monsterkey?: true
    endDate?: true
    position?: true
  }

  export type Monster_collection_explorationsCountAggregateInputType = {
    id?: true
    collectionid?: true
    collectionkey?: true
    monsterkey?: true
    endDate?: true
    position?: true
    _all?: true
  }

  export type Monster_collection_explorationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which monster_collection_explorations to aggregate.
     */
    where?: monster_collection_explorationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of monster_collection_explorations to fetch.
     */
    orderBy?: monster_collection_explorationsOrderByWithRelationInput | monster_collection_explorationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: monster_collection_explorationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` monster_collection_explorations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` monster_collection_explorations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned monster_collection_explorations
    **/
    _count?: true | Monster_collection_explorationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Monster_collection_explorationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Monster_collection_explorationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Monster_collection_explorationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Monster_collection_explorationsMaxAggregateInputType
  }

  export type GetMonster_collection_explorationsAggregateType<T extends Monster_collection_explorationsAggregateArgs> = {
        [P in keyof T & keyof AggregateMonster_collection_explorations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMonster_collection_explorations[P]>
      : GetScalarType<T[P], AggregateMonster_collection_explorations[P]>
  }




  export type monster_collection_explorationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: monster_collection_explorationsWhereInput
    orderBy?: monster_collection_explorationsOrderByWithAggregationInput | monster_collection_explorationsOrderByWithAggregationInput[]
    by: Monster_collection_explorationsScalarFieldEnum[] | Monster_collection_explorationsScalarFieldEnum
    having?: monster_collection_explorationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Monster_collection_explorationsCountAggregateInputType | true
    _avg?: Monster_collection_explorationsAvgAggregateInputType
    _sum?: Monster_collection_explorationsSumAggregateInputType
    _min?: Monster_collection_explorationsMinAggregateInputType
    _max?: Monster_collection_explorationsMaxAggregateInputType
  }

  export type Monster_collection_explorationsGroupByOutputType = {
    id: bigint
    collectionid: number | null
    collectionkey: number | null
    monsterkey: string | null
    endDate: Date | null
    position: number | null
    _count: Monster_collection_explorationsCountAggregateOutputType | null
    _avg: Monster_collection_explorationsAvgAggregateOutputType | null
    _sum: Monster_collection_explorationsSumAggregateOutputType | null
    _min: Monster_collection_explorationsMinAggregateOutputType | null
    _max: Monster_collection_explorationsMaxAggregateOutputType | null
  }

  type GetMonster_collection_explorationsGroupByPayload<T extends monster_collection_explorationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Monster_collection_explorationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Monster_collection_explorationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Monster_collection_explorationsGroupByOutputType[P]>
            : GetScalarType<T[P], Monster_collection_explorationsGroupByOutputType[P]>
        }
      >
    >


  export type monster_collection_explorationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    collectionid?: boolean
    collectionkey?: boolean
    monsterkey?: boolean
    endDate?: boolean
    position?: boolean
  }, ExtArgs["result"]["monster_collection_explorations"]>


  export type monster_collection_explorationsSelectScalar = {
    id?: boolean
    collectionid?: boolean
    collectionkey?: boolean
    monsterkey?: boolean
    endDate?: boolean
    position?: boolean
  }


  export type $monster_collection_explorationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "monster_collection_explorations"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      collectionid: number | null
      collectionkey: number | null
      monsterkey: string | null
      endDate: Date | null
      position: number | null
    }, ExtArgs["result"]["monster_collection_explorations"]>
    composites: {}
  }

  type monster_collection_explorationsGetPayload<S extends boolean | null | undefined | monster_collection_explorationsDefaultArgs> = $Result.GetResult<Prisma.$monster_collection_explorationsPayload, S>

  type monster_collection_explorationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<monster_collection_explorationsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Monster_collection_explorationsCountAggregateInputType | true
    }

  export interface monster_collection_explorationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['monster_collection_explorations'], meta: { name: 'monster_collection_explorations' } }
    /**
     * Find zero or one Monster_collection_explorations that matches the filter.
     * @param {monster_collection_explorationsFindUniqueArgs} args - Arguments to find a Monster_collection_explorations
     * @example
     * // Get one Monster_collection_explorations
     * const monster_collection_explorations = await prisma.monster_collection_explorations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends monster_collection_explorationsFindUniqueArgs>(args: SelectSubset<T, monster_collection_explorationsFindUniqueArgs<ExtArgs>>): Prisma__monster_collection_explorationsClient<$Result.GetResult<Prisma.$monster_collection_explorationsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Monster_collection_explorations that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {monster_collection_explorationsFindUniqueOrThrowArgs} args - Arguments to find a Monster_collection_explorations
     * @example
     * // Get one Monster_collection_explorations
     * const monster_collection_explorations = await prisma.monster_collection_explorations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends monster_collection_explorationsFindUniqueOrThrowArgs>(args: SelectSubset<T, monster_collection_explorationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__monster_collection_explorationsClient<$Result.GetResult<Prisma.$monster_collection_explorationsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Monster_collection_explorations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monster_collection_explorationsFindFirstArgs} args - Arguments to find a Monster_collection_explorations
     * @example
     * // Get one Monster_collection_explorations
     * const monster_collection_explorations = await prisma.monster_collection_explorations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends monster_collection_explorationsFindFirstArgs>(args?: SelectSubset<T, monster_collection_explorationsFindFirstArgs<ExtArgs>>): Prisma__monster_collection_explorationsClient<$Result.GetResult<Prisma.$monster_collection_explorationsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Monster_collection_explorations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monster_collection_explorationsFindFirstOrThrowArgs} args - Arguments to find a Monster_collection_explorations
     * @example
     * // Get one Monster_collection_explorations
     * const monster_collection_explorations = await prisma.monster_collection_explorations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends monster_collection_explorationsFindFirstOrThrowArgs>(args?: SelectSubset<T, monster_collection_explorationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__monster_collection_explorationsClient<$Result.GetResult<Prisma.$monster_collection_explorationsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Monster_collection_explorations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monster_collection_explorationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Monster_collection_explorations
     * const monster_collection_explorations = await prisma.monster_collection_explorations.findMany()
     * 
     * // Get first 10 Monster_collection_explorations
     * const monster_collection_explorations = await prisma.monster_collection_explorations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const monster_collection_explorationsWithIdOnly = await prisma.monster_collection_explorations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends monster_collection_explorationsFindManyArgs>(args?: SelectSubset<T, monster_collection_explorationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$monster_collection_explorationsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Monster_collection_explorations.
     * @param {monster_collection_explorationsCreateArgs} args - Arguments to create a Monster_collection_explorations.
     * @example
     * // Create one Monster_collection_explorations
     * const Monster_collection_explorations = await prisma.monster_collection_explorations.create({
     *   data: {
     *     // ... data to create a Monster_collection_explorations
     *   }
     * })
     * 
     */
    create<T extends monster_collection_explorationsCreateArgs>(args: SelectSubset<T, monster_collection_explorationsCreateArgs<ExtArgs>>): Prisma__monster_collection_explorationsClient<$Result.GetResult<Prisma.$monster_collection_explorationsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Monster_collection_explorations.
     * @param {monster_collection_explorationsCreateManyArgs} args - Arguments to create many Monster_collection_explorations.
     * @example
     * // Create many Monster_collection_explorations
     * const monster_collection_explorations = await prisma.monster_collection_explorations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends monster_collection_explorationsCreateManyArgs>(args?: SelectSubset<T, monster_collection_explorationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Monster_collection_explorations.
     * @param {monster_collection_explorationsDeleteArgs} args - Arguments to delete one Monster_collection_explorations.
     * @example
     * // Delete one Monster_collection_explorations
     * const Monster_collection_explorations = await prisma.monster_collection_explorations.delete({
     *   where: {
     *     // ... filter to delete one Monster_collection_explorations
     *   }
     * })
     * 
     */
    delete<T extends monster_collection_explorationsDeleteArgs>(args: SelectSubset<T, monster_collection_explorationsDeleteArgs<ExtArgs>>): Prisma__monster_collection_explorationsClient<$Result.GetResult<Prisma.$monster_collection_explorationsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Monster_collection_explorations.
     * @param {monster_collection_explorationsUpdateArgs} args - Arguments to update one Monster_collection_explorations.
     * @example
     * // Update one Monster_collection_explorations
     * const monster_collection_explorations = await prisma.monster_collection_explorations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends monster_collection_explorationsUpdateArgs>(args: SelectSubset<T, monster_collection_explorationsUpdateArgs<ExtArgs>>): Prisma__monster_collection_explorationsClient<$Result.GetResult<Prisma.$monster_collection_explorationsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Monster_collection_explorations.
     * @param {monster_collection_explorationsDeleteManyArgs} args - Arguments to filter Monster_collection_explorations to delete.
     * @example
     * // Delete a few Monster_collection_explorations
     * const { count } = await prisma.monster_collection_explorations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends monster_collection_explorationsDeleteManyArgs>(args?: SelectSubset<T, monster_collection_explorationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Monster_collection_explorations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monster_collection_explorationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Monster_collection_explorations
     * const monster_collection_explorations = await prisma.monster_collection_explorations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends monster_collection_explorationsUpdateManyArgs>(args: SelectSubset<T, monster_collection_explorationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Monster_collection_explorations.
     * @param {monster_collection_explorationsUpsertArgs} args - Arguments to update or create a Monster_collection_explorations.
     * @example
     * // Update or create a Monster_collection_explorations
     * const monster_collection_explorations = await prisma.monster_collection_explorations.upsert({
     *   create: {
     *     // ... data to create a Monster_collection_explorations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Monster_collection_explorations we want to update
     *   }
     * })
     */
    upsert<T extends monster_collection_explorationsUpsertArgs>(args: SelectSubset<T, monster_collection_explorationsUpsertArgs<ExtArgs>>): Prisma__monster_collection_explorationsClient<$Result.GetResult<Prisma.$monster_collection_explorationsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Monster_collection_explorations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monster_collection_explorationsCountArgs} args - Arguments to filter Monster_collection_explorations to count.
     * @example
     * // Count the number of Monster_collection_explorations
     * const count = await prisma.monster_collection_explorations.count({
     *   where: {
     *     // ... the filter for the Monster_collection_explorations we want to count
     *   }
     * })
    **/
    count<T extends monster_collection_explorationsCountArgs>(
      args?: Subset<T, monster_collection_explorationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Monster_collection_explorationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Monster_collection_explorations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Monster_collection_explorationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Monster_collection_explorationsAggregateArgs>(args: Subset<T, Monster_collection_explorationsAggregateArgs>): Prisma.PrismaPromise<GetMonster_collection_explorationsAggregateType<T>>

    /**
     * Group by Monster_collection_explorations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monster_collection_explorationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends monster_collection_explorationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: monster_collection_explorationsGroupByArgs['orderBy'] }
        : { orderBy?: monster_collection_explorationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, monster_collection_explorationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMonster_collection_explorationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the monster_collection_explorations model
   */
  readonly fields: monster_collection_explorationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for monster_collection_explorations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__monster_collection_explorationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the monster_collection_explorations model
   */ 
  interface monster_collection_explorationsFieldRefs {
    readonly id: FieldRef<"monster_collection_explorations", 'BigInt'>
    readonly collectionid: FieldRef<"monster_collection_explorations", 'Int'>
    readonly collectionkey: FieldRef<"monster_collection_explorations", 'Int'>
    readonly monsterkey: FieldRef<"monster_collection_explorations", 'String'>
    readonly endDate: FieldRef<"monster_collection_explorations", 'DateTime'>
    readonly position: FieldRef<"monster_collection_explorations", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * monster_collection_explorations findUnique
   */
  export type monster_collection_explorationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collection_explorations
     */
    select?: monster_collection_explorationsSelect<ExtArgs> | null
    /**
     * Filter, which monster_collection_explorations to fetch.
     */
    where: monster_collection_explorationsWhereUniqueInput
  }

  /**
   * monster_collection_explorations findUniqueOrThrow
   */
  export type monster_collection_explorationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collection_explorations
     */
    select?: monster_collection_explorationsSelect<ExtArgs> | null
    /**
     * Filter, which monster_collection_explorations to fetch.
     */
    where: monster_collection_explorationsWhereUniqueInput
  }

  /**
   * monster_collection_explorations findFirst
   */
  export type monster_collection_explorationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collection_explorations
     */
    select?: monster_collection_explorationsSelect<ExtArgs> | null
    /**
     * Filter, which monster_collection_explorations to fetch.
     */
    where?: monster_collection_explorationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of monster_collection_explorations to fetch.
     */
    orderBy?: monster_collection_explorationsOrderByWithRelationInput | monster_collection_explorationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for monster_collection_explorations.
     */
    cursor?: monster_collection_explorationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` monster_collection_explorations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` monster_collection_explorations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of monster_collection_explorations.
     */
    distinct?: Monster_collection_explorationsScalarFieldEnum | Monster_collection_explorationsScalarFieldEnum[]
  }

  /**
   * monster_collection_explorations findFirstOrThrow
   */
  export type monster_collection_explorationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collection_explorations
     */
    select?: monster_collection_explorationsSelect<ExtArgs> | null
    /**
     * Filter, which monster_collection_explorations to fetch.
     */
    where?: monster_collection_explorationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of monster_collection_explorations to fetch.
     */
    orderBy?: monster_collection_explorationsOrderByWithRelationInput | monster_collection_explorationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for monster_collection_explorations.
     */
    cursor?: monster_collection_explorationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` monster_collection_explorations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` monster_collection_explorations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of monster_collection_explorations.
     */
    distinct?: Monster_collection_explorationsScalarFieldEnum | Monster_collection_explorationsScalarFieldEnum[]
  }

  /**
   * monster_collection_explorations findMany
   */
  export type monster_collection_explorationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collection_explorations
     */
    select?: monster_collection_explorationsSelect<ExtArgs> | null
    /**
     * Filter, which monster_collection_explorations to fetch.
     */
    where?: monster_collection_explorationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of monster_collection_explorations to fetch.
     */
    orderBy?: monster_collection_explorationsOrderByWithRelationInput | monster_collection_explorationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing monster_collection_explorations.
     */
    cursor?: monster_collection_explorationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` monster_collection_explorations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` monster_collection_explorations.
     */
    skip?: number
    distinct?: Monster_collection_explorationsScalarFieldEnum | Monster_collection_explorationsScalarFieldEnum[]
  }

  /**
   * monster_collection_explorations create
   */
  export type monster_collection_explorationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collection_explorations
     */
    select?: monster_collection_explorationsSelect<ExtArgs> | null
    /**
     * The data needed to create a monster_collection_explorations.
     */
    data?: XOR<monster_collection_explorationsCreateInput, monster_collection_explorationsUncheckedCreateInput>
  }

  /**
   * monster_collection_explorations createMany
   */
  export type monster_collection_explorationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many monster_collection_explorations.
     */
    data: monster_collection_explorationsCreateManyInput | monster_collection_explorationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * monster_collection_explorations update
   */
  export type monster_collection_explorationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collection_explorations
     */
    select?: monster_collection_explorationsSelect<ExtArgs> | null
    /**
     * The data needed to update a monster_collection_explorations.
     */
    data: XOR<monster_collection_explorationsUpdateInput, monster_collection_explorationsUncheckedUpdateInput>
    /**
     * Choose, which monster_collection_explorations to update.
     */
    where: monster_collection_explorationsWhereUniqueInput
  }

  /**
   * monster_collection_explorations updateMany
   */
  export type monster_collection_explorationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update monster_collection_explorations.
     */
    data: XOR<monster_collection_explorationsUpdateManyMutationInput, monster_collection_explorationsUncheckedUpdateManyInput>
    /**
     * Filter which monster_collection_explorations to update
     */
    where?: monster_collection_explorationsWhereInput
  }

  /**
   * monster_collection_explorations upsert
   */
  export type monster_collection_explorationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collection_explorations
     */
    select?: monster_collection_explorationsSelect<ExtArgs> | null
    /**
     * The filter to search for the monster_collection_explorations to update in case it exists.
     */
    where: monster_collection_explorationsWhereUniqueInput
    /**
     * In case the monster_collection_explorations found by the `where` argument doesn't exist, create a new monster_collection_explorations with this data.
     */
    create: XOR<monster_collection_explorationsCreateInput, monster_collection_explorationsUncheckedCreateInput>
    /**
     * In case the monster_collection_explorations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<monster_collection_explorationsUpdateInput, monster_collection_explorationsUncheckedUpdateInput>
  }

  /**
   * monster_collection_explorations delete
   */
  export type monster_collection_explorationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collection_explorations
     */
    select?: monster_collection_explorationsSelect<ExtArgs> | null
    /**
     * Filter which monster_collection_explorations to delete.
     */
    where: monster_collection_explorationsWhereUniqueInput
  }

  /**
   * monster_collection_explorations deleteMany
   */
  export type monster_collection_explorationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which monster_collection_explorations to delete
     */
    where?: monster_collection_explorationsWhereInput
  }

  /**
   * monster_collection_explorations without action
   */
  export type monster_collection_explorationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collection_explorations
     */
    select?: monster_collection_explorationsSelect<ExtArgs> | null
  }


  /**
   * Model monster_collection_group_rewards
   */

  export type AggregateMonster_collection_group_rewards = {
    _count: Monster_collection_group_rewardsCountAggregateOutputType | null
    _avg: Monster_collection_group_rewardsAvgAggregateOutputType | null
    _sum: Monster_collection_group_rewardsSumAggregateOutputType | null
    _min: Monster_collection_group_rewardsMinAggregateOutputType | null
    _max: Monster_collection_group_rewardsMaxAggregateOutputType | null
  }

  export type Monster_collection_group_rewardsAvgAggregateOutputType = {
    region: number | null
    session: number | null
    groupid: number | null
    rewardid: number | null
    quantity: number | null
  }

  export type Monster_collection_group_rewardsSumAggregateOutputType = {
    region: number | null
    session: number | null
    groupid: number | null
    rewardid: number | null
    quantity: number | null
  }

  export type Monster_collection_group_rewardsMinAggregateOutputType = {
    region: number | null
    session: number | null
    groupid: number | null
    rewardid: number | null
    quantity: number | null
  }

  export type Monster_collection_group_rewardsMaxAggregateOutputType = {
    region: number | null
    session: number | null
    groupid: number | null
    rewardid: number | null
    quantity: number | null
  }

  export type Monster_collection_group_rewardsCountAggregateOutputType = {
    region: number
    session: number
    groupid: number
    rewardid: number
    quantity: number
    _all: number
  }


  export type Monster_collection_group_rewardsAvgAggregateInputType = {
    region?: true
    session?: true
    groupid?: true
    rewardid?: true
    quantity?: true
  }

  export type Monster_collection_group_rewardsSumAggregateInputType = {
    region?: true
    session?: true
    groupid?: true
    rewardid?: true
    quantity?: true
  }

  export type Monster_collection_group_rewardsMinAggregateInputType = {
    region?: true
    session?: true
    groupid?: true
    rewardid?: true
    quantity?: true
  }

  export type Monster_collection_group_rewardsMaxAggregateInputType = {
    region?: true
    session?: true
    groupid?: true
    rewardid?: true
    quantity?: true
  }

  export type Monster_collection_group_rewardsCountAggregateInputType = {
    region?: true
    session?: true
    groupid?: true
    rewardid?: true
    quantity?: true
    _all?: true
  }

  export type Monster_collection_group_rewardsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which monster_collection_group_rewards to aggregate.
     */
    where?: monster_collection_group_rewardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of monster_collection_group_rewards to fetch.
     */
    orderBy?: monster_collection_group_rewardsOrderByWithRelationInput | monster_collection_group_rewardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: monster_collection_group_rewardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` monster_collection_group_rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` monster_collection_group_rewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned monster_collection_group_rewards
    **/
    _count?: true | Monster_collection_group_rewardsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Monster_collection_group_rewardsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Monster_collection_group_rewardsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Monster_collection_group_rewardsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Monster_collection_group_rewardsMaxAggregateInputType
  }

  export type GetMonster_collection_group_rewardsAggregateType<T extends Monster_collection_group_rewardsAggregateArgs> = {
        [P in keyof T & keyof AggregateMonster_collection_group_rewards]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMonster_collection_group_rewards[P]>
      : GetScalarType<T[P], AggregateMonster_collection_group_rewards[P]>
  }




  export type monster_collection_group_rewardsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: monster_collection_group_rewardsWhereInput
    orderBy?: monster_collection_group_rewardsOrderByWithAggregationInput | monster_collection_group_rewardsOrderByWithAggregationInput[]
    by: Monster_collection_group_rewardsScalarFieldEnum[] | Monster_collection_group_rewardsScalarFieldEnum
    having?: monster_collection_group_rewardsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Monster_collection_group_rewardsCountAggregateInputType | true
    _avg?: Monster_collection_group_rewardsAvgAggregateInputType
    _sum?: Monster_collection_group_rewardsSumAggregateInputType
    _min?: Monster_collection_group_rewardsMinAggregateInputType
    _max?: Monster_collection_group_rewardsMaxAggregateInputType
  }

  export type Monster_collection_group_rewardsGroupByOutputType = {
    region: number
    session: number
    groupid: number
    rewardid: number | null
    quantity: number | null
    _count: Monster_collection_group_rewardsCountAggregateOutputType | null
    _avg: Monster_collection_group_rewardsAvgAggregateOutputType | null
    _sum: Monster_collection_group_rewardsSumAggregateOutputType | null
    _min: Monster_collection_group_rewardsMinAggregateOutputType | null
    _max: Monster_collection_group_rewardsMaxAggregateOutputType | null
  }

  type GetMonster_collection_group_rewardsGroupByPayload<T extends monster_collection_group_rewardsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Monster_collection_group_rewardsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Monster_collection_group_rewardsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Monster_collection_group_rewardsGroupByOutputType[P]>
            : GetScalarType<T[P], Monster_collection_group_rewardsGroupByOutputType[P]>
        }
      >
    >


  export type monster_collection_group_rewardsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    region?: boolean
    session?: boolean
    groupid?: boolean
    rewardid?: boolean
    quantity?: boolean
  }, ExtArgs["result"]["monster_collection_group_rewards"]>


  export type monster_collection_group_rewardsSelectScalar = {
    region?: boolean
    session?: boolean
    groupid?: boolean
    rewardid?: boolean
    quantity?: boolean
  }


  export type $monster_collection_group_rewardsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "monster_collection_group_rewards"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      region: number
      session: number
      groupid: number
      rewardid: number | null
      quantity: number | null
    }, ExtArgs["result"]["monster_collection_group_rewards"]>
    composites: {}
  }

  type monster_collection_group_rewardsGetPayload<S extends boolean | null | undefined | monster_collection_group_rewardsDefaultArgs> = $Result.GetResult<Prisma.$monster_collection_group_rewardsPayload, S>

  type monster_collection_group_rewardsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<monster_collection_group_rewardsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Monster_collection_group_rewardsCountAggregateInputType | true
    }

  export interface monster_collection_group_rewardsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['monster_collection_group_rewards'], meta: { name: 'monster_collection_group_rewards' } }
    /**
     * Find zero or one Monster_collection_group_rewards that matches the filter.
     * @param {monster_collection_group_rewardsFindUniqueArgs} args - Arguments to find a Monster_collection_group_rewards
     * @example
     * // Get one Monster_collection_group_rewards
     * const monster_collection_group_rewards = await prisma.monster_collection_group_rewards.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends monster_collection_group_rewardsFindUniqueArgs>(args: SelectSubset<T, monster_collection_group_rewardsFindUniqueArgs<ExtArgs>>): Prisma__monster_collection_group_rewardsClient<$Result.GetResult<Prisma.$monster_collection_group_rewardsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Monster_collection_group_rewards that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {monster_collection_group_rewardsFindUniqueOrThrowArgs} args - Arguments to find a Monster_collection_group_rewards
     * @example
     * // Get one Monster_collection_group_rewards
     * const monster_collection_group_rewards = await prisma.monster_collection_group_rewards.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends monster_collection_group_rewardsFindUniqueOrThrowArgs>(args: SelectSubset<T, monster_collection_group_rewardsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__monster_collection_group_rewardsClient<$Result.GetResult<Prisma.$monster_collection_group_rewardsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Monster_collection_group_rewards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monster_collection_group_rewardsFindFirstArgs} args - Arguments to find a Monster_collection_group_rewards
     * @example
     * // Get one Monster_collection_group_rewards
     * const monster_collection_group_rewards = await prisma.monster_collection_group_rewards.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends monster_collection_group_rewardsFindFirstArgs>(args?: SelectSubset<T, monster_collection_group_rewardsFindFirstArgs<ExtArgs>>): Prisma__monster_collection_group_rewardsClient<$Result.GetResult<Prisma.$monster_collection_group_rewardsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Monster_collection_group_rewards that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monster_collection_group_rewardsFindFirstOrThrowArgs} args - Arguments to find a Monster_collection_group_rewards
     * @example
     * // Get one Monster_collection_group_rewards
     * const monster_collection_group_rewards = await prisma.monster_collection_group_rewards.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends monster_collection_group_rewardsFindFirstOrThrowArgs>(args?: SelectSubset<T, monster_collection_group_rewardsFindFirstOrThrowArgs<ExtArgs>>): Prisma__monster_collection_group_rewardsClient<$Result.GetResult<Prisma.$monster_collection_group_rewardsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Monster_collection_group_rewards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monster_collection_group_rewardsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Monster_collection_group_rewards
     * const monster_collection_group_rewards = await prisma.monster_collection_group_rewards.findMany()
     * 
     * // Get first 10 Monster_collection_group_rewards
     * const monster_collection_group_rewards = await prisma.monster_collection_group_rewards.findMany({ take: 10 })
     * 
     * // Only select the `region`
     * const monster_collection_group_rewardsWithRegionOnly = await prisma.monster_collection_group_rewards.findMany({ select: { region: true } })
     * 
     */
    findMany<T extends monster_collection_group_rewardsFindManyArgs>(args?: SelectSubset<T, monster_collection_group_rewardsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$monster_collection_group_rewardsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Monster_collection_group_rewards.
     * @param {monster_collection_group_rewardsCreateArgs} args - Arguments to create a Monster_collection_group_rewards.
     * @example
     * // Create one Monster_collection_group_rewards
     * const Monster_collection_group_rewards = await prisma.monster_collection_group_rewards.create({
     *   data: {
     *     // ... data to create a Monster_collection_group_rewards
     *   }
     * })
     * 
     */
    create<T extends monster_collection_group_rewardsCreateArgs>(args: SelectSubset<T, monster_collection_group_rewardsCreateArgs<ExtArgs>>): Prisma__monster_collection_group_rewardsClient<$Result.GetResult<Prisma.$monster_collection_group_rewardsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Monster_collection_group_rewards.
     * @param {monster_collection_group_rewardsCreateManyArgs} args - Arguments to create many Monster_collection_group_rewards.
     * @example
     * // Create many Monster_collection_group_rewards
     * const monster_collection_group_rewards = await prisma.monster_collection_group_rewards.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends monster_collection_group_rewardsCreateManyArgs>(args?: SelectSubset<T, monster_collection_group_rewardsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Monster_collection_group_rewards.
     * @param {monster_collection_group_rewardsDeleteArgs} args - Arguments to delete one Monster_collection_group_rewards.
     * @example
     * // Delete one Monster_collection_group_rewards
     * const Monster_collection_group_rewards = await prisma.monster_collection_group_rewards.delete({
     *   where: {
     *     // ... filter to delete one Monster_collection_group_rewards
     *   }
     * })
     * 
     */
    delete<T extends monster_collection_group_rewardsDeleteArgs>(args: SelectSubset<T, monster_collection_group_rewardsDeleteArgs<ExtArgs>>): Prisma__monster_collection_group_rewardsClient<$Result.GetResult<Prisma.$monster_collection_group_rewardsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Monster_collection_group_rewards.
     * @param {monster_collection_group_rewardsUpdateArgs} args - Arguments to update one Monster_collection_group_rewards.
     * @example
     * // Update one Monster_collection_group_rewards
     * const monster_collection_group_rewards = await prisma.monster_collection_group_rewards.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends monster_collection_group_rewardsUpdateArgs>(args: SelectSubset<T, monster_collection_group_rewardsUpdateArgs<ExtArgs>>): Prisma__monster_collection_group_rewardsClient<$Result.GetResult<Prisma.$monster_collection_group_rewardsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Monster_collection_group_rewards.
     * @param {monster_collection_group_rewardsDeleteManyArgs} args - Arguments to filter Monster_collection_group_rewards to delete.
     * @example
     * // Delete a few Monster_collection_group_rewards
     * const { count } = await prisma.monster_collection_group_rewards.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends monster_collection_group_rewardsDeleteManyArgs>(args?: SelectSubset<T, monster_collection_group_rewardsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Monster_collection_group_rewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monster_collection_group_rewardsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Monster_collection_group_rewards
     * const monster_collection_group_rewards = await prisma.monster_collection_group_rewards.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends monster_collection_group_rewardsUpdateManyArgs>(args: SelectSubset<T, monster_collection_group_rewardsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Monster_collection_group_rewards.
     * @param {monster_collection_group_rewardsUpsertArgs} args - Arguments to update or create a Monster_collection_group_rewards.
     * @example
     * // Update or create a Monster_collection_group_rewards
     * const monster_collection_group_rewards = await prisma.monster_collection_group_rewards.upsert({
     *   create: {
     *     // ... data to create a Monster_collection_group_rewards
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Monster_collection_group_rewards we want to update
     *   }
     * })
     */
    upsert<T extends monster_collection_group_rewardsUpsertArgs>(args: SelectSubset<T, monster_collection_group_rewardsUpsertArgs<ExtArgs>>): Prisma__monster_collection_group_rewardsClient<$Result.GetResult<Prisma.$monster_collection_group_rewardsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Monster_collection_group_rewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monster_collection_group_rewardsCountArgs} args - Arguments to filter Monster_collection_group_rewards to count.
     * @example
     * // Count the number of Monster_collection_group_rewards
     * const count = await prisma.monster_collection_group_rewards.count({
     *   where: {
     *     // ... the filter for the Monster_collection_group_rewards we want to count
     *   }
     * })
    **/
    count<T extends monster_collection_group_rewardsCountArgs>(
      args?: Subset<T, monster_collection_group_rewardsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Monster_collection_group_rewardsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Monster_collection_group_rewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Monster_collection_group_rewardsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Monster_collection_group_rewardsAggregateArgs>(args: Subset<T, Monster_collection_group_rewardsAggregateArgs>): Prisma.PrismaPromise<GetMonster_collection_group_rewardsAggregateType<T>>

    /**
     * Group by Monster_collection_group_rewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monster_collection_group_rewardsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends monster_collection_group_rewardsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: monster_collection_group_rewardsGroupByArgs['orderBy'] }
        : { orderBy?: monster_collection_group_rewardsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, monster_collection_group_rewardsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMonster_collection_group_rewardsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the monster_collection_group_rewards model
   */
  readonly fields: monster_collection_group_rewardsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for monster_collection_group_rewards.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__monster_collection_group_rewardsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the monster_collection_group_rewards model
   */ 
  interface monster_collection_group_rewardsFieldRefs {
    readonly region: FieldRef<"monster_collection_group_rewards", 'Int'>
    readonly session: FieldRef<"monster_collection_group_rewards", 'Int'>
    readonly groupid: FieldRef<"monster_collection_group_rewards", 'Int'>
    readonly rewardid: FieldRef<"monster_collection_group_rewards", 'Int'>
    readonly quantity: FieldRef<"monster_collection_group_rewards", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * monster_collection_group_rewards findUnique
   */
  export type monster_collection_group_rewardsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collection_group_rewards
     */
    select?: monster_collection_group_rewardsSelect<ExtArgs> | null
    /**
     * Filter, which monster_collection_group_rewards to fetch.
     */
    where: monster_collection_group_rewardsWhereUniqueInput
  }

  /**
   * monster_collection_group_rewards findUniqueOrThrow
   */
  export type monster_collection_group_rewardsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collection_group_rewards
     */
    select?: monster_collection_group_rewardsSelect<ExtArgs> | null
    /**
     * Filter, which monster_collection_group_rewards to fetch.
     */
    where: monster_collection_group_rewardsWhereUniqueInput
  }

  /**
   * monster_collection_group_rewards findFirst
   */
  export type monster_collection_group_rewardsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collection_group_rewards
     */
    select?: monster_collection_group_rewardsSelect<ExtArgs> | null
    /**
     * Filter, which monster_collection_group_rewards to fetch.
     */
    where?: monster_collection_group_rewardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of monster_collection_group_rewards to fetch.
     */
    orderBy?: monster_collection_group_rewardsOrderByWithRelationInput | monster_collection_group_rewardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for monster_collection_group_rewards.
     */
    cursor?: monster_collection_group_rewardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` monster_collection_group_rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` monster_collection_group_rewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of monster_collection_group_rewards.
     */
    distinct?: Monster_collection_group_rewardsScalarFieldEnum | Monster_collection_group_rewardsScalarFieldEnum[]
  }

  /**
   * monster_collection_group_rewards findFirstOrThrow
   */
  export type monster_collection_group_rewardsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collection_group_rewards
     */
    select?: monster_collection_group_rewardsSelect<ExtArgs> | null
    /**
     * Filter, which monster_collection_group_rewards to fetch.
     */
    where?: monster_collection_group_rewardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of monster_collection_group_rewards to fetch.
     */
    orderBy?: monster_collection_group_rewardsOrderByWithRelationInput | monster_collection_group_rewardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for monster_collection_group_rewards.
     */
    cursor?: monster_collection_group_rewardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` monster_collection_group_rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` monster_collection_group_rewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of monster_collection_group_rewards.
     */
    distinct?: Monster_collection_group_rewardsScalarFieldEnum | Monster_collection_group_rewardsScalarFieldEnum[]
  }

  /**
   * monster_collection_group_rewards findMany
   */
  export type monster_collection_group_rewardsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collection_group_rewards
     */
    select?: monster_collection_group_rewardsSelect<ExtArgs> | null
    /**
     * Filter, which monster_collection_group_rewards to fetch.
     */
    where?: monster_collection_group_rewardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of monster_collection_group_rewards to fetch.
     */
    orderBy?: monster_collection_group_rewardsOrderByWithRelationInput | monster_collection_group_rewardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing monster_collection_group_rewards.
     */
    cursor?: monster_collection_group_rewardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` monster_collection_group_rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` monster_collection_group_rewards.
     */
    skip?: number
    distinct?: Monster_collection_group_rewardsScalarFieldEnum | Monster_collection_group_rewardsScalarFieldEnum[]
  }

  /**
   * monster_collection_group_rewards create
   */
  export type monster_collection_group_rewardsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collection_group_rewards
     */
    select?: monster_collection_group_rewardsSelect<ExtArgs> | null
    /**
     * The data needed to create a monster_collection_group_rewards.
     */
    data: XOR<monster_collection_group_rewardsCreateInput, monster_collection_group_rewardsUncheckedCreateInput>
  }

  /**
   * monster_collection_group_rewards createMany
   */
  export type monster_collection_group_rewardsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many monster_collection_group_rewards.
     */
    data: monster_collection_group_rewardsCreateManyInput | monster_collection_group_rewardsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * monster_collection_group_rewards update
   */
  export type monster_collection_group_rewardsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collection_group_rewards
     */
    select?: monster_collection_group_rewardsSelect<ExtArgs> | null
    /**
     * The data needed to update a monster_collection_group_rewards.
     */
    data: XOR<monster_collection_group_rewardsUpdateInput, monster_collection_group_rewardsUncheckedUpdateInput>
    /**
     * Choose, which monster_collection_group_rewards to update.
     */
    where: monster_collection_group_rewardsWhereUniqueInput
  }

  /**
   * monster_collection_group_rewards updateMany
   */
  export type monster_collection_group_rewardsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update monster_collection_group_rewards.
     */
    data: XOR<monster_collection_group_rewardsUpdateManyMutationInput, monster_collection_group_rewardsUncheckedUpdateManyInput>
    /**
     * Filter which monster_collection_group_rewards to update
     */
    where?: monster_collection_group_rewardsWhereInput
  }

  /**
   * monster_collection_group_rewards upsert
   */
  export type monster_collection_group_rewardsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collection_group_rewards
     */
    select?: monster_collection_group_rewardsSelect<ExtArgs> | null
    /**
     * The filter to search for the monster_collection_group_rewards to update in case it exists.
     */
    where: monster_collection_group_rewardsWhereUniqueInput
    /**
     * In case the monster_collection_group_rewards found by the `where` argument doesn't exist, create a new monster_collection_group_rewards with this data.
     */
    create: XOR<monster_collection_group_rewardsCreateInput, monster_collection_group_rewardsUncheckedCreateInput>
    /**
     * In case the monster_collection_group_rewards was found with the provided `where` argument, update it with this data.
     */
    update: XOR<monster_collection_group_rewardsUpdateInput, monster_collection_group_rewardsUncheckedUpdateInput>
  }

  /**
   * monster_collection_group_rewards delete
   */
  export type monster_collection_group_rewardsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collection_group_rewards
     */
    select?: monster_collection_group_rewardsSelect<ExtArgs> | null
    /**
     * Filter which monster_collection_group_rewards to delete.
     */
    where: monster_collection_group_rewardsWhereUniqueInput
  }

  /**
   * monster_collection_group_rewards deleteMany
   */
  export type monster_collection_group_rewardsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which monster_collection_group_rewards to delete
     */
    where?: monster_collection_group_rewardsWhereInput
  }

  /**
   * monster_collection_group_rewards without action
   */
  export type monster_collection_group_rewardsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collection_group_rewards
     */
    select?: monster_collection_group_rewardsSelect<ExtArgs> | null
  }


  /**
   * Model monster_collection_mobs
   */

  export type AggregateMonster_collection_mobs = {
    _count: Monster_collection_mobsCountAggregateOutputType | null
    _avg: Monster_collection_mobsAvgAggregateOutputType | null
    _sum: Monster_collection_mobsSumAggregateOutputType | null
    _min: Monster_collection_mobsMinAggregateOutputType | null
    _max: Monster_collection_mobsMaxAggregateOutputType | null
  }

  export type Monster_collection_mobsAvgAggregateOutputType = {
    id: number | null
    collectionid: number | null
    mobid: number | null
  }

  export type Monster_collection_mobsSumAggregateOutputType = {
    id: number | null
    collectionid: number | null
    mobid: number | null
  }

  export type Monster_collection_mobsMinAggregateOutputType = {
    id: number | null
    collectionid: number | null
    mobid: number | null
  }

  export type Monster_collection_mobsMaxAggregateOutputType = {
    id: number | null
    collectionid: number | null
    mobid: number | null
  }

  export type Monster_collection_mobsCountAggregateOutputType = {
    id: number
    collectionid: number
    mobid: number
    _all: number
  }


  export type Monster_collection_mobsAvgAggregateInputType = {
    id?: true
    collectionid?: true
    mobid?: true
  }

  export type Monster_collection_mobsSumAggregateInputType = {
    id?: true
    collectionid?: true
    mobid?: true
  }

  export type Monster_collection_mobsMinAggregateInputType = {
    id?: true
    collectionid?: true
    mobid?: true
  }

  export type Monster_collection_mobsMaxAggregateInputType = {
    id?: true
    collectionid?: true
    mobid?: true
  }

  export type Monster_collection_mobsCountAggregateInputType = {
    id?: true
    collectionid?: true
    mobid?: true
    _all?: true
  }

  export type Monster_collection_mobsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which monster_collection_mobs to aggregate.
     */
    where?: monster_collection_mobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of monster_collection_mobs to fetch.
     */
    orderBy?: monster_collection_mobsOrderByWithRelationInput | monster_collection_mobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: monster_collection_mobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` monster_collection_mobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` monster_collection_mobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned monster_collection_mobs
    **/
    _count?: true | Monster_collection_mobsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Monster_collection_mobsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Monster_collection_mobsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Monster_collection_mobsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Monster_collection_mobsMaxAggregateInputType
  }

  export type GetMonster_collection_mobsAggregateType<T extends Monster_collection_mobsAggregateArgs> = {
        [P in keyof T & keyof AggregateMonster_collection_mobs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMonster_collection_mobs[P]>
      : GetScalarType<T[P], AggregateMonster_collection_mobs[P]>
  }




  export type monster_collection_mobsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: monster_collection_mobsWhereInput
    orderBy?: monster_collection_mobsOrderByWithAggregationInput | monster_collection_mobsOrderByWithAggregationInput[]
    by: Monster_collection_mobsScalarFieldEnum[] | Monster_collection_mobsScalarFieldEnum
    having?: monster_collection_mobsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Monster_collection_mobsCountAggregateInputType | true
    _avg?: Monster_collection_mobsAvgAggregateInputType
    _sum?: Monster_collection_mobsSumAggregateInputType
    _min?: Monster_collection_mobsMinAggregateInputType
    _max?: Monster_collection_mobsMaxAggregateInputType
  }

  export type Monster_collection_mobsGroupByOutputType = {
    id: number
    collectionid: number | null
    mobid: number | null
    _count: Monster_collection_mobsCountAggregateOutputType | null
    _avg: Monster_collection_mobsAvgAggregateOutputType | null
    _sum: Monster_collection_mobsSumAggregateOutputType | null
    _min: Monster_collection_mobsMinAggregateOutputType | null
    _max: Monster_collection_mobsMaxAggregateOutputType | null
  }

  type GetMonster_collection_mobsGroupByPayload<T extends monster_collection_mobsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Monster_collection_mobsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Monster_collection_mobsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Monster_collection_mobsGroupByOutputType[P]>
            : GetScalarType<T[P], Monster_collection_mobsGroupByOutputType[P]>
        }
      >
    >


  export type monster_collection_mobsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    collectionid?: boolean
    mobid?: boolean
  }, ExtArgs["result"]["monster_collection_mobs"]>


  export type monster_collection_mobsSelectScalar = {
    id?: boolean
    collectionid?: boolean
    mobid?: boolean
  }


  export type $monster_collection_mobsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "monster_collection_mobs"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      collectionid: number | null
      mobid: number | null
    }, ExtArgs["result"]["monster_collection_mobs"]>
    composites: {}
  }

  type monster_collection_mobsGetPayload<S extends boolean | null | undefined | monster_collection_mobsDefaultArgs> = $Result.GetResult<Prisma.$monster_collection_mobsPayload, S>

  type monster_collection_mobsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<monster_collection_mobsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Monster_collection_mobsCountAggregateInputType | true
    }

  export interface monster_collection_mobsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['monster_collection_mobs'], meta: { name: 'monster_collection_mobs' } }
    /**
     * Find zero or one Monster_collection_mobs that matches the filter.
     * @param {monster_collection_mobsFindUniqueArgs} args - Arguments to find a Monster_collection_mobs
     * @example
     * // Get one Monster_collection_mobs
     * const monster_collection_mobs = await prisma.monster_collection_mobs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends monster_collection_mobsFindUniqueArgs>(args: SelectSubset<T, monster_collection_mobsFindUniqueArgs<ExtArgs>>): Prisma__monster_collection_mobsClient<$Result.GetResult<Prisma.$monster_collection_mobsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Monster_collection_mobs that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {monster_collection_mobsFindUniqueOrThrowArgs} args - Arguments to find a Monster_collection_mobs
     * @example
     * // Get one Monster_collection_mobs
     * const monster_collection_mobs = await prisma.monster_collection_mobs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends monster_collection_mobsFindUniqueOrThrowArgs>(args: SelectSubset<T, monster_collection_mobsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__monster_collection_mobsClient<$Result.GetResult<Prisma.$monster_collection_mobsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Monster_collection_mobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monster_collection_mobsFindFirstArgs} args - Arguments to find a Monster_collection_mobs
     * @example
     * // Get one Monster_collection_mobs
     * const monster_collection_mobs = await prisma.monster_collection_mobs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends monster_collection_mobsFindFirstArgs>(args?: SelectSubset<T, monster_collection_mobsFindFirstArgs<ExtArgs>>): Prisma__monster_collection_mobsClient<$Result.GetResult<Prisma.$monster_collection_mobsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Monster_collection_mobs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monster_collection_mobsFindFirstOrThrowArgs} args - Arguments to find a Monster_collection_mobs
     * @example
     * // Get one Monster_collection_mobs
     * const monster_collection_mobs = await prisma.monster_collection_mobs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends monster_collection_mobsFindFirstOrThrowArgs>(args?: SelectSubset<T, monster_collection_mobsFindFirstOrThrowArgs<ExtArgs>>): Prisma__monster_collection_mobsClient<$Result.GetResult<Prisma.$monster_collection_mobsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Monster_collection_mobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monster_collection_mobsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Monster_collection_mobs
     * const monster_collection_mobs = await prisma.monster_collection_mobs.findMany()
     * 
     * // Get first 10 Monster_collection_mobs
     * const monster_collection_mobs = await prisma.monster_collection_mobs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const monster_collection_mobsWithIdOnly = await prisma.monster_collection_mobs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends monster_collection_mobsFindManyArgs>(args?: SelectSubset<T, monster_collection_mobsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$monster_collection_mobsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Monster_collection_mobs.
     * @param {monster_collection_mobsCreateArgs} args - Arguments to create a Monster_collection_mobs.
     * @example
     * // Create one Monster_collection_mobs
     * const Monster_collection_mobs = await prisma.monster_collection_mobs.create({
     *   data: {
     *     // ... data to create a Monster_collection_mobs
     *   }
     * })
     * 
     */
    create<T extends monster_collection_mobsCreateArgs>(args: SelectSubset<T, monster_collection_mobsCreateArgs<ExtArgs>>): Prisma__monster_collection_mobsClient<$Result.GetResult<Prisma.$monster_collection_mobsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Monster_collection_mobs.
     * @param {monster_collection_mobsCreateManyArgs} args - Arguments to create many Monster_collection_mobs.
     * @example
     * // Create many Monster_collection_mobs
     * const monster_collection_mobs = await prisma.monster_collection_mobs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends monster_collection_mobsCreateManyArgs>(args?: SelectSubset<T, monster_collection_mobsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Monster_collection_mobs.
     * @param {monster_collection_mobsDeleteArgs} args - Arguments to delete one Monster_collection_mobs.
     * @example
     * // Delete one Monster_collection_mobs
     * const Monster_collection_mobs = await prisma.monster_collection_mobs.delete({
     *   where: {
     *     // ... filter to delete one Monster_collection_mobs
     *   }
     * })
     * 
     */
    delete<T extends monster_collection_mobsDeleteArgs>(args: SelectSubset<T, monster_collection_mobsDeleteArgs<ExtArgs>>): Prisma__monster_collection_mobsClient<$Result.GetResult<Prisma.$monster_collection_mobsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Monster_collection_mobs.
     * @param {monster_collection_mobsUpdateArgs} args - Arguments to update one Monster_collection_mobs.
     * @example
     * // Update one Monster_collection_mobs
     * const monster_collection_mobs = await prisma.monster_collection_mobs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends monster_collection_mobsUpdateArgs>(args: SelectSubset<T, monster_collection_mobsUpdateArgs<ExtArgs>>): Prisma__monster_collection_mobsClient<$Result.GetResult<Prisma.$monster_collection_mobsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Monster_collection_mobs.
     * @param {monster_collection_mobsDeleteManyArgs} args - Arguments to filter Monster_collection_mobs to delete.
     * @example
     * // Delete a few Monster_collection_mobs
     * const { count } = await prisma.monster_collection_mobs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends monster_collection_mobsDeleteManyArgs>(args?: SelectSubset<T, monster_collection_mobsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Monster_collection_mobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monster_collection_mobsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Monster_collection_mobs
     * const monster_collection_mobs = await prisma.monster_collection_mobs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends monster_collection_mobsUpdateManyArgs>(args: SelectSubset<T, monster_collection_mobsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Monster_collection_mobs.
     * @param {monster_collection_mobsUpsertArgs} args - Arguments to update or create a Monster_collection_mobs.
     * @example
     * // Update or create a Monster_collection_mobs
     * const monster_collection_mobs = await prisma.monster_collection_mobs.upsert({
     *   create: {
     *     // ... data to create a Monster_collection_mobs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Monster_collection_mobs we want to update
     *   }
     * })
     */
    upsert<T extends monster_collection_mobsUpsertArgs>(args: SelectSubset<T, monster_collection_mobsUpsertArgs<ExtArgs>>): Prisma__monster_collection_mobsClient<$Result.GetResult<Prisma.$monster_collection_mobsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Monster_collection_mobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monster_collection_mobsCountArgs} args - Arguments to filter Monster_collection_mobs to count.
     * @example
     * // Count the number of Monster_collection_mobs
     * const count = await prisma.monster_collection_mobs.count({
     *   where: {
     *     // ... the filter for the Monster_collection_mobs we want to count
     *   }
     * })
    **/
    count<T extends monster_collection_mobsCountArgs>(
      args?: Subset<T, monster_collection_mobsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Monster_collection_mobsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Monster_collection_mobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Monster_collection_mobsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Monster_collection_mobsAggregateArgs>(args: Subset<T, Monster_collection_mobsAggregateArgs>): Prisma.PrismaPromise<GetMonster_collection_mobsAggregateType<T>>

    /**
     * Group by Monster_collection_mobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monster_collection_mobsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends monster_collection_mobsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: monster_collection_mobsGroupByArgs['orderBy'] }
        : { orderBy?: monster_collection_mobsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, monster_collection_mobsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMonster_collection_mobsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the monster_collection_mobs model
   */
  readonly fields: monster_collection_mobsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for monster_collection_mobs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__monster_collection_mobsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the monster_collection_mobs model
   */ 
  interface monster_collection_mobsFieldRefs {
    readonly id: FieldRef<"monster_collection_mobs", 'Int'>
    readonly collectionid: FieldRef<"monster_collection_mobs", 'Int'>
    readonly mobid: FieldRef<"monster_collection_mobs", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * monster_collection_mobs findUnique
   */
  export type monster_collection_mobsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collection_mobs
     */
    select?: monster_collection_mobsSelect<ExtArgs> | null
    /**
     * Filter, which monster_collection_mobs to fetch.
     */
    where: monster_collection_mobsWhereUniqueInput
  }

  /**
   * monster_collection_mobs findUniqueOrThrow
   */
  export type monster_collection_mobsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collection_mobs
     */
    select?: monster_collection_mobsSelect<ExtArgs> | null
    /**
     * Filter, which monster_collection_mobs to fetch.
     */
    where: monster_collection_mobsWhereUniqueInput
  }

  /**
   * monster_collection_mobs findFirst
   */
  export type monster_collection_mobsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collection_mobs
     */
    select?: monster_collection_mobsSelect<ExtArgs> | null
    /**
     * Filter, which monster_collection_mobs to fetch.
     */
    where?: monster_collection_mobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of monster_collection_mobs to fetch.
     */
    orderBy?: monster_collection_mobsOrderByWithRelationInput | monster_collection_mobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for monster_collection_mobs.
     */
    cursor?: monster_collection_mobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` monster_collection_mobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` monster_collection_mobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of monster_collection_mobs.
     */
    distinct?: Monster_collection_mobsScalarFieldEnum | Monster_collection_mobsScalarFieldEnum[]
  }

  /**
   * monster_collection_mobs findFirstOrThrow
   */
  export type monster_collection_mobsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collection_mobs
     */
    select?: monster_collection_mobsSelect<ExtArgs> | null
    /**
     * Filter, which monster_collection_mobs to fetch.
     */
    where?: monster_collection_mobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of monster_collection_mobs to fetch.
     */
    orderBy?: monster_collection_mobsOrderByWithRelationInput | monster_collection_mobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for monster_collection_mobs.
     */
    cursor?: monster_collection_mobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` monster_collection_mobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` monster_collection_mobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of monster_collection_mobs.
     */
    distinct?: Monster_collection_mobsScalarFieldEnum | Monster_collection_mobsScalarFieldEnum[]
  }

  /**
   * monster_collection_mobs findMany
   */
  export type monster_collection_mobsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collection_mobs
     */
    select?: monster_collection_mobsSelect<ExtArgs> | null
    /**
     * Filter, which monster_collection_mobs to fetch.
     */
    where?: monster_collection_mobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of monster_collection_mobs to fetch.
     */
    orderBy?: monster_collection_mobsOrderByWithRelationInput | monster_collection_mobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing monster_collection_mobs.
     */
    cursor?: monster_collection_mobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` monster_collection_mobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` monster_collection_mobs.
     */
    skip?: number
    distinct?: Monster_collection_mobsScalarFieldEnum | Monster_collection_mobsScalarFieldEnum[]
  }

  /**
   * monster_collection_mobs create
   */
  export type monster_collection_mobsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collection_mobs
     */
    select?: monster_collection_mobsSelect<ExtArgs> | null
    /**
     * The data needed to create a monster_collection_mobs.
     */
    data?: XOR<monster_collection_mobsCreateInput, monster_collection_mobsUncheckedCreateInput>
  }

  /**
   * monster_collection_mobs createMany
   */
  export type monster_collection_mobsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many monster_collection_mobs.
     */
    data: monster_collection_mobsCreateManyInput | monster_collection_mobsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * monster_collection_mobs update
   */
  export type monster_collection_mobsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collection_mobs
     */
    select?: monster_collection_mobsSelect<ExtArgs> | null
    /**
     * The data needed to update a monster_collection_mobs.
     */
    data: XOR<monster_collection_mobsUpdateInput, monster_collection_mobsUncheckedUpdateInput>
    /**
     * Choose, which monster_collection_mobs to update.
     */
    where: monster_collection_mobsWhereUniqueInput
  }

  /**
   * monster_collection_mobs updateMany
   */
  export type monster_collection_mobsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update monster_collection_mobs.
     */
    data: XOR<monster_collection_mobsUpdateManyMutationInput, monster_collection_mobsUncheckedUpdateManyInput>
    /**
     * Filter which monster_collection_mobs to update
     */
    where?: monster_collection_mobsWhereInput
  }

  /**
   * monster_collection_mobs upsert
   */
  export type monster_collection_mobsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collection_mobs
     */
    select?: monster_collection_mobsSelect<ExtArgs> | null
    /**
     * The filter to search for the monster_collection_mobs to update in case it exists.
     */
    where: monster_collection_mobsWhereUniqueInput
    /**
     * In case the monster_collection_mobs found by the `where` argument doesn't exist, create a new monster_collection_mobs with this data.
     */
    create: XOR<monster_collection_mobsCreateInput, monster_collection_mobsUncheckedCreateInput>
    /**
     * In case the monster_collection_mobs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<monster_collection_mobsUpdateInput, monster_collection_mobsUncheckedUpdateInput>
  }

  /**
   * monster_collection_mobs delete
   */
  export type monster_collection_mobsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collection_mobs
     */
    select?: monster_collection_mobsSelect<ExtArgs> | null
    /**
     * Filter which monster_collection_mobs to delete.
     */
    where: monster_collection_mobsWhereUniqueInput
  }

  /**
   * monster_collection_mobs deleteMany
   */
  export type monster_collection_mobsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which monster_collection_mobs to delete
     */
    where?: monster_collection_mobsWhereInput
  }

  /**
   * monster_collection_mobs without action
   */
  export type monster_collection_mobsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collection_mobs
     */
    select?: monster_collection_mobsSelect<ExtArgs> | null
  }


  /**
   * Model monster_collection_rewards
   */

  export type AggregateMonster_collection_rewards = {
    _count: Monster_collection_rewardsCountAggregateOutputType | null
    _avg: Monster_collection_rewardsAvgAggregateOutputType | null
    _sum: Monster_collection_rewardsSumAggregateOutputType | null
    _min: Monster_collection_rewardsMinAggregateOutputType | null
    _max: Monster_collection_rewardsMaxAggregateOutputType | null
  }

  export type Monster_collection_rewardsAvgAggregateOutputType = {
    region: number | null
    session: number | null
    groupid: number | null
    collectionid: number | null
  }

  export type Monster_collection_rewardsSumAggregateOutputType = {
    region: number | null
    session: number | null
    groupid: number | null
    collectionid: number | null
  }

  export type Monster_collection_rewardsMinAggregateOutputType = {
    region: number | null
    session: number | null
    groupid: number | null
    collectionid: number | null
  }

  export type Monster_collection_rewardsMaxAggregateOutputType = {
    region: number | null
    session: number | null
    groupid: number | null
    collectionid: number | null
  }

  export type Monster_collection_rewardsCountAggregateOutputType = {
    region: number
    session: number
    groupid: number
    collectionid: number
    _all: number
  }


  export type Monster_collection_rewardsAvgAggregateInputType = {
    region?: true
    session?: true
    groupid?: true
    collectionid?: true
  }

  export type Monster_collection_rewardsSumAggregateInputType = {
    region?: true
    session?: true
    groupid?: true
    collectionid?: true
  }

  export type Monster_collection_rewardsMinAggregateInputType = {
    region?: true
    session?: true
    groupid?: true
    collectionid?: true
  }

  export type Monster_collection_rewardsMaxAggregateInputType = {
    region?: true
    session?: true
    groupid?: true
    collectionid?: true
  }

  export type Monster_collection_rewardsCountAggregateInputType = {
    region?: true
    session?: true
    groupid?: true
    collectionid?: true
    _all?: true
  }

  export type Monster_collection_rewardsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which monster_collection_rewards to aggregate.
     */
    where?: monster_collection_rewardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of monster_collection_rewards to fetch.
     */
    orderBy?: monster_collection_rewardsOrderByWithRelationInput | monster_collection_rewardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: monster_collection_rewardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` monster_collection_rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` monster_collection_rewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned monster_collection_rewards
    **/
    _count?: true | Monster_collection_rewardsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Monster_collection_rewardsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Monster_collection_rewardsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Monster_collection_rewardsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Monster_collection_rewardsMaxAggregateInputType
  }

  export type GetMonster_collection_rewardsAggregateType<T extends Monster_collection_rewardsAggregateArgs> = {
        [P in keyof T & keyof AggregateMonster_collection_rewards]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMonster_collection_rewards[P]>
      : GetScalarType<T[P], AggregateMonster_collection_rewards[P]>
  }




  export type monster_collection_rewardsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: monster_collection_rewardsWhereInput
    orderBy?: monster_collection_rewardsOrderByWithAggregationInput | monster_collection_rewardsOrderByWithAggregationInput[]
    by: Monster_collection_rewardsScalarFieldEnum[] | Monster_collection_rewardsScalarFieldEnum
    having?: monster_collection_rewardsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Monster_collection_rewardsCountAggregateInputType | true
    _avg?: Monster_collection_rewardsAvgAggregateInputType
    _sum?: Monster_collection_rewardsSumAggregateInputType
    _min?: Monster_collection_rewardsMinAggregateInputType
    _max?: Monster_collection_rewardsMaxAggregateInputType
  }

  export type Monster_collection_rewardsGroupByOutputType = {
    region: number
    session: number
    groupid: number
    collectionid: number | null
    _count: Monster_collection_rewardsCountAggregateOutputType | null
    _avg: Monster_collection_rewardsAvgAggregateOutputType | null
    _sum: Monster_collection_rewardsSumAggregateOutputType | null
    _min: Monster_collection_rewardsMinAggregateOutputType | null
    _max: Monster_collection_rewardsMaxAggregateOutputType | null
  }

  type GetMonster_collection_rewardsGroupByPayload<T extends monster_collection_rewardsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Monster_collection_rewardsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Monster_collection_rewardsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Monster_collection_rewardsGroupByOutputType[P]>
            : GetScalarType<T[P], Monster_collection_rewardsGroupByOutputType[P]>
        }
      >
    >


  export type monster_collection_rewardsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    region?: boolean
    session?: boolean
    groupid?: boolean
    collectionid?: boolean
  }, ExtArgs["result"]["monster_collection_rewards"]>


  export type monster_collection_rewardsSelectScalar = {
    region?: boolean
    session?: boolean
    groupid?: boolean
    collectionid?: boolean
  }


  export type $monster_collection_rewardsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "monster_collection_rewards"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      region: number
      session: number
      groupid: number
      collectionid: number | null
    }, ExtArgs["result"]["monster_collection_rewards"]>
    composites: {}
  }

  type monster_collection_rewardsGetPayload<S extends boolean | null | undefined | monster_collection_rewardsDefaultArgs> = $Result.GetResult<Prisma.$monster_collection_rewardsPayload, S>

  type monster_collection_rewardsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<monster_collection_rewardsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Monster_collection_rewardsCountAggregateInputType | true
    }

  export interface monster_collection_rewardsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['monster_collection_rewards'], meta: { name: 'monster_collection_rewards' } }
    /**
     * Find zero or one Monster_collection_rewards that matches the filter.
     * @param {monster_collection_rewardsFindUniqueArgs} args - Arguments to find a Monster_collection_rewards
     * @example
     * // Get one Monster_collection_rewards
     * const monster_collection_rewards = await prisma.monster_collection_rewards.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends monster_collection_rewardsFindUniqueArgs>(args: SelectSubset<T, monster_collection_rewardsFindUniqueArgs<ExtArgs>>): Prisma__monster_collection_rewardsClient<$Result.GetResult<Prisma.$monster_collection_rewardsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Monster_collection_rewards that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {monster_collection_rewardsFindUniqueOrThrowArgs} args - Arguments to find a Monster_collection_rewards
     * @example
     * // Get one Monster_collection_rewards
     * const monster_collection_rewards = await prisma.monster_collection_rewards.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends monster_collection_rewardsFindUniqueOrThrowArgs>(args: SelectSubset<T, monster_collection_rewardsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__monster_collection_rewardsClient<$Result.GetResult<Prisma.$monster_collection_rewardsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Monster_collection_rewards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monster_collection_rewardsFindFirstArgs} args - Arguments to find a Monster_collection_rewards
     * @example
     * // Get one Monster_collection_rewards
     * const monster_collection_rewards = await prisma.monster_collection_rewards.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends monster_collection_rewardsFindFirstArgs>(args?: SelectSubset<T, monster_collection_rewardsFindFirstArgs<ExtArgs>>): Prisma__monster_collection_rewardsClient<$Result.GetResult<Prisma.$monster_collection_rewardsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Monster_collection_rewards that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monster_collection_rewardsFindFirstOrThrowArgs} args - Arguments to find a Monster_collection_rewards
     * @example
     * // Get one Monster_collection_rewards
     * const monster_collection_rewards = await prisma.monster_collection_rewards.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends monster_collection_rewardsFindFirstOrThrowArgs>(args?: SelectSubset<T, monster_collection_rewardsFindFirstOrThrowArgs<ExtArgs>>): Prisma__monster_collection_rewardsClient<$Result.GetResult<Prisma.$monster_collection_rewardsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Monster_collection_rewards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monster_collection_rewardsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Monster_collection_rewards
     * const monster_collection_rewards = await prisma.monster_collection_rewards.findMany()
     * 
     * // Get first 10 Monster_collection_rewards
     * const monster_collection_rewards = await prisma.monster_collection_rewards.findMany({ take: 10 })
     * 
     * // Only select the `region`
     * const monster_collection_rewardsWithRegionOnly = await prisma.monster_collection_rewards.findMany({ select: { region: true } })
     * 
     */
    findMany<T extends monster_collection_rewardsFindManyArgs>(args?: SelectSubset<T, monster_collection_rewardsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$monster_collection_rewardsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Monster_collection_rewards.
     * @param {monster_collection_rewardsCreateArgs} args - Arguments to create a Monster_collection_rewards.
     * @example
     * // Create one Monster_collection_rewards
     * const Monster_collection_rewards = await prisma.monster_collection_rewards.create({
     *   data: {
     *     // ... data to create a Monster_collection_rewards
     *   }
     * })
     * 
     */
    create<T extends monster_collection_rewardsCreateArgs>(args: SelectSubset<T, monster_collection_rewardsCreateArgs<ExtArgs>>): Prisma__monster_collection_rewardsClient<$Result.GetResult<Prisma.$monster_collection_rewardsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Monster_collection_rewards.
     * @param {monster_collection_rewardsCreateManyArgs} args - Arguments to create many Monster_collection_rewards.
     * @example
     * // Create many Monster_collection_rewards
     * const monster_collection_rewards = await prisma.monster_collection_rewards.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends monster_collection_rewardsCreateManyArgs>(args?: SelectSubset<T, monster_collection_rewardsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Monster_collection_rewards.
     * @param {monster_collection_rewardsDeleteArgs} args - Arguments to delete one Monster_collection_rewards.
     * @example
     * // Delete one Monster_collection_rewards
     * const Monster_collection_rewards = await prisma.monster_collection_rewards.delete({
     *   where: {
     *     // ... filter to delete one Monster_collection_rewards
     *   }
     * })
     * 
     */
    delete<T extends monster_collection_rewardsDeleteArgs>(args: SelectSubset<T, monster_collection_rewardsDeleteArgs<ExtArgs>>): Prisma__monster_collection_rewardsClient<$Result.GetResult<Prisma.$monster_collection_rewardsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Monster_collection_rewards.
     * @param {monster_collection_rewardsUpdateArgs} args - Arguments to update one Monster_collection_rewards.
     * @example
     * // Update one Monster_collection_rewards
     * const monster_collection_rewards = await prisma.monster_collection_rewards.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends monster_collection_rewardsUpdateArgs>(args: SelectSubset<T, monster_collection_rewardsUpdateArgs<ExtArgs>>): Prisma__monster_collection_rewardsClient<$Result.GetResult<Prisma.$monster_collection_rewardsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Monster_collection_rewards.
     * @param {monster_collection_rewardsDeleteManyArgs} args - Arguments to filter Monster_collection_rewards to delete.
     * @example
     * // Delete a few Monster_collection_rewards
     * const { count } = await prisma.monster_collection_rewards.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends monster_collection_rewardsDeleteManyArgs>(args?: SelectSubset<T, monster_collection_rewardsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Monster_collection_rewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monster_collection_rewardsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Monster_collection_rewards
     * const monster_collection_rewards = await prisma.monster_collection_rewards.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends monster_collection_rewardsUpdateManyArgs>(args: SelectSubset<T, monster_collection_rewardsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Monster_collection_rewards.
     * @param {monster_collection_rewardsUpsertArgs} args - Arguments to update or create a Monster_collection_rewards.
     * @example
     * // Update or create a Monster_collection_rewards
     * const monster_collection_rewards = await prisma.monster_collection_rewards.upsert({
     *   create: {
     *     // ... data to create a Monster_collection_rewards
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Monster_collection_rewards we want to update
     *   }
     * })
     */
    upsert<T extends monster_collection_rewardsUpsertArgs>(args: SelectSubset<T, monster_collection_rewardsUpsertArgs<ExtArgs>>): Prisma__monster_collection_rewardsClient<$Result.GetResult<Prisma.$monster_collection_rewardsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Monster_collection_rewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monster_collection_rewardsCountArgs} args - Arguments to filter Monster_collection_rewards to count.
     * @example
     * // Count the number of Monster_collection_rewards
     * const count = await prisma.monster_collection_rewards.count({
     *   where: {
     *     // ... the filter for the Monster_collection_rewards we want to count
     *   }
     * })
    **/
    count<T extends monster_collection_rewardsCountArgs>(
      args?: Subset<T, monster_collection_rewardsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Monster_collection_rewardsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Monster_collection_rewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Monster_collection_rewardsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Monster_collection_rewardsAggregateArgs>(args: Subset<T, Monster_collection_rewardsAggregateArgs>): Prisma.PrismaPromise<GetMonster_collection_rewardsAggregateType<T>>

    /**
     * Group by Monster_collection_rewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monster_collection_rewardsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends monster_collection_rewardsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: monster_collection_rewardsGroupByArgs['orderBy'] }
        : { orderBy?: monster_collection_rewardsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, monster_collection_rewardsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMonster_collection_rewardsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the monster_collection_rewards model
   */
  readonly fields: monster_collection_rewardsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for monster_collection_rewards.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__monster_collection_rewardsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the monster_collection_rewards model
   */ 
  interface monster_collection_rewardsFieldRefs {
    readonly region: FieldRef<"monster_collection_rewards", 'Int'>
    readonly session: FieldRef<"monster_collection_rewards", 'Int'>
    readonly groupid: FieldRef<"monster_collection_rewards", 'Int'>
    readonly collectionid: FieldRef<"monster_collection_rewards", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * monster_collection_rewards findUnique
   */
  export type monster_collection_rewardsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collection_rewards
     */
    select?: monster_collection_rewardsSelect<ExtArgs> | null
    /**
     * Filter, which monster_collection_rewards to fetch.
     */
    where: monster_collection_rewardsWhereUniqueInput
  }

  /**
   * monster_collection_rewards findUniqueOrThrow
   */
  export type monster_collection_rewardsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collection_rewards
     */
    select?: monster_collection_rewardsSelect<ExtArgs> | null
    /**
     * Filter, which monster_collection_rewards to fetch.
     */
    where: monster_collection_rewardsWhereUniqueInput
  }

  /**
   * monster_collection_rewards findFirst
   */
  export type monster_collection_rewardsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collection_rewards
     */
    select?: monster_collection_rewardsSelect<ExtArgs> | null
    /**
     * Filter, which monster_collection_rewards to fetch.
     */
    where?: monster_collection_rewardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of monster_collection_rewards to fetch.
     */
    orderBy?: monster_collection_rewardsOrderByWithRelationInput | monster_collection_rewardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for monster_collection_rewards.
     */
    cursor?: monster_collection_rewardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` monster_collection_rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` monster_collection_rewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of monster_collection_rewards.
     */
    distinct?: Monster_collection_rewardsScalarFieldEnum | Monster_collection_rewardsScalarFieldEnum[]
  }

  /**
   * monster_collection_rewards findFirstOrThrow
   */
  export type monster_collection_rewardsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collection_rewards
     */
    select?: monster_collection_rewardsSelect<ExtArgs> | null
    /**
     * Filter, which monster_collection_rewards to fetch.
     */
    where?: monster_collection_rewardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of monster_collection_rewards to fetch.
     */
    orderBy?: monster_collection_rewardsOrderByWithRelationInput | monster_collection_rewardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for monster_collection_rewards.
     */
    cursor?: monster_collection_rewardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` monster_collection_rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` monster_collection_rewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of monster_collection_rewards.
     */
    distinct?: Monster_collection_rewardsScalarFieldEnum | Monster_collection_rewardsScalarFieldEnum[]
  }

  /**
   * monster_collection_rewards findMany
   */
  export type monster_collection_rewardsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collection_rewards
     */
    select?: monster_collection_rewardsSelect<ExtArgs> | null
    /**
     * Filter, which monster_collection_rewards to fetch.
     */
    where?: monster_collection_rewardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of monster_collection_rewards to fetch.
     */
    orderBy?: monster_collection_rewardsOrderByWithRelationInput | monster_collection_rewardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing monster_collection_rewards.
     */
    cursor?: monster_collection_rewardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` monster_collection_rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` monster_collection_rewards.
     */
    skip?: number
    distinct?: Monster_collection_rewardsScalarFieldEnum | Monster_collection_rewardsScalarFieldEnum[]
  }

  /**
   * monster_collection_rewards create
   */
  export type monster_collection_rewardsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collection_rewards
     */
    select?: monster_collection_rewardsSelect<ExtArgs> | null
    /**
     * The data needed to create a monster_collection_rewards.
     */
    data: XOR<monster_collection_rewardsCreateInput, monster_collection_rewardsUncheckedCreateInput>
  }

  /**
   * monster_collection_rewards createMany
   */
  export type monster_collection_rewardsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many monster_collection_rewards.
     */
    data: monster_collection_rewardsCreateManyInput | monster_collection_rewardsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * monster_collection_rewards update
   */
  export type monster_collection_rewardsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collection_rewards
     */
    select?: monster_collection_rewardsSelect<ExtArgs> | null
    /**
     * The data needed to update a monster_collection_rewards.
     */
    data: XOR<monster_collection_rewardsUpdateInput, monster_collection_rewardsUncheckedUpdateInput>
    /**
     * Choose, which monster_collection_rewards to update.
     */
    where: monster_collection_rewardsWhereUniqueInput
  }

  /**
   * monster_collection_rewards updateMany
   */
  export type monster_collection_rewardsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update monster_collection_rewards.
     */
    data: XOR<monster_collection_rewardsUpdateManyMutationInput, monster_collection_rewardsUncheckedUpdateManyInput>
    /**
     * Filter which monster_collection_rewards to update
     */
    where?: monster_collection_rewardsWhereInput
  }

  /**
   * monster_collection_rewards upsert
   */
  export type monster_collection_rewardsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collection_rewards
     */
    select?: monster_collection_rewardsSelect<ExtArgs> | null
    /**
     * The filter to search for the monster_collection_rewards to update in case it exists.
     */
    where: monster_collection_rewardsWhereUniqueInput
    /**
     * In case the monster_collection_rewards found by the `where` argument doesn't exist, create a new monster_collection_rewards with this data.
     */
    create: XOR<monster_collection_rewardsCreateInput, monster_collection_rewardsUncheckedCreateInput>
    /**
     * In case the monster_collection_rewards was found with the provided `where` argument, update it with this data.
     */
    update: XOR<monster_collection_rewardsUpdateInput, monster_collection_rewardsUncheckedUpdateInput>
  }

  /**
   * monster_collection_rewards delete
   */
  export type monster_collection_rewardsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collection_rewards
     */
    select?: monster_collection_rewardsSelect<ExtArgs> | null
    /**
     * Filter which monster_collection_rewards to delete.
     */
    where: monster_collection_rewardsWhereUniqueInput
  }

  /**
   * monster_collection_rewards deleteMany
   */
  export type monster_collection_rewardsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which monster_collection_rewards to delete
     */
    where?: monster_collection_rewardsWhereInput
  }

  /**
   * monster_collection_rewards without action
   */
  export type monster_collection_rewardsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collection_rewards
     */
    select?: monster_collection_rewardsSelect<ExtArgs> | null
  }


  /**
   * Model monster_collection_session_rewards
   */

  export type AggregateMonster_collection_session_rewards = {
    _count: Monster_collection_session_rewardsCountAggregateOutputType | null
    _avg: Monster_collection_session_rewardsAvgAggregateOutputType | null
    _sum: Monster_collection_session_rewardsSumAggregateOutputType | null
    _min: Monster_collection_session_rewardsMinAggregateOutputType | null
    _max: Monster_collection_session_rewardsMaxAggregateOutputType | null
  }

  export type Monster_collection_session_rewardsAvgAggregateOutputType = {
    region: number | null
    session: number | null
    rewardid: number | null
    quantity: number | null
  }

  export type Monster_collection_session_rewardsSumAggregateOutputType = {
    region: number | null
    session: number | null
    rewardid: number | null
    quantity: number | null
  }

  export type Monster_collection_session_rewardsMinAggregateOutputType = {
    region: number | null
    session: number | null
    rewardid: number | null
    quantity: number | null
  }

  export type Monster_collection_session_rewardsMaxAggregateOutputType = {
    region: number | null
    session: number | null
    rewardid: number | null
    quantity: number | null
  }

  export type Monster_collection_session_rewardsCountAggregateOutputType = {
    region: number
    session: number
    rewardid: number
    quantity: number
    _all: number
  }


  export type Monster_collection_session_rewardsAvgAggregateInputType = {
    region?: true
    session?: true
    rewardid?: true
    quantity?: true
  }

  export type Monster_collection_session_rewardsSumAggregateInputType = {
    region?: true
    session?: true
    rewardid?: true
    quantity?: true
  }

  export type Monster_collection_session_rewardsMinAggregateInputType = {
    region?: true
    session?: true
    rewardid?: true
    quantity?: true
  }

  export type Monster_collection_session_rewardsMaxAggregateInputType = {
    region?: true
    session?: true
    rewardid?: true
    quantity?: true
  }

  export type Monster_collection_session_rewardsCountAggregateInputType = {
    region?: true
    session?: true
    rewardid?: true
    quantity?: true
    _all?: true
  }

  export type Monster_collection_session_rewardsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which monster_collection_session_rewards to aggregate.
     */
    where?: monster_collection_session_rewardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of monster_collection_session_rewards to fetch.
     */
    orderBy?: monster_collection_session_rewardsOrderByWithRelationInput | monster_collection_session_rewardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: monster_collection_session_rewardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` monster_collection_session_rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` monster_collection_session_rewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned monster_collection_session_rewards
    **/
    _count?: true | Monster_collection_session_rewardsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Monster_collection_session_rewardsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Monster_collection_session_rewardsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Monster_collection_session_rewardsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Monster_collection_session_rewardsMaxAggregateInputType
  }

  export type GetMonster_collection_session_rewardsAggregateType<T extends Monster_collection_session_rewardsAggregateArgs> = {
        [P in keyof T & keyof AggregateMonster_collection_session_rewards]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMonster_collection_session_rewards[P]>
      : GetScalarType<T[P], AggregateMonster_collection_session_rewards[P]>
  }




  export type monster_collection_session_rewardsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: monster_collection_session_rewardsWhereInput
    orderBy?: monster_collection_session_rewardsOrderByWithAggregationInput | monster_collection_session_rewardsOrderByWithAggregationInput[]
    by: Monster_collection_session_rewardsScalarFieldEnum[] | Monster_collection_session_rewardsScalarFieldEnum
    having?: monster_collection_session_rewardsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Monster_collection_session_rewardsCountAggregateInputType | true
    _avg?: Monster_collection_session_rewardsAvgAggregateInputType
    _sum?: Monster_collection_session_rewardsSumAggregateInputType
    _min?: Monster_collection_session_rewardsMinAggregateInputType
    _max?: Monster_collection_session_rewardsMaxAggregateInputType
  }

  export type Monster_collection_session_rewardsGroupByOutputType = {
    region: number
    session: number
    rewardid: number | null
    quantity: number | null
    _count: Monster_collection_session_rewardsCountAggregateOutputType | null
    _avg: Monster_collection_session_rewardsAvgAggregateOutputType | null
    _sum: Monster_collection_session_rewardsSumAggregateOutputType | null
    _min: Monster_collection_session_rewardsMinAggregateOutputType | null
    _max: Monster_collection_session_rewardsMaxAggregateOutputType | null
  }

  type GetMonster_collection_session_rewardsGroupByPayload<T extends monster_collection_session_rewardsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Monster_collection_session_rewardsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Monster_collection_session_rewardsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Monster_collection_session_rewardsGroupByOutputType[P]>
            : GetScalarType<T[P], Monster_collection_session_rewardsGroupByOutputType[P]>
        }
      >
    >


  export type monster_collection_session_rewardsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    region?: boolean
    session?: boolean
    rewardid?: boolean
    quantity?: boolean
  }, ExtArgs["result"]["monster_collection_session_rewards"]>


  export type monster_collection_session_rewardsSelectScalar = {
    region?: boolean
    session?: boolean
    rewardid?: boolean
    quantity?: boolean
  }


  export type $monster_collection_session_rewardsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "monster_collection_session_rewards"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      region: number
      session: number
      rewardid: number | null
      quantity: number | null
    }, ExtArgs["result"]["monster_collection_session_rewards"]>
    composites: {}
  }

  type monster_collection_session_rewardsGetPayload<S extends boolean | null | undefined | monster_collection_session_rewardsDefaultArgs> = $Result.GetResult<Prisma.$monster_collection_session_rewardsPayload, S>

  type monster_collection_session_rewardsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<monster_collection_session_rewardsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Monster_collection_session_rewardsCountAggregateInputType | true
    }

  export interface monster_collection_session_rewardsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['monster_collection_session_rewards'], meta: { name: 'monster_collection_session_rewards' } }
    /**
     * Find zero or one Monster_collection_session_rewards that matches the filter.
     * @param {monster_collection_session_rewardsFindUniqueArgs} args - Arguments to find a Monster_collection_session_rewards
     * @example
     * // Get one Monster_collection_session_rewards
     * const monster_collection_session_rewards = await prisma.monster_collection_session_rewards.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends monster_collection_session_rewardsFindUniqueArgs>(args: SelectSubset<T, monster_collection_session_rewardsFindUniqueArgs<ExtArgs>>): Prisma__monster_collection_session_rewardsClient<$Result.GetResult<Prisma.$monster_collection_session_rewardsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Monster_collection_session_rewards that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {monster_collection_session_rewardsFindUniqueOrThrowArgs} args - Arguments to find a Monster_collection_session_rewards
     * @example
     * // Get one Monster_collection_session_rewards
     * const monster_collection_session_rewards = await prisma.monster_collection_session_rewards.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends monster_collection_session_rewardsFindUniqueOrThrowArgs>(args: SelectSubset<T, monster_collection_session_rewardsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__monster_collection_session_rewardsClient<$Result.GetResult<Prisma.$monster_collection_session_rewardsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Monster_collection_session_rewards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monster_collection_session_rewardsFindFirstArgs} args - Arguments to find a Monster_collection_session_rewards
     * @example
     * // Get one Monster_collection_session_rewards
     * const monster_collection_session_rewards = await prisma.monster_collection_session_rewards.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends monster_collection_session_rewardsFindFirstArgs>(args?: SelectSubset<T, monster_collection_session_rewardsFindFirstArgs<ExtArgs>>): Prisma__monster_collection_session_rewardsClient<$Result.GetResult<Prisma.$monster_collection_session_rewardsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Monster_collection_session_rewards that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monster_collection_session_rewardsFindFirstOrThrowArgs} args - Arguments to find a Monster_collection_session_rewards
     * @example
     * // Get one Monster_collection_session_rewards
     * const monster_collection_session_rewards = await prisma.monster_collection_session_rewards.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends monster_collection_session_rewardsFindFirstOrThrowArgs>(args?: SelectSubset<T, monster_collection_session_rewardsFindFirstOrThrowArgs<ExtArgs>>): Prisma__monster_collection_session_rewardsClient<$Result.GetResult<Prisma.$monster_collection_session_rewardsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Monster_collection_session_rewards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monster_collection_session_rewardsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Monster_collection_session_rewards
     * const monster_collection_session_rewards = await prisma.monster_collection_session_rewards.findMany()
     * 
     * // Get first 10 Monster_collection_session_rewards
     * const monster_collection_session_rewards = await prisma.monster_collection_session_rewards.findMany({ take: 10 })
     * 
     * // Only select the `region`
     * const monster_collection_session_rewardsWithRegionOnly = await prisma.monster_collection_session_rewards.findMany({ select: { region: true } })
     * 
     */
    findMany<T extends monster_collection_session_rewardsFindManyArgs>(args?: SelectSubset<T, monster_collection_session_rewardsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$monster_collection_session_rewardsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Monster_collection_session_rewards.
     * @param {monster_collection_session_rewardsCreateArgs} args - Arguments to create a Monster_collection_session_rewards.
     * @example
     * // Create one Monster_collection_session_rewards
     * const Monster_collection_session_rewards = await prisma.monster_collection_session_rewards.create({
     *   data: {
     *     // ... data to create a Monster_collection_session_rewards
     *   }
     * })
     * 
     */
    create<T extends monster_collection_session_rewardsCreateArgs>(args: SelectSubset<T, monster_collection_session_rewardsCreateArgs<ExtArgs>>): Prisma__monster_collection_session_rewardsClient<$Result.GetResult<Prisma.$monster_collection_session_rewardsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Monster_collection_session_rewards.
     * @param {monster_collection_session_rewardsCreateManyArgs} args - Arguments to create many Monster_collection_session_rewards.
     * @example
     * // Create many Monster_collection_session_rewards
     * const monster_collection_session_rewards = await prisma.monster_collection_session_rewards.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends monster_collection_session_rewardsCreateManyArgs>(args?: SelectSubset<T, monster_collection_session_rewardsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Monster_collection_session_rewards.
     * @param {monster_collection_session_rewardsDeleteArgs} args - Arguments to delete one Monster_collection_session_rewards.
     * @example
     * // Delete one Monster_collection_session_rewards
     * const Monster_collection_session_rewards = await prisma.monster_collection_session_rewards.delete({
     *   where: {
     *     // ... filter to delete one Monster_collection_session_rewards
     *   }
     * })
     * 
     */
    delete<T extends monster_collection_session_rewardsDeleteArgs>(args: SelectSubset<T, monster_collection_session_rewardsDeleteArgs<ExtArgs>>): Prisma__monster_collection_session_rewardsClient<$Result.GetResult<Prisma.$monster_collection_session_rewardsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Monster_collection_session_rewards.
     * @param {monster_collection_session_rewardsUpdateArgs} args - Arguments to update one Monster_collection_session_rewards.
     * @example
     * // Update one Monster_collection_session_rewards
     * const monster_collection_session_rewards = await prisma.monster_collection_session_rewards.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends monster_collection_session_rewardsUpdateArgs>(args: SelectSubset<T, monster_collection_session_rewardsUpdateArgs<ExtArgs>>): Prisma__monster_collection_session_rewardsClient<$Result.GetResult<Prisma.$monster_collection_session_rewardsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Monster_collection_session_rewards.
     * @param {monster_collection_session_rewardsDeleteManyArgs} args - Arguments to filter Monster_collection_session_rewards to delete.
     * @example
     * // Delete a few Monster_collection_session_rewards
     * const { count } = await prisma.monster_collection_session_rewards.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends monster_collection_session_rewardsDeleteManyArgs>(args?: SelectSubset<T, monster_collection_session_rewardsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Monster_collection_session_rewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monster_collection_session_rewardsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Monster_collection_session_rewards
     * const monster_collection_session_rewards = await prisma.monster_collection_session_rewards.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends monster_collection_session_rewardsUpdateManyArgs>(args: SelectSubset<T, monster_collection_session_rewardsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Monster_collection_session_rewards.
     * @param {monster_collection_session_rewardsUpsertArgs} args - Arguments to update or create a Monster_collection_session_rewards.
     * @example
     * // Update or create a Monster_collection_session_rewards
     * const monster_collection_session_rewards = await prisma.monster_collection_session_rewards.upsert({
     *   create: {
     *     // ... data to create a Monster_collection_session_rewards
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Monster_collection_session_rewards we want to update
     *   }
     * })
     */
    upsert<T extends monster_collection_session_rewardsUpsertArgs>(args: SelectSubset<T, monster_collection_session_rewardsUpsertArgs<ExtArgs>>): Prisma__monster_collection_session_rewardsClient<$Result.GetResult<Prisma.$monster_collection_session_rewardsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Monster_collection_session_rewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monster_collection_session_rewardsCountArgs} args - Arguments to filter Monster_collection_session_rewards to count.
     * @example
     * // Count the number of Monster_collection_session_rewards
     * const count = await prisma.monster_collection_session_rewards.count({
     *   where: {
     *     // ... the filter for the Monster_collection_session_rewards we want to count
     *   }
     * })
    **/
    count<T extends monster_collection_session_rewardsCountArgs>(
      args?: Subset<T, monster_collection_session_rewardsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Monster_collection_session_rewardsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Monster_collection_session_rewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Monster_collection_session_rewardsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Monster_collection_session_rewardsAggregateArgs>(args: Subset<T, Monster_collection_session_rewardsAggregateArgs>): Prisma.PrismaPromise<GetMonster_collection_session_rewardsAggregateType<T>>

    /**
     * Group by Monster_collection_session_rewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monster_collection_session_rewardsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends monster_collection_session_rewardsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: monster_collection_session_rewardsGroupByArgs['orderBy'] }
        : { orderBy?: monster_collection_session_rewardsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, monster_collection_session_rewardsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMonster_collection_session_rewardsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the monster_collection_session_rewards model
   */
  readonly fields: monster_collection_session_rewardsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for monster_collection_session_rewards.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__monster_collection_session_rewardsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the monster_collection_session_rewards model
   */ 
  interface monster_collection_session_rewardsFieldRefs {
    readonly region: FieldRef<"monster_collection_session_rewards", 'Int'>
    readonly session: FieldRef<"monster_collection_session_rewards", 'Int'>
    readonly rewardid: FieldRef<"monster_collection_session_rewards", 'Int'>
    readonly quantity: FieldRef<"monster_collection_session_rewards", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * monster_collection_session_rewards findUnique
   */
  export type monster_collection_session_rewardsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collection_session_rewards
     */
    select?: monster_collection_session_rewardsSelect<ExtArgs> | null
    /**
     * Filter, which monster_collection_session_rewards to fetch.
     */
    where: monster_collection_session_rewardsWhereUniqueInput
  }

  /**
   * monster_collection_session_rewards findUniqueOrThrow
   */
  export type monster_collection_session_rewardsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collection_session_rewards
     */
    select?: monster_collection_session_rewardsSelect<ExtArgs> | null
    /**
     * Filter, which monster_collection_session_rewards to fetch.
     */
    where: monster_collection_session_rewardsWhereUniqueInput
  }

  /**
   * monster_collection_session_rewards findFirst
   */
  export type monster_collection_session_rewardsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collection_session_rewards
     */
    select?: monster_collection_session_rewardsSelect<ExtArgs> | null
    /**
     * Filter, which monster_collection_session_rewards to fetch.
     */
    where?: monster_collection_session_rewardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of monster_collection_session_rewards to fetch.
     */
    orderBy?: monster_collection_session_rewardsOrderByWithRelationInput | monster_collection_session_rewardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for monster_collection_session_rewards.
     */
    cursor?: monster_collection_session_rewardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` monster_collection_session_rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` monster_collection_session_rewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of monster_collection_session_rewards.
     */
    distinct?: Monster_collection_session_rewardsScalarFieldEnum | Monster_collection_session_rewardsScalarFieldEnum[]
  }

  /**
   * monster_collection_session_rewards findFirstOrThrow
   */
  export type monster_collection_session_rewardsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collection_session_rewards
     */
    select?: monster_collection_session_rewardsSelect<ExtArgs> | null
    /**
     * Filter, which monster_collection_session_rewards to fetch.
     */
    where?: monster_collection_session_rewardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of monster_collection_session_rewards to fetch.
     */
    orderBy?: monster_collection_session_rewardsOrderByWithRelationInput | monster_collection_session_rewardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for monster_collection_session_rewards.
     */
    cursor?: monster_collection_session_rewardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` monster_collection_session_rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` monster_collection_session_rewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of monster_collection_session_rewards.
     */
    distinct?: Monster_collection_session_rewardsScalarFieldEnum | Monster_collection_session_rewardsScalarFieldEnum[]
  }

  /**
   * monster_collection_session_rewards findMany
   */
  export type monster_collection_session_rewardsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collection_session_rewards
     */
    select?: monster_collection_session_rewardsSelect<ExtArgs> | null
    /**
     * Filter, which monster_collection_session_rewards to fetch.
     */
    where?: monster_collection_session_rewardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of monster_collection_session_rewards to fetch.
     */
    orderBy?: monster_collection_session_rewardsOrderByWithRelationInput | monster_collection_session_rewardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing monster_collection_session_rewards.
     */
    cursor?: monster_collection_session_rewardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` monster_collection_session_rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` monster_collection_session_rewards.
     */
    skip?: number
    distinct?: Monster_collection_session_rewardsScalarFieldEnum | Monster_collection_session_rewardsScalarFieldEnum[]
  }

  /**
   * monster_collection_session_rewards create
   */
  export type monster_collection_session_rewardsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collection_session_rewards
     */
    select?: monster_collection_session_rewardsSelect<ExtArgs> | null
    /**
     * The data needed to create a monster_collection_session_rewards.
     */
    data: XOR<monster_collection_session_rewardsCreateInput, monster_collection_session_rewardsUncheckedCreateInput>
  }

  /**
   * monster_collection_session_rewards createMany
   */
  export type monster_collection_session_rewardsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many monster_collection_session_rewards.
     */
    data: monster_collection_session_rewardsCreateManyInput | monster_collection_session_rewardsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * monster_collection_session_rewards update
   */
  export type monster_collection_session_rewardsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collection_session_rewards
     */
    select?: monster_collection_session_rewardsSelect<ExtArgs> | null
    /**
     * The data needed to update a monster_collection_session_rewards.
     */
    data: XOR<monster_collection_session_rewardsUpdateInput, monster_collection_session_rewardsUncheckedUpdateInput>
    /**
     * Choose, which monster_collection_session_rewards to update.
     */
    where: monster_collection_session_rewardsWhereUniqueInput
  }

  /**
   * monster_collection_session_rewards updateMany
   */
  export type monster_collection_session_rewardsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update monster_collection_session_rewards.
     */
    data: XOR<monster_collection_session_rewardsUpdateManyMutationInput, monster_collection_session_rewardsUncheckedUpdateManyInput>
    /**
     * Filter which monster_collection_session_rewards to update
     */
    where?: monster_collection_session_rewardsWhereInput
  }

  /**
   * monster_collection_session_rewards upsert
   */
  export type monster_collection_session_rewardsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collection_session_rewards
     */
    select?: monster_collection_session_rewardsSelect<ExtArgs> | null
    /**
     * The filter to search for the monster_collection_session_rewards to update in case it exists.
     */
    where: monster_collection_session_rewardsWhereUniqueInput
    /**
     * In case the monster_collection_session_rewards found by the `where` argument doesn't exist, create a new monster_collection_session_rewards with this data.
     */
    create: XOR<monster_collection_session_rewardsCreateInput, monster_collection_session_rewardsUncheckedCreateInput>
    /**
     * In case the monster_collection_session_rewards was found with the provided `where` argument, update it with this data.
     */
    update: XOR<monster_collection_session_rewardsUpdateInput, monster_collection_session_rewardsUncheckedUpdateInput>
  }

  /**
   * monster_collection_session_rewards delete
   */
  export type monster_collection_session_rewardsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collection_session_rewards
     */
    select?: monster_collection_session_rewardsSelect<ExtArgs> | null
    /**
     * Filter which monster_collection_session_rewards to delete.
     */
    where: monster_collection_session_rewardsWhereUniqueInput
  }

  /**
   * monster_collection_session_rewards deleteMany
   */
  export type monster_collection_session_rewardsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which monster_collection_session_rewards to delete
     */
    where?: monster_collection_session_rewardsWhereInput
  }

  /**
   * monster_collection_session_rewards without action
   */
  export type monster_collection_session_rewardsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collection_session_rewards
     */
    select?: monster_collection_session_rewardsSelect<ExtArgs> | null
  }


  /**
   * Model monster_collections
   */

  export type AggregateMonster_collections = {
    _count: Monster_collectionsCountAggregateOutputType | null
    _avg: Monster_collectionsAvgAggregateOutputType | null
    _sum: Monster_collectionsSumAggregateOutputType | null
    _min: Monster_collectionsMinAggregateOutputType | null
    _max: Monster_collectionsMaxAggregateOutputType | null
  }

  export type Monster_collectionsAvgAggregateOutputType = {
    id: number | null
    templateid: number | null
    accid: number | null
  }

  export type Monster_collectionsSumAggregateOutputType = {
    id: number | null
    templateid: number | null
    accid: number | null
  }

  export type Monster_collectionsMinAggregateOutputType = {
    id: number | null
    templateid: number | null
    accid: number | null
  }

  export type Monster_collectionsMaxAggregateOutputType = {
    id: number | null
    templateid: number | null
    accid: number | null
  }

  export type Monster_collectionsCountAggregateOutputType = {
    id: number
    templateid: number
    accid: number
    _all: number
  }


  export type Monster_collectionsAvgAggregateInputType = {
    id?: true
    templateid?: true
    accid?: true
  }

  export type Monster_collectionsSumAggregateInputType = {
    id?: true
    templateid?: true
    accid?: true
  }

  export type Monster_collectionsMinAggregateInputType = {
    id?: true
    templateid?: true
    accid?: true
  }

  export type Monster_collectionsMaxAggregateInputType = {
    id?: true
    templateid?: true
    accid?: true
  }

  export type Monster_collectionsCountAggregateInputType = {
    id?: true
    templateid?: true
    accid?: true
    _all?: true
  }

  export type Monster_collectionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which monster_collections to aggregate.
     */
    where?: monster_collectionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of monster_collections to fetch.
     */
    orderBy?: monster_collectionsOrderByWithRelationInput | monster_collectionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: monster_collectionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` monster_collections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` monster_collections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned monster_collections
    **/
    _count?: true | Monster_collectionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Monster_collectionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Monster_collectionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Monster_collectionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Monster_collectionsMaxAggregateInputType
  }

  export type GetMonster_collectionsAggregateType<T extends Monster_collectionsAggregateArgs> = {
        [P in keyof T & keyof AggregateMonster_collections]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMonster_collections[P]>
      : GetScalarType<T[P], AggregateMonster_collections[P]>
  }




  export type monster_collectionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: monster_collectionsWhereInput
    orderBy?: monster_collectionsOrderByWithAggregationInput | monster_collectionsOrderByWithAggregationInput[]
    by: Monster_collectionsScalarFieldEnum[] | Monster_collectionsScalarFieldEnum
    having?: monster_collectionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Monster_collectionsCountAggregateInputType | true
    _avg?: Monster_collectionsAvgAggregateInputType
    _sum?: Monster_collectionsSumAggregateInputType
    _min?: Monster_collectionsMinAggregateInputType
    _max?: Monster_collectionsMaxAggregateInputType
  }

  export type Monster_collectionsGroupByOutputType = {
    id: number
    templateid: number
    accid: number
    _count: Monster_collectionsCountAggregateOutputType | null
    _avg: Monster_collectionsAvgAggregateOutputType | null
    _sum: Monster_collectionsSumAggregateOutputType | null
    _min: Monster_collectionsMinAggregateOutputType | null
    _max: Monster_collectionsMaxAggregateOutputType | null
  }

  type GetMonster_collectionsGroupByPayload<T extends monster_collectionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Monster_collectionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Monster_collectionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Monster_collectionsGroupByOutputType[P]>
            : GetScalarType<T[P], Monster_collectionsGroupByOutputType[P]>
        }
      >
    >


  export type monster_collectionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    templateid?: boolean
    accid?: boolean
  }, ExtArgs["result"]["monster_collections"]>


  export type monster_collectionsSelectScalar = {
    id?: boolean
    templateid?: boolean
    accid?: boolean
  }


  export type $monster_collectionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "monster_collections"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      templateid: number
      accid: number
    }, ExtArgs["result"]["monster_collections"]>
    composites: {}
  }

  type monster_collectionsGetPayload<S extends boolean | null | undefined | monster_collectionsDefaultArgs> = $Result.GetResult<Prisma.$monster_collectionsPayload, S>

  type monster_collectionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<monster_collectionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Monster_collectionsCountAggregateInputType | true
    }

  export interface monster_collectionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['monster_collections'], meta: { name: 'monster_collections' } }
    /**
     * Find zero or one Monster_collections that matches the filter.
     * @param {monster_collectionsFindUniqueArgs} args - Arguments to find a Monster_collections
     * @example
     * // Get one Monster_collections
     * const monster_collections = await prisma.monster_collections.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends monster_collectionsFindUniqueArgs>(args: SelectSubset<T, monster_collectionsFindUniqueArgs<ExtArgs>>): Prisma__monster_collectionsClient<$Result.GetResult<Prisma.$monster_collectionsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Monster_collections that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {monster_collectionsFindUniqueOrThrowArgs} args - Arguments to find a Monster_collections
     * @example
     * // Get one Monster_collections
     * const monster_collections = await prisma.monster_collections.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends monster_collectionsFindUniqueOrThrowArgs>(args: SelectSubset<T, monster_collectionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__monster_collectionsClient<$Result.GetResult<Prisma.$monster_collectionsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Monster_collections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monster_collectionsFindFirstArgs} args - Arguments to find a Monster_collections
     * @example
     * // Get one Monster_collections
     * const monster_collections = await prisma.monster_collections.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends monster_collectionsFindFirstArgs>(args?: SelectSubset<T, monster_collectionsFindFirstArgs<ExtArgs>>): Prisma__monster_collectionsClient<$Result.GetResult<Prisma.$monster_collectionsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Monster_collections that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monster_collectionsFindFirstOrThrowArgs} args - Arguments to find a Monster_collections
     * @example
     * // Get one Monster_collections
     * const monster_collections = await prisma.monster_collections.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends monster_collectionsFindFirstOrThrowArgs>(args?: SelectSubset<T, monster_collectionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__monster_collectionsClient<$Result.GetResult<Prisma.$monster_collectionsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Monster_collections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monster_collectionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Monster_collections
     * const monster_collections = await prisma.monster_collections.findMany()
     * 
     * // Get first 10 Monster_collections
     * const monster_collections = await prisma.monster_collections.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const monster_collectionsWithIdOnly = await prisma.monster_collections.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends monster_collectionsFindManyArgs>(args?: SelectSubset<T, monster_collectionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$monster_collectionsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Monster_collections.
     * @param {monster_collectionsCreateArgs} args - Arguments to create a Monster_collections.
     * @example
     * // Create one Monster_collections
     * const Monster_collections = await prisma.monster_collections.create({
     *   data: {
     *     // ... data to create a Monster_collections
     *   }
     * })
     * 
     */
    create<T extends monster_collectionsCreateArgs>(args: SelectSubset<T, monster_collectionsCreateArgs<ExtArgs>>): Prisma__monster_collectionsClient<$Result.GetResult<Prisma.$monster_collectionsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Monster_collections.
     * @param {monster_collectionsCreateManyArgs} args - Arguments to create many Monster_collections.
     * @example
     * // Create many Monster_collections
     * const monster_collections = await prisma.monster_collections.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends monster_collectionsCreateManyArgs>(args?: SelectSubset<T, monster_collectionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Monster_collections.
     * @param {monster_collectionsDeleteArgs} args - Arguments to delete one Monster_collections.
     * @example
     * // Delete one Monster_collections
     * const Monster_collections = await prisma.monster_collections.delete({
     *   where: {
     *     // ... filter to delete one Monster_collections
     *   }
     * })
     * 
     */
    delete<T extends monster_collectionsDeleteArgs>(args: SelectSubset<T, monster_collectionsDeleteArgs<ExtArgs>>): Prisma__monster_collectionsClient<$Result.GetResult<Prisma.$monster_collectionsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Monster_collections.
     * @param {monster_collectionsUpdateArgs} args - Arguments to update one Monster_collections.
     * @example
     * // Update one Monster_collections
     * const monster_collections = await prisma.monster_collections.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends monster_collectionsUpdateArgs>(args: SelectSubset<T, monster_collectionsUpdateArgs<ExtArgs>>): Prisma__monster_collectionsClient<$Result.GetResult<Prisma.$monster_collectionsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Monster_collections.
     * @param {monster_collectionsDeleteManyArgs} args - Arguments to filter Monster_collections to delete.
     * @example
     * // Delete a few Monster_collections
     * const { count } = await prisma.monster_collections.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends monster_collectionsDeleteManyArgs>(args?: SelectSubset<T, monster_collectionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Monster_collections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monster_collectionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Monster_collections
     * const monster_collections = await prisma.monster_collections.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends monster_collectionsUpdateManyArgs>(args: SelectSubset<T, monster_collectionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Monster_collections.
     * @param {monster_collectionsUpsertArgs} args - Arguments to update or create a Monster_collections.
     * @example
     * // Update or create a Monster_collections
     * const monster_collections = await prisma.monster_collections.upsert({
     *   create: {
     *     // ... data to create a Monster_collections
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Monster_collections we want to update
     *   }
     * })
     */
    upsert<T extends monster_collectionsUpsertArgs>(args: SelectSubset<T, monster_collectionsUpsertArgs<ExtArgs>>): Prisma__monster_collectionsClient<$Result.GetResult<Prisma.$monster_collectionsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Monster_collections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monster_collectionsCountArgs} args - Arguments to filter Monster_collections to count.
     * @example
     * // Count the number of Monster_collections
     * const count = await prisma.monster_collections.count({
     *   where: {
     *     // ... the filter for the Monster_collections we want to count
     *   }
     * })
    **/
    count<T extends monster_collectionsCountArgs>(
      args?: Subset<T, monster_collectionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Monster_collectionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Monster_collections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Monster_collectionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Monster_collectionsAggregateArgs>(args: Subset<T, Monster_collectionsAggregateArgs>): Prisma.PrismaPromise<GetMonster_collectionsAggregateType<T>>

    /**
     * Group by Monster_collections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monster_collectionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends monster_collectionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: monster_collectionsGroupByArgs['orderBy'] }
        : { orderBy?: monster_collectionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, monster_collectionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMonster_collectionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the monster_collections model
   */
  readonly fields: monster_collectionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for monster_collections.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__monster_collectionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the monster_collections model
   */ 
  interface monster_collectionsFieldRefs {
    readonly id: FieldRef<"monster_collections", 'Int'>
    readonly templateid: FieldRef<"monster_collections", 'Int'>
    readonly accid: FieldRef<"monster_collections", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * monster_collections findUnique
   */
  export type monster_collectionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collections
     */
    select?: monster_collectionsSelect<ExtArgs> | null
    /**
     * Filter, which monster_collections to fetch.
     */
    where: monster_collectionsWhereUniqueInput
  }

  /**
   * monster_collections findUniqueOrThrow
   */
  export type monster_collectionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collections
     */
    select?: monster_collectionsSelect<ExtArgs> | null
    /**
     * Filter, which monster_collections to fetch.
     */
    where: monster_collectionsWhereUniqueInput
  }

  /**
   * monster_collections findFirst
   */
  export type monster_collectionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collections
     */
    select?: monster_collectionsSelect<ExtArgs> | null
    /**
     * Filter, which monster_collections to fetch.
     */
    where?: monster_collectionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of monster_collections to fetch.
     */
    orderBy?: monster_collectionsOrderByWithRelationInput | monster_collectionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for monster_collections.
     */
    cursor?: monster_collectionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` monster_collections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` monster_collections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of monster_collections.
     */
    distinct?: Monster_collectionsScalarFieldEnum | Monster_collectionsScalarFieldEnum[]
  }

  /**
   * monster_collections findFirstOrThrow
   */
  export type monster_collectionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collections
     */
    select?: monster_collectionsSelect<ExtArgs> | null
    /**
     * Filter, which monster_collections to fetch.
     */
    where?: monster_collectionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of monster_collections to fetch.
     */
    orderBy?: monster_collectionsOrderByWithRelationInput | monster_collectionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for monster_collections.
     */
    cursor?: monster_collectionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` monster_collections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` monster_collections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of monster_collections.
     */
    distinct?: Monster_collectionsScalarFieldEnum | Monster_collectionsScalarFieldEnum[]
  }

  /**
   * monster_collections findMany
   */
  export type monster_collectionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collections
     */
    select?: monster_collectionsSelect<ExtArgs> | null
    /**
     * Filter, which monster_collections to fetch.
     */
    where?: monster_collectionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of monster_collections to fetch.
     */
    orderBy?: monster_collectionsOrderByWithRelationInput | monster_collectionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing monster_collections.
     */
    cursor?: monster_collectionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` monster_collections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` monster_collections.
     */
    skip?: number
    distinct?: Monster_collectionsScalarFieldEnum | Monster_collectionsScalarFieldEnum[]
  }

  /**
   * monster_collections create
   */
  export type monster_collectionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collections
     */
    select?: monster_collectionsSelect<ExtArgs> | null
    /**
     * The data needed to create a monster_collections.
     */
    data?: XOR<monster_collectionsCreateInput, monster_collectionsUncheckedCreateInput>
  }

  /**
   * monster_collections createMany
   */
  export type monster_collectionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many monster_collections.
     */
    data: monster_collectionsCreateManyInput | monster_collectionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * monster_collections update
   */
  export type monster_collectionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collections
     */
    select?: monster_collectionsSelect<ExtArgs> | null
    /**
     * The data needed to update a monster_collections.
     */
    data: XOR<monster_collectionsUpdateInput, monster_collectionsUncheckedUpdateInput>
    /**
     * Choose, which monster_collections to update.
     */
    where: monster_collectionsWhereUniqueInput
  }

  /**
   * monster_collections updateMany
   */
  export type monster_collectionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update monster_collections.
     */
    data: XOR<monster_collectionsUpdateManyMutationInput, monster_collectionsUncheckedUpdateManyInput>
    /**
     * Filter which monster_collections to update
     */
    where?: monster_collectionsWhereInput
  }

  /**
   * monster_collections upsert
   */
  export type monster_collectionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collections
     */
    select?: monster_collectionsSelect<ExtArgs> | null
    /**
     * The filter to search for the monster_collections to update in case it exists.
     */
    where: monster_collectionsWhereUniqueInput
    /**
     * In case the monster_collections found by the `where` argument doesn't exist, create a new monster_collections with this data.
     */
    create: XOR<monster_collectionsCreateInput, monster_collectionsUncheckedCreateInput>
    /**
     * In case the monster_collections was found with the provided `where` argument, update it with this data.
     */
    update: XOR<monster_collectionsUpdateInput, monster_collectionsUncheckedUpdateInput>
  }

  /**
   * monster_collections delete
   */
  export type monster_collectionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collections
     */
    select?: monster_collectionsSelect<ExtArgs> | null
    /**
     * Filter which monster_collections to delete.
     */
    where: monster_collectionsWhereUniqueInput
  }

  /**
   * monster_collections deleteMany
   */
  export type monster_collectionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which monster_collections to delete
     */
    where?: monster_collectionsWhereInput
  }

  /**
   * monster_collections without action
   */
  export type monster_collectionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monster_collections
     */
    select?: monster_collectionsSelect<ExtArgs> | null
  }


  /**
   * Model monsterbookcards
   */

  export type AggregateMonsterbookcards = {
    _count: MonsterbookcardsCountAggregateOutputType | null
    _avg: MonsterbookcardsAvgAggregateOutputType | null
    _sum: MonsterbookcardsSumAggregateOutputType | null
    _min: MonsterbookcardsMinAggregateOutputType | null
    _max: MonsterbookcardsMaxAggregateOutputType | null
  }

  export type MonsterbookcardsAvgAggregateOutputType = {
    id: number | null
    bookid: number | null
    cardid: number | null
  }

  export type MonsterbookcardsSumAggregateOutputType = {
    id: bigint | null
    bookid: number | null
    cardid: number | null
  }

  export type MonsterbookcardsMinAggregateOutputType = {
    id: bigint | null
    bookid: number | null
    cardid: number | null
  }

  export type MonsterbookcardsMaxAggregateOutputType = {
    id: bigint | null
    bookid: number | null
    cardid: number | null
  }

  export type MonsterbookcardsCountAggregateOutputType = {
    id: number
    bookid: number
    cardid: number
    _all: number
  }


  export type MonsterbookcardsAvgAggregateInputType = {
    id?: true
    bookid?: true
    cardid?: true
  }

  export type MonsterbookcardsSumAggregateInputType = {
    id?: true
    bookid?: true
    cardid?: true
  }

  export type MonsterbookcardsMinAggregateInputType = {
    id?: true
    bookid?: true
    cardid?: true
  }

  export type MonsterbookcardsMaxAggregateInputType = {
    id?: true
    bookid?: true
    cardid?: true
  }

  export type MonsterbookcardsCountAggregateInputType = {
    id?: true
    bookid?: true
    cardid?: true
    _all?: true
  }

  export type MonsterbookcardsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which monsterbookcards to aggregate.
     */
    where?: monsterbookcardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of monsterbookcards to fetch.
     */
    orderBy?: monsterbookcardsOrderByWithRelationInput | monsterbookcardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: monsterbookcardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` monsterbookcards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` monsterbookcards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned monsterbookcards
    **/
    _count?: true | MonsterbookcardsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MonsterbookcardsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MonsterbookcardsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MonsterbookcardsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MonsterbookcardsMaxAggregateInputType
  }

  export type GetMonsterbookcardsAggregateType<T extends MonsterbookcardsAggregateArgs> = {
        [P in keyof T & keyof AggregateMonsterbookcards]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMonsterbookcards[P]>
      : GetScalarType<T[P], AggregateMonsterbookcards[P]>
  }




  export type monsterbookcardsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: monsterbookcardsWhereInput
    orderBy?: monsterbookcardsOrderByWithAggregationInput | monsterbookcardsOrderByWithAggregationInput[]
    by: MonsterbookcardsScalarFieldEnum[] | MonsterbookcardsScalarFieldEnum
    having?: monsterbookcardsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MonsterbookcardsCountAggregateInputType | true
    _avg?: MonsterbookcardsAvgAggregateInputType
    _sum?: MonsterbookcardsSumAggregateInputType
    _min?: MonsterbookcardsMinAggregateInputType
    _max?: MonsterbookcardsMaxAggregateInputType
  }

  export type MonsterbookcardsGroupByOutputType = {
    id: bigint
    bookid: number | null
    cardid: number | null
    _count: MonsterbookcardsCountAggregateOutputType | null
    _avg: MonsterbookcardsAvgAggregateOutputType | null
    _sum: MonsterbookcardsSumAggregateOutputType | null
    _min: MonsterbookcardsMinAggregateOutputType | null
    _max: MonsterbookcardsMaxAggregateOutputType | null
  }

  type GetMonsterbookcardsGroupByPayload<T extends monsterbookcardsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MonsterbookcardsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MonsterbookcardsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MonsterbookcardsGroupByOutputType[P]>
            : GetScalarType<T[P], MonsterbookcardsGroupByOutputType[P]>
        }
      >
    >


  export type monsterbookcardsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookid?: boolean
    cardid?: boolean
  }, ExtArgs["result"]["monsterbookcards"]>


  export type monsterbookcardsSelectScalar = {
    id?: boolean
    bookid?: boolean
    cardid?: boolean
  }


  export type $monsterbookcardsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "monsterbookcards"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      bookid: number | null
      cardid: number | null
    }, ExtArgs["result"]["monsterbookcards"]>
    composites: {}
  }

  type monsterbookcardsGetPayload<S extends boolean | null | undefined | monsterbookcardsDefaultArgs> = $Result.GetResult<Prisma.$monsterbookcardsPayload, S>

  type monsterbookcardsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<monsterbookcardsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MonsterbookcardsCountAggregateInputType | true
    }

  export interface monsterbookcardsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['monsterbookcards'], meta: { name: 'monsterbookcards' } }
    /**
     * Find zero or one Monsterbookcards that matches the filter.
     * @param {monsterbookcardsFindUniqueArgs} args - Arguments to find a Monsterbookcards
     * @example
     * // Get one Monsterbookcards
     * const monsterbookcards = await prisma.monsterbookcards.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends monsterbookcardsFindUniqueArgs>(args: SelectSubset<T, monsterbookcardsFindUniqueArgs<ExtArgs>>): Prisma__monsterbookcardsClient<$Result.GetResult<Prisma.$monsterbookcardsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Monsterbookcards that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {monsterbookcardsFindUniqueOrThrowArgs} args - Arguments to find a Monsterbookcards
     * @example
     * // Get one Monsterbookcards
     * const monsterbookcards = await prisma.monsterbookcards.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends monsterbookcardsFindUniqueOrThrowArgs>(args: SelectSubset<T, monsterbookcardsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__monsterbookcardsClient<$Result.GetResult<Prisma.$monsterbookcardsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Monsterbookcards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monsterbookcardsFindFirstArgs} args - Arguments to find a Monsterbookcards
     * @example
     * // Get one Monsterbookcards
     * const monsterbookcards = await prisma.monsterbookcards.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends monsterbookcardsFindFirstArgs>(args?: SelectSubset<T, monsterbookcardsFindFirstArgs<ExtArgs>>): Prisma__monsterbookcardsClient<$Result.GetResult<Prisma.$monsterbookcardsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Monsterbookcards that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monsterbookcardsFindFirstOrThrowArgs} args - Arguments to find a Monsterbookcards
     * @example
     * // Get one Monsterbookcards
     * const monsterbookcards = await prisma.monsterbookcards.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends monsterbookcardsFindFirstOrThrowArgs>(args?: SelectSubset<T, monsterbookcardsFindFirstOrThrowArgs<ExtArgs>>): Prisma__monsterbookcardsClient<$Result.GetResult<Prisma.$monsterbookcardsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Monsterbookcards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monsterbookcardsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Monsterbookcards
     * const monsterbookcards = await prisma.monsterbookcards.findMany()
     * 
     * // Get first 10 Monsterbookcards
     * const monsterbookcards = await prisma.monsterbookcards.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const monsterbookcardsWithIdOnly = await prisma.monsterbookcards.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends monsterbookcardsFindManyArgs>(args?: SelectSubset<T, monsterbookcardsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$monsterbookcardsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Monsterbookcards.
     * @param {monsterbookcardsCreateArgs} args - Arguments to create a Monsterbookcards.
     * @example
     * // Create one Monsterbookcards
     * const Monsterbookcards = await prisma.monsterbookcards.create({
     *   data: {
     *     // ... data to create a Monsterbookcards
     *   }
     * })
     * 
     */
    create<T extends monsterbookcardsCreateArgs>(args: SelectSubset<T, monsterbookcardsCreateArgs<ExtArgs>>): Prisma__monsterbookcardsClient<$Result.GetResult<Prisma.$monsterbookcardsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Monsterbookcards.
     * @param {monsterbookcardsCreateManyArgs} args - Arguments to create many Monsterbookcards.
     * @example
     * // Create many Monsterbookcards
     * const monsterbookcards = await prisma.monsterbookcards.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends monsterbookcardsCreateManyArgs>(args?: SelectSubset<T, monsterbookcardsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Monsterbookcards.
     * @param {monsterbookcardsDeleteArgs} args - Arguments to delete one Monsterbookcards.
     * @example
     * // Delete one Monsterbookcards
     * const Monsterbookcards = await prisma.monsterbookcards.delete({
     *   where: {
     *     // ... filter to delete one Monsterbookcards
     *   }
     * })
     * 
     */
    delete<T extends monsterbookcardsDeleteArgs>(args: SelectSubset<T, monsterbookcardsDeleteArgs<ExtArgs>>): Prisma__monsterbookcardsClient<$Result.GetResult<Prisma.$monsterbookcardsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Monsterbookcards.
     * @param {monsterbookcardsUpdateArgs} args - Arguments to update one Monsterbookcards.
     * @example
     * // Update one Monsterbookcards
     * const monsterbookcards = await prisma.monsterbookcards.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends monsterbookcardsUpdateArgs>(args: SelectSubset<T, monsterbookcardsUpdateArgs<ExtArgs>>): Prisma__monsterbookcardsClient<$Result.GetResult<Prisma.$monsterbookcardsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Monsterbookcards.
     * @param {monsterbookcardsDeleteManyArgs} args - Arguments to filter Monsterbookcards to delete.
     * @example
     * // Delete a few Monsterbookcards
     * const { count } = await prisma.monsterbookcards.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends monsterbookcardsDeleteManyArgs>(args?: SelectSubset<T, monsterbookcardsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Monsterbookcards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monsterbookcardsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Monsterbookcards
     * const monsterbookcards = await prisma.monsterbookcards.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends monsterbookcardsUpdateManyArgs>(args: SelectSubset<T, monsterbookcardsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Monsterbookcards.
     * @param {monsterbookcardsUpsertArgs} args - Arguments to update or create a Monsterbookcards.
     * @example
     * // Update or create a Monsterbookcards
     * const monsterbookcards = await prisma.monsterbookcards.upsert({
     *   create: {
     *     // ... data to create a Monsterbookcards
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Monsterbookcards we want to update
     *   }
     * })
     */
    upsert<T extends monsterbookcardsUpsertArgs>(args: SelectSubset<T, monsterbookcardsUpsertArgs<ExtArgs>>): Prisma__monsterbookcardsClient<$Result.GetResult<Prisma.$monsterbookcardsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Monsterbookcards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monsterbookcardsCountArgs} args - Arguments to filter Monsterbookcards to count.
     * @example
     * // Count the number of Monsterbookcards
     * const count = await prisma.monsterbookcards.count({
     *   where: {
     *     // ... the filter for the Monsterbookcards we want to count
     *   }
     * })
    **/
    count<T extends monsterbookcardsCountArgs>(
      args?: Subset<T, monsterbookcardsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MonsterbookcardsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Monsterbookcards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonsterbookcardsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MonsterbookcardsAggregateArgs>(args: Subset<T, MonsterbookcardsAggregateArgs>): Prisma.PrismaPromise<GetMonsterbookcardsAggregateType<T>>

    /**
     * Group by Monsterbookcards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monsterbookcardsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends monsterbookcardsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: monsterbookcardsGroupByArgs['orderBy'] }
        : { orderBy?: monsterbookcardsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, monsterbookcardsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMonsterbookcardsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the monsterbookcards model
   */
  readonly fields: monsterbookcardsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for monsterbookcards.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__monsterbookcardsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the monsterbookcards model
   */ 
  interface monsterbookcardsFieldRefs {
    readonly id: FieldRef<"monsterbookcards", 'BigInt'>
    readonly bookid: FieldRef<"monsterbookcards", 'Int'>
    readonly cardid: FieldRef<"monsterbookcards", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * monsterbookcards findUnique
   */
  export type monsterbookcardsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monsterbookcards
     */
    select?: monsterbookcardsSelect<ExtArgs> | null
    /**
     * Filter, which monsterbookcards to fetch.
     */
    where: monsterbookcardsWhereUniqueInput
  }

  /**
   * monsterbookcards findUniqueOrThrow
   */
  export type monsterbookcardsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monsterbookcards
     */
    select?: monsterbookcardsSelect<ExtArgs> | null
    /**
     * Filter, which monsterbookcards to fetch.
     */
    where: monsterbookcardsWhereUniqueInput
  }

  /**
   * monsterbookcards findFirst
   */
  export type monsterbookcardsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monsterbookcards
     */
    select?: monsterbookcardsSelect<ExtArgs> | null
    /**
     * Filter, which monsterbookcards to fetch.
     */
    where?: monsterbookcardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of monsterbookcards to fetch.
     */
    orderBy?: monsterbookcardsOrderByWithRelationInput | monsterbookcardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for monsterbookcards.
     */
    cursor?: monsterbookcardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` monsterbookcards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` monsterbookcards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of monsterbookcards.
     */
    distinct?: MonsterbookcardsScalarFieldEnum | MonsterbookcardsScalarFieldEnum[]
  }

  /**
   * monsterbookcards findFirstOrThrow
   */
  export type monsterbookcardsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monsterbookcards
     */
    select?: monsterbookcardsSelect<ExtArgs> | null
    /**
     * Filter, which monsterbookcards to fetch.
     */
    where?: monsterbookcardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of monsterbookcards to fetch.
     */
    orderBy?: monsterbookcardsOrderByWithRelationInput | monsterbookcardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for monsterbookcards.
     */
    cursor?: monsterbookcardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` monsterbookcards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` monsterbookcards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of monsterbookcards.
     */
    distinct?: MonsterbookcardsScalarFieldEnum | MonsterbookcardsScalarFieldEnum[]
  }

  /**
   * monsterbookcards findMany
   */
  export type monsterbookcardsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monsterbookcards
     */
    select?: monsterbookcardsSelect<ExtArgs> | null
    /**
     * Filter, which monsterbookcards to fetch.
     */
    where?: monsterbookcardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of monsterbookcards to fetch.
     */
    orderBy?: monsterbookcardsOrderByWithRelationInput | monsterbookcardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing monsterbookcards.
     */
    cursor?: monsterbookcardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` monsterbookcards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` monsterbookcards.
     */
    skip?: number
    distinct?: MonsterbookcardsScalarFieldEnum | MonsterbookcardsScalarFieldEnum[]
  }

  /**
   * monsterbookcards create
   */
  export type monsterbookcardsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monsterbookcards
     */
    select?: monsterbookcardsSelect<ExtArgs> | null
    /**
     * The data needed to create a monsterbookcards.
     */
    data?: XOR<monsterbookcardsCreateInput, monsterbookcardsUncheckedCreateInput>
  }

  /**
   * monsterbookcards createMany
   */
  export type monsterbookcardsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many monsterbookcards.
     */
    data: monsterbookcardsCreateManyInput | monsterbookcardsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * monsterbookcards update
   */
  export type monsterbookcardsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monsterbookcards
     */
    select?: monsterbookcardsSelect<ExtArgs> | null
    /**
     * The data needed to update a monsterbookcards.
     */
    data: XOR<monsterbookcardsUpdateInput, monsterbookcardsUncheckedUpdateInput>
    /**
     * Choose, which monsterbookcards to update.
     */
    where: monsterbookcardsWhereUniqueInput
  }

  /**
   * monsterbookcards updateMany
   */
  export type monsterbookcardsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update monsterbookcards.
     */
    data: XOR<monsterbookcardsUpdateManyMutationInput, monsterbookcardsUncheckedUpdateManyInput>
    /**
     * Filter which monsterbookcards to update
     */
    where?: monsterbookcardsWhereInput
  }

  /**
   * monsterbookcards upsert
   */
  export type monsterbookcardsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monsterbookcards
     */
    select?: monsterbookcardsSelect<ExtArgs> | null
    /**
     * The filter to search for the monsterbookcards to update in case it exists.
     */
    where: monsterbookcardsWhereUniqueInput
    /**
     * In case the monsterbookcards found by the `where` argument doesn't exist, create a new monsterbookcards with this data.
     */
    create: XOR<monsterbookcardsCreateInput, monsterbookcardsUncheckedCreateInput>
    /**
     * In case the monsterbookcards was found with the provided `where` argument, update it with this data.
     */
    update: XOR<monsterbookcardsUpdateInput, monsterbookcardsUncheckedUpdateInput>
  }

  /**
   * monsterbookcards delete
   */
  export type monsterbookcardsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monsterbookcards
     */
    select?: monsterbookcardsSelect<ExtArgs> | null
    /**
     * Filter which monsterbookcards to delete.
     */
    where: monsterbookcardsWhereUniqueInput
  }

  /**
   * monsterbookcards deleteMany
   */
  export type monsterbookcardsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which monsterbookcards to delete
     */
    where?: monsterbookcardsWhereInput
  }

  /**
   * monsterbookcards without action
   */
  export type monsterbookcardsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monsterbookcards
     */
    select?: monsterbookcardsSelect<ExtArgs> | null
  }


  /**
   * Model monsterbookinfos
   */

  export type AggregateMonsterbookinfos = {
    _count: MonsterbookinfosCountAggregateOutputType | null
    _avg: MonsterbookinfosAvgAggregateOutputType | null
    _sum: MonsterbookinfosSumAggregateOutputType | null
    _min: MonsterbookinfosMinAggregateOutputType | null
    _max: MonsterbookinfosMaxAggregateOutputType | null
  }

  export type MonsterbookinfosAvgAggregateOutputType = {
    id: number | null
    setid: number | null
    coverid: number | null
  }

  export type MonsterbookinfosSumAggregateOutputType = {
    id: number | null
    setid: number | null
    coverid: number | null
  }

  export type MonsterbookinfosMinAggregateOutputType = {
    id: number | null
    setid: number | null
    coverid: number | null
  }

  export type MonsterbookinfosMaxAggregateOutputType = {
    id: number | null
    setid: number | null
    coverid: number | null
  }

  export type MonsterbookinfosCountAggregateOutputType = {
    id: number
    setid: number
    coverid: number
    _all: number
  }


  export type MonsterbookinfosAvgAggregateInputType = {
    id?: true
    setid?: true
    coverid?: true
  }

  export type MonsterbookinfosSumAggregateInputType = {
    id?: true
    setid?: true
    coverid?: true
  }

  export type MonsterbookinfosMinAggregateInputType = {
    id?: true
    setid?: true
    coverid?: true
  }

  export type MonsterbookinfosMaxAggregateInputType = {
    id?: true
    setid?: true
    coverid?: true
  }

  export type MonsterbookinfosCountAggregateInputType = {
    id?: true
    setid?: true
    coverid?: true
    _all?: true
  }

  export type MonsterbookinfosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which monsterbookinfos to aggregate.
     */
    where?: monsterbookinfosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of monsterbookinfos to fetch.
     */
    orderBy?: monsterbookinfosOrderByWithRelationInput | monsterbookinfosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: monsterbookinfosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` monsterbookinfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` monsterbookinfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned monsterbookinfos
    **/
    _count?: true | MonsterbookinfosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MonsterbookinfosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MonsterbookinfosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MonsterbookinfosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MonsterbookinfosMaxAggregateInputType
  }

  export type GetMonsterbookinfosAggregateType<T extends MonsterbookinfosAggregateArgs> = {
        [P in keyof T & keyof AggregateMonsterbookinfos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMonsterbookinfos[P]>
      : GetScalarType<T[P], AggregateMonsterbookinfos[P]>
  }




  export type monsterbookinfosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: monsterbookinfosWhereInput
    orderBy?: monsterbookinfosOrderByWithAggregationInput | monsterbookinfosOrderByWithAggregationInput[]
    by: MonsterbookinfosScalarFieldEnum[] | MonsterbookinfosScalarFieldEnum
    having?: monsterbookinfosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MonsterbookinfosCountAggregateInputType | true
    _avg?: MonsterbookinfosAvgAggregateInputType
    _sum?: MonsterbookinfosSumAggregateInputType
    _min?: MonsterbookinfosMinAggregateInputType
    _max?: MonsterbookinfosMaxAggregateInputType
  }

  export type MonsterbookinfosGroupByOutputType = {
    id: number
    setid: number | null
    coverid: number | null
    _count: MonsterbookinfosCountAggregateOutputType | null
    _avg: MonsterbookinfosAvgAggregateOutputType | null
    _sum: MonsterbookinfosSumAggregateOutputType | null
    _min: MonsterbookinfosMinAggregateOutputType | null
    _max: MonsterbookinfosMaxAggregateOutputType | null
  }

  type GetMonsterbookinfosGroupByPayload<T extends monsterbookinfosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MonsterbookinfosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MonsterbookinfosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MonsterbookinfosGroupByOutputType[P]>
            : GetScalarType<T[P], MonsterbookinfosGroupByOutputType[P]>
        }
      >
    >


  export type monsterbookinfosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    setid?: boolean
    coverid?: boolean
  }, ExtArgs["result"]["monsterbookinfos"]>


  export type monsterbookinfosSelectScalar = {
    id?: boolean
    setid?: boolean
    coverid?: boolean
  }


  export type $monsterbookinfosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "monsterbookinfos"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      setid: number | null
      coverid: number | null
    }, ExtArgs["result"]["monsterbookinfos"]>
    composites: {}
  }

  type monsterbookinfosGetPayload<S extends boolean | null | undefined | monsterbookinfosDefaultArgs> = $Result.GetResult<Prisma.$monsterbookinfosPayload, S>

  type monsterbookinfosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<monsterbookinfosFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MonsterbookinfosCountAggregateInputType | true
    }

  export interface monsterbookinfosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['monsterbookinfos'], meta: { name: 'monsterbookinfos' } }
    /**
     * Find zero or one Monsterbookinfos that matches the filter.
     * @param {monsterbookinfosFindUniqueArgs} args - Arguments to find a Monsterbookinfos
     * @example
     * // Get one Monsterbookinfos
     * const monsterbookinfos = await prisma.monsterbookinfos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends monsterbookinfosFindUniqueArgs>(args: SelectSubset<T, monsterbookinfosFindUniqueArgs<ExtArgs>>): Prisma__monsterbookinfosClient<$Result.GetResult<Prisma.$monsterbookinfosPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Monsterbookinfos that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {monsterbookinfosFindUniqueOrThrowArgs} args - Arguments to find a Monsterbookinfos
     * @example
     * // Get one Monsterbookinfos
     * const monsterbookinfos = await prisma.monsterbookinfos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends monsterbookinfosFindUniqueOrThrowArgs>(args: SelectSubset<T, monsterbookinfosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__monsterbookinfosClient<$Result.GetResult<Prisma.$monsterbookinfosPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Monsterbookinfos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monsterbookinfosFindFirstArgs} args - Arguments to find a Monsterbookinfos
     * @example
     * // Get one Monsterbookinfos
     * const monsterbookinfos = await prisma.monsterbookinfos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends monsterbookinfosFindFirstArgs>(args?: SelectSubset<T, monsterbookinfosFindFirstArgs<ExtArgs>>): Prisma__monsterbookinfosClient<$Result.GetResult<Prisma.$monsterbookinfosPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Monsterbookinfos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monsterbookinfosFindFirstOrThrowArgs} args - Arguments to find a Monsterbookinfos
     * @example
     * // Get one Monsterbookinfos
     * const monsterbookinfos = await prisma.monsterbookinfos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends monsterbookinfosFindFirstOrThrowArgs>(args?: SelectSubset<T, monsterbookinfosFindFirstOrThrowArgs<ExtArgs>>): Prisma__monsterbookinfosClient<$Result.GetResult<Prisma.$monsterbookinfosPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Monsterbookinfos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monsterbookinfosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Monsterbookinfos
     * const monsterbookinfos = await prisma.monsterbookinfos.findMany()
     * 
     * // Get first 10 Monsterbookinfos
     * const monsterbookinfos = await prisma.monsterbookinfos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const monsterbookinfosWithIdOnly = await prisma.monsterbookinfos.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends monsterbookinfosFindManyArgs>(args?: SelectSubset<T, monsterbookinfosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$monsterbookinfosPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Monsterbookinfos.
     * @param {monsterbookinfosCreateArgs} args - Arguments to create a Monsterbookinfos.
     * @example
     * // Create one Monsterbookinfos
     * const Monsterbookinfos = await prisma.monsterbookinfos.create({
     *   data: {
     *     // ... data to create a Monsterbookinfos
     *   }
     * })
     * 
     */
    create<T extends monsterbookinfosCreateArgs>(args: SelectSubset<T, monsterbookinfosCreateArgs<ExtArgs>>): Prisma__monsterbookinfosClient<$Result.GetResult<Prisma.$monsterbookinfosPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Monsterbookinfos.
     * @param {monsterbookinfosCreateManyArgs} args - Arguments to create many Monsterbookinfos.
     * @example
     * // Create many Monsterbookinfos
     * const monsterbookinfos = await prisma.monsterbookinfos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends monsterbookinfosCreateManyArgs>(args?: SelectSubset<T, monsterbookinfosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Monsterbookinfos.
     * @param {monsterbookinfosDeleteArgs} args - Arguments to delete one Monsterbookinfos.
     * @example
     * // Delete one Monsterbookinfos
     * const Monsterbookinfos = await prisma.monsterbookinfos.delete({
     *   where: {
     *     // ... filter to delete one Monsterbookinfos
     *   }
     * })
     * 
     */
    delete<T extends monsterbookinfosDeleteArgs>(args: SelectSubset<T, monsterbookinfosDeleteArgs<ExtArgs>>): Prisma__monsterbookinfosClient<$Result.GetResult<Prisma.$monsterbookinfosPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Monsterbookinfos.
     * @param {monsterbookinfosUpdateArgs} args - Arguments to update one Monsterbookinfos.
     * @example
     * // Update one Monsterbookinfos
     * const monsterbookinfos = await prisma.monsterbookinfos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends monsterbookinfosUpdateArgs>(args: SelectSubset<T, monsterbookinfosUpdateArgs<ExtArgs>>): Prisma__monsterbookinfosClient<$Result.GetResult<Prisma.$monsterbookinfosPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Monsterbookinfos.
     * @param {monsterbookinfosDeleteManyArgs} args - Arguments to filter Monsterbookinfos to delete.
     * @example
     * // Delete a few Monsterbookinfos
     * const { count } = await prisma.monsterbookinfos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends monsterbookinfosDeleteManyArgs>(args?: SelectSubset<T, monsterbookinfosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Monsterbookinfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monsterbookinfosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Monsterbookinfos
     * const monsterbookinfos = await prisma.monsterbookinfos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends monsterbookinfosUpdateManyArgs>(args: SelectSubset<T, monsterbookinfosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Monsterbookinfos.
     * @param {monsterbookinfosUpsertArgs} args - Arguments to update or create a Monsterbookinfos.
     * @example
     * // Update or create a Monsterbookinfos
     * const monsterbookinfos = await prisma.monsterbookinfos.upsert({
     *   create: {
     *     // ... data to create a Monsterbookinfos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Monsterbookinfos we want to update
     *   }
     * })
     */
    upsert<T extends monsterbookinfosUpsertArgs>(args: SelectSubset<T, monsterbookinfosUpsertArgs<ExtArgs>>): Prisma__monsterbookinfosClient<$Result.GetResult<Prisma.$monsterbookinfosPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Monsterbookinfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monsterbookinfosCountArgs} args - Arguments to filter Monsterbookinfos to count.
     * @example
     * // Count the number of Monsterbookinfos
     * const count = await prisma.monsterbookinfos.count({
     *   where: {
     *     // ... the filter for the Monsterbookinfos we want to count
     *   }
     * })
    **/
    count<T extends monsterbookinfosCountArgs>(
      args?: Subset<T, monsterbookinfosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MonsterbookinfosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Monsterbookinfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonsterbookinfosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MonsterbookinfosAggregateArgs>(args: Subset<T, MonsterbookinfosAggregateArgs>): Prisma.PrismaPromise<GetMonsterbookinfosAggregateType<T>>

    /**
     * Group by Monsterbookinfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monsterbookinfosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends monsterbookinfosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: monsterbookinfosGroupByArgs['orderBy'] }
        : { orderBy?: monsterbookinfosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, monsterbookinfosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMonsterbookinfosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the monsterbookinfos model
   */
  readonly fields: monsterbookinfosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for monsterbookinfos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__monsterbookinfosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the monsterbookinfos model
   */ 
  interface monsterbookinfosFieldRefs {
    readonly id: FieldRef<"monsterbookinfos", 'Int'>
    readonly setid: FieldRef<"monsterbookinfos", 'Int'>
    readonly coverid: FieldRef<"monsterbookinfos", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * monsterbookinfos findUnique
   */
  export type monsterbookinfosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monsterbookinfos
     */
    select?: monsterbookinfosSelect<ExtArgs> | null
    /**
     * Filter, which monsterbookinfos to fetch.
     */
    where: monsterbookinfosWhereUniqueInput
  }

  /**
   * monsterbookinfos findUniqueOrThrow
   */
  export type monsterbookinfosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monsterbookinfos
     */
    select?: monsterbookinfosSelect<ExtArgs> | null
    /**
     * Filter, which monsterbookinfos to fetch.
     */
    where: monsterbookinfosWhereUniqueInput
  }

  /**
   * monsterbookinfos findFirst
   */
  export type monsterbookinfosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monsterbookinfos
     */
    select?: monsterbookinfosSelect<ExtArgs> | null
    /**
     * Filter, which monsterbookinfos to fetch.
     */
    where?: monsterbookinfosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of monsterbookinfos to fetch.
     */
    orderBy?: monsterbookinfosOrderByWithRelationInput | monsterbookinfosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for monsterbookinfos.
     */
    cursor?: monsterbookinfosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` monsterbookinfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` monsterbookinfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of monsterbookinfos.
     */
    distinct?: MonsterbookinfosScalarFieldEnum | MonsterbookinfosScalarFieldEnum[]
  }

  /**
   * monsterbookinfos findFirstOrThrow
   */
  export type monsterbookinfosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monsterbookinfos
     */
    select?: monsterbookinfosSelect<ExtArgs> | null
    /**
     * Filter, which monsterbookinfos to fetch.
     */
    where?: monsterbookinfosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of monsterbookinfos to fetch.
     */
    orderBy?: monsterbookinfosOrderByWithRelationInput | monsterbookinfosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for monsterbookinfos.
     */
    cursor?: monsterbookinfosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` monsterbookinfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` monsterbookinfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of monsterbookinfos.
     */
    distinct?: MonsterbookinfosScalarFieldEnum | MonsterbookinfosScalarFieldEnum[]
  }

  /**
   * monsterbookinfos findMany
   */
  export type monsterbookinfosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monsterbookinfos
     */
    select?: monsterbookinfosSelect<ExtArgs> | null
    /**
     * Filter, which monsterbookinfos to fetch.
     */
    where?: monsterbookinfosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of monsterbookinfos to fetch.
     */
    orderBy?: monsterbookinfosOrderByWithRelationInput | monsterbookinfosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing monsterbookinfos.
     */
    cursor?: monsterbookinfosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` monsterbookinfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` monsterbookinfos.
     */
    skip?: number
    distinct?: MonsterbookinfosScalarFieldEnum | MonsterbookinfosScalarFieldEnum[]
  }

  /**
   * monsterbookinfos create
   */
  export type monsterbookinfosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monsterbookinfos
     */
    select?: monsterbookinfosSelect<ExtArgs> | null
    /**
     * The data needed to create a monsterbookinfos.
     */
    data?: XOR<monsterbookinfosCreateInput, monsterbookinfosUncheckedCreateInput>
  }

  /**
   * monsterbookinfos createMany
   */
  export type monsterbookinfosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many monsterbookinfos.
     */
    data: monsterbookinfosCreateManyInput | monsterbookinfosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * monsterbookinfos update
   */
  export type monsterbookinfosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monsterbookinfos
     */
    select?: monsterbookinfosSelect<ExtArgs> | null
    /**
     * The data needed to update a monsterbookinfos.
     */
    data: XOR<monsterbookinfosUpdateInput, monsterbookinfosUncheckedUpdateInput>
    /**
     * Choose, which monsterbookinfos to update.
     */
    where: monsterbookinfosWhereUniqueInput
  }

  /**
   * monsterbookinfos updateMany
   */
  export type monsterbookinfosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update monsterbookinfos.
     */
    data: XOR<monsterbookinfosUpdateManyMutationInput, monsterbookinfosUncheckedUpdateManyInput>
    /**
     * Filter which monsterbookinfos to update
     */
    where?: monsterbookinfosWhereInput
  }

  /**
   * monsterbookinfos upsert
   */
  export type monsterbookinfosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monsterbookinfos
     */
    select?: monsterbookinfosSelect<ExtArgs> | null
    /**
     * The filter to search for the monsterbookinfos to update in case it exists.
     */
    where: monsterbookinfosWhereUniqueInput
    /**
     * In case the monsterbookinfos found by the `where` argument doesn't exist, create a new monsterbookinfos with this data.
     */
    create: XOR<monsterbookinfosCreateInput, monsterbookinfosUncheckedCreateInput>
    /**
     * In case the monsterbookinfos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<monsterbookinfosUpdateInput, monsterbookinfosUncheckedUpdateInput>
  }

  /**
   * monsterbookinfos delete
   */
  export type monsterbookinfosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monsterbookinfos
     */
    select?: monsterbookinfosSelect<ExtArgs> | null
    /**
     * Filter which monsterbookinfos to delete.
     */
    where: monsterbookinfosWhereUniqueInput
  }

  /**
   * monsterbookinfos deleteMany
   */
  export type monsterbookinfosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which monsterbookinfos to delete
     */
    where?: monsterbookinfosWhereInput
  }

  /**
   * monsterbookinfos without action
   */
  export type monsterbookinfosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monsterbookinfos
     */
    select?: monsterbookinfosSelect<ExtArgs> | null
  }


  /**
   * Model noncombatstatdaylimit
   */

  export type AggregateNoncombatstatdaylimit = {
    _count: NoncombatstatdaylimitCountAggregateOutputType | null
    _avg: NoncombatstatdaylimitAvgAggregateOutputType | null
    _sum: NoncombatstatdaylimitSumAggregateOutputType | null
    _min: NoncombatstatdaylimitMinAggregateOutputType | null
    _max: NoncombatstatdaylimitMaxAggregateOutputType | null
  }

  export type NoncombatstatdaylimitAvgAggregateOutputType = {
    id: number | null
    charisma: number | null
    charm: number | null
    insight: number | null
    will: number | null
    craft: number | null
    sense: number | null
    charmbycashpr: number | null
  }

  export type NoncombatstatdaylimitSumAggregateOutputType = {
    id: number | null
    charisma: number | null
    charm: number | null
    insight: number | null
    will: number | null
    craft: number | null
    sense: number | null
    charmbycashpr: number | null
  }

  export type NoncombatstatdaylimitMinAggregateOutputType = {
    id: number | null
    charisma: number | null
    charm: number | null
    insight: number | null
    will: number | null
    craft: number | null
    sense: number | null
    lastupdatecharmbycashpr: Date | null
    charmbycashpr: number | null
  }

  export type NoncombatstatdaylimitMaxAggregateOutputType = {
    id: number | null
    charisma: number | null
    charm: number | null
    insight: number | null
    will: number | null
    craft: number | null
    sense: number | null
    lastupdatecharmbycashpr: Date | null
    charmbycashpr: number | null
  }

  export type NoncombatstatdaylimitCountAggregateOutputType = {
    id: number
    charisma: number
    charm: number
    insight: number
    will: number
    craft: number
    sense: number
    lastupdatecharmbycashpr: number
    charmbycashpr: number
    _all: number
  }


  export type NoncombatstatdaylimitAvgAggregateInputType = {
    id?: true
    charisma?: true
    charm?: true
    insight?: true
    will?: true
    craft?: true
    sense?: true
    charmbycashpr?: true
  }

  export type NoncombatstatdaylimitSumAggregateInputType = {
    id?: true
    charisma?: true
    charm?: true
    insight?: true
    will?: true
    craft?: true
    sense?: true
    charmbycashpr?: true
  }

  export type NoncombatstatdaylimitMinAggregateInputType = {
    id?: true
    charisma?: true
    charm?: true
    insight?: true
    will?: true
    craft?: true
    sense?: true
    lastupdatecharmbycashpr?: true
    charmbycashpr?: true
  }

  export type NoncombatstatdaylimitMaxAggregateInputType = {
    id?: true
    charisma?: true
    charm?: true
    insight?: true
    will?: true
    craft?: true
    sense?: true
    lastupdatecharmbycashpr?: true
    charmbycashpr?: true
  }

  export type NoncombatstatdaylimitCountAggregateInputType = {
    id?: true
    charisma?: true
    charm?: true
    insight?: true
    will?: true
    craft?: true
    sense?: true
    lastupdatecharmbycashpr?: true
    charmbycashpr?: true
    _all?: true
  }

  export type NoncombatstatdaylimitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which noncombatstatdaylimit to aggregate.
     */
    where?: noncombatstatdaylimitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of noncombatstatdaylimits to fetch.
     */
    orderBy?: noncombatstatdaylimitOrderByWithRelationInput | noncombatstatdaylimitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: noncombatstatdaylimitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` noncombatstatdaylimits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` noncombatstatdaylimits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned noncombatstatdaylimits
    **/
    _count?: true | NoncombatstatdaylimitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NoncombatstatdaylimitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NoncombatstatdaylimitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NoncombatstatdaylimitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NoncombatstatdaylimitMaxAggregateInputType
  }

  export type GetNoncombatstatdaylimitAggregateType<T extends NoncombatstatdaylimitAggregateArgs> = {
        [P in keyof T & keyof AggregateNoncombatstatdaylimit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNoncombatstatdaylimit[P]>
      : GetScalarType<T[P], AggregateNoncombatstatdaylimit[P]>
  }




  export type noncombatstatdaylimitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: noncombatstatdaylimitWhereInput
    orderBy?: noncombatstatdaylimitOrderByWithAggregationInput | noncombatstatdaylimitOrderByWithAggregationInput[]
    by: NoncombatstatdaylimitScalarFieldEnum[] | NoncombatstatdaylimitScalarFieldEnum
    having?: noncombatstatdaylimitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NoncombatstatdaylimitCountAggregateInputType | true
    _avg?: NoncombatstatdaylimitAvgAggregateInputType
    _sum?: NoncombatstatdaylimitSumAggregateInputType
    _min?: NoncombatstatdaylimitMinAggregateInputType
    _max?: NoncombatstatdaylimitMaxAggregateInputType
  }

  export type NoncombatstatdaylimitGroupByOutputType = {
    id: number
    charisma: number | null
    charm: number | null
    insight: number | null
    will: number | null
    craft: number | null
    sense: number | null
    lastupdatecharmbycashpr: Date | null
    charmbycashpr: number | null
    _count: NoncombatstatdaylimitCountAggregateOutputType | null
    _avg: NoncombatstatdaylimitAvgAggregateOutputType | null
    _sum: NoncombatstatdaylimitSumAggregateOutputType | null
    _min: NoncombatstatdaylimitMinAggregateOutputType | null
    _max: NoncombatstatdaylimitMaxAggregateOutputType | null
  }

  type GetNoncombatstatdaylimitGroupByPayload<T extends noncombatstatdaylimitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NoncombatstatdaylimitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NoncombatstatdaylimitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NoncombatstatdaylimitGroupByOutputType[P]>
            : GetScalarType<T[P], NoncombatstatdaylimitGroupByOutputType[P]>
        }
      >
    >


  export type noncombatstatdaylimitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    charisma?: boolean
    charm?: boolean
    insight?: boolean
    will?: boolean
    craft?: boolean
    sense?: boolean
    lastupdatecharmbycashpr?: boolean
    charmbycashpr?: boolean
  }, ExtArgs["result"]["noncombatstatdaylimit"]>


  export type noncombatstatdaylimitSelectScalar = {
    id?: boolean
    charisma?: boolean
    charm?: boolean
    insight?: boolean
    will?: boolean
    craft?: boolean
    sense?: boolean
    lastupdatecharmbycashpr?: boolean
    charmbycashpr?: boolean
  }


  export type $noncombatstatdaylimitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "noncombatstatdaylimit"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      charisma: number | null
      charm: number | null
      insight: number | null
      will: number | null
      craft: number | null
      sense: number | null
      lastupdatecharmbycashpr: Date | null
      charmbycashpr: number | null
    }, ExtArgs["result"]["noncombatstatdaylimit"]>
    composites: {}
  }

  type noncombatstatdaylimitGetPayload<S extends boolean | null | undefined | noncombatstatdaylimitDefaultArgs> = $Result.GetResult<Prisma.$noncombatstatdaylimitPayload, S>

  type noncombatstatdaylimitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<noncombatstatdaylimitFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NoncombatstatdaylimitCountAggregateInputType | true
    }

  export interface noncombatstatdaylimitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['noncombatstatdaylimit'], meta: { name: 'noncombatstatdaylimit' } }
    /**
     * Find zero or one Noncombatstatdaylimit that matches the filter.
     * @param {noncombatstatdaylimitFindUniqueArgs} args - Arguments to find a Noncombatstatdaylimit
     * @example
     * // Get one Noncombatstatdaylimit
     * const noncombatstatdaylimit = await prisma.noncombatstatdaylimit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends noncombatstatdaylimitFindUniqueArgs>(args: SelectSubset<T, noncombatstatdaylimitFindUniqueArgs<ExtArgs>>): Prisma__noncombatstatdaylimitClient<$Result.GetResult<Prisma.$noncombatstatdaylimitPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Noncombatstatdaylimit that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {noncombatstatdaylimitFindUniqueOrThrowArgs} args - Arguments to find a Noncombatstatdaylimit
     * @example
     * // Get one Noncombatstatdaylimit
     * const noncombatstatdaylimit = await prisma.noncombatstatdaylimit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends noncombatstatdaylimitFindUniqueOrThrowArgs>(args: SelectSubset<T, noncombatstatdaylimitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__noncombatstatdaylimitClient<$Result.GetResult<Prisma.$noncombatstatdaylimitPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Noncombatstatdaylimit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {noncombatstatdaylimitFindFirstArgs} args - Arguments to find a Noncombatstatdaylimit
     * @example
     * // Get one Noncombatstatdaylimit
     * const noncombatstatdaylimit = await prisma.noncombatstatdaylimit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends noncombatstatdaylimitFindFirstArgs>(args?: SelectSubset<T, noncombatstatdaylimitFindFirstArgs<ExtArgs>>): Prisma__noncombatstatdaylimitClient<$Result.GetResult<Prisma.$noncombatstatdaylimitPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Noncombatstatdaylimit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {noncombatstatdaylimitFindFirstOrThrowArgs} args - Arguments to find a Noncombatstatdaylimit
     * @example
     * // Get one Noncombatstatdaylimit
     * const noncombatstatdaylimit = await prisma.noncombatstatdaylimit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends noncombatstatdaylimitFindFirstOrThrowArgs>(args?: SelectSubset<T, noncombatstatdaylimitFindFirstOrThrowArgs<ExtArgs>>): Prisma__noncombatstatdaylimitClient<$Result.GetResult<Prisma.$noncombatstatdaylimitPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Noncombatstatdaylimits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {noncombatstatdaylimitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Noncombatstatdaylimits
     * const noncombatstatdaylimits = await prisma.noncombatstatdaylimit.findMany()
     * 
     * // Get first 10 Noncombatstatdaylimits
     * const noncombatstatdaylimits = await prisma.noncombatstatdaylimit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const noncombatstatdaylimitWithIdOnly = await prisma.noncombatstatdaylimit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends noncombatstatdaylimitFindManyArgs>(args?: SelectSubset<T, noncombatstatdaylimitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$noncombatstatdaylimitPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Noncombatstatdaylimit.
     * @param {noncombatstatdaylimitCreateArgs} args - Arguments to create a Noncombatstatdaylimit.
     * @example
     * // Create one Noncombatstatdaylimit
     * const Noncombatstatdaylimit = await prisma.noncombatstatdaylimit.create({
     *   data: {
     *     // ... data to create a Noncombatstatdaylimit
     *   }
     * })
     * 
     */
    create<T extends noncombatstatdaylimitCreateArgs>(args: SelectSubset<T, noncombatstatdaylimitCreateArgs<ExtArgs>>): Prisma__noncombatstatdaylimitClient<$Result.GetResult<Prisma.$noncombatstatdaylimitPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Noncombatstatdaylimits.
     * @param {noncombatstatdaylimitCreateManyArgs} args - Arguments to create many Noncombatstatdaylimits.
     * @example
     * // Create many Noncombatstatdaylimits
     * const noncombatstatdaylimit = await prisma.noncombatstatdaylimit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends noncombatstatdaylimitCreateManyArgs>(args?: SelectSubset<T, noncombatstatdaylimitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Noncombatstatdaylimit.
     * @param {noncombatstatdaylimitDeleteArgs} args - Arguments to delete one Noncombatstatdaylimit.
     * @example
     * // Delete one Noncombatstatdaylimit
     * const Noncombatstatdaylimit = await prisma.noncombatstatdaylimit.delete({
     *   where: {
     *     // ... filter to delete one Noncombatstatdaylimit
     *   }
     * })
     * 
     */
    delete<T extends noncombatstatdaylimitDeleteArgs>(args: SelectSubset<T, noncombatstatdaylimitDeleteArgs<ExtArgs>>): Prisma__noncombatstatdaylimitClient<$Result.GetResult<Prisma.$noncombatstatdaylimitPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Noncombatstatdaylimit.
     * @param {noncombatstatdaylimitUpdateArgs} args - Arguments to update one Noncombatstatdaylimit.
     * @example
     * // Update one Noncombatstatdaylimit
     * const noncombatstatdaylimit = await prisma.noncombatstatdaylimit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends noncombatstatdaylimitUpdateArgs>(args: SelectSubset<T, noncombatstatdaylimitUpdateArgs<ExtArgs>>): Prisma__noncombatstatdaylimitClient<$Result.GetResult<Prisma.$noncombatstatdaylimitPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Noncombatstatdaylimits.
     * @param {noncombatstatdaylimitDeleteManyArgs} args - Arguments to filter Noncombatstatdaylimits to delete.
     * @example
     * // Delete a few Noncombatstatdaylimits
     * const { count } = await prisma.noncombatstatdaylimit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends noncombatstatdaylimitDeleteManyArgs>(args?: SelectSubset<T, noncombatstatdaylimitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Noncombatstatdaylimits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {noncombatstatdaylimitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Noncombatstatdaylimits
     * const noncombatstatdaylimit = await prisma.noncombatstatdaylimit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends noncombatstatdaylimitUpdateManyArgs>(args: SelectSubset<T, noncombatstatdaylimitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Noncombatstatdaylimit.
     * @param {noncombatstatdaylimitUpsertArgs} args - Arguments to update or create a Noncombatstatdaylimit.
     * @example
     * // Update or create a Noncombatstatdaylimit
     * const noncombatstatdaylimit = await prisma.noncombatstatdaylimit.upsert({
     *   create: {
     *     // ... data to create a Noncombatstatdaylimit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Noncombatstatdaylimit we want to update
     *   }
     * })
     */
    upsert<T extends noncombatstatdaylimitUpsertArgs>(args: SelectSubset<T, noncombatstatdaylimitUpsertArgs<ExtArgs>>): Prisma__noncombatstatdaylimitClient<$Result.GetResult<Prisma.$noncombatstatdaylimitPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Noncombatstatdaylimits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {noncombatstatdaylimitCountArgs} args - Arguments to filter Noncombatstatdaylimits to count.
     * @example
     * // Count the number of Noncombatstatdaylimits
     * const count = await prisma.noncombatstatdaylimit.count({
     *   where: {
     *     // ... the filter for the Noncombatstatdaylimits we want to count
     *   }
     * })
    **/
    count<T extends noncombatstatdaylimitCountArgs>(
      args?: Subset<T, noncombatstatdaylimitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NoncombatstatdaylimitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Noncombatstatdaylimit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoncombatstatdaylimitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NoncombatstatdaylimitAggregateArgs>(args: Subset<T, NoncombatstatdaylimitAggregateArgs>): Prisma.PrismaPromise<GetNoncombatstatdaylimitAggregateType<T>>

    /**
     * Group by Noncombatstatdaylimit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {noncombatstatdaylimitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends noncombatstatdaylimitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: noncombatstatdaylimitGroupByArgs['orderBy'] }
        : { orderBy?: noncombatstatdaylimitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, noncombatstatdaylimitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNoncombatstatdaylimitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the noncombatstatdaylimit model
   */
  readonly fields: noncombatstatdaylimitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for noncombatstatdaylimit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__noncombatstatdaylimitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the noncombatstatdaylimit model
   */ 
  interface noncombatstatdaylimitFieldRefs {
    readonly id: FieldRef<"noncombatstatdaylimit", 'Int'>
    readonly charisma: FieldRef<"noncombatstatdaylimit", 'Int'>
    readonly charm: FieldRef<"noncombatstatdaylimit", 'Int'>
    readonly insight: FieldRef<"noncombatstatdaylimit", 'Int'>
    readonly will: FieldRef<"noncombatstatdaylimit", 'Int'>
    readonly craft: FieldRef<"noncombatstatdaylimit", 'Int'>
    readonly sense: FieldRef<"noncombatstatdaylimit", 'Int'>
    readonly lastupdatecharmbycashpr: FieldRef<"noncombatstatdaylimit", 'DateTime'>
    readonly charmbycashpr: FieldRef<"noncombatstatdaylimit", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * noncombatstatdaylimit findUnique
   */
  export type noncombatstatdaylimitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the noncombatstatdaylimit
     */
    select?: noncombatstatdaylimitSelect<ExtArgs> | null
    /**
     * Filter, which noncombatstatdaylimit to fetch.
     */
    where: noncombatstatdaylimitWhereUniqueInput
  }

  /**
   * noncombatstatdaylimit findUniqueOrThrow
   */
  export type noncombatstatdaylimitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the noncombatstatdaylimit
     */
    select?: noncombatstatdaylimitSelect<ExtArgs> | null
    /**
     * Filter, which noncombatstatdaylimit to fetch.
     */
    where: noncombatstatdaylimitWhereUniqueInput
  }

  /**
   * noncombatstatdaylimit findFirst
   */
  export type noncombatstatdaylimitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the noncombatstatdaylimit
     */
    select?: noncombatstatdaylimitSelect<ExtArgs> | null
    /**
     * Filter, which noncombatstatdaylimit to fetch.
     */
    where?: noncombatstatdaylimitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of noncombatstatdaylimits to fetch.
     */
    orderBy?: noncombatstatdaylimitOrderByWithRelationInput | noncombatstatdaylimitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for noncombatstatdaylimits.
     */
    cursor?: noncombatstatdaylimitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` noncombatstatdaylimits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` noncombatstatdaylimits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of noncombatstatdaylimits.
     */
    distinct?: NoncombatstatdaylimitScalarFieldEnum | NoncombatstatdaylimitScalarFieldEnum[]
  }

  /**
   * noncombatstatdaylimit findFirstOrThrow
   */
  export type noncombatstatdaylimitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the noncombatstatdaylimit
     */
    select?: noncombatstatdaylimitSelect<ExtArgs> | null
    /**
     * Filter, which noncombatstatdaylimit to fetch.
     */
    where?: noncombatstatdaylimitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of noncombatstatdaylimits to fetch.
     */
    orderBy?: noncombatstatdaylimitOrderByWithRelationInput | noncombatstatdaylimitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for noncombatstatdaylimits.
     */
    cursor?: noncombatstatdaylimitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` noncombatstatdaylimits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` noncombatstatdaylimits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of noncombatstatdaylimits.
     */
    distinct?: NoncombatstatdaylimitScalarFieldEnum | NoncombatstatdaylimitScalarFieldEnum[]
  }

  /**
   * noncombatstatdaylimit findMany
   */
  export type noncombatstatdaylimitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the noncombatstatdaylimit
     */
    select?: noncombatstatdaylimitSelect<ExtArgs> | null
    /**
     * Filter, which noncombatstatdaylimits to fetch.
     */
    where?: noncombatstatdaylimitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of noncombatstatdaylimits to fetch.
     */
    orderBy?: noncombatstatdaylimitOrderByWithRelationInput | noncombatstatdaylimitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing noncombatstatdaylimits.
     */
    cursor?: noncombatstatdaylimitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` noncombatstatdaylimits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` noncombatstatdaylimits.
     */
    skip?: number
    distinct?: NoncombatstatdaylimitScalarFieldEnum | NoncombatstatdaylimitScalarFieldEnum[]
  }

  /**
   * noncombatstatdaylimit create
   */
  export type noncombatstatdaylimitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the noncombatstatdaylimit
     */
    select?: noncombatstatdaylimitSelect<ExtArgs> | null
    /**
     * The data needed to create a noncombatstatdaylimit.
     */
    data?: XOR<noncombatstatdaylimitCreateInput, noncombatstatdaylimitUncheckedCreateInput>
  }

  /**
   * noncombatstatdaylimit createMany
   */
  export type noncombatstatdaylimitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many noncombatstatdaylimits.
     */
    data: noncombatstatdaylimitCreateManyInput | noncombatstatdaylimitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * noncombatstatdaylimit update
   */
  export type noncombatstatdaylimitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the noncombatstatdaylimit
     */
    select?: noncombatstatdaylimitSelect<ExtArgs> | null
    /**
     * The data needed to update a noncombatstatdaylimit.
     */
    data: XOR<noncombatstatdaylimitUpdateInput, noncombatstatdaylimitUncheckedUpdateInput>
    /**
     * Choose, which noncombatstatdaylimit to update.
     */
    where: noncombatstatdaylimitWhereUniqueInput
  }

  /**
   * noncombatstatdaylimit updateMany
   */
  export type noncombatstatdaylimitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update noncombatstatdaylimits.
     */
    data: XOR<noncombatstatdaylimitUpdateManyMutationInput, noncombatstatdaylimitUncheckedUpdateManyInput>
    /**
     * Filter which noncombatstatdaylimits to update
     */
    where?: noncombatstatdaylimitWhereInput
  }

  /**
   * noncombatstatdaylimit upsert
   */
  export type noncombatstatdaylimitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the noncombatstatdaylimit
     */
    select?: noncombatstatdaylimitSelect<ExtArgs> | null
    /**
     * The filter to search for the noncombatstatdaylimit to update in case it exists.
     */
    where: noncombatstatdaylimitWhereUniqueInput
    /**
     * In case the noncombatstatdaylimit found by the `where` argument doesn't exist, create a new noncombatstatdaylimit with this data.
     */
    create: XOR<noncombatstatdaylimitCreateInput, noncombatstatdaylimitUncheckedCreateInput>
    /**
     * In case the noncombatstatdaylimit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<noncombatstatdaylimitUpdateInput, noncombatstatdaylimitUncheckedUpdateInput>
  }

  /**
   * noncombatstatdaylimit delete
   */
  export type noncombatstatdaylimitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the noncombatstatdaylimit
     */
    select?: noncombatstatdaylimitSelect<ExtArgs> | null
    /**
     * Filter which noncombatstatdaylimit to delete.
     */
    where: noncombatstatdaylimitWhereUniqueInput
  }

  /**
   * noncombatstatdaylimit deleteMany
   */
  export type noncombatstatdaylimitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which noncombatstatdaylimits to delete
     */
    where?: noncombatstatdaylimitWhereInput
  }

  /**
   * noncombatstatdaylimit without action
   */
  export type noncombatstatdaylimitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the noncombatstatdaylimit
     */
    select?: noncombatstatdaylimitSelect<ExtArgs> | null
  }


  /**
   * Model npc
   */

  export type AggregateNpc = {
    _count: NpcCountAggregateOutputType | null
    _avg: NpcAvgAggregateOutputType | null
    _sum: NpcSumAggregateOutputType | null
    _min: NpcMinAggregateOutputType | null
    _max: NpcMaxAggregateOutputType | null
  }

  export type NpcAvgAggregateOutputType = {
    id: number | null
    npcid: number | null
    mapid: number | null
    x: number | null
    y: number | null
    cy: number | null
    rx0: number | null
    rx1: number | null
    fh: number | null
  }

  export type NpcSumAggregateOutputType = {
    id: number | null
    npcid: number | null
    mapid: number | null
    x: number | null
    y: number | null
    cy: number | null
    rx0: number | null
    rx1: number | null
    fh: number | null
  }

  export type NpcMinAggregateOutputType = {
    id: number | null
    npcid: number | null
    mapid: number | null
    x: number | null
    y: number | null
    cy: number | null
    rx0: number | null
    rx1: number | null
    fh: number | null
  }

  export type NpcMaxAggregateOutputType = {
    id: number | null
    npcid: number | null
    mapid: number | null
    x: number | null
    y: number | null
    cy: number | null
    rx0: number | null
    rx1: number | null
    fh: number | null
  }

  export type NpcCountAggregateOutputType = {
    id: number
    npcid: number
    mapid: number
    x: number
    y: number
    cy: number
    rx0: number
    rx1: number
    fh: number
    _all: number
  }


  export type NpcAvgAggregateInputType = {
    id?: true
    npcid?: true
    mapid?: true
    x?: true
    y?: true
    cy?: true
    rx0?: true
    rx1?: true
    fh?: true
  }

  export type NpcSumAggregateInputType = {
    id?: true
    npcid?: true
    mapid?: true
    x?: true
    y?: true
    cy?: true
    rx0?: true
    rx1?: true
    fh?: true
  }

  export type NpcMinAggregateInputType = {
    id?: true
    npcid?: true
    mapid?: true
    x?: true
    y?: true
    cy?: true
    rx0?: true
    rx1?: true
    fh?: true
  }

  export type NpcMaxAggregateInputType = {
    id?: true
    npcid?: true
    mapid?: true
    x?: true
    y?: true
    cy?: true
    rx0?: true
    rx1?: true
    fh?: true
  }

  export type NpcCountAggregateInputType = {
    id?: true
    npcid?: true
    mapid?: true
    x?: true
    y?: true
    cy?: true
    rx0?: true
    rx1?: true
    fh?: true
    _all?: true
  }

  export type NpcAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which npc to aggregate.
     */
    where?: npcWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of npcs to fetch.
     */
    orderBy?: npcOrderByWithRelationInput | npcOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: npcWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` npcs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` npcs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned npcs
    **/
    _count?: true | NpcCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NpcAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NpcSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NpcMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NpcMaxAggregateInputType
  }

  export type GetNpcAggregateType<T extends NpcAggregateArgs> = {
        [P in keyof T & keyof AggregateNpc]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNpc[P]>
      : GetScalarType<T[P], AggregateNpc[P]>
  }




  export type npcGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: npcWhereInput
    orderBy?: npcOrderByWithAggregationInput | npcOrderByWithAggregationInput[]
    by: NpcScalarFieldEnum[] | NpcScalarFieldEnum
    having?: npcScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NpcCountAggregateInputType | true
    _avg?: NpcAvgAggregateInputType
    _sum?: NpcSumAggregateInputType
    _min?: NpcMinAggregateInputType
    _max?: NpcMaxAggregateInputType
  }

  export type NpcGroupByOutputType = {
    id: number
    npcid: number | null
    mapid: number | null
    x: number | null
    y: number | null
    cy: number | null
    rx0: number | null
    rx1: number | null
    fh: number | null
    _count: NpcCountAggregateOutputType | null
    _avg: NpcAvgAggregateOutputType | null
    _sum: NpcSumAggregateOutputType | null
    _min: NpcMinAggregateOutputType | null
    _max: NpcMaxAggregateOutputType | null
  }

  type GetNpcGroupByPayload<T extends npcGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NpcGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NpcGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NpcGroupByOutputType[P]>
            : GetScalarType<T[P], NpcGroupByOutputType[P]>
        }
      >
    >


  export type npcSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    npcid?: boolean
    mapid?: boolean
    x?: boolean
    y?: boolean
    cy?: boolean
    rx0?: boolean
    rx1?: boolean
    fh?: boolean
  }, ExtArgs["result"]["npc"]>


  export type npcSelectScalar = {
    id?: boolean
    npcid?: boolean
    mapid?: boolean
    x?: boolean
    y?: boolean
    cy?: boolean
    rx0?: boolean
    rx1?: boolean
    fh?: boolean
  }


  export type $npcPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "npc"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      npcid: number | null
      mapid: number | null
      x: number | null
      y: number | null
      cy: number | null
      rx0: number | null
      rx1: number | null
      fh: number | null
    }, ExtArgs["result"]["npc"]>
    composites: {}
  }

  type npcGetPayload<S extends boolean | null | undefined | npcDefaultArgs> = $Result.GetResult<Prisma.$npcPayload, S>

  type npcCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<npcFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NpcCountAggregateInputType | true
    }

  export interface npcDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['npc'], meta: { name: 'npc' } }
    /**
     * Find zero or one Npc that matches the filter.
     * @param {npcFindUniqueArgs} args - Arguments to find a Npc
     * @example
     * // Get one Npc
     * const npc = await prisma.npc.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends npcFindUniqueArgs>(args: SelectSubset<T, npcFindUniqueArgs<ExtArgs>>): Prisma__npcClient<$Result.GetResult<Prisma.$npcPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Npc that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {npcFindUniqueOrThrowArgs} args - Arguments to find a Npc
     * @example
     * // Get one Npc
     * const npc = await prisma.npc.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends npcFindUniqueOrThrowArgs>(args: SelectSubset<T, npcFindUniqueOrThrowArgs<ExtArgs>>): Prisma__npcClient<$Result.GetResult<Prisma.$npcPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Npc that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {npcFindFirstArgs} args - Arguments to find a Npc
     * @example
     * // Get one Npc
     * const npc = await prisma.npc.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends npcFindFirstArgs>(args?: SelectSubset<T, npcFindFirstArgs<ExtArgs>>): Prisma__npcClient<$Result.GetResult<Prisma.$npcPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Npc that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {npcFindFirstOrThrowArgs} args - Arguments to find a Npc
     * @example
     * // Get one Npc
     * const npc = await prisma.npc.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends npcFindFirstOrThrowArgs>(args?: SelectSubset<T, npcFindFirstOrThrowArgs<ExtArgs>>): Prisma__npcClient<$Result.GetResult<Prisma.$npcPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Npcs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {npcFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Npcs
     * const npcs = await prisma.npc.findMany()
     * 
     * // Get first 10 Npcs
     * const npcs = await prisma.npc.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const npcWithIdOnly = await prisma.npc.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends npcFindManyArgs>(args?: SelectSubset<T, npcFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$npcPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Npc.
     * @param {npcCreateArgs} args - Arguments to create a Npc.
     * @example
     * // Create one Npc
     * const Npc = await prisma.npc.create({
     *   data: {
     *     // ... data to create a Npc
     *   }
     * })
     * 
     */
    create<T extends npcCreateArgs>(args: SelectSubset<T, npcCreateArgs<ExtArgs>>): Prisma__npcClient<$Result.GetResult<Prisma.$npcPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Npcs.
     * @param {npcCreateManyArgs} args - Arguments to create many Npcs.
     * @example
     * // Create many Npcs
     * const npc = await prisma.npc.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends npcCreateManyArgs>(args?: SelectSubset<T, npcCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Npc.
     * @param {npcDeleteArgs} args - Arguments to delete one Npc.
     * @example
     * // Delete one Npc
     * const Npc = await prisma.npc.delete({
     *   where: {
     *     // ... filter to delete one Npc
     *   }
     * })
     * 
     */
    delete<T extends npcDeleteArgs>(args: SelectSubset<T, npcDeleteArgs<ExtArgs>>): Prisma__npcClient<$Result.GetResult<Prisma.$npcPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Npc.
     * @param {npcUpdateArgs} args - Arguments to update one Npc.
     * @example
     * // Update one Npc
     * const npc = await prisma.npc.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends npcUpdateArgs>(args: SelectSubset<T, npcUpdateArgs<ExtArgs>>): Prisma__npcClient<$Result.GetResult<Prisma.$npcPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Npcs.
     * @param {npcDeleteManyArgs} args - Arguments to filter Npcs to delete.
     * @example
     * // Delete a few Npcs
     * const { count } = await prisma.npc.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends npcDeleteManyArgs>(args?: SelectSubset<T, npcDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Npcs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {npcUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Npcs
     * const npc = await prisma.npc.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends npcUpdateManyArgs>(args: SelectSubset<T, npcUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Npc.
     * @param {npcUpsertArgs} args - Arguments to update or create a Npc.
     * @example
     * // Update or create a Npc
     * const npc = await prisma.npc.upsert({
     *   create: {
     *     // ... data to create a Npc
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Npc we want to update
     *   }
     * })
     */
    upsert<T extends npcUpsertArgs>(args: SelectSubset<T, npcUpsertArgs<ExtArgs>>): Prisma__npcClient<$Result.GetResult<Prisma.$npcPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Npcs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {npcCountArgs} args - Arguments to filter Npcs to count.
     * @example
     * // Count the number of Npcs
     * const count = await prisma.npc.count({
     *   where: {
     *     // ... the filter for the Npcs we want to count
     *   }
     * })
    **/
    count<T extends npcCountArgs>(
      args?: Subset<T, npcCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NpcCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Npc.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NpcAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NpcAggregateArgs>(args: Subset<T, NpcAggregateArgs>): Prisma.PrismaPromise<GetNpcAggregateType<T>>

    /**
     * Group by Npc.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {npcGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends npcGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: npcGroupByArgs['orderBy'] }
        : { orderBy?: npcGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, npcGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNpcGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the npc model
   */
  readonly fields: npcFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for npc.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__npcClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the npc model
   */ 
  interface npcFieldRefs {
    readonly id: FieldRef<"npc", 'Int'>
    readonly npcid: FieldRef<"npc", 'Int'>
    readonly mapid: FieldRef<"npc", 'Int'>
    readonly x: FieldRef<"npc", 'Int'>
    readonly y: FieldRef<"npc", 'Int'>
    readonly cy: FieldRef<"npc", 'Int'>
    readonly rx0: FieldRef<"npc", 'Int'>
    readonly rx1: FieldRef<"npc", 'Int'>
    readonly fh: FieldRef<"npc", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * npc findUnique
   */
  export type npcFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the npc
     */
    select?: npcSelect<ExtArgs> | null
    /**
     * Filter, which npc to fetch.
     */
    where: npcWhereUniqueInput
  }

  /**
   * npc findUniqueOrThrow
   */
  export type npcFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the npc
     */
    select?: npcSelect<ExtArgs> | null
    /**
     * Filter, which npc to fetch.
     */
    where: npcWhereUniqueInput
  }

  /**
   * npc findFirst
   */
  export type npcFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the npc
     */
    select?: npcSelect<ExtArgs> | null
    /**
     * Filter, which npc to fetch.
     */
    where?: npcWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of npcs to fetch.
     */
    orderBy?: npcOrderByWithRelationInput | npcOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for npcs.
     */
    cursor?: npcWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` npcs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` npcs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of npcs.
     */
    distinct?: NpcScalarFieldEnum | NpcScalarFieldEnum[]
  }

  /**
   * npc findFirstOrThrow
   */
  export type npcFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the npc
     */
    select?: npcSelect<ExtArgs> | null
    /**
     * Filter, which npc to fetch.
     */
    where?: npcWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of npcs to fetch.
     */
    orderBy?: npcOrderByWithRelationInput | npcOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for npcs.
     */
    cursor?: npcWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` npcs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` npcs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of npcs.
     */
    distinct?: NpcScalarFieldEnum | NpcScalarFieldEnum[]
  }

  /**
   * npc findMany
   */
  export type npcFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the npc
     */
    select?: npcSelect<ExtArgs> | null
    /**
     * Filter, which npcs to fetch.
     */
    where?: npcWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of npcs to fetch.
     */
    orderBy?: npcOrderByWithRelationInput | npcOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing npcs.
     */
    cursor?: npcWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` npcs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` npcs.
     */
    skip?: number
    distinct?: NpcScalarFieldEnum | NpcScalarFieldEnum[]
  }

  /**
   * npc create
   */
  export type npcCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the npc
     */
    select?: npcSelect<ExtArgs> | null
    /**
     * The data needed to create a npc.
     */
    data?: XOR<npcCreateInput, npcUncheckedCreateInput>
  }

  /**
   * npc createMany
   */
  export type npcCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many npcs.
     */
    data: npcCreateManyInput | npcCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * npc update
   */
  export type npcUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the npc
     */
    select?: npcSelect<ExtArgs> | null
    /**
     * The data needed to update a npc.
     */
    data: XOR<npcUpdateInput, npcUncheckedUpdateInput>
    /**
     * Choose, which npc to update.
     */
    where: npcWhereUniqueInput
  }

  /**
   * npc updateMany
   */
  export type npcUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update npcs.
     */
    data: XOR<npcUpdateManyMutationInput, npcUncheckedUpdateManyInput>
    /**
     * Filter which npcs to update
     */
    where?: npcWhereInput
  }

  /**
   * npc upsert
   */
  export type npcUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the npc
     */
    select?: npcSelect<ExtArgs> | null
    /**
     * The filter to search for the npc to update in case it exists.
     */
    where: npcWhereUniqueInput
    /**
     * In case the npc found by the `where` argument doesn't exist, create a new npc with this data.
     */
    create: XOR<npcCreateInput, npcUncheckedCreateInput>
    /**
     * In case the npc was found with the provided `where` argument, update it with this data.
     */
    update: XOR<npcUpdateInput, npcUncheckedUpdateInput>
  }

  /**
   * npc delete
   */
  export type npcDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the npc
     */
    select?: npcSelect<ExtArgs> | null
    /**
     * Filter which npc to delete.
     */
    where: npcWhereUniqueInput
  }

  /**
   * npc deleteMany
   */
  export type npcDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which npcs to delete
     */
    where?: npcWhereInput
  }

  /**
   * npc without action
   */
  export type npcDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the npc
     */
    select?: npcSelect<ExtArgs> | null
  }


  /**
   * Model offense_managers
   */

  export type AggregateOffense_managers = {
    _count: Offense_managersCountAggregateOutputType | null
    _avg: Offense_managersAvgAggregateOutputType | null
    _sum: Offense_managersSumAggregateOutputType | null
    _min: Offense_managersMinAggregateOutputType | null
    _max: Offense_managersMaxAggregateOutputType | null
  }

  export type Offense_managersAvgAggregateOutputType = {
    id: number | null
    points: number | null
  }

  export type Offense_managersSumAggregateOutputType = {
    id: number | null
    points: number | null
  }

  export type Offense_managersMinAggregateOutputType = {
    id: number | null
    points: number | null
  }

  export type Offense_managersMaxAggregateOutputType = {
    id: number | null
    points: number | null
  }

  export type Offense_managersCountAggregateOutputType = {
    id: number
    points: number
    _all: number
  }


  export type Offense_managersAvgAggregateInputType = {
    id?: true
    points?: true
  }

  export type Offense_managersSumAggregateInputType = {
    id?: true
    points?: true
  }

  export type Offense_managersMinAggregateInputType = {
    id?: true
    points?: true
  }

  export type Offense_managersMaxAggregateInputType = {
    id?: true
    points?: true
  }

  export type Offense_managersCountAggregateInputType = {
    id?: true
    points?: true
    _all?: true
  }

  export type Offense_managersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which offense_managers to aggregate.
     */
    where?: offense_managersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of offense_managers to fetch.
     */
    orderBy?: offense_managersOrderByWithRelationInput | offense_managersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: offense_managersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` offense_managers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` offense_managers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned offense_managers
    **/
    _count?: true | Offense_managersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Offense_managersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Offense_managersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Offense_managersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Offense_managersMaxAggregateInputType
  }

  export type GetOffense_managersAggregateType<T extends Offense_managersAggregateArgs> = {
        [P in keyof T & keyof AggregateOffense_managers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOffense_managers[P]>
      : GetScalarType<T[P], AggregateOffense_managers[P]>
  }




  export type offense_managersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: offense_managersWhereInput
    orderBy?: offense_managersOrderByWithAggregationInput | offense_managersOrderByWithAggregationInput[]
    by: Offense_managersScalarFieldEnum[] | Offense_managersScalarFieldEnum
    having?: offense_managersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Offense_managersCountAggregateInputType | true
    _avg?: Offense_managersAvgAggregateInputType
    _sum?: Offense_managersSumAggregateInputType
    _min?: Offense_managersMinAggregateInputType
    _max?: Offense_managersMaxAggregateInputType
  }

  export type Offense_managersGroupByOutputType = {
    id: number
    points: number | null
    _count: Offense_managersCountAggregateOutputType | null
    _avg: Offense_managersAvgAggregateOutputType | null
    _sum: Offense_managersSumAggregateOutputType | null
    _min: Offense_managersMinAggregateOutputType | null
    _max: Offense_managersMaxAggregateOutputType | null
  }

  type GetOffense_managersGroupByPayload<T extends offense_managersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Offense_managersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Offense_managersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Offense_managersGroupByOutputType[P]>
            : GetScalarType<T[P], Offense_managersGroupByOutputType[P]>
        }
      >
    >


  export type offense_managersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    points?: boolean
  }, ExtArgs["result"]["offense_managers"]>


  export type offense_managersSelectScalar = {
    id?: boolean
    points?: boolean
  }


  export type $offense_managersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "offense_managers"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      points: number | null
    }, ExtArgs["result"]["offense_managers"]>
    composites: {}
  }

  type offense_managersGetPayload<S extends boolean | null | undefined | offense_managersDefaultArgs> = $Result.GetResult<Prisma.$offense_managersPayload, S>

  type offense_managersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<offense_managersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Offense_managersCountAggregateInputType | true
    }

  export interface offense_managersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['offense_managers'], meta: { name: 'offense_managers' } }
    /**
     * Find zero or one Offense_managers that matches the filter.
     * @param {offense_managersFindUniqueArgs} args - Arguments to find a Offense_managers
     * @example
     * // Get one Offense_managers
     * const offense_managers = await prisma.offense_managers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends offense_managersFindUniqueArgs>(args: SelectSubset<T, offense_managersFindUniqueArgs<ExtArgs>>): Prisma__offense_managersClient<$Result.GetResult<Prisma.$offense_managersPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Offense_managers that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {offense_managersFindUniqueOrThrowArgs} args - Arguments to find a Offense_managers
     * @example
     * // Get one Offense_managers
     * const offense_managers = await prisma.offense_managers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends offense_managersFindUniqueOrThrowArgs>(args: SelectSubset<T, offense_managersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__offense_managersClient<$Result.GetResult<Prisma.$offense_managersPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Offense_managers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {offense_managersFindFirstArgs} args - Arguments to find a Offense_managers
     * @example
     * // Get one Offense_managers
     * const offense_managers = await prisma.offense_managers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends offense_managersFindFirstArgs>(args?: SelectSubset<T, offense_managersFindFirstArgs<ExtArgs>>): Prisma__offense_managersClient<$Result.GetResult<Prisma.$offense_managersPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Offense_managers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {offense_managersFindFirstOrThrowArgs} args - Arguments to find a Offense_managers
     * @example
     * // Get one Offense_managers
     * const offense_managers = await prisma.offense_managers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends offense_managersFindFirstOrThrowArgs>(args?: SelectSubset<T, offense_managersFindFirstOrThrowArgs<ExtArgs>>): Prisma__offense_managersClient<$Result.GetResult<Prisma.$offense_managersPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Offense_managers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {offense_managersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Offense_managers
     * const offense_managers = await prisma.offense_managers.findMany()
     * 
     * // Get first 10 Offense_managers
     * const offense_managers = await prisma.offense_managers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const offense_managersWithIdOnly = await prisma.offense_managers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends offense_managersFindManyArgs>(args?: SelectSubset<T, offense_managersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$offense_managersPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Offense_managers.
     * @param {offense_managersCreateArgs} args - Arguments to create a Offense_managers.
     * @example
     * // Create one Offense_managers
     * const Offense_managers = await prisma.offense_managers.create({
     *   data: {
     *     // ... data to create a Offense_managers
     *   }
     * })
     * 
     */
    create<T extends offense_managersCreateArgs>(args: SelectSubset<T, offense_managersCreateArgs<ExtArgs>>): Prisma__offense_managersClient<$Result.GetResult<Prisma.$offense_managersPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Offense_managers.
     * @param {offense_managersCreateManyArgs} args - Arguments to create many Offense_managers.
     * @example
     * // Create many Offense_managers
     * const offense_managers = await prisma.offense_managers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends offense_managersCreateManyArgs>(args?: SelectSubset<T, offense_managersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Offense_managers.
     * @param {offense_managersDeleteArgs} args - Arguments to delete one Offense_managers.
     * @example
     * // Delete one Offense_managers
     * const Offense_managers = await prisma.offense_managers.delete({
     *   where: {
     *     // ... filter to delete one Offense_managers
     *   }
     * })
     * 
     */
    delete<T extends offense_managersDeleteArgs>(args: SelectSubset<T, offense_managersDeleteArgs<ExtArgs>>): Prisma__offense_managersClient<$Result.GetResult<Prisma.$offense_managersPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Offense_managers.
     * @param {offense_managersUpdateArgs} args - Arguments to update one Offense_managers.
     * @example
     * // Update one Offense_managers
     * const offense_managers = await prisma.offense_managers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends offense_managersUpdateArgs>(args: SelectSubset<T, offense_managersUpdateArgs<ExtArgs>>): Prisma__offense_managersClient<$Result.GetResult<Prisma.$offense_managersPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Offense_managers.
     * @param {offense_managersDeleteManyArgs} args - Arguments to filter Offense_managers to delete.
     * @example
     * // Delete a few Offense_managers
     * const { count } = await prisma.offense_managers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends offense_managersDeleteManyArgs>(args?: SelectSubset<T, offense_managersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Offense_managers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {offense_managersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Offense_managers
     * const offense_managers = await prisma.offense_managers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends offense_managersUpdateManyArgs>(args: SelectSubset<T, offense_managersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Offense_managers.
     * @param {offense_managersUpsertArgs} args - Arguments to update or create a Offense_managers.
     * @example
     * // Update or create a Offense_managers
     * const offense_managers = await prisma.offense_managers.upsert({
     *   create: {
     *     // ... data to create a Offense_managers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Offense_managers we want to update
     *   }
     * })
     */
    upsert<T extends offense_managersUpsertArgs>(args: SelectSubset<T, offense_managersUpsertArgs<ExtArgs>>): Prisma__offense_managersClient<$Result.GetResult<Prisma.$offense_managersPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Offense_managers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {offense_managersCountArgs} args - Arguments to filter Offense_managers to count.
     * @example
     * // Count the number of Offense_managers
     * const count = await prisma.offense_managers.count({
     *   where: {
     *     // ... the filter for the Offense_managers we want to count
     *   }
     * })
    **/
    count<T extends offense_managersCountArgs>(
      args?: Subset<T, offense_managersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Offense_managersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Offense_managers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Offense_managersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Offense_managersAggregateArgs>(args: Subset<T, Offense_managersAggregateArgs>): Prisma.PrismaPromise<GetOffense_managersAggregateType<T>>

    /**
     * Group by Offense_managers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {offense_managersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends offense_managersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: offense_managersGroupByArgs['orderBy'] }
        : { orderBy?: offense_managersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, offense_managersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOffense_managersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the offense_managers model
   */
  readonly fields: offense_managersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for offense_managers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__offense_managersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the offense_managers model
   */ 
  interface offense_managersFieldRefs {
    readonly id: FieldRef<"offense_managers", 'Int'>
    readonly points: FieldRef<"offense_managers", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * offense_managers findUnique
   */
  export type offense_managersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offense_managers
     */
    select?: offense_managersSelect<ExtArgs> | null
    /**
     * Filter, which offense_managers to fetch.
     */
    where: offense_managersWhereUniqueInput
  }

  /**
   * offense_managers findUniqueOrThrow
   */
  export type offense_managersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offense_managers
     */
    select?: offense_managersSelect<ExtArgs> | null
    /**
     * Filter, which offense_managers to fetch.
     */
    where: offense_managersWhereUniqueInput
  }

  /**
   * offense_managers findFirst
   */
  export type offense_managersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offense_managers
     */
    select?: offense_managersSelect<ExtArgs> | null
    /**
     * Filter, which offense_managers to fetch.
     */
    where?: offense_managersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of offense_managers to fetch.
     */
    orderBy?: offense_managersOrderByWithRelationInput | offense_managersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for offense_managers.
     */
    cursor?: offense_managersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` offense_managers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` offense_managers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of offense_managers.
     */
    distinct?: Offense_managersScalarFieldEnum | Offense_managersScalarFieldEnum[]
  }

  /**
   * offense_managers findFirstOrThrow
   */
  export type offense_managersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offense_managers
     */
    select?: offense_managersSelect<ExtArgs> | null
    /**
     * Filter, which offense_managers to fetch.
     */
    where?: offense_managersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of offense_managers to fetch.
     */
    orderBy?: offense_managersOrderByWithRelationInput | offense_managersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for offense_managers.
     */
    cursor?: offense_managersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` offense_managers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` offense_managers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of offense_managers.
     */
    distinct?: Offense_managersScalarFieldEnum | Offense_managersScalarFieldEnum[]
  }

  /**
   * offense_managers findMany
   */
  export type offense_managersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offense_managers
     */
    select?: offense_managersSelect<ExtArgs> | null
    /**
     * Filter, which offense_managers to fetch.
     */
    where?: offense_managersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of offense_managers to fetch.
     */
    orderBy?: offense_managersOrderByWithRelationInput | offense_managersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing offense_managers.
     */
    cursor?: offense_managersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` offense_managers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` offense_managers.
     */
    skip?: number
    distinct?: Offense_managersScalarFieldEnum | Offense_managersScalarFieldEnum[]
  }

  /**
   * offense_managers create
   */
  export type offense_managersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offense_managers
     */
    select?: offense_managersSelect<ExtArgs> | null
    /**
     * The data needed to create a offense_managers.
     */
    data?: XOR<offense_managersCreateInput, offense_managersUncheckedCreateInput>
  }

  /**
   * offense_managers createMany
   */
  export type offense_managersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many offense_managers.
     */
    data: offense_managersCreateManyInput | offense_managersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * offense_managers update
   */
  export type offense_managersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offense_managers
     */
    select?: offense_managersSelect<ExtArgs> | null
    /**
     * The data needed to update a offense_managers.
     */
    data: XOR<offense_managersUpdateInput, offense_managersUncheckedUpdateInput>
    /**
     * Choose, which offense_managers to update.
     */
    where: offense_managersWhereUniqueInput
  }

  /**
   * offense_managers updateMany
   */
  export type offense_managersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update offense_managers.
     */
    data: XOR<offense_managersUpdateManyMutationInput, offense_managersUncheckedUpdateManyInput>
    /**
     * Filter which offense_managers to update
     */
    where?: offense_managersWhereInput
  }

  /**
   * offense_managers upsert
   */
  export type offense_managersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offense_managers
     */
    select?: offense_managersSelect<ExtArgs> | null
    /**
     * The filter to search for the offense_managers to update in case it exists.
     */
    where: offense_managersWhereUniqueInput
    /**
     * In case the offense_managers found by the `where` argument doesn't exist, create a new offense_managers with this data.
     */
    create: XOR<offense_managersCreateInput, offense_managersUncheckedCreateInput>
    /**
     * In case the offense_managers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<offense_managersUpdateInput, offense_managersUncheckedUpdateInput>
  }

  /**
   * offense_managers delete
   */
  export type offense_managersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offense_managers
     */
    select?: offense_managersSelect<ExtArgs> | null
    /**
     * Filter which offense_managers to delete.
     */
    where: offense_managersWhereUniqueInput
  }

  /**
   * offense_managers deleteMany
   */
  export type offense_managersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which offense_managers to delete
     */
    where?: offense_managersWhereInput
  }

  /**
   * offense_managers without action
   */
  export type offense_managersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offense_managers
     */
    select?: offense_managersSelect<ExtArgs> | null
  }


  /**
   * Model offenses
   */

  export type AggregateOffenses = {
    _count: OffensesCountAggregateOutputType | null
    _avg: OffensesAvgAggregateOutputType | null
    _sum: OffensesSumAggregateOutputType | null
    _min: OffensesMinAggregateOutputType | null
    _max: OffensesMaxAggregateOutputType | null
  }

  export type OffensesAvgAggregateOutputType = {
    id: number | null
    manager_id: number | null
    charid: number | null
    accountid: number | null
    issuer_char_id: number | null
  }

  export type OffensesSumAggregateOutputType = {
    id: bigint | null
    manager_id: number | null
    charid: number | null
    accountid: number | null
    issuer_char_id: number | null
  }

  export type OffensesMinAggregateOutputType = {
    id: bigint | null
    manager_id: number | null
    charid: number | null
    accountid: number | null
    msg: string | null
    type: string | null
    issuedate: Date | null
    issuer_char_id: number | null
  }

  export type OffensesMaxAggregateOutputType = {
    id: bigint | null
    manager_id: number | null
    charid: number | null
    accountid: number | null
    msg: string | null
    type: string | null
    issuedate: Date | null
    issuer_char_id: number | null
  }

  export type OffensesCountAggregateOutputType = {
    id: number
    manager_id: number
    charid: number
    accountid: number
    msg: number
    type: number
    issuedate: number
    issuer_char_id: number
    _all: number
  }


  export type OffensesAvgAggregateInputType = {
    id?: true
    manager_id?: true
    charid?: true
    accountid?: true
    issuer_char_id?: true
  }

  export type OffensesSumAggregateInputType = {
    id?: true
    manager_id?: true
    charid?: true
    accountid?: true
    issuer_char_id?: true
  }

  export type OffensesMinAggregateInputType = {
    id?: true
    manager_id?: true
    charid?: true
    accountid?: true
    msg?: true
    type?: true
    issuedate?: true
    issuer_char_id?: true
  }

  export type OffensesMaxAggregateInputType = {
    id?: true
    manager_id?: true
    charid?: true
    accountid?: true
    msg?: true
    type?: true
    issuedate?: true
    issuer_char_id?: true
  }

  export type OffensesCountAggregateInputType = {
    id?: true
    manager_id?: true
    charid?: true
    accountid?: true
    msg?: true
    type?: true
    issuedate?: true
    issuer_char_id?: true
    _all?: true
  }

  export type OffensesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which offenses to aggregate.
     */
    where?: offensesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of offenses to fetch.
     */
    orderBy?: offensesOrderByWithRelationInput | offensesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: offensesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` offenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` offenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned offenses
    **/
    _count?: true | OffensesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OffensesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OffensesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OffensesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OffensesMaxAggregateInputType
  }

  export type GetOffensesAggregateType<T extends OffensesAggregateArgs> = {
        [P in keyof T & keyof AggregateOffenses]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOffenses[P]>
      : GetScalarType<T[P], AggregateOffenses[P]>
  }




  export type offensesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: offensesWhereInput
    orderBy?: offensesOrderByWithAggregationInput | offensesOrderByWithAggregationInput[]
    by: OffensesScalarFieldEnum[] | OffensesScalarFieldEnum
    having?: offensesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OffensesCountAggregateInputType | true
    _avg?: OffensesAvgAggregateInputType
    _sum?: OffensesSumAggregateInputType
    _min?: OffensesMinAggregateInputType
    _max?: OffensesMaxAggregateInputType
  }

  export type OffensesGroupByOutputType = {
    id: bigint
    manager_id: number | null
    charid: number | null
    accountid: number | null
    msg: string | null
    type: string | null
    issuedate: Date | null
    issuer_char_id: number | null
    _count: OffensesCountAggregateOutputType | null
    _avg: OffensesAvgAggregateOutputType | null
    _sum: OffensesSumAggregateOutputType | null
    _min: OffensesMinAggregateOutputType | null
    _max: OffensesMaxAggregateOutputType | null
  }

  type GetOffensesGroupByPayload<T extends offensesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OffensesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OffensesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OffensesGroupByOutputType[P]>
            : GetScalarType<T[P], OffensesGroupByOutputType[P]>
        }
      >
    >


  export type offensesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    manager_id?: boolean
    charid?: boolean
    accountid?: boolean
    msg?: boolean
    type?: boolean
    issuedate?: boolean
    issuer_char_id?: boolean
  }, ExtArgs["result"]["offenses"]>


  export type offensesSelectScalar = {
    id?: boolean
    manager_id?: boolean
    charid?: boolean
    accountid?: boolean
    msg?: boolean
    type?: boolean
    issuedate?: boolean
    issuer_char_id?: boolean
  }


  export type $offensesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "offenses"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      manager_id: number | null
      charid: number | null
      accountid: number | null
      msg: string | null
      type: string | null
      issuedate: Date | null
      issuer_char_id: number | null
    }, ExtArgs["result"]["offenses"]>
    composites: {}
  }

  type offensesGetPayload<S extends boolean | null | undefined | offensesDefaultArgs> = $Result.GetResult<Prisma.$offensesPayload, S>

  type offensesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<offensesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OffensesCountAggregateInputType | true
    }

  export interface offensesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['offenses'], meta: { name: 'offenses' } }
    /**
     * Find zero or one Offenses that matches the filter.
     * @param {offensesFindUniqueArgs} args - Arguments to find a Offenses
     * @example
     * // Get one Offenses
     * const offenses = await prisma.offenses.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends offensesFindUniqueArgs>(args: SelectSubset<T, offensesFindUniqueArgs<ExtArgs>>): Prisma__offensesClient<$Result.GetResult<Prisma.$offensesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Offenses that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {offensesFindUniqueOrThrowArgs} args - Arguments to find a Offenses
     * @example
     * // Get one Offenses
     * const offenses = await prisma.offenses.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends offensesFindUniqueOrThrowArgs>(args: SelectSubset<T, offensesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__offensesClient<$Result.GetResult<Prisma.$offensesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Offenses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {offensesFindFirstArgs} args - Arguments to find a Offenses
     * @example
     * // Get one Offenses
     * const offenses = await prisma.offenses.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends offensesFindFirstArgs>(args?: SelectSubset<T, offensesFindFirstArgs<ExtArgs>>): Prisma__offensesClient<$Result.GetResult<Prisma.$offensesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Offenses that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {offensesFindFirstOrThrowArgs} args - Arguments to find a Offenses
     * @example
     * // Get one Offenses
     * const offenses = await prisma.offenses.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends offensesFindFirstOrThrowArgs>(args?: SelectSubset<T, offensesFindFirstOrThrowArgs<ExtArgs>>): Prisma__offensesClient<$Result.GetResult<Prisma.$offensesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Offenses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {offensesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Offenses
     * const offenses = await prisma.offenses.findMany()
     * 
     * // Get first 10 Offenses
     * const offenses = await prisma.offenses.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const offensesWithIdOnly = await prisma.offenses.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends offensesFindManyArgs>(args?: SelectSubset<T, offensesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$offensesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Offenses.
     * @param {offensesCreateArgs} args - Arguments to create a Offenses.
     * @example
     * // Create one Offenses
     * const Offenses = await prisma.offenses.create({
     *   data: {
     *     // ... data to create a Offenses
     *   }
     * })
     * 
     */
    create<T extends offensesCreateArgs>(args: SelectSubset<T, offensesCreateArgs<ExtArgs>>): Prisma__offensesClient<$Result.GetResult<Prisma.$offensesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Offenses.
     * @param {offensesCreateManyArgs} args - Arguments to create many Offenses.
     * @example
     * // Create many Offenses
     * const offenses = await prisma.offenses.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends offensesCreateManyArgs>(args?: SelectSubset<T, offensesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Offenses.
     * @param {offensesDeleteArgs} args - Arguments to delete one Offenses.
     * @example
     * // Delete one Offenses
     * const Offenses = await prisma.offenses.delete({
     *   where: {
     *     // ... filter to delete one Offenses
     *   }
     * })
     * 
     */
    delete<T extends offensesDeleteArgs>(args: SelectSubset<T, offensesDeleteArgs<ExtArgs>>): Prisma__offensesClient<$Result.GetResult<Prisma.$offensesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Offenses.
     * @param {offensesUpdateArgs} args - Arguments to update one Offenses.
     * @example
     * // Update one Offenses
     * const offenses = await prisma.offenses.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends offensesUpdateArgs>(args: SelectSubset<T, offensesUpdateArgs<ExtArgs>>): Prisma__offensesClient<$Result.GetResult<Prisma.$offensesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Offenses.
     * @param {offensesDeleteManyArgs} args - Arguments to filter Offenses to delete.
     * @example
     * // Delete a few Offenses
     * const { count } = await prisma.offenses.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends offensesDeleteManyArgs>(args?: SelectSubset<T, offensesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Offenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {offensesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Offenses
     * const offenses = await prisma.offenses.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends offensesUpdateManyArgs>(args: SelectSubset<T, offensesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Offenses.
     * @param {offensesUpsertArgs} args - Arguments to update or create a Offenses.
     * @example
     * // Update or create a Offenses
     * const offenses = await prisma.offenses.upsert({
     *   create: {
     *     // ... data to create a Offenses
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Offenses we want to update
     *   }
     * })
     */
    upsert<T extends offensesUpsertArgs>(args: SelectSubset<T, offensesUpsertArgs<ExtArgs>>): Prisma__offensesClient<$Result.GetResult<Prisma.$offensesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Offenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {offensesCountArgs} args - Arguments to filter Offenses to count.
     * @example
     * // Count the number of Offenses
     * const count = await prisma.offenses.count({
     *   where: {
     *     // ... the filter for the Offenses we want to count
     *   }
     * })
    **/
    count<T extends offensesCountArgs>(
      args?: Subset<T, offensesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OffensesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Offenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffensesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OffensesAggregateArgs>(args: Subset<T, OffensesAggregateArgs>): Prisma.PrismaPromise<GetOffensesAggregateType<T>>

    /**
     * Group by Offenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {offensesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends offensesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: offensesGroupByArgs['orderBy'] }
        : { orderBy?: offensesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, offensesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOffensesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the offenses model
   */
  readonly fields: offensesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for offenses.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__offensesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the offenses model
   */ 
  interface offensesFieldRefs {
    readonly id: FieldRef<"offenses", 'BigInt'>
    readonly manager_id: FieldRef<"offenses", 'Int'>
    readonly charid: FieldRef<"offenses", 'Int'>
    readonly accountid: FieldRef<"offenses", 'Int'>
    readonly msg: FieldRef<"offenses", 'String'>
    readonly type: FieldRef<"offenses", 'String'>
    readonly issuedate: FieldRef<"offenses", 'DateTime'>
    readonly issuer_char_id: FieldRef<"offenses", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * offenses findUnique
   */
  export type offensesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offenses
     */
    select?: offensesSelect<ExtArgs> | null
    /**
     * Filter, which offenses to fetch.
     */
    where: offensesWhereUniqueInput
  }

  /**
   * offenses findUniqueOrThrow
   */
  export type offensesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offenses
     */
    select?: offensesSelect<ExtArgs> | null
    /**
     * Filter, which offenses to fetch.
     */
    where: offensesWhereUniqueInput
  }

  /**
   * offenses findFirst
   */
  export type offensesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offenses
     */
    select?: offensesSelect<ExtArgs> | null
    /**
     * Filter, which offenses to fetch.
     */
    where?: offensesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of offenses to fetch.
     */
    orderBy?: offensesOrderByWithRelationInput | offensesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for offenses.
     */
    cursor?: offensesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` offenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` offenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of offenses.
     */
    distinct?: OffensesScalarFieldEnum | OffensesScalarFieldEnum[]
  }

  /**
   * offenses findFirstOrThrow
   */
  export type offensesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offenses
     */
    select?: offensesSelect<ExtArgs> | null
    /**
     * Filter, which offenses to fetch.
     */
    where?: offensesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of offenses to fetch.
     */
    orderBy?: offensesOrderByWithRelationInput | offensesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for offenses.
     */
    cursor?: offensesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` offenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` offenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of offenses.
     */
    distinct?: OffensesScalarFieldEnum | OffensesScalarFieldEnum[]
  }

  /**
   * offenses findMany
   */
  export type offensesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offenses
     */
    select?: offensesSelect<ExtArgs> | null
    /**
     * Filter, which offenses to fetch.
     */
    where?: offensesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of offenses to fetch.
     */
    orderBy?: offensesOrderByWithRelationInput | offensesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing offenses.
     */
    cursor?: offensesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` offenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` offenses.
     */
    skip?: number
    distinct?: OffensesScalarFieldEnum | OffensesScalarFieldEnum[]
  }

  /**
   * offenses create
   */
  export type offensesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offenses
     */
    select?: offensesSelect<ExtArgs> | null
    /**
     * The data needed to create a offenses.
     */
    data?: XOR<offensesCreateInput, offensesUncheckedCreateInput>
  }

  /**
   * offenses createMany
   */
  export type offensesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many offenses.
     */
    data: offensesCreateManyInput | offensesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * offenses update
   */
  export type offensesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offenses
     */
    select?: offensesSelect<ExtArgs> | null
    /**
     * The data needed to update a offenses.
     */
    data: XOR<offensesUpdateInput, offensesUncheckedUpdateInput>
    /**
     * Choose, which offenses to update.
     */
    where: offensesWhereUniqueInput
  }

  /**
   * offenses updateMany
   */
  export type offensesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update offenses.
     */
    data: XOR<offensesUpdateManyMutationInput, offensesUncheckedUpdateManyInput>
    /**
     * Filter which offenses to update
     */
    where?: offensesWhereInput
  }

  /**
   * offenses upsert
   */
  export type offensesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offenses
     */
    select?: offensesSelect<ExtArgs> | null
    /**
     * The filter to search for the offenses to update in case it exists.
     */
    where: offensesWhereUniqueInput
    /**
     * In case the offenses found by the `where` argument doesn't exist, create a new offenses with this data.
     */
    create: XOR<offensesCreateInput, offensesUncheckedCreateInput>
    /**
     * In case the offenses was found with the provided `where` argument, update it with this data.
     */
    update: XOR<offensesUpdateInput, offensesUncheckedUpdateInput>
  }

  /**
   * offenses delete
   */
  export type offensesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offenses
     */
    select?: offensesSelect<ExtArgs> | null
    /**
     * Filter which offenses to delete.
     */
    where: offensesWhereUniqueInput
  }

  /**
   * offenses deleteMany
   */
  export type offensesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which offenses to delete
     */
    where?: offensesWhereInput
  }

  /**
   * offenses without action
   */
  export type offensesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offenses
     */
    select?: offensesSelect<ExtArgs> | null
  }


  /**
   * Model party
   */

  export type AggregateParty = {
    _count: PartyCountAggregateOutputType | null
    _avg: PartyAvgAggregateOutputType | null
    _sum: PartySumAggregateOutputType | null
    _min: PartyMinAggregateOutputType | null
    _max: PartyMaxAggregateOutputType | null
  }

  export type PartyAvgAggregateOutputType = {
    id: number | null
    partyleaderid: number | null
  }

  export type PartySumAggregateOutputType = {
    id: number | null
    partyleaderid: number | null
  }

  export type PartyMinAggregateOutputType = {
    id: number | null
    name: string | null
    partyleaderid: number | null
    appliable: boolean | null
    isprivateparty: boolean | null
  }

  export type PartyMaxAggregateOutputType = {
    id: number | null
    name: string | null
    partyleaderid: number | null
    appliable: boolean | null
    isprivateparty: boolean | null
  }

  export type PartyCountAggregateOutputType = {
    id: number
    name: number
    partyleaderid: number
    appliable: number
    isprivateparty: number
    _all: number
  }


  export type PartyAvgAggregateInputType = {
    id?: true
    partyleaderid?: true
  }

  export type PartySumAggregateInputType = {
    id?: true
    partyleaderid?: true
  }

  export type PartyMinAggregateInputType = {
    id?: true
    name?: true
    partyleaderid?: true
    appliable?: true
    isprivateparty?: true
  }

  export type PartyMaxAggregateInputType = {
    id?: true
    name?: true
    partyleaderid?: true
    appliable?: true
    isprivateparty?: true
  }

  export type PartyCountAggregateInputType = {
    id?: true
    name?: true
    partyleaderid?: true
    appliable?: true
    isprivateparty?: true
    _all?: true
  }

  export type PartyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which party to aggregate.
     */
    where?: partyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parties to fetch.
     */
    orderBy?: partyOrderByWithRelationInput | partyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: partyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned parties
    **/
    _count?: true | PartyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PartyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PartySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PartyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PartyMaxAggregateInputType
  }

  export type GetPartyAggregateType<T extends PartyAggregateArgs> = {
        [P in keyof T & keyof AggregateParty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParty[P]>
      : GetScalarType<T[P], AggregateParty[P]>
  }




  export type partyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: partyWhereInput
    orderBy?: partyOrderByWithAggregationInput | partyOrderByWithAggregationInput[]
    by: PartyScalarFieldEnum[] | PartyScalarFieldEnum
    having?: partyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PartyCountAggregateInputType | true
    _avg?: PartyAvgAggregateInputType
    _sum?: PartySumAggregateInputType
    _min?: PartyMinAggregateInputType
    _max?: PartyMaxAggregateInputType
  }

  export type PartyGroupByOutputType = {
    id: number
    name: string | null
    partyleaderid: number | null
    appliable: boolean | null
    isprivateparty: boolean | null
    _count: PartyCountAggregateOutputType | null
    _avg: PartyAvgAggregateOutputType | null
    _sum: PartySumAggregateOutputType | null
    _min: PartyMinAggregateOutputType | null
    _max: PartyMaxAggregateOutputType | null
  }

  type GetPartyGroupByPayload<T extends partyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PartyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PartyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PartyGroupByOutputType[P]>
            : GetScalarType<T[P], PartyGroupByOutputType[P]>
        }
      >
    >


  export type partySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    partyleaderid?: boolean
    appliable?: boolean
    isprivateparty?: boolean
  }, ExtArgs["result"]["party"]>


  export type partySelectScalar = {
    id?: boolean
    name?: boolean
    partyleaderid?: boolean
    appliable?: boolean
    isprivateparty?: boolean
  }


  export type $partyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "party"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string | null
      partyleaderid: number | null
      appliable: boolean | null
      isprivateparty: boolean | null
    }, ExtArgs["result"]["party"]>
    composites: {}
  }

  type partyGetPayload<S extends boolean | null | undefined | partyDefaultArgs> = $Result.GetResult<Prisma.$partyPayload, S>

  type partyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<partyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PartyCountAggregateInputType | true
    }

  export interface partyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['party'], meta: { name: 'party' } }
    /**
     * Find zero or one Party that matches the filter.
     * @param {partyFindUniqueArgs} args - Arguments to find a Party
     * @example
     * // Get one Party
     * const party = await prisma.party.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends partyFindUniqueArgs>(args: SelectSubset<T, partyFindUniqueArgs<ExtArgs>>): Prisma__partyClient<$Result.GetResult<Prisma.$partyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Party that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {partyFindUniqueOrThrowArgs} args - Arguments to find a Party
     * @example
     * // Get one Party
     * const party = await prisma.party.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends partyFindUniqueOrThrowArgs>(args: SelectSubset<T, partyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__partyClient<$Result.GetResult<Prisma.$partyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Party that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {partyFindFirstArgs} args - Arguments to find a Party
     * @example
     * // Get one Party
     * const party = await prisma.party.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends partyFindFirstArgs>(args?: SelectSubset<T, partyFindFirstArgs<ExtArgs>>): Prisma__partyClient<$Result.GetResult<Prisma.$partyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Party that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {partyFindFirstOrThrowArgs} args - Arguments to find a Party
     * @example
     * // Get one Party
     * const party = await prisma.party.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends partyFindFirstOrThrowArgs>(args?: SelectSubset<T, partyFindFirstOrThrowArgs<ExtArgs>>): Prisma__partyClient<$Result.GetResult<Prisma.$partyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Parties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {partyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Parties
     * const parties = await prisma.party.findMany()
     * 
     * // Get first 10 Parties
     * const parties = await prisma.party.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const partyWithIdOnly = await prisma.party.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends partyFindManyArgs>(args?: SelectSubset<T, partyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$partyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Party.
     * @param {partyCreateArgs} args - Arguments to create a Party.
     * @example
     * // Create one Party
     * const Party = await prisma.party.create({
     *   data: {
     *     // ... data to create a Party
     *   }
     * })
     * 
     */
    create<T extends partyCreateArgs>(args: SelectSubset<T, partyCreateArgs<ExtArgs>>): Prisma__partyClient<$Result.GetResult<Prisma.$partyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Parties.
     * @param {partyCreateManyArgs} args - Arguments to create many Parties.
     * @example
     * // Create many Parties
     * const party = await prisma.party.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends partyCreateManyArgs>(args?: SelectSubset<T, partyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Party.
     * @param {partyDeleteArgs} args - Arguments to delete one Party.
     * @example
     * // Delete one Party
     * const Party = await prisma.party.delete({
     *   where: {
     *     // ... filter to delete one Party
     *   }
     * })
     * 
     */
    delete<T extends partyDeleteArgs>(args: SelectSubset<T, partyDeleteArgs<ExtArgs>>): Prisma__partyClient<$Result.GetResult<Prisma.$partyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Party.
     * @param {partyUpdateArgs} args - Arguments to update one Party.
     * @example
     * // Update one Party
     * const party = await prisma.party.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends partyUpdateArgs>(args: SelectSubset<T, partyUpdateArgs<ExtArgs>>): Prisma__partyClient<$Result.GetResult<Prisma.$partyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Parties.
     * @param {partyDeleteManyArgs} args - Arguments to filter Parties to delete.
     * @example
     * // Delete a few Parties
     * const { count } = await prisma.party.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends partyDeleteManyArgs>(args?: SelectSubset<T, partyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {partyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Parties
     * const party = await prisma.party.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends partyUpdateManyArgs>(args: SelectSubset<T, partyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Party.
     * @param {partyUpsertArgs} args - Arguments to update or create a Party.
     * @example
     * // Update or create a Party
     * const party = await prisma.party.upsert({
     *   create: {
     *     // ... data to create a Party
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Party we want to update
     *   }
     * })
     */
    upsert<T extends partyUpsertArgs>(args: SelectSubset<T, partyUpsertArgs<ExtArgs>>): Prisma__partyClient<$Result.GetResult<Prisma.$partyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Parties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {partyCountArgs} args - Arguments to filter Parties to count.
     * @example
     * // Count the number of Parties
     * const count = await prisma.party.count({
     *   where: {
     *     // ... the filter for the Parties we want to count
     *   }
     * })
    **/
    count<T extends partyCountArgs>(
      args?: Subset<T, partyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PartyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Party.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PartyAggregateArgs>(args: Subset<T, PartyAggregateArgs>): Prisma.PrismaPromise<GetPartyAggregateType<T>>

    /**
     * Group by Party.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {partyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends partyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: partyGroupByArgs['orderBy'] }
        : { orderBy?: partyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, partyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPartyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the party model
   */
  readonly fields: partyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for party.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__partyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the party model
   */ 
  interface partyFieldRefs {
    readonly id: FieldRef<"party", 'Int'>
    readonly name: FieldRef<"party", 'String'>
    readonly partyleaderid: FieldRef<"party", 'Int'>
    readonly appliable: FieldRef<"party", 'Boolean'>
    readonly isprivateparty: FieldRef<"party", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * party findUnique
   */
  export type partyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the party
     */
    select?: partySelect<ExtArgs> | null
    /**
     * Filter, which party to fetch.
     */
    where: partyWhereUniqueInput
  }

  /**
   * party findUniqueOrThrow
   */
  export type partyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the party
     */
    select?: partySelect<ExtArgs> | null
    /**
     * Filter, which party to fetch.
     */
    where: partyWhereUniqueInput
  }

  /**
   * party findFirst
   */
  export type partyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the party
     */
    select?: partySelect<ExtArgs> | null
    /**
     * Filter, which party to fetch.
     */
    where?: partyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parties to fetch.
     */
    orderBy?: partyOrderByWithRelationInput | partyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for parties.
     */
    cursor?: partyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of parties.
     */
    distinct?: PartyScalarFieldEnum | PartyScalarFieldEnum[]
  }

  /**
   * party findFirstOrThrow
   */
  export type partyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the party
     */
    select?: partySelect<ExtArgs> | null
    /**
     * Filter, which party to fetch.
     */
    where?: partyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parties to fetch.
     */
    orderBy?: partyOrderByWithRelationInput | partyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for parties.
     */
    cursor?: partyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of parties.
     */
    distinct?: PartyScalarFieldEnum | PartyScalarFieldEnum[]
  }

  /**
   * party findMany
   */
  export type partyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the party
     */
    select?: partySelect<ExtArgs> | null
    /**
     * Filter, which parties to fetch.
     */
    where?: partyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parties to fetch.
     */
    orderBy?: partyOrderByWithRelationInput | partyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing parties.
     */
    cursor?: partyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parties.
     */
    skip?: number
    distinct?: PartyScalarFieldEnum | PartyScalarFieldEnum[]
  }

  /**
   * party create
   */
  export type partyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the party
     */
    select?: partySelect<ExtArgs> | null
    /**
     * The data needed to create a party.
     */
    data?: XOR<partyCreateInput, partyUncheckedCreateInput>
  }

  /**
   * party createMany
   */
  export type partyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many parties.
     */
    data: partyCreateManyInput | partyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * party update
   */
  export type partyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the party
     */
    select?: partySelect<ExtArgs> | null
    /**
     * The data needed to update a party.
     */
    data: XOR<partyUpdateInput, partyUncheckedUpdateInput>
    /**
     * Choose, which party to update.
     */
    where: partyWhereUniqueInput
  }

  /**
   * party updateMany
   */
  export type partyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update parties.
     */
    data: XOR<partyUpdateManyMutationInput, partyUncheckedUpdateManyInput>
    /**
     * Filter which parties to update
     */
    where?: partyWhereInput
  }

  /**
   * party upsert
   */
  export type partyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the party
     */
    select?: partySelect<ExtArgs> | null
    /**
     * The filter to search for the party to update in case it exists.
     */
    where: partyWhereUniqueInput
    /**
     * In case the party found by the `where` argument doesn't exist, create a new party with this data.
     */
    create: XOR<partyCreateInput, partyUncheckedCreateInput>
    /**
     * In case the party was found with the provided `where` argument, update it with this data.
     */
    update: XOR<partyUpdateInput, partyUncheckedUpdateInput>
  }

  /**
   * party delete
   */
  export type partyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the party
     */
    select?: partySelect<ExtArgs> | null
    /**
     * Filter which party to delete.
     */
    where: partyWhereUniqueInput
  }

  /**
   * party deleteMany
   */
  export type partyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which parties to delete
     */
    where?: partyWhereInput
  }

  /**
   * party without action
   */
  export type partyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the party
     */
    select?: partySelect<ExtArgs> | null
  }


  /**
   * Model partyboss
   */

  export type AggregatePartyboss = {
    _count: PartybossCountAggregateOutputType | null
    _avg: PartybossAvgAggregateOutputType | null
    _sum: PartybossSumAggregateOutputType | null
    _min: PartybossMinAggregateOutputType | null
    _max: PartybossMaxAggregateOutputType | null
  }

  export type PartybossAvgAggregateOutputType = {
    id: number | null
    charid: number | null
    orderid: number | null
    difficulty: number | null
    attempt: number | null
  }

  export type PartybossSumAggregateOutputType = {
    id: number | null
    charid: number | null
    orderid: number | null
    difficulty: number | null
    attempt: number | null
  }

  export type PartybossMinAggregateOutputType = {
    id: number | null
    charid: number | null
    orderid: number | null
    bossname: string | null
    difficulty: number | null
    attempt: number | null
    lastattempttime: Date | null
  }

  export type PartybossMaxAggregateOutputType = {
    id: number | null
    charid: number | null
    orderid: number | null
    bossname: string | null
    difficulty: number | null
    attempt: number | null
    lastattempttime: Date | null
  }

  export type PartybossCountAggregateOutputType = {
    id: number
    charid: number
    orderid: number
    bossname: number
    difficulty: number
    attempt: number
    lastattempttime: number
    _all: number
  }


  export type PartybossAvgAggregateInputType = {
    id?: true
    charid?: true
    orderid?: true
    difficulty?: true
    attempt?: true
  }

  export type PartybossSumAggregateInputType = {
    id?: true
    charid?: true
    orderid?: true
    difficulty?: true
    attempt?: true
  }

  export type PartybossMinAggregateInputType = {
    id?: true
    charid?: true
    orderid?: true
    bossname?: true
    difficulty?: true
    attempt?: true
    lastattempttime?: true
  }

  export type PartybossMaxAggregateInputType = {
    id?: true
    charid?: true
    orderid?: true
    bossname?: true
    difficulty?: true
    attempt?: true
    lastattempttime?: true
  }

  export type PartybossCountAggregateInputType = {
    id?: true
    charid?: true
    orderid?: true
    bossname?: true
    difficulty?: true
    attempt?: true
    lastattempttime?: true
    _all?: true
  }

  export type PartybossAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which partyboss to aggregate.
     */
    where?: partybossWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of partybosses to fetch.
     */
    orderBy?: partybossOrderByWithRelationInput | partybossOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: partybossWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` partybosses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` partybosses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned partybosses
    **/
    _count?: true | PartybossCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PartybossAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PartybossSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PartybossMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PartybossMaxAggregateInputType
  }

  export type GetPartybossAggregateType<T extends PartybossAggregateArgs> = {
        [P in keyof T & keyof AggregatePartyboss]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePartyboss[P]>
      : GetScalarType<T[P], AggregatePartyboss[P]>
  }




  export type partybossGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: partybossWhereInput
    orderBy?: partybossOrderByWithAggregationInput | partybossOrderByWithAggregationInput[]
    by: PartybossScalarFieldEnum[] | PartybossScalarFieldEnum
    having?: partybossScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PartybossCountAggregateInputType | true
    _avg?: PartybossAvgAggregateInputType
    _sum?: PartybossSumAggregateInputType
    _min?: PartybossMinAggregateInputType
    _max?: PartybossMaxAggregateInputType
  }

  export type PartybossGroupByOutputType = {
    id: number
    charid: number | null
    orderid: number | null
    bossname: string | null
    difficulty: number | null
    attempt: number | null
    lastattempttime: Date | null
    _count: PartybossCountAggregateOutputType | null
    _avg: PartybossAvgAggregateOutputType | null
    _sum: PartybossSumAggregateOutputType | null
    _min: PartybossMinAggregateOutputType | null
    _max: PartybossMaxAggregateOutputType | null
  }

  type GetPartybossGroupByPayload<T extends partybossGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PartybossGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PartybossGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PartybossGroupByOutputType[P]>
            : GetScalarType<T[P], PartybossGroupByOutputType[P]>
        }
      >
    >


  export type partybossSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    charid?: boolean
    orderid?: boolean
    bossname?: boolean
    difficulty?: boolean
    attempt?: boolean
    lastattempttime?: boolean
  }, ExtArgs["result"]["partyboss"]>


  export type partybossSelectScalar = {
    id?: boolean
    charid?: boolean
    orderid?: boolean
    bossname?: boolean
    difficulty?: boolean
    attempt?: boolean
    lastattempttime?: boolean
  }


  export type $partybossPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "partyboss"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      charid: number | null
      orderid: number | null
      bossname: string | null
      difficulty: number | null
      attempt: number | null
      lastattempttime: Date | null
    }, ExtArgs["result"]["partyboss"]>
    composites: {}
  }

  type partybossGetPayload<S extends boolean | null | undefined | partybossDefaultArgs> = $Result.GetResult<Prisma.$partybossPayload, S>

  type partybossCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<partybossFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PartybossCountAggregateInputType | true
    }

  export interface partybossDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['partyboss'], meta: { name: 'partyboss' } }
    /**
     * Find zero or one Partyboss that matches the filter.
     * @param {partybossFindUniqueArgs} args - Arguments to find a Partyboss
     * @example
     * // Get one Partyboss
     * const partyboss = await prisma.partyboss.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends partybossFindUniqueArgs>(args: SelectSubset<T, partybossFindUniqueArgs<ExtArgs>>): Prisma__partybossClient<$Result.GetResult<Prisma.$partybossPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Partyboss that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {partybossFindUniqueOrThrowArgs} args - Arguments to find a Partyboss
     * @example
     * // Get one Partyboss
     * const partyboss = await prisma.partyboss.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends partybossFindUniqueOrThrowArgs>(args: SelectSubset<T, partybossFindUniqueOrThrowArgs<ExtArgs>>): Prisma__partybossClient<$Result.GetResult<Prisma.$partybossPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Partyboss that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {partybossFindFirstArgs} args - Arguments to find a Partyboss
     * @example
     * // Get one Partyboss
     * const partyboss = await prisma.partyboss.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends partybossFindFirstArgs>(args?: SelectSubset<T, partybossFindFirstArgs<ExtArgs>>): Prisma__partybossClient<$Result.GetResult<Prisma.$partybossPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Partyboss that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {partybossFindFirstOrThrowArgs} args - Arguments to find a Partyboss
     * @example
     * // Get one Partyboss
     * const partyboss = await prisma.partyboss.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends partybossFindFirstOrThrowArgs>(args?: SelectSubset<T, partybossFindFirstOrThrowArgs<ExtArgs>>): Prisma__partybossClient<$Result.GetResult<Prisma.$partybossPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Partybosses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {partybossFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Partybosses
     * const partybosses = await prisma.partyboss.findMany()
     * 
     * // Get first 10 Partybosses
     * const partybosses = await prisma.partyboss.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const partybossWithIdOnly = await prisma.partyboss.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends partybossFindManyArgs>(args?: SelectSubset<T, partybossFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$partybossPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Partyboss.
     * @param {partybossCreateArgs} args - Arguments to create a Partyboss.
     * @example
     * // Create one Partyboss
     * const Partyboss = await prisma.partyboss.create({
     *   data: {
     *     // ... data to create a Partyboss
     *   }
     * })
     * 
     */
    create<T extends partybossCreateArgs>(args: SelectSubset<T, partybossCreateArgs<ExtArgs>>): Prisma__partybossClient<$Result.GetResult<Prisma.$partybossPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Partybosses.
     * @param {partybossCreateManyArgs} args - Arguments to create many Partybosses.
     * @example
     * // Create many Partybosses
     * const partyboss = await prisma.partyboss.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends partybossCreateManyArgs>(args?: SelectSubset<T, partybossCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Partyboss.
     * @param {partybossDeleteArgs} args - Arguments to delete one Partyboss.
     * @example
     * // Delete one Partyboss
     * const Partyboss = await prisma.partyboss.delete({
     *   where: {
     *     // ... filter to delete one Partyboss
     *   }
     * })
     * 
     */
    delete<T extends partybossDeleteArgs>(args: SelectSubset<T, partybossDeleteArgs<ExtArgs>>): Prisma__partybossClient<$Result.GetResult<Prisma.$partybossPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Partyboss.
     * @param {partybossUpdateArgs} args - Arguments to update one Partyboss.
     * @example
     * // Update one Partyboss
     * const partyboss = await prisma.partyboss.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends partybossUpdateArgs>(args: SelectSubset<T, partybossUpdateArgs<ExtArgs>>): Prisma__partybossClient<$Result.GetResult<Prisma.$partybossPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Partybosses.
     * @param {partybossDeleteManyArgs} args - Arguments to filter Partybosses to delete.
     * @example
     * // Delete a few Partybosses
     * const { count } = await prisma.partyboss.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends partybossDeleteManyArgs>(args?: SelectSubset<T, partybossDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Partybosses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {partybossUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Partybosses
     * const partyboss = await prisma.partyboss.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends partybossUpdateManyArgs>(args: SelectSubset<T, partybossUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Partyboss.
     * @param {partybossUpsertArgs} args - Arguments to update or create a Partyboss.
     * @example
     * // Update or create a Partyboss
     * const partyboss = await prisma.partyboss.upsert({
     *   create: {
     *     // ... data to create a Partyboss
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Partyboss we want to update
     *   }
     * })
     */
    upsert<T extends partybossUpsertArgs>(args: SelectSubset<T, partybossUpsertArgs<ExtArgs>>): Prisma__partybossClient<$Result.GetResult<Prisma.$partybossPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Partybosses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {partybossCountArgs} args - Arguments to filter Partybosses to count.
     * @example
     * // Count the number of Partybosses
     * const count = await prisma.partyboss.count({
     *   where: {
     *     // ... the filter for the Partybosses we want to count
     *   }
     * })
    **/
    count<T extends partybossCountArgs>(
      args?: Subset<T, partybossCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PartybossCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Partyboss.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartybossAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PartybossAggregateArgs>(args: Subset<T, PartybossAggregateArgs>): Prisma.PrismaPromise<GetPartybossAggregateType<T>>

    /**
     * Group by Partyboss.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {partybossGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends partybossGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: partybossGroupByArgs['orderBy'] }
        : { orderBy?: partybossGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, partybossGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPartybossGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the partyboss model
   */
  readonly fields: partybossFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for partyboss.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__partybossClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the partyboss model
   */ 
  interface partybossFieldRefs {
    readonly id: FieldRef<"partyboss", 'Int'>
    readonly charid: FieldRef<"partyboss", 'Int'>
    readonly orderid: FieldRef<"partyboss", 'Int'>
    readonly bossname: FieldRef<"partyboss", 'String'>
    readonly difficulty: FieldRef<"partyboss", 'Int'>
    readonly attempt: FieldRef<"partyboss", 'Int'>
    readonly lastattempttime: FieldRef<"partyboss", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * partyboss findUnique
   */
  export type partybossFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the partyboss
     */
    select?: partybossSelect<ExtArgs> | null
    /**
     * Filter, which partyboss to fetch.
     */
    where: partybossWhereUniqueInput
  }

  /**
   * partyboss findUniqueOrThrow
   */
  export type partybossFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the partyboss
     */
    select?: partybossSelect<ExtArgs> | null
    /**
     * Filter, which partyboss to fetch.
     */
    where: partybossWhereUniqueInput
  }

  /**
   * partyboss findFirst
   */
  export type partybossFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the partyboss
     */
    select?: partybossSelect<ExtArgs> | null
    /**
     * Filter, which partyboss to fetch.
     */
    where?: partybossWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of partybosses to fetch.
     */
    orderBy?: partybossOrderByWithRelationInput | partybossOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for partybosses.
     */
    cursor?: partybossWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` partybosses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` partybosses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of partybosses.
     */
    distinct?: PartybossScalarFieldEnum | PartybossScalarFieldEnum[]
  }

  /**
   * partyboss findFirstOrThrow
   */
  export type partybossFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the partyboss
     */
    select?: partybossSelect<ExtArgs> | null
    /**
     * Filter, which partyboss to fetch.
     */
    where?: partybossWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of partybosses to fetch.
     */
    orderBy?: partybossOrderByWithRelationInput | partybossOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for partybosses.
     */
    cursor?: partybossWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` partybosses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` partybosses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of partybosses.
     */
    distinct?: PartybossScalarFieldEnum | PartybossScalarFieldEnum[]
  }

  /**
   * partyboss findMany
   */
  export type partybossFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the partyboss
     */
    select?: partybossSelect<ExtArgs> | null
    /**
     * Filter, which partybosses to fetch.
     */
    where?: partybossWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of partybosses to fetch.
     */
    orderBy?: partybossOrderByWithRelationInput | partybossOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing partybosses.
     */
    cursor?: partybossWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` partybosses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` partybosses.
     */
    skip?: number
    distinct?: PartybossScalarFieldEnum | PartybossScalarFieldEnum[]
  }

  /**
   * partyboss create
   */
  export type partybossCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the partyboss
     */
    select?: partybossSelect<ExtArgs> | null
    /**
     * The data needed to create a partyboss.
     */
    data?: XOR<partybossCreateInput, partybossUncheckedCreateInput>
  }

  /**
   * partyboss createMany
   */
  export type partybossCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many partybosses.
     */
    data: partybossCreateManyInput | partybossCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * partyboss update
   */
  export type partybossUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the partyboss
     */
    select?: partybossSelect<ExtArgs> | null
    /**
     * The data needed to update a partyboss.
     */
    data: XOR<partybossUpdateInput, partybossUncheckedUpdateInput>
    /**
     * Choose, which partyboss to update.
     */
    where: partybossWhereUniqueInput
  }

  /**
   * partyboss updateMany
   */
  export type partybossUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update partybosses.
     */
    data: XOR<partybossUpdateManyMutationInput, partybossUncheckedUpdateManyInput>
    /**
     * Filter which partybosses to update
     */
    where?: partybossWhereInput
  }

  /**
   * partyboss upsert
   */
  export type partybossUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the partyboss
     */
    select?: partybossSelect<ExtArgs> | null
    /**
     * The filter to search for the partyboss to update in case it exists.
     */
    where: partybossWhereUniqueInput
    /**
     * In case the partyboss found by the `where` argument doesn't exist, create a new partyboss with this data.
     */
    create: XOR<partybossCreateInput, partybossUncheckedCreateInput>
    /**
     * In case the partyboss was found with the provided `where` argument, update it with this data.
     */
    update: XOR<partybossUpdateInput, partybossUncheckedUpdateInput>
  }

  /**
   * partyboss delete
   */
  export type partybossDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the partyboss
     */
    select?: partybossSelect<ExtArgs> | null
    /**
     * Filter which partyboss to delete.
     */
    where: partybossWhereUniqueInput
  }

  /**
   * partyboss deleteMany
   */
  export type partybossDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which partybosses to delete
     */
    where?: partybossWhereInput
  }

  /**
   * partyboss without action
   */
  export type partybossDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the partyboss
     */
    select?: partybossSelect<ExtArgs> | null
  }


  /**
   * Model partymembers
   */

  export type AggregatePartymembers = {
    _count: PartymembersCountAggregateOutputType | null
    _avg: PartymembersAvgAggregateOutputType | null
    _sum: PartymembersSumAggregateOutputType | null
    _min: PartymembersMinAggregateOutputType | null
    _max: PartymembersMaxAggregateOutputType | null
  }

  export type PartymembersAvgAggregateOutputType = {
    id: number | null
    partyid: number | null
    charid: number | null
    job: number | null
    subJob: number | null
    level: number | null
    channel: number | null
    fieldid: number | null
  }

  export type PartymembersSumAggregateOutputType = {
    id: number | null
    partyid: number | null
    charid: number | null
    job: number | null
    subJob: number | null
    level: number | null
    channel: number | null
    fieldid: number | null
  }

  export type PartymembersMinAggregateOutputType = {
    id: number | null
    partyid: number | null
    charid: number | null
    name: string | null
    job: number | null
    subJob: number | null
    level: number | null
    channel: number | null
    fieldid: number | null
    loggedin: boolean | null
  }

  export type PartymembersMaxAggregateOutputType = {
    id: number | null
    partyid: number | null
    charid: number | null
    name: string | null
    job: number | null
    subJob: number | null
    level: number | null
    channel: number | null
    fieldid: number | null
    loggedin: boolean | null
  }

  export type PartymembersCountAggregateOutputType = {
    id: number
    partyid: number
    charid: number
    name: number
    job: number
    subJob: number
    level: number
    channel: number
    fieldid: number
    loggedin: number
    _all: number
  }


  export type PartymembersAvgAggregateInputType = {
    id?: true
    partyid?: true
    charid?: true
    job?: true
    subJob?: true
    level?: true
    channel?: true
    fieldid?: true
  }

  export type PartymembersSumAggregateInputType = {
    id?: true
    partyid?: true
    charid?: true
    job?: true
    subJob?: true
    level?: true
    channel?: true
    fieldid?: true
  }

  export type PartymembersMinAggregateInputType = {
    id?: true
    partyid?: true
    charid?: true
    name?: true
    job?: true
    subJob?: true
    level?: true
    channel?: true
    fieldid?: true
    loggedin?: true
  }

  export type PartymembersMaxAggregateInputType = {
    id?: true
    partyid?: true
    charid?: true
    name?: true
    job?: true
    subJob?: true
    level?: true
    channel?: true
    fieldid?: true
    loggedin?: true
  }

  export type PartymembersCountAggregateInputType = {
    id?: true
    partyid?: true
    charid?: true
    name?: true
    job?: true
    subJob?: true
    level?: true
    channel?: true
    fieldid?: true
    loggedin?: true
    _all?: true
  }

  export type PartymembersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which partymembers to aggregate.
     */
    where?: partymembersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of partymembers to fetch.
     */
    orderBy?: partymembersOrderByWithRelationInput | partymembersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: partymembersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` partymembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` partymembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned partymembers
    **/
    _count?: true | PartymembersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PartymembersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PartymembersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PartymembersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PartymembersMaxAggregateInputType
  }

  export type GetPartymembersAggregateType<T extends PartymembersAggregateArgs> = {
        [P in keyof T & keyof AggregatePartymembers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePartymembers[P]>
      : GetScalarType<T[P], AggregatePartymembers[P]>
  }




  export type partymembersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: partymembersWhereInput
    orderBy?: partymembersOrderByWithAggregationInput | partymembersOrderByWithAggregationInput[]
    by: PartymembersScalarFieldEnum[] | PartymembersScalarFieldEnum
    having?: partymembersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PartymembersCountAggregateInputType | true
    _avg?: PartymembersAvgAggregateInputType
    _sum?: PartymembersSumAggregateInputType
    _min?: PartymembersMinAggregateInputType
    _max?: PartymembersMaxAggregateInputType
  }

  export type PartymembersGroupByOutputType = {
    id: number
    partyid: number | null
    charid: number | null
    name: string | null
    job: number | null
    subJob: number | null
    level: number | null
    channel: number | null
    fieldid: number | null
    loggedin: boolean | null
    _count: PartymembersCountAggregateOutputType | null
    _avg: PartymembersAvgAggregateOutputType | null
    _sum: PartymembersSumAggregateOutputType | null
    _min: PartymembersMinAggregateOutputType | null
    _max: PartymembersMaxAggregateOutputType | null
  }

  type GetPartymembersGroupByPayload<T extends partymembersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PartymembersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PartymembersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PartymembersGroupByOutputType[P]>
            : GetScalarType<T[P], PartymembersGroupByOutputType[P]>
        }
      >
    >


  export type partymembersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    partyid?: boolean
    charid?: boolean
    name?: boolean
    job?: boolean
    subJob?: boolean
    level?: boolean
    channel?: boolean
    fieldid?: boolean
    loggedin?: boolean
  }, ExtArgs["result"]["partymembers"]>


  export type partymembersSelectScalar = {
    id?: boolean
    partyid?: boolean
    charid?: boolean
    name?: boolean
    job?: boolean
    subJob?: boolean
    level?: boolean
    channel?: boolean
    fieldid?: boolean
    loggedin?: boolean
  }


  export type $partymembersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "partymembers"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      partyid: number | null
      charid: number | null
      name: string | null
      job: number | null
      subJob: number | null
      level: number | null
      channel: number | null
      fieldid: number | null
      loggedin: boolean | null
    }, ExtArgs["result"]["partymembers"]>
    composites: {}
  }

  type partymembersGetPayload<S extends boolean | null | undefined | partymembersDefaultArgs> = $Result.GetResult<Prisma.$partymembersPayload, S>

  type partymembersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<partymembersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PartymembersCountAggregateInputType | true
    }

  export interface partymembersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['partymembers'], meta: { name: 'partymembers' } }
    /**
     * Find zero or one Partymembers that matches the filter.
     * @param {partymembersFindUniqueArgs} args - Arguments to find a Partymembers
     * @example
     * // Get one Partymembers
     * const partymembers = await prisma.partymembers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends partymembersFindUniqueArgs>(args: SelectSubset<T, partymembersFindUniqueArgs<ExtArgs>>): Prisma__partymembersClient<$Result.GetResult<Prisma.$partymembersPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Partymembers that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {partymembersFindUniqueOrThrowArgs} args - Arguments to find a Partymembers
     * @example
     * // Get one Partymembers
     * const partymembers = await prisma.partymembers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends partymembersFindUniqueOrThrowArgs>(args: SelectSubset<T, partymembersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__partymembersClient<$Result.GetResult<Prisma.$partymembersPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Partymembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {partymembersFindFirstArgs} args - Arguments to find a Partymembers
     * @example
     * // Get one Partymembers
     * const partymembers = await prisma.partymembers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends partymembersFindFirstArgs>(args?: SelectSubset<T, partymembersFindFirstArgs<ExtArgs>>): Prisma__partymembersClient<$Result.GetResult<Prisma.$partymembersPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Partymembers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {partymembersFindFirstOrThrowArgs} args - Arguments to find a Partymembers
     * @example
     * // Get one Partymembers
     * const partymembers = await prisma.partymembers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends partymembersFindFirstOrThrowArgs>(args?: SelectSubset<T, partymembersFindFirstOrThrowArgs<ExtArgs>>): Prisma__partymembersClient<$Result.GetResult<Prisma.$partymembersPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Partymembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {partymembersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Partymembers
     * const partymembers = await prisma.partymembers.findMany()
     * 
     * // Get first 10 Partymembers
     * const partymembers = await prisma.partymembers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const partymembersWithIdOnly = await prisma.partymembers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends partymembersFindManyArgs>(args?: SelectSubset<T, partymembersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$partymembersPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Partymembers.
     * @param {partymembersCreateArgs} args - Arguments to create a Partymembers.
     * @example
     * // Create one Partymembers
     * const Partymembers = await prisma.partymembers.create({
     *   data: {
     *     // ... data to create a Partymembers
     *   }
     * })
     * 
     */
    create<T extends partymembersCreateArgs>(args: SelectSubset<T, partymembersCreateArgs<ExtArgs>>): Prisma__partymembersClient<$Result.GetResult<Prisma.$partymembersPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Partymembers.
     * @param {partymembersCreateManyArgs} args - Arguments to create many Partymembers.
     * @example
     * // Create many Partymembers
     * const partymembers = await prisma.partymembers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends partymembersCreateManyArgs>(args?: SelectSubset<T, partymembersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Partymembers.
     * @param {partymembersDeleteArgs} args - Arguments to delete one Partymembers.
     * @example
     * // Delete one Partymembers
     * const Partymembers = await prisma.partymembers.delete({
     *   where: {
     *     // ... filter to delete one Partymembers
     *   }
     * })
     * 
     */
    delete<T extends partymembersDeleteArgs>(args: SelectSubset<T, partymembersDeleteArgs<ExtArgs>>): Prisma__partymembersClient<$Result.GetResult<Prisma.$partymembersPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Partymembers.
     * @param {partymembersUpdateArgs} args - Arguments to update one Partymembers.
     * @example
     * // Update one Partymembers
     * const partymembers = await prisma.partymembers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends partymembersUpdateArgs>(args: SelectSubset<T, partymembersUpdateArgs<ExtArgs>>): Prisma__partymembersClient<$Result.GetResult<Prisma.$partymembersPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Partymembers.
     * @param {partymembersDeleteManyArgs} args - Arguments to filter Partymembers to delete.
     * @example
     * // Delete a few Partymembers
     * const { count } = await prisma.partymembers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends partymembersDeleteManyArgs>(args?: SelectSubset<T, partymembersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Partymembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {partymembersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Partymembers
     * const partymembers = await prisma.partymembers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends partymembersUpdateManyArgs>(args: SelectSubset<T, partymembersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Partymembers.
     * @param {partymembersUpsertArgs} args - Arguments to update or create a Partymembers.
     * @example
     * // Update or create a Partymembers
     * const partymembers = await prisma.partymembers.upsert({
     *   create: {
     *     // ... data to create a Partymembers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Partymembers we want to update
     *   }
     * })
     */
    upsert<T extends partymembersUpsertArgs>(args: SelectSubset<T, partymembersUpsertArgs<ExtArgs>>): Prisma__partymembersClient<$Result.GetResult<Prisma.$partymembersPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Partymembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {partymembersCountArgs} args - Arguments to filter Partymembers to count.
     * @example
     * // Count the number of Partymembers
     * const count = await prisma.partymembers.count({
     *   where: {
     *     // ... the filter for the Partymembers we want to count
     *   }
     * })
    **/
    count<T extends partymembersCountArgs>(
      args?: Subset<T, partymembersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PartymembersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Partymembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartymembersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PartymembersAggregateArgs>(args: Subset<T, PartymembersAggregateArgs>): Prisma.PrismaPromise<GetPartymembersAggregateType<T>>

    /**
     * Group by Partymembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {partymembersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends partymembersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: partymembersGroupByArgs['orderBy'] }
        : { orderBy?: partymembersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, partymembersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPartymembersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the partymembers model
   */
  readonly fields: partymembersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for partymembers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__partymembersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the partymembers model
   */ 
  interface partymembersFieldRefs {
    readonly id: FieldRef<"partymembers", 'Int'>
    readonly partyid: FieldRef<"partymembers", 'Int'>
    readonly charid: FieldRef<"partymembers", 'Int'>
    readonly name: FieldRef<"partymembers", 'String'>
    readonly job: FieldRef<"partymembers", 'Int'>
    readonly subJob: FieldRef<"partymembers", 'Int'>
    readonly level: FieldRef<"partymembers", 'Int'>
    readonly channel: FieldRef<"partymembers", 'Int'>
    readonly fieldid: FieldRef<"partymembers", 'Int'>
    readonly loggedin: FieldRef<"partymembers", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * partymembers findUnique
   */
  export type partymembersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the partymembers
     */
    select?: partymembersSelect<ExtArgs> | null
    /**
     * Filter, which partymembers to fetch.
     */
    where: partymembersWhereUniqueInput
  }

  /**
   * partymembers findUniqueOrThrow
   */
  export type partymembersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the partymembers
     */
    select?: partymembersSelect<ExtArgs> | null
    /**
     * Filter, which partymembers to fetch.
     */
    where: partymembersWhereUniqueInput
  }

  /**
   * partymembers findFirst
   */
  export type partymembersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the partymembers
     */
    select?: partymembersSelect<ExtArgs> | null
    /**
     * Filter, which partymembers to fetch.
     */
    where?: partymembersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of partymembers to fetch.
     */
    orderBy?: partymembersOrderByWithRelationInput | partymembersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for partymembers.
     */
    cursor?: partymembersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` partymembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` partymembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of partymembers.
     */
    distinct?: PartymembersScalarFieldEnum | PartymembersScalarFieldEnum[]
  }

  /**
   * partymembers findFirstOrThrow
   */
  export type partymembersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the partymembers
     */
    select?: partymembersSelect<ExtArgs> | null
    /**
     * Filter, which partymembers to fetch.
     */
    where?: partymembersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of partymembers to fetch.
     */
    orderBy?: partymembersOrderByWithRelationInput | partymembersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for partymembers.
     */
    cursor?: partymembersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` partymembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` partymembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of partymembers.
     */
    distinct?: PartymembersScalarFieldEnum | PartymembersScalarFieldEnum[]
  }

  /**
   * partymembers findMany
   */
  export type partymembersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the partymembers
     */
    select?: partymembersSelect<ExtArgs> | null
    /**
     * Filter, which partymembers to fetch.
     */
    where?: partymembersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of partymembers to fetch.
     */
    orderBy?: partymembersOrderByWithRelationInput | partymembersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing partymembers.
     */
    cursor?: partymembersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` partymembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` partymembers.
     */
    skip?: number
    distinct?: PartymembersScalarFieldEnum | PartymembersScalarFieldEnum[]
  }

  /**
   * partymembers create
   */
  export type partymembersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the partymembers
     */
    select?: partymembersSelect<ExtArgs> | null
    /**
     * The data needed to create a partymembers.
     */
    data?: XOR<partymembersCreateInput, partymembersUncheckedCreateInput>
  }

  /**
   * partymembers createMany
   */
  export type partymembersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many partymembers.
     */
    data: partymembersCreateManyInput | partymembersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * partymembers update
   */
  export type partymembersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the partymembers
     */
    select?: partymembersSelect<ExtArgs> | null
    /**
     * The data needed to update a partymembers.
     */
    data: XOR<partymembersUpdateInput, partymembersUncheckedUpdateInput>
    /**
     * Choose, which partymembers to update.
     */
    where: partymembersWhereUniqueInput
  }

  /**
   * partymembers updateMany
   */
  export type partymembersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update partymembers.
     */
    data: XOR<partymembersUpdateManyMutationInput, partymembersUncheckedUpdateManyInput>
    /**
     * Filter which partymembers to update
     */
    where?: partymembersWhereInput
  }

  /**
   * partymembers upsert
   */
  export type partymembersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the partymembers
     */
    select?: partymembersSelect<ExtArgs> | null
    /**
     * The filter to search for the partymembers to update in case it exists.
     */
    where: partymembersWhereUniqueInput
    /**
     * In case the partymembers found by the `where` argument doesn't exist, create a new partymembers with this data.
     */
    create: XOR<partymembersCreateInput, partymembersUncheckedCreateInput>
    /**
     * In case the partymembers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<partymembersUpdateInput, partymembersUncheckedUpdateInput>
  }

  /**
   * partymembers delete
   */
  export type partymembersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the partymembers
     */
    select?: partymembersSelect<ExtArgs> | null
    /**
     * Filter which partymembers to delete.
     */
    where: partymembersWhereUniqueInput
  }

  /**
   * partymembers deleteMany
   */
  export type partymembersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which partymembers to delete
     */
    where?: partymembersWhereInput
  }

  /**
   * partymembers without action
   */
  export type partymembersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the partymembers
     */
    select?: partymembersSelect<ExtArgs> | null
  }


  /**
   * Model petids
   */

  export type AggregatePetids = {
    _count: PetidsCountAggregateOutputType | null
    _avg: PetidsAvgAggregateOutputType | null
    _sum: PetidsSumAggregateOutputType | null
    _min: PetidsMinAggregateOutputType | null
    _max: PetidsMaxAggregateOutputType | null
  }

  export type PetidsAvgAggregateOutputType = {
    id: number | null
    alid: number | null
    petid: number | null
  }

  export type PetidsSumAggregateOutputType = {
    id: number | null
    alid: number | null
    petid: number | null
  }

  export type PetidsMinAggregateOutputType = {
    id: number | null
    alid: number | null
    petid: number | null
  }

  export type PetidsMaxAggregateOutputType = {
    id: number | null
    alid: number | null
    petid: number | null
  }

  export type PetidsCountAggregateOutputType = {
    id: number
    alid: number
    petid: number
    _all: number
  }


  export type PetidsAvgAggregateInputType = {
    id?: true
    alid?: true
    petid?: true
  }

  export type PetidsSumAggregateInputType = {
    id?: true
    alid?: true
    petid?: true
  }

  export type PetidsMinAggregateInputType = {
    id?: true
    alid?: true
    petid?: true
  }

  export type PetidsMaxAggregateInputType = {
    id?: true
    alid?: true
    petid?: true
  }

  export type PetidsCountAggregateInputType = {
    id?: true
    alid?: true
    petid?: true
    _all?: true
  }

  export type PetidsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which petids to aggregate.
     */
    where?: petidsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of petids to fetch.
     */
    orderBy?: petidsOrderByWithRelationInput | petidsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: petidsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` petids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` petids.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned petids
    **/
    _count?: true | PetidsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PetidsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PetidsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PetidsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PetidsMaxAggregateInputType
  }

  export type GetPetidsAggregateType<T extends PetidsAggregateArgs> = {
        [P in keyof T & keyof AggregatePetids]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePetids[P]>
      : GetScalarType<T[P], AggregatePetids[P]>
  }




  export type petidsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: petidsWhereInput
    orderBy?: petidsOrderByWithAggregationInput | petidsOrderByWithAggregationInput[]
    by: PetidsScalarFieldEnum[] | PetidsScalarFieldEnum
    having?: petidsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PetidsCountAggregateInputType | true
    _avg?: PetidsAvgAggregateInputType
    _sum?: PetidsSumAggregateInputType
    _min?: PetidsMinAggregateInputType
    _max?: PetidsMaxAggregateInputType
  }

  export type PetidsGroupByOutputType = {
    id: number
    alid: number | null
    petid: number | null
    _count: PetidsCountAggregateOutputType | null
    _avg: PetidsAvgAggregateOutputType | null
    _sum: PetidsSumAggregateOutputType | null
    _min: PetidsMinAggregateOutputType | null
    _max: PetidsMaxAggregateOutputType | null
  }

  type GetPetidsGroupByPayload<T extends petidsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PetidsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PetidsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PetidsGroupByOutputType[P]>
            : GetScalarType<T[P], PetidsGroupByOutputType[P]>
        }
      >
    >


  export type petidsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    alid?: boolean
    petid?: boolean
  }, ExtArgs["result"]["petids"]>


  export type petidsSelectScalar = {
    id?: boolean
    alid?: boolean
    petid?: boolean
  }


  export type $petidsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "petids"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      alid: number | null
      petid: number | null
    }, ExtArgs["result"]["petids"]>
    composites: {}
  }

  type petidsGetPayload<S extends boolean | null | undefined | petidsDefaultArgs> = $Result.GetResult<Prisma.$petidsPayload, S>

  type petidsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<petidsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PetidsCountAggregateInputType | true
    }

  export interface petidsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['petids'], meta: { name: 'petids' } }
    /**
     * Find zero or one Petids that matches the filter.
     * @param {petidsFindUniqueArgs} args - Arguments to find a Petids
     * @example
     * // Get one Petids
     * const petids = await prisma.petids.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends petidsFindUniqueArgs>(args: SelectSubset<T, petidsFindUniqueArgs<ExtArgs>>): Prisma__petidsClient<$Result.GetResult<Prisma.$petidsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Petids that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {petidsFindUniqueOrThrowArgs} args - Arguments to find a Petids
     * @example
     * // Get one Petids
     * const petids = await prisma.petids.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends petidsFindUniqueOrThrowArgs>(args: SelectSubset<T, petidsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__petidsClient<$Result.GetResult<Prisma.$petidsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Petids that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {petidsFindFirstArgs} args - Arguments to find a Petids
     * @example
     * // Get one Petids
     * const petids = await prisma.petids.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends petidsFindFirstArgs>(args?: SelectSubset<T, petidsFindFirstArgs<ExtArgs>>): Prisma__petidsClient<$Result.GetResult<Prisma.$petidsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Petids that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {petidsFindFirstOrThrowArgs} args - Arguments to find a Petids
     * @example
     * // Get one Petids
     * const petids = await prisma.petids.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends petidsFindFirstOrThrowArgs>(args?: SelectSubset<T, petidsFindFirstOrThrowArgs<ExtArgs>>): Prisma__petidsClient<$Result.GetResult<Prisma.$petidsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Petids that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {petidsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Petids
     * const petids = await prisma.petids.findMany()
     * 
     * // Get first 10 Petids
     * const petids = await prisma.petids.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const petidsWithIdOnly = await prisma.petids.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends petidsFindManyArgs>(args?: SelectSubset<T, petidsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$petidsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Petids.
     * @param {petidsCreateArgs} args - Arguments to create a Petids.
     * @example
     * // Create one Petids
     * const Petids = await prisma.petids.create({
     *   data: {
     *     // ... data to create a Petids
     *   }
     * })
     * 
     */
    create<T extends petidsCreateArgs>(args: SelectSubset<T, petidsCreateArgs<ExtArgs>>): Prisma__petidsClient<$Result.GetResult<Prisma.$petidsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Petids.
     * @param {petidsCreateManyArgs} args - Arguments to create many Petids.
     * @example
     * // Create many Petids
     * const petids = await prisma.petids.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends petidsCreateManyArgs>(args?: SelectSubset<T, petidsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Petids.
     * @param {petidsDeleteArgs} args - Arguments to delete one Petids.
     * @example
     * // Delete one Petids
     * const Petids = await prisma.petids.delete({
     *   where: {
     *     // ... filter to delete one Petids
     *   }
     * })
     * 
     */
    delete<T extends petidsDeleteArgs>(args: SelectSubset<T, petidsDeleteArgs<ExtArgs>>): Prisma__petidsClient<$Result.GetResult<Prisma.$petidsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Petids.
     * @param {petidsUpdateArgs} args - Arguments to update one Petids.
     * @example
     * // Update one Petids
     * const petids = await prisma.petids.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends petidsUpdateArgs>(args: SelectSubset<T, petidsUpdateArgs<ExtArgs>>): Prisma__petidsClient<$Result.GetResult<Prisma.$petidsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Petids.
     * @param {petidsDeleteManyArgs} args - Arguments to filter Petids to delete.
     * @example
     * // Delete a few Petids
     * const { count } = await prisma.petids.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends petidsDeleteManyArgs>(args?: SelectSubset<T, petidsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Petids.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {petidsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Petids
     * const petids = await prisma.petids.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends petidsUpdateManyArgs>(args: SelectSubset<T, petidsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Petids.
     * @param {petidsUpsertArgs} args - Arguments to update or create a Petids.
     * @example
     * // Update or create a Petids
     * const petids = await prisma.petids.upsert({
     *   create: {
     *     // ... data to create a Petids
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Petids we want to update
     *   }
     * })
     */
    upsert<T extends petidsUpsertArgs>(args: SelectSubset<T, petidsUpsertArgs<ExtArgs>>): Prisma__petidsClient<$Result.GetResult<Prisma.$petidsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Petids.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {petidsCountArgs} args - Arguments to filter Petids to count.
     * @example
     * // Count the number of Petids
     * const count = await prisma.petids.count({
     *   where: {
     *     // ... the filter for the Petids we want to count
     *   }
     * })
    **/
    count<T extends petidsCountArgs>(
      args?: Subset<T, petidsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PetidsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Petids.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetidsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PetidsAggregateArgs>(args: Subset<T, PetidsAggregateArgs>): Prisma.PrismaPromise<GetPetidsAggregateType<T>>

    /**
     * Group by Petids.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {petidsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends petidsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: petidsGroupByArgs['orderBy'] }
        : { orderBy?: petidsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, petidsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPetidsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the petids model
   */
  readonly fields: petidsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for petids.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__petidsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the petids model
   */ 
  interface petidsFieldRefs {
    readonly id: FieldRef<"petids", 'Int'>
    readonly alid: FieldRef<"petids", 'Int'>
    readonly petid: FieldRef<"petids", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * petids findUnique
   */
  export type petidsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the petids
     */
    select?: petidsSelect<ExtArgs> | null
    /**
     * Filter, which petids to fetch.
     */
    where: petidsWhereUniqueInput
  }

  /**
   * petids findUniqueOrThrow
   */
  export type petidsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the petids
     */
    select?: petidsSelect<ExtArgs> | null
    /**
     * Filter, which petids to fetch.
     */
    where: petidsWhereUniqueInput
  }

  /**
   * petids findFirst
   */
  export type petidsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the petids
     */
    select?: petidsSelect<ExtArgs> | null
    /**
     * Filter, which petids to fetch.
     */
    where?: petidsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of petids to fetch.
     */
    orderBy?: petidsOrderByWithRelationInput | petidsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for petids.
     */
    cursor?: petidsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` petids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` petids.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of petids.
     */
    distinct?: PetidsScalarFieldEnum | PetidsScalarFieldEnum[]
  }

  /**
   * petids findFirstOrThrow
   */
  export type petidsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the petids
     */
    select?: petidsSelect<ExtArgs> | null
    /**
     * Filter, which petids to fetch.
     */
    where?: petidsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of petids to fetch.
     */
    orderBy?: petidsOrderByWithRelationInput | petidsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for petids.
     */
    cursor?: petidsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` petids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` petids.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of petids.
     */
    distinct?: PetidsScalarFieldEnum | PetidsScalarFieldEnum[]
  }

  /**
   * petids findMany
   */
  export type petidsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the petids
     */
    select?: petidsSelect<ExtArgs> | null
    /**
     * Filter, which petids to fetch.
     */
    where?: petidsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of petids to fetch.
     */
    orderBy?: petidsOrderByWithRelationInput | petidsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing petids.
     */
    cursor?: petidsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` petids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` petids.
     */
    skip?: number
    distinct?: PetidsScalarFieldEnum | PetidsScalarFieldEnum[]
  }

  /**
   * petids create
   */
  export type petidsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the petids
     */
    select?: petidsSelect<ExtArgs> | null
    /**
     * The data needed to create a petids.
     */
    data?: XOR<petidsCreateInput, petidsUncheckedCreateInput>
  }

  /**
   * petids createMany
   */
  export type petidsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many petids.
     */
    data: petidsCreateManyInput | petidsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * petids update
   */
  export type petidsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the petids
     */
    select?: petidsSelect<ExtArgs> | null
    /**
     * The data needed to update a petids.
     */
    data: XOR<petidsUpdateInput, petidsUncheckedUpdateInput>
    /**
     * Choose, which petids to update.
     */
    where: petidsWhereUniqueInput
  }

  /**
   * petids updateMany
   */
  export type petidsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update petids.
     */
    data: XOR<petidsUpdateManyMutationInput, petidsUncheckedUpdateManyInput>
    /**
     * Filter which petids to update
     */
    where?: petidsWhereInput
  }

  /**
   * petids upsert
   */
  export type petidsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the petids
     */
    select?: petidsSelect<ExtArgs> | null
    /**
     * The filter to search for the petids to update in case it exists.
     */
    where: petidsWhereUniqueInput
    /**
     * In case the petids found by the `where` argument doesn't exist, create a new petids with this data.
     */
    create: XOR<petidsCreateInput, petidsUncheckedCreateInput>
    /**
     * In case the petids was found with the provided `where` argument, update it with this data.
     */
    update: XOR<petidsUpdateInput, petidsUncheckedUpdateInput>
  }

  /**
   * petids delete
   */
  export type petidsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the petids
     */
    select?: petidsSelect<ExtArgs> | null
    /**
     * Filter which petids to delete.
     */
    where: petidsWhereUniqueInput
  }

  /**
   * petids deleteMany
   */
  export type petidsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which petids to delete
     */
    where?: petidsWhereInput
  }

  /**
   * petids without action
   */
  export type petidsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the petids
     */
    select?: petidsSelect<ExtArgs> | null
  }


  /**
   * Model petitems
   */

  export type AggregatePetitems = {
    _count: PetitemsCountAggregateOutputType | null
    _avg: PetitemsAvgAggregateOutputType | null
    _sum: PetitemsSumAggregateOutputType | null
    _min: PetitemsMinAggregateOutputType | null
    _max: PetitemsMaxAggregateOutputType | null
  }

  export type PetitemsAvgAggregateOutputType = {
    itemid: number | null
    level: number | null
    tameness: number | null
    repleteness: number | null
    petattribute: number | null
    petskill: number | null
    remainlife: number | null
    attribute: number | null
    activestate: number | null
    autobuffskill: number | null
    pethue: number | null
    giantrate: number | null
  }

  export type PetitemsSumAggregateOutputType = {
    itemid: bigint | null
    level: number | null
    tameness: number | null
    repleteness: number | null
    petattribute: number | null
    petskill: number | null
    remainlife: number | null
    attribute: number | null
    activestate: number | null
    autobuffskill: number | null
    pethue: number | null
    giantrate: number | null
  }

  export type PetitemsMinAggregateOutputType = {
    itemid: bigint | null
    name: string | null
    level: number | null
    tameness: number | null
    repleteness: number | null
    petattribute: number | null
    petskill: number | null
    datedead: Date | null
    remainlife: number | null
    attribute: number | null
    activestate: number | null
    autobuffskill: number | null
    pethue: number | null
    giantrate: number | null
    exceptionList: string | null
  }

  export type PetitemsMaxAggregateOutputType = {
    itemid: bigint | null
    name: string | null
    level: number | null
    tameness: number | null
    repleteness: number | null
    petattribute: number | null
    petskill: number | null
    datedead: Date | null
    remainlife: number | null
    attribute: number | null
    activestate: number | null
    autobuffskill: number | null
    pethue: number | null
    giantrate: number | null
    exceptionList: string | null
  }

  export type PetitemsCountAggregateOutputType = {
    itemid: number
    name: number
    level: number
    tameness: number
    repleteness: number
    petattribute: number
    petskill: number
    datedead: number
    remainlife: number
    attribute: number
    activestate: number
    autobuffskill: number
    pethue: number
    giantrate: number
    exceptionList: number
    _all: number
  }


  export type PetitemsAvgAggregateInputType = {
    itemid?: true
    level?: true
    tameness?: true
    repleteness?: true
    petattribute?: true
    petskill?: true
    remainlife?: true
    attribute?: true
    activestate?: true
    autobuffskill?: true
    pethue?: true
    giantrate?: true
  }

  export type PetitemsSumAggregateInputType = {
    itemid?: true
    level?: true
    tameness?: true
    repleteness?: true
    petattribute?: true
    petskill?: true
    remainlife?: true
    attribute?: true
    activestate?: true
    autobuffskill?: true
    pethue?: true
    giantrate?: true
  }

  export type PetitemsMinAggregateInputType = {
    itemid?: true
    name?: true
    level?: true
    tameness?: true
    repleteness?: true
    petattribute?: true
    petskill?: true
    datedead?: true
    remainlife?: true
    attribute?: true
    activestate?: true
    autobuffskill?: true
    pethue?: true
    giantrate?: true
    exceptionList?: true
  }

  export type PetitemsMaxAggregateInputType = {
    itemid?: true
    name?: true
    level?: true
    tameness?: true
    repleteness?: true
    petattribute?: true
    petskill?: true
    datedead?: true
    remainlife?: true
    attribute?: true
    activestate?: true
    autobuffskill?: true
    pethue?: true
    giantrate?: true
    exceptionList?: true
  }

  export type PetitemsCountAggregateInputType = {
    itemid?: true
    name?: true
    level?: true
    tameness?: true
    repleteness?: true
    petattribute?: true
    petskill?: true
    datedead?: true
    remainlife?: true
    attribute?: true
    activestate?: true
    autobuffskill?: true
    pethue?: true
    giantrate?: true
    exceptionList?: true
    _all?: true
  }

  export type PetitemsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which petitems to aggregate.
     */
    where?: petitemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of petitems to fetch.
     */
    orderBy?: petitemsOrderByWithRelationInput | petitemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: petitemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` petitems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` petitems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned petitems
    **/
    _count?: true | PetitemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PetitemsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PetitemsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PetitemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PetitemsMaxAggregateInputType
  }

  export type GetPetitemsAggregateType<T extends PetitemsAggregateArgs> = {
        [P in keyof T & keyof AggregatePetitems]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePetitems[P]>
      : GetScalarType<T[P], AggregatePetitems[P]>
  }




  export type petitemsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: petitemsWhereInput
    orderBy?: petitemsOrderByWithAggregationInput | petitemsOrderByWithAggregationInput[]
    by: PetitemsScalarFieldEnum[] | PetitemsScalarFieldEnum
    having?: petitemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PetitemsCountAggregateInputType | true
    _avg?: PetitemsAvgAggregateInputType
    _sum?: PetitemsSumAggregateInputType
    _min?: PetitemsMinAggregateInputType
    _max?: PetitemsMaxAggregateInputType
  }

  export type PetitemsGroupByOutputType = {
    itemid: bigint
    name: string | null
    level: number | null
    tameness: number | null
    repleteness: number | null
    petattribute: number | null
    petskill: number | null
    datedead: Date | null
    remainlife: number | null
    attribute: number | null
    activestate: number | null
    autobuffskill: number | null
    pethue: number | null
    giantrate: number | null
    exceptionList: string | null
    _count: PetitemsCountAggregateOutputType | null
    _avg: PetitemsAvgAggregateOutputType | null
    _sum: PetitemsSumAggregateOutputType | null
    _min: PetitemsMinAggregateOutputType | null
    _max: PetitemsMaxAggregateOutputType | null
  }

  type GetPetitemsGroupByPayload<T extends petitemsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PetitemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PetitemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PetitemsGroupByOutputType[P]>
            : GetScalarType<T[P], PetitemsGroupByOutputType[P]>
        }
      >
    >


  export type petitemsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    itemid?: boolean
    name?: boolean
    level?: boolean
    tameness?: boolean
    repleteness?: boolean
    petattribute?: boolean
    petskill?: boolean
    datedead?: boolean
    remainlife?: boolean
    attribute?: boolean
    activestate?: boolean
    autobuffskill?: boolean
    pethue?: boolean
    giantrate?: boolean
    exceptionList?: boolean
  }, ExtArgs["result"]["petitems"]>


  export type petitemsSelectScalar = {
    itemid?: boolean
    name?: boolean
    level?: boolean
    tameness?: boolean
    repleteness?: boolean
    petattribute?: boolean
    petskill?: boolean
    datedead?: boolean
    remainlife?: boolean
    attribute?: boolean
    activestate?: boolean
    autobuffskill?: boolean
    pethue?: boolean
    giantrate?: boolean
    exceptionList?: boolean
  }


  export type $petitemsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "petitems"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      itemid: bigint
      name: string | null
      level: number | null
      tameness: number | null
      repleteness: number | null
      petattribute: number | null
      petskill: number | null
      datedead: Date | null
      remainlife: number | null
      attribute: number | null
      activestate: number | null
      autobuffskill: number | null
      pethue: number | null
      giantrate: number | null
      exceptionList: string | null
    }, ExtArgs["result"]["petitems"]>
    composites: {}
  }

  type petitemsGetPayload<S extends boolean | null | undefined | petitemsDefaultArgs> = $Result.GetResult<Prisma.$petitemsPayload, S>

  type petitemsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<petitemsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PetitemsCountAggregateInputType | true
    }

  export interface petitemsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['petitems'], meta: { name: 'petitems' } }
    /**
     * Find zero or one Petitems that matches the filter.
     * @param {petitemsFindUniqueArgs} args - Arguments to find a Petitems
     * @example
     * // Get one Petitems
     * const petitems = await prisma.petitems.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends petitemsFindUniqueArgs>(args: SelectSubset<T, petitemsFindUniqueArgs<ExtArgs>>): Prisma__petitemsClient<$Result.GetResult<Prisma.$petitemsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Petitems that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {petitemsFindUniqueOrThrowArgs} args - Arguments to find a Petitems
     * @example
     * // Get one Petitems
     * const petitems = await prisma.petitems.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends petitemsFindUniqueOrThrowArgs>(args: SelectSubset<T, petitemsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__petitemsClient<$Result.GetResult<Prisma.$petitemsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Petitems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {petitemsFindFirstArgs} args - Arguments to find a Petitems
     * @example
     * // Get one Petitems
     * const petitems = await prisma.petitems.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends petitemsFindFirstArgs>(args?: SelectSubset<T, petitemsFindFirstArgs<ExtArgs>>): Prisma__petitemsClient<$Result.GetResult<Prisma.$petitemsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Petitems that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {petitemsFindFirstOrThrowArgs} args - Arguments to find a Petitems
     * @example
     * // Get one Petitems
     * const petitems = await prisma.petitems.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends petitemsFindFirstOrThrowArgs>(args?: SelectSubset<T, petitemsFindFirstOrThrowArgs<ExtArgs>>): Prisma__petitemsClient<$Result.GetResult<Prisma.$petitemsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Petitems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {petitemsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Petitems
     * const petitems = await prisma.petitems.findMany()
     * 
     * // Get first 10 Petitems
     * const petitems = await prisma.petitems.findMany({ take: 10 })
     * 
     * // Only select the `itemid`
     * const petitemsWithItemidOnly = await prisma.petitems.findMany({ select: { itemid: true } })
     * 
     */
    findMany<T extends petitemsFindManyArgs>(args?: SelectSubset<T, petitemsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$petitemsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Petitems.
     * @param {petitemsCreateArgs} args - Arguments to create a Petitems.
     * @example
     * // Create one Petitems
     * const Petitems = await prisma.petitems.create({
     *   data: {
     *     // ... data to create a Petitems
     *   }
     * })
     * 
     */
    create<T extends petitemsCreateArgs>(args: SelectSubset<T, petitemsCreateArgs<ExtArgs>>): Prisma__petitemsClient<$Result.GetResult<Prisma.$petitemsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Petitems.
     * @param {petitemsCreateManyArgs} args - Arguments to create many Petitems.
     * @example
     * // Create many Petitems
     * const petitems = await prisma.petitems.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends petitemsCreateManyArgs>(args?: SelectSubset<T, petitemsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Petitems.
     * @param {petitemsDeleteArgs} args - Arguments to delete one Petitems.
     * @example
     * // Delete one Petitems
     * const Petitems = await prisma.petitems.delete({
     *   where: {
     *     // ... filter to delete one Petitems
     *   }
     * })
     * 
     */
    delete<T extends petitemsDeleteArgs>(args: SelectSubset<T, petitemsDeleteArgs<ExtArgs>>): Prisma__petitemsClient<$Result.GetResult<Prisma.$petitemsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Petitems.
     * @param {petitemsUpdateArgs} args - Arguments to update one Petitems.
     * @example
     * // Update one Petitems
     * const petitems = await prisma.petitems.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends petitemsUpdateArgs>(args: SelectSubset<T, petitemsUpdateArgs<ExtArgs>>): Prisma__petitemsClient<$Result.GetResult<Prisma.$petitemsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Petitems.
     * @param {petitemsDeleteManyArgs} args - Arguments to filter Petitems to delete.
     * @example
     * // Delete a few Petitems
     * const { count } = await prisma.petitems.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends petitemsDeleteManyArgs>(args?: SelectSubset<T, petitemsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Petitems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {petitemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Petitems
     * const petitems = await prisma.petitems.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends petitemsUpdateManyArgs>(args: SelectSubset<T, petitemsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Petitems.
     * @param {petitemsUpsertArgs} args - Arguments to update or create a Petitems.
     * @example
     * // Update or create a Petitems
     * const petitems = await prisma.petitems.upsert({
     *   create: {
     *     // ... data to create a Petitems
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Petitems we want to update
     *   }
     * })
     */
    upsert<T extends petitemsUpsertArgs>(args: SelectSubset<T, petitemsUpsertArgs<ExtArgs>>): Prisma__petitemsClient<$Result.GetResult<Prisma.$petitemsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Petitems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {petitemsCountArgs} args - Arguments to filter Petitems to count.
     * @example
     * // Count the number of Petitems
     * const count = await prisma.petitems.count({
     *   where: {
     *     // ... the filter for the Petitems we want to count
     *   }
     * })
    **/
    count<T extends petitemsCountArgs>(
      args?: Subset<T, petitemsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PetitemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Petitems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetitemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PetitemsAggregateArgs>(args: Subset<T, PetitemsAggregateArgs>): Prisma.PrismaPromise<GetPetitemsAggregateType<T>>

    /**
     * Group by Petitems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {petitemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends petitemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: petitemsGroupByArgs['orderBy'] }
        : { orderBy?: petitemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, petitemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPetitemsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the petitems model
   */
  readonly fields: petitemsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for petitems.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__petitemsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the petitems model
   */ 
  interface petitemsFieldRefs {
    readonly itemid: FieldRef<"petitems", 'BigInt'>
    readonly name: FieldRef<"petitems", 'String'>
    readonly level: FieldRef<"petitems", 'Int'>
    readonly tameness: FieldRef<"petitems", 'Int'>
    readonly repleteness: FieldRef<"petitems", 'Int'>
    readonly petattribute: FieldRef<"petitems", 'Int'>
    readonly petskill: FieldRef<"petitems", 'Int'>
    readonly datedead: FieldRef<"petitems", 'DateTime'>
    readonly remainlife: FieldRef<"petitems", 'Int'>
    readonly attribute: FieldRef<"petitems", 'Int'>
    readonly activestate: FieldRef<"petitems", 'Int'>
    readonly autobuffskill: FieldRef<"petitems", 'Int'>
    readonly pethue: FieldRef<"petitems", 'Int'>
    readonly giantrate: FieldRef<"petitems", 'Int'>
    readonly exceptionList: FieldRef<"petitems", 'String'>
  }
    

  // Custom InputTypes
  /**
   * petitems findUnique
   */
  export type petitemsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the petitems
     */
    select?: petitemsSelect<ExtArgs> | null
    /**
     * Filter, which petitems to fetch.
     */
    where: petitemsWhereUniqueInput
  }

  /**
   * petitems findUniqueOrThrow
   */
  export type petitemsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the petitems
     */
    select?: petitemsSelect<ExtArgs> | null
    /**
     * Filter, which petitems to fetch.
     */
    where: petitemsWhereUniqueInput
  }

  /**
   * petitems findFirst
   */
  export type petitemsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the petitems
     */
    select?: petitemsSelect<ExtArgs> | null
    /**
     * Filter, which petitems to fetch.
     */
    where?: petitemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of petitems to fetch.
     */
    orderBy?: petitemsOrderByWithRelationInput | petitemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for petitems.
     */
    cursor?: petitemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` petitems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` petitems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of petitems.
     */
    distinct?: PetitemsScalarFieldEnum | PetitemsScalarFieldEnum[]
  }

  /**
   * petitems findFirstOrThrow
   */
  export type petitemsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the petitems
     */
    select?: petitemsSelect<ExtArgs> | null
    /**
     * Filter, which petitems to fetch.
     */
    where?: petitemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of petitems to fetch.
     */
    orderBy?: petitemsOrderByWithRelationInput | petitemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for petitems.
     */
    cursor?: petitemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` petitems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` petitems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of petitems.
     */
    distinct?: PetitemsScalarFieldEnum | PetitemsScalarFieldEnum[]
  }

  /**
   * petitems findMany
   */
  export type petitemsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the petitems
     */
    select?: petitemsSelect<ExtArgs> | null
    /**
     * Filter, which petitems to fetch.
     */
    where?: petitemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of petitems to fetch.
     */
    orderBy?: petitemsOrderByWithRelationInput | petitemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing petitems.
     */
    cursor?: petitemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` petitems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` petitems.
     */
    skip?: number
    distinct?: PetitemsScalarFieldEnum | PetitemsScalarFieldEnum[]
  }

  /**
   * petitems create
   */
  export type petitemsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the petitems
     */
    select?: petitemsSelect<ExtArgs> | null
    /**
     * The data needed to create a petitems.
     */
    data: XOR<petitemsCreateInput, petitemsUncheckedCreateInput>
  }

  /**
   * petitems createMany
   */
  export type petitemsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many petitems.
     */
    data: petitemsCreateManyInput | petitemsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * petitems update
   */
  export type petitemsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the petitems
     */
    select?: petitemsSelect<ExtArgs> | null
    /**
     * The data needed to update a petitems.
     */
    data: XOR<petitemsUpdateInput, petitemsUncheckedUpdateInput>
    /**
     * Choose, which petitems to update.
     */
    where: petitemsWhereUniqueInput
  }

  /**
   * petitems updateMany
   */
  export type petitemsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update petitems.
     */
    data: XOR<petitemsUpdateManyMutationInput, petitemsUncheckedUpdateManyInput>
    /**
     * Filter which petitems to update
     */
    where?: petitemsWhereInput
  }

  /**
   * petitems upsert
   */
  export type petitemsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the petitems
     */
    select?: petitemsSelect<ExtArgs> | null
    /**
     * The filter to search for the petitems to update in case it exists.
     */
    where: petitemsWhereUniqueInput
    /**
     * In case the petitems found by the `where` argument doesn't exist, create a new petitems with this data.
     */
    create: XOR<petitemsCreateInput, petitemsUncheckedCreateInput>
    /**
     * In case the petitems was found with the provided `where` argument, update it with this data.
     */
    update: XOR<petitemsUpdateInput, petitemsUncheckedUpdateInput>
  }

  /**
   * petitems delete
   */
  export type petitemsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the petitems
     */
    select?: petitemsSelect<ExtArgs> | null
    /**
     * Filter which petitems to delete.
     */
    where: petitemsWhereUniqueInput
  }

  /**
   * petitems deleteMany
   */
  export type petitemsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which petitems to delete
     */
    where?: petitemsWhereInput
  }

  /**
   * petitems without action
   */
  export type petitemsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the petitems
     */
    select?: petitemsSelect<ExtArgs> | null
  }


  /**
   * Model questlists
   */

  export type AggregateQuestlists = {
    _count: QuestlistsCountAggregateOutputType | null
    _avg: QuestlistsAvgAggregateOutputType | null
    _sum: QuestlistsSumAggregateOutputType | null
    _min: QuestlistsMinAggregateOutputType | null
    _max: QuestlistsMaxAggregateOutputType | null
  }

  export type QuestlistsAvgAggregateOutputType = {
    questlist_id: number | null
    questmanager_id: number | null
    questid: number | null
    fk_questid: number | null
  }

  export type QuestlistsSumAggregateOutputType = {
    questlist_id: bigint | null
    questmanager_id: bigint | null
    questid: number | null
    fk_questid: bigint | null
  }

  export type QuestlistsMinAggregateOutputType = {
    questlist_id: bigint | null
    questmanager_id: bigint | null
    questid: number | null
    fk_questid: bigint | null
  }

  export type QuestlistsMaxAggregateOutputType = {
    questlist_id: bigint | null
    questmanager_id: bigint | null
    questid: number | null
    fk_questid: bigint | null
  }

  export type QuestlistsCountAggregateOutputType = {
    questlist_id: number
    questmanager_id: number
    questid: number
    fk_questid: number
    _all: number
  }


  export type QuestlistsAvgAggregateInputType = {
    questlist_id?: true
    questmanager_id?: true
    questid?: true
    fk_questid?: true
  }

  export type QuestlistsSumAggregateInputType = {
    questlist_id?: true
    questmanager_id?: true
    questid?: true
    fk_questid?: true
  }

  export type QuestlistsMinAggregateInputType = {
    questlist_id?: true
    questmanager_id?: true
    questid?: true
    fk_questid?: true
  }

  export type QuestlistsMaxAggregateInputType = {
    questlist_id?: true
    questmanager_id?: true
    questid?: true
    fk_questid?: true
  }

  export type QuestlistsCountAggregateInputType = {
    questlist_id?: true
    questmanager_id?: true
    questid?: true
    fk_questid?: true
    _all?: true
  }

  export type QuestlistsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which questlists to aggregate.
     */
    where?: questlistsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questlists to fetch.
     */
    orderBy?: questlistsOrderByWithRelationInput | questlistsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: questlistsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questlists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned questlists
    **/
    _count?: true | QuestlistsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuestlistsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuestlistsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestlistsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestlistsMaxAggregateInputType
  }

  export type GetQuestlistsAggregateType<T extends QuestlistsAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestlists]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestlists[P]>
      : GetScalarType<T[P], AggregateQuestlists[P]>
  }




  export type questlistsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: questlistsWhereInput
    orderBy?: questlistsOrderByWithAggregationInput | questlistsOrderByWithAggregationInput[]
    by: QuestlistsScalarFieldEnum[] | QuestlistsScalarFieldEnum
    having?: questlistsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestlistsCountAggregateInputType | true
    _avg?: QuestlistsAvgAggregateInputType
    _sum?: QuestlistsSumAggregateInputType
    _min?: QuestlistsMinAggregateInputType
    _max?: QuestlistsMaxAggregateInputType
  }

  export type QuestlistsGroupByOutputType = {
    questlist_id: bigint
    questmanager_id: bigint | null
    questid: number | null
    fk_questid: bigint | null
    _count: QuestlistsCountAggregateOutputType | null
    _avg: QuestlistsAvgAggregateOutputType | null
    _sum: QuestlistsSumAggregateOutputType | null
    _min: QuestlistsMinAggregateOutputType | null
    _max: QuestlistsMaxAggregateOutputType | null
  }

  type GetQuestlistsGroupByPayload<T extends questlistsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestlistsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestlistsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestlistsGroupByOutputType[P]>
            : GetScalarType<T[P], QuestlistsGroupByOutputType[P]>
        }
      >
    >


  export type questlistsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    questlist_id?: boolean
    questmanager_id?: boolean
    questid?: boolean
    fk_questid?: boolean
  }, ExtArgs["result"]["questlists"]>


  export type questlistsSelectScalar = {
    questlist_id?: boolean
    questmanager_id?: boolean
    questid?: boolean
    fk_questid?: boolean
  }


  export type $questlistsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "questlists"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      questlist_id: bigint
      questmanager_id: bigint | null
      questid: number | null
      fk_questid: bigint | null
    }, ExtArgs["result"]["questlists"]>
    composites: {}
  }

  type questlistsGetPayload<S extends boolean | null | undefined | questlistsDefaultArgs> = $Result.GetResult<Prisma.$questlistsPayload, S>

  type questlistsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<questlistsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QuestlistsCountAggregateInputType | true
    }

  export interface questlistsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['questlists'], meta: { name: 'questlists' } }
    /**
     * Find zero or one Questlists that matches the filter.
     * @param {questlistsFindUniqueArgs} args - Arguments to find a Questlists
     * @example
     * // Get one Questlists
     * const questlists = await prisma.questlists.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends questlistsFindUniqueArgs>(args: SelectSubset<T, questlistsFindUniqueArgs<ExtArgs>>): Prisma__questlistsClient<$Result.GetResult<Prisma.$questlistsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Questlists that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {questlistsFindUniqueOrThrowArgs} args - Arguments to find a Questlists
     * @example
     * // Get one Questlists
     * const questlists = await prisma.questlists.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends questlistsFindUniqueOrThrowArgs>(args: SelectSubset<T, questlistsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__questlistsClient<$Result.GetResult<Prisma.$questlistsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Questlists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questlistsFindFirstArgs} args - Arguments to find a Questlists
     * @example
     * // Get one Questlists
     * const questlists = await prisma.questlists.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends questlistsFindFirstArgs>(args?: SelectSubset<T, questlistsFindFirstArgs<ExtArgs>>): Prisma__questlistsClient<$Result.GetResult<Prisma.$questlistsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Questlists that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questlistsFindFirstOrThrowArgs} args - Arguments to find a Questlists
     * @example
     * // Get one Questlists
     * const questlists = await prisma.questlists.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends questlistsFindFirstOrThrowArgs>(args?: SelectSubset<T, questlistsFindFirstOrThrowArgs<ExtArgs>>): Prisma__questlistsClient<$Result.GetResult<Prisma.$questlistsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Questlists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questlistsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Questlists
     * const questlists = await prisma.questlists.findMany()
     * 
     * // Get first 10 Questlists
     * const questlists = await prisma.questlists.findMany({ take: 10 })
     * 
     * // Only select the `questlist_id`
     * const questlistsWithQuestlist_idOnly = await prisma.questlists.findMany({ select: { questlist_id: true } })
     * 
     */
    findMany<T extends questlistsFindManyArgs>(args?: SelectSubset<T, questlistsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$questlistsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Questlists.
     * @param {questlistsCreateArgs} args - Arguments to create a Questlists.
     * @example
     * // Create one Questlists
     * const Questlists = await prisma.questlists.create({
     *   data: {
     *     // ... data to create a Questlists
     *   }
     * })
     * 
     */
    create<T extends questlistsCreateArgs>(args: SelectSubset<T, questlistsCreateArgs<ExtArgs>>): Prisma__questlistsClient<$Result.GetResult<Prisma.$questlistsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Questlists.
     * @param {questlistsCreateManyArgs} args - Arguments to create many Questlists.
     * @example
     * // Create many Questlists
     * const questlists = await prisma.questlists.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends questlistsCreateManyArgs>(args?: SelectSubset<T, questlistsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Questlists.
     * @param {questlistsDeleteArgs} args - Arguments to delete one Questlists.
     * @example
     * // Delete one Questlists
     * const Questlists = await prisma.questlists.delete({
     *   where: {
     *     // ... filter to delete one Questlists
     *   }
     * })
     * 
     */
    delete<T extends questlistsDeleteArgs>(args: SelectSubset<T, questlistsDeleteArgs<ExtArgs>>): Prisma__questlistsClient<$Result.GetResult<Prisma.$questlistsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Questlists.
     * @param {questlistsUpdateArgs} args - Arguments to update one Questlists.
     * @example
     * // Update one Questlists
     * const questlists = await prisma.questlists.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends questlistsUpdateArgs>(args: SelectSubset<T, questlistsUpdateArgs<ExtArgs>>): Prisma__questlistsClient<$Result.GetResult<Prisma.$questlistsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Questlists.
     * @param {questlistsDeleteManyArgs} args - Arguments to filter Questlists to delete.
     * @example
     * // Delete a few Questlists
     * const { count } = await prisma.questlists.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends questlistsDeleteManyArgs>(args?: SelectSubset<T, questlistsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Questlists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questlistsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Questlists
     * const questlists = await prisma.questlists.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends questlistsUpdateManyArgs>(args: SelectSubset<T, questlistsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Questlists.
     * @param {questlistsUpsertArgs} args - Arguments to update or create a Questlists.
     * @example
     * // Update or create a Questlists
     * const questlists = await prisma.questlists.upsert({
     *   create: {
     *     // ... data to create a Questlists
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Questlists we want to update
     *   }
     * })
     */
    upsert<T extends questlistsUpsertArgs>(args: SelectSubset<T, questlistsUpsertArgs<ExtArgs>>): Prisma__questlistsClient<$Result.GetResult<Prisma.$questlistsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Questlists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questlistsCountArgs} args - Arguments to filter Questlists to count.
     * @example
     * // Count the number of Questlists
     * const count = await prisma.questlists.count({
     *   where: {
     *     // ... the filter for the Questlists we want to count
     *   }
     * })
    **/
    count<T extends questlistsCountArgs>(
      args?: Subset<T, questlistsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestlistsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Questlists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestlistsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestlistsAggregateArgs>(args: Subset<T, QuestlistsAggregateArgs>): Prisma.PrismaPromise<GetQuestlistsAggregateType<T>>

    /**
     * Group by Questlists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questlistsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends questlistsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: questlistsGroupByArgs['orderBy'] }
        : { orderBy?: questlistsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, questlistsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestlistsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the questlists model
   */
  readonly fields: questlistsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for questlists.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__questlistsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the questlists model
   */ 
  interface questlistsFieldRefs {
    readonly questlist_id: FieldRef<"questlists", 'BigInt'>
    readonly questmanager_id: FieldRef<"questlists", 'BigInt'>
    readonly questid: FieldRef<"questlists", 'Int'>
    readonly fk_questid: FieldRef<"questlists", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * questlists findUnique
   */
  export type questlistsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questlists
     */
    select?: questlistsSelect<ExtArgs> | null
    /**
     * Filter, which questlists to fetch.
     */
    where: questlistsWhereUniqueInput
  }

  /**
   * questlists findUniqueOrThrow
   */
  export type questlistsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questlists
     */
    select?: questlistsSelect<ExtArgs> | null
    /**
     * Filter, which questlists to fetch.
     */
    where: questlistsWhereUniqueInput
  }

  /**
   * questlists findFirst
   */
  export type questlistsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questlists
     */
    select?: questlistsSelect<ExtArgs> | null
    /**
     * Filter, which questlists to fetch.
     */
    where?: questlistsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questlists to fetch.
     */
    orderBy?: questlistsOrderByWithRelationInput | questlistsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for questlists.
     */
    cursor?: questlistsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questlists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of questlists.
     */
    distinct?: QuestlistsScalarFieldEnum | QuestlistsScalarFieldEnum[]
  }

  /**
   * questlists findFirstOrThrow
   */
  export type questlistsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questlists
     */
    select?: questlistsSelect<ExtArgs> | null
    /**
     * Filter, which questlists to fetch.
     */
    where?: questlistsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questlists to fetch.
     */
    orderBy?: questlistsOrderByWithRelationInput | questlistsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for questlists.
     */
    cursor?: questlistsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questlists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of questlists.
     */
    distinct?: QuestlistsScalarFieldEnum | QuestlistsScalarFieldEnum[]
  }

  /**
   * questlists findMany
   */
  export type questlistsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questlists
     */
    select?: questlistsSelect<ExtArgs> | null
    /**
     * Filter, which questlists to fetch.
     */
    where?: questlistsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questlists to fetch.
     */
    orderBy?: questlistsOrderByWithRelationInput | questlistsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing questlists.
     */
    cursor?: questlistsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questlists.
     */
    skip?: number
    distinct?: QuestlistsScalarFieldEnum | QuestlistsScalarFieldEnum[]
  }

  /**
   * questlists create
   */
  export type questlistsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questlists
     */
    select?: questlistsSelect<ExtArgs> | null
    /**
     * The data needed to create a questlists.
     */
    data?: XOR<questlistsCreateInput, questlistsUncheckedCreateInput>
  }

  /**
   * questlists createMany
   */
  export type questlistsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many questlists.
     */
    data: questlistsCreateManyInput | questlistsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * questlists update
   */
  export type questlistsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questlists
     */
    select?: questlistsSelect<ExtArgs> | null
    /**
     * The data needed to update a questlists.
     */
    data: XOR<questlistsUpdateInput, questlistsUncheckedUpdateInput>
    /**
     * Choose, which questlists to update.
     */
    where: questlistsWhereUniqueInput
  }

  /**
   * questlists updateMany
   */
  export type questlistsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update questlists.
     */
    data: XOR<questlistsUpdateManyMutationInput, questlistsUncheckedUpdateManyInput>
    /**
     * Filter which questlists to update
     */
    where?: questlistsWhereInput
  }

  /**
   * questlists upsert
   */
  export type questlistsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questlists
     */
    select?: questlistsSelect<ExtArgs> | null
    /**
     * The filter to search for the questlists to update in case it exists.
     */
    where: questlistsWhereUniqueInput
    /**
     * In case the questlists found by the `where` argument doesn't exist, create a new questlists with this data.
     */
    create: XOR<questlistsCreateInput, questlistsUncheckedCreateInput>
    /**
     * In case the questlists was found with the provided `where` argument, update it with this data.
     */
    update: XOR<questlistsUpdateInput, questlistsUncheckedUpdateInput>
  }

  /**
   * questlists delete
   */
  export type questlistsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questlists
     */
    select?: questlistsSelect<ExtArgs> | null
    /**
     * Filter which questlists to delete.
     */
    where: questlistsWhereUniqueInput
  }

  /**
   * questlists deleteMany
   */
  export type questlistsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which questlists to delete
     */
    where?: questlistsWhereInput
  }

  /**
   * questlists without action
   */
  export type questlistsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questlists
     */
    select?: questlistsSelect<ExtArgs> | null
  }


  /**
   * Model questmanagers
   */

  export type AggregateQuestmanagers = {
    _count: QuestmanagersCountAggregateOutputType | null
    _avg: QuestmanagersAvgAggregateOutputType | null
    _sum: QuestmanagersSumAggregateOutputType | null
    _min: QuestmanagersMinAggregateOutputType | null
    _max: QuestmanagersMaxAggregateOutputType | null
  }

  export type QuestmanagersAvgAggregateOutputType = {
    id: number | null
  }

  export type QuestmanagersSumAggregateOutputType = {
    id: bigint | null
  }

  export type QuestmanagersMinAggregateOutputType = {
    id: bigint | null
  }

  export type QuestmanagersMaxAggregateOutputType = {
    id: bigint | null
  }

  export type QuestmanagersCountAggregateOutputType = {
    id: number
    _all: number
  }


  export type QuestmanagersAvgAggregateInputType = {
    id?: true
  }

  export type QuestmanagersSumAggregateInputType = {
    id?: true
  }

  export type QuestmanagersMinAggregateInputType = {
    id?: true
  }

  export type QuestmanagersMaxAggregateInputType = {
    id?: true
  }

  export type QuestmanagersCountAggregateInputType = {
    id?: true
    _all?: true
  }

  export type QuestmanagersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which questmanagers to aggregate.
     */
    where?: questmanagersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questmanagers to fetch.
     */
    orderBy?: questmanagersOrderByWithRelationInput | questmanagersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: questmanagersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questmanagers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questmanagers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned questmanagers
    **/
    _count?: true | QuestmanagersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuestmanagersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuestmanagersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestmanagersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestmanagersMaxAggregateInputType
  }

  export type GetQuestmanagersAggregateType<T extends QuestmanagersAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestmanagers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestmanagers[P]>
      : GetScalarType<T[P], AggregateQuestmanagers[P]>
  }




  export type questmanagersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: questmanagersWhereInput
    orderBy?: questmanagersOrderByWithAggregationInput | questmanagersOrderByWithAggregationInput[]
    by: QuestmanagersScalarFieldEnum[] | QuestmanagersScalarFieldEnum
    having?: questmanagersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestmanagersCountAggregateInputType | true
    _avg?: QuestmanagersAvgAggregateInputType
    _sum?: QuestmanagersSumAggregateInputType
    _min?: QuestmanagersMinAggregateInputType
    _max?: QuestmanagersMaxAggregateInputType
  }

  export type QuestmanagersGroupByOutputType = {
    id: bigint
    _count: QuestmanagersCountAggregateOutputType | null
    _avg: QuestmanagersAvgAggregateOutputType | null
    _sum: QuestmanagersSumAggregateOutputType | null
    _min: QuestmanagersMinAggregateOutputType | null
    _max: QuestmanagersMaxAggregateOutputType | null
  }

  type GetQuestmanagersGroupByPayload<T extends questmanagersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestmanagersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestmanagersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestmanagersGroupByOutputType[P]>
            : GetScalarType<T[P], QuestmanagersGroupByOutputType[P]>
        }
      >
    >


  export type questmanagersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
  }, ExtArgs["result"]["questmanagers"]>


  export type questmanagersSelectScalar = {
    id?: boolean
  }


  export type $questmanagersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "questmanagers"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
    }, ExtArgs["result"]["questmanagers"]>
    composites: {}
  }

  type questmanagersGetPayload<S extends boolean | null | undefined | questmanagersDefaultArgs> = $Result.GetResult<Prisma.$questmanagersPayload, S>

  type questmanagersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<questmanagersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QuestmanagersCountAggregateInputType | true
    }

  export interface questmanagersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['questmanagers'], meta: { name: 'questmanagers' } }
    /**
     * Find zero or one Questmanagers that matches the filter.
     * @param {questmanagersFindUniqueArgs} args - Arguments to find a Questmanagers
     * @example
     * // Get one Questmanagers
     * const questmanagers = await prisma.questmanagers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends questmanagersFindUniqueArgs>(args: SelectSubset<T, questmanagersFindUniqueArgs<ExtArgs>>): Prisma__questmanagersClient<$Result.GetResult<Prisma.$questmanagersPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Questmanagers that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {questmanagersFindUniqueOrThrowArgs} args - Arguments to find a Questmanagers
     * @example
     * // Get one Questmanagers
     * const questmanagers = await prisma.questmanagers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends questmanagersFindUniqueOrThrowArgs>(args: SelectSubset<T, questmanagersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__questmanagersClient<$Result.GetResult<Prisma.$questmanagersPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Questmanagers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questmanagersFindFirstArgs} args - Arguments to find a Questmanagers
     * @example
     * // Get one Questmanagers
     * const questmanagers = await prisma.questmanagers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends questmanagersFindFirstArgs>(args?: SelectSubset<T, questmanagersFindFirstArgs<ExtArgs>>): Prisma__questmanagersClient<$Result.GetResult<Prisma.$questmanagersPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Questmanagers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questmanagersFindFirstOrThrowArgs} args - Arguments to find a Questmanagers
     * @example
     * // Get one Questmanagers
     * const questmanagers = await prisma.questmanagers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends questmanagersFindFirstOrThrowArgs>(args?: SelectSubset<T, questmanagersFindFirstOrThrowArgs<ExtArgs>>): Prisma__questmanagersClient<$Result.GetResult<Prisma.$questmanagersPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Questmanagers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questmanagersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Questmanagers
     * const questmanagers = await prisma.questmanagers.findMany()
     * 
     * // Get first 10 Questmanagers
     * const questmanagers = await prisma.questmanagers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questmanagersWithIdOnly = await prisma.questmanagers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends questmanagersFindManyArgs>(args?: SelectSubset<T, questmanagersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$questmanagersPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Questmanagers.
     * @param {questmanagersCreateArgs} args - Arguments to create a Questmanagers.
     * @example
     * // Create one Questmanagers
     * const Questmanagers = await prisma.questmanagers.create({
     *   data: {
     *     // ... data to create a Questmanagers
     *   }
     * })
     * 
     */
    create<T extends questmanagersCreateArgs>(args: SelectSubset<T, questmanagersCreateArgs<ExtArgs>>): Prisma__questmanagersClient<$Result.GetResult<Prisma.$questmanagersPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Questmanagers.
     * @param {questmanagersCreateManyArgs} args - Arguments to create many Questmanagers.
     * @example
     * // Create many Questmanagers
     * const questmanagers = await prisma.questmanagers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends questmanagersCreateManyArgs>(args?: SelectSubset<T, questmanagersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Questmanagers.
     * @param {questmanagersDeleteArgs} args - Arguments to delete one Questmanagers.
     * @example
     * // Delete one Questmanagers
     * const Questmanagers = await prisma.questmanagers.delete({
     *   where: {
     *     // ... filter to delete one Questmanagers
     *   }
     * })
     * 
     */
    delete<T extends questmanagersDeleteArgs>(args: SelectSubset<T, questmanagersDeleteArgs<ExtArgs>>): Prisma__questmanagersClient<$Result.GetResult<Prisma.$questmanagersPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Questmanagers.
     * @param {questmanagersUpdateArgs} args - Arguments to update one Questmanagers.
     * @example
     * // Update one Questmanagers
     * const questmanagers = await prisma.questmanagers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends questmanagersUpdateArgs>(args: SelectSubset<T, questmanagersUpdateArgs<ExtArgs>>): Prisma__questmanagersClient<$Result.GetResult<Prisma.$questmanagersPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Questmanagers.
     * @param {questmanagersDeleteManyArgs} args - Arguments to filter Questmanagers to delete.
     * @example
     * // Delete a few Questmanagers
     * const { count } = await prisma.questmanagers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends questmanagersDeleteManyArgs>(args?: SelectSubset<T, questmanagersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Questmanagers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questmanagersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Questmanagers
     * const questmanagers = await prisma.questmanagers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends questmanagersUpdateManyArgs>(args: SelectSubset<T, questmanagersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Questmanagers.
     * @param {questmanagersUpsertArgs} args - Arguments to update or create a Questmanagers.
     * @example
     * // Update or create a Questmanagers
     * const questmanagers = await prisma.questmanagers.upsert({
     *   create: {
     *     // ... data to create a Questmanagers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Questmanagers we want to update
     *   }
     * })
     */
    upsert<T extends questmanagersUpsertArgs>(args: SelectSubset<T, questmanagersUpsertArgs<ExtArgs>>): Prisma__questmanagersClient<$Result.GetResult<Prisma.$questmanagersPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Questmanagers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questmanagersCountArgs} args - Arguments to filter Questmanagers to count.
     * @example
     * // Count the number of Questmanagers
     * const count = await prisma.questmanagers.count({
     *   where: {
     *     // ... the filter for the Questmanagers we want to count
     *   }
     * })
    **/
    count<T extends questmanagersCountArgs>(
      args?: Subset<T, questmanagersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestmanagersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Questmanagers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestmanagersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestmanagersAggregateArgs>(args: Subset<T, QuestmanagersAggregateArgs>): Prisma.PrismaPromise<GetQuestmanagersAggregateType<T>>

    /**
     * Group by Questmanagers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questmanagersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends questmanagersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: questmanagersGroupByArgs['orderBy'] }
        : { orderBy?: questmanagersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, questmanagersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestmanagersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the questmanagers model
   */
  readonly fields: questmanagersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for questmanagers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__questmanagersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the questmanagers model
   */ 
  interface questmanagersFieldRefs {
    readonly id: FieldRef<"questmanagers", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * questmanagers findUnique
   */
  export type questmanagersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questmanagers
     */
    select?: questmanagersSelect<ExtArgs> | null
    /**
     * Filter, which questmanagers to fetch.
     */
    where: questmanagersWhereUniqueInput
  }

  /**
   * questmanagers findUniqueOrThrow
   */
  export type questmanagersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questmanagers
     */
    select?: questmanagersSelect<ExtArgs> | null
    /**
     * Filter, which questmanagers to fetch.
     */
    where: questmanagersWhereUniqueInput
  }

  /**
   * questmanagers findFirst
   */
  export type questmanagersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questmanagers
     */
    select?: questmanagersSelect<ExtArgs> | null
    /**
     * Filter, which questmanagers to fetch.
     */
    where?: questmanagersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questmanagers to fetch.
     */
    orderBy?: questmanagersOrderByWithRelationInput | questmanagersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for questmanagers.
     */
    cursor?: questmanagersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questmanagers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questmanagers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of questmanagers.
     */
    distinct?: QuestmanagersScalarFieldEnum | QuestmanagersScalarFieldEnum[]
  }

  /**
   * questmanagers findFirstOrThrow
   */
  export type questmanagersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questmanagers
     */
    select?: questmanagersSelect<ExtArgs> | null
    /**
     * Filter, which questmanagers to fetch.
     */
    where?: questmanagersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questmanagers to fetch.
     */
    orderBy?: questmanagersOrderByWithRelationInput | questmanagersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for questmanagers.
     */
    cursor?: questmanagersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questmanagers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questmanagers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of questmanagers.
     */
    distinct?: QuestmanagersScalarFieldEnum | QuestmanagersScalarFieldEnum[]
  }

  /**
   * questmanagers findMany
   */
  export type questmanagersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questmanagers
     */
    select?: questmanagersSelect<ExtArgs> | null
    /**
     * Filter, which questmanagers to fetch.
     */
    where?: questmanagersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questmanagers to fetch.
     */
    orderBy?: questmanagersOrderByWithRelationInput | questmanagersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing questmanagers.
     */
    cursor?: questmanagersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questmanagers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questmanagers.
     */
    skip?: number
    distinct?: QuestmanagersScalarFieldEnum | QuestmanagersScalarFieldEnum[]
  }

  /**
   * questmanagers create
   */
  export type questmanagersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questmanagers
     */
    select?: questmanagersSelect<ExtArgs> | null
    /**
     * The data needed to create a questmanagers.
     */
    data?: XOR<questmanagersCreateInput, questmanagersUncheckedCreateInput>
  }

  /**
   * questmanagers createMany
   */
  export type questmanagersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many questmanagers.
     */
    data: questmanagersCreateManyInput | questmanagersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * questmanagers update
   */
  export type questmanagersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questmanagers
     */
    select?: questmanagersSelect<ExtArgs> | null
    /**
     * The data needed to update a questmanagers.
     */
    data: XOR<questmanagersUpdateInput, questmanagersUncheckedUpdateInput>
    /**
     * Choose, which questmanagers to update.
     */
    where: questmanagersWhereUniqueInput
  }

  /**
   * questmanagers updateMany
   */
  export type questmanagersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update questmanagers.
     */
    data: XOR<questmanagersUpdateManyMutationInput, questmanagersUncheckedUpdateManyInput>
    /**
     * Filter which questmanagers to update
     */
    where?: questmanagersWhereInput
  }

  /**
   * questmanagers upsert
   */
  export type questmanagersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questmanagers
     */
    select?: questmanagersSelect<ExtArgs> | null
    /**
     * The filter to search for the questmanagers to update in case it exists.
     */
    where: questmanagersWhereUniqueInput
    /**
     * In case the questmanagers found by the `where` argument doesn't exist, create a new questmanagers with this data.
     */
    create: XOR<questmanagersCreateInput, questmanagersUncheckedCreateInput>
    /**
     * In case the questmanagers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<questmanagersUpdateInput, questmanagersUncheckedUpdateInput>
  }

  /**
   * questmanagers delete
   */
  export type questmanagersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questmanagers
     */
    select?: questmanagersSelect<ExtArgs> | null
    /**
     * Filter which questmanagers to delete.
     */
    where: questmanagersWhereUniqueInput
  }

  /**
   * questmanagers deleteMany
   */
  export type questmanagersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which questmanagers to delete
     */
    where?: questmanagersWhereInput
  }

  /**
   * questmanagers without action
   */
  export type questmanagersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questmanagers
     */
    select?: questmanagersSelect<ExtArgs> | null
  }


  /**
   * Model questprogressrequirements
   */

  export type AggregateQuestprogressrequirements = {
    _count: QuestprogressrequirementsCountAggregateOutputType | null
    _avg: QuestprogressrequirementsAvgAggregateOutputType | null
    _sum: QuestprogressrequirementsSumAggregateOutputType | null
    _min: QuestprogressrequirementsMinAggregateOutputType | null
    _max: QuestprogressrequirementsMaxAggregateOutputType | null
  }

  export type QuestprogressrequirementsAvgAggregateOutputType = {
    id: number | null
    orderNum: number | null
    questid: number | null
    unitid: number | null
    requiredcount: number | null
    currentcount: number | null
  }

  export type QuestprogressrequirementsSumAggregateOutputType = {
    id: bigint | null
    orderNum: number | null
    questid: bigint | null
    unitid: number | null
    requiredcount: number | null
    currentcount: number | null
  }

  export type QuestprogressrequirementsMinAggregateOutputType = {
    id: bigint | null
    orderNum: number | null
    progresstype: string | null
    questid: bigint | null
    unitid: number | null
    requiredcount: number | null
    currentcount: number | null
  }

  export type QuestprogressrequirementsMaxAggregateOutputType = {
    id: bigint | null
    orderNum: number | null
    progresstype: string | null
    questid: bigint | null
    unitid: number | null
    requiredcount: number | null
    currentcount: number | null
  }

  export type QuestprogressrequirementsCountAggregateOutputType = {
    id: number
    orderNum: number
    progresstype: number
    questid: number
    unitid: number
    requiredcount: number
    currentcount: number
    _all: number
  }


  export type QuestprogressrequirementsAvgAggregateInputType = {
    id?: true
    orderNum?: true
    questid?: true
    unitid?: true
    requiredcount?: true
    currentcount?: true
  }

  export type QuestprogressrequirementsSumAggregateInputType = {
    id?: true
    orderNum?: true
    questid?: true
    unitid?: true
    requiredcount?: true
    currentcount?: true
  }

  export type QuestprogressrequirementsMinAggregateInputType = {
    id?: true
    orderNum?: true
    progresstype?: true
    questid?: true
    unitid?: true
    requiredcount?: true
    currentcount?: true
  }

  export type QuestprogressrequirementsMaxAggregateInputType = {
    id?: true
    orderNum?: true
    progresstype?: true
    questid?: true
    unitid?: true
    requiredcount?: true
    currentcount?: true
  }

  export type QuestprogressrequirementsCountAggregateInputType = {
    id?: true
    orderNum?: true
    progresstype?: true
    questid?: true
    unitid?: true
    requiredcount?: true
    currentcount?: true
    _all?: true
  }

  export type QuestprogressrequirementsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which questprogressrequirements to aggregate.
     */
    where?: questprogressrequirementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questprogressrequirements to fetch.
     */
    orderBy?: questprogressrequirementsOrderByWithRelationInput | questprogressrequirementsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: questprogressrequirementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questprogressrequirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questprogressrequirements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned questprogressrequirements
    **/
    _count?: true | QuestprogressrequirementsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuestprogressrequirementsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuestprogressrequirementsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestprogressrequirementsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestprogressrequirementsMaxAggregateInputType
  }

  export type GetQuestprogressrequirementsAggregateType<T extends QuestprogressrequirementsAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestprogressrequirements]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestprogressrequirements[P]>
      : GetScalarType<T[P], AggregateQuestprogressrequirements[P]>
  }




  export type questprogressrequirementsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: questprogressrequirementsWhereInput
    orderBy?: questprogressrequirementsOrderByWithAggregationInput | questprogressrequirementsOrderByWithAggregationInput[]
    by: QuestprogressrequirementsScalarFieldEnum[] | QuestprogressrequirementsScalarFieldEnum
    having?: questprogressrequirementsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestprogressrequirementsCountAggregateInputType | true
    _avg?: QuestprogressrequirementsAvgAggregateInputType
    _sum?: QuestprogressrequirementsSumAggregateInputType
    _min?: QuestprogressrequirementsMinAggregateInputType
    _max?: QuestprogressrequirementsMaxAggregateInputType
  }

  export type QuestprogressrequirementsGroupByOutputType = {
    id: bigint
    orderNum: number | null
    progresstype: string | null
    questid: bigint | null
    unitid: number | null
    requiredcount: number | null
    currentcount: number | null
    _count: QuestprogressrequirementsCountAggregateOutputType | null
    _avg: QuestprogressrequirementsAvgAggregateOutputType | null
    _sum: QuestprogressrequirementsSumAggregateOutputType | null
    _min: QuestprogressrequirementsMinAggregateOutputType | null
    _max: QuestprogressrequirementsMaxAggregateOutputType | null
  }

  type GetQuestprogressrequirementsGroupByPayload<T extends questprogressrequirementsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestprogressrequirementsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestprogressrequirementsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestprogressrequirementsGroupByOutputType[P]>
            : GetScalarType<T[P], QuestprogressrequirementsGroupByOutputType[P]>
        }
      >
    >


  export type questprogressrequirementsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNum?: boolean
    progresstype?: boolean
    questid?: boolean
    unitid?: boolean
    requiredcount?: boolean
    currentcount?: boolean
  }, ExtArgs["result"]["questprogressrequirements"]>


  export type questprogressrequirementsSelectScalar = {
    id?: boolean
    orderNum?: boolean
    progresstype?: boolean
    questid?: boolean
    unitid?: boolean
    requiredcount?: boolean
    currentcount?: boolean
  }


  export type $questprogressrequirementsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "questprogressrequirements"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      orderNum: number | null
      progresstype: string | null
      questid: bigint | null
      unitid: number | null
      requiredcount: number | null
      currentcount: number | null
    }, ExtArgs["result"]["questprogressrequirements"]>
    composites: {}
  }

  type questprogressrequirementsGetPayload<S extends boolean | null | undefined | questprogressrequirementsDefaultArgs> = $Result.GetResult<Prisma.$questprogressrequirementsPayload, S>

  type questprogressrequirementsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<questprogressrequirementsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QuestprogressrequirementsCountAggregateInputType | true
    }

  export interface questprogressrequirementsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['questprogressrequirements'], meta: { name: 'questprogressrequirements' } }
    /**
     * Find zero or one Questprogressrequirements that matches the filter.
     * @param {questprogressrequirementsFindUniqueArgs} args - Arguments to find a Questprogressrequirements
     * @example
     * // Get one Questprogressrequirements
     * const questprogressrequirements = await prisma.questprogressrequirements.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends questprogressrequirementsFindUniqueArgs>(args: SelectSubset<T, questprogressrequirementsFindUniqueArgs<ExtArgs>>): Prisma__questprogressrequirementsClient<$Result.GetResult<Prisma.$questprogressrequirementsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Questprogressrequirements that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {questprogressrequirementsFindUniqueOrThrowArgs} args - Arguments to find a Questprogressrequirements
     * @example
     * // Get one Questprogressrequirements
     * const questprogressrequirements = await prisma.questprogressrequirements.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends questprogressrequirementsFindUniqueOrThrowArgs>(args: SelectSubset<T, questprogressrequirementsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__questprogressrequirementsClient<$Result.GetResult<Prisma.$questprogressrequirementsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Questprogressrequirements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questprogressrequirementsFindFirstArgs} args - Arguments to find a Questprogressrequirements
     * @example
     * // Get one Questprogressrequirements
     * const questprogressrequirements = await prisma.questprogressrequirements.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends questprogressrequirementsFindFirstArgs>(args?: SelectSubset<T, questprogressrequirementsFindFirstArgs<ExtArgs>>): Prisma__questprogressrequirementsClient<$Result.GetResult<Prisma.$questprogressrequirementsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Questprogressrequirements that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questprogressrequirementsFindFirstOrThrowArgs} args - Arguments to find a Questprogressrequirements
     * @example
     * // Get one Questprogressrequirements
     * const questprogressrequirements = await prisma.questprogressrequirements.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends questprogressrequirementsFindFirstOrThrowArgs>(args?: SelectSubset<T, questprogressrequirementsFindFirstOrThrowArgs<ExtArgs>>): Prisma__questprogressrequirementsClient<$Result.GetResult<Prisma.$questprogressrequirementsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Questprogressrequirements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questprogressrequirementsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Questprogressrequirements
     * const questprogressrequirements = await prisma.questprogressrequirements.findMany()
     * 
     * // Get first 10 Questprogressrequirements
     * const questprogressrequirements = await prisma.questprogressrequirements.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questprogressrequirementsWithIdOnly = await prisma.questprogressrequirements.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends questprogressrequirementsFindManyArgs>(args?: SelectSubset<T, questprogressrequirementsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$questprogressrequirementsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Questprogressrequirements.
     * @param {questprogressrequirementsCreateArgs} args - Arguments to create a Questprogressrequirements.
     * @example
     * // Create one Questprogressrequirements
     * const Questprogressrequirements = await prisma.questprogressrequirements.create({
     *   data: {
     *     // ... data to create a Questprogressrequirements
     *   }
     * })
     * 
     */
    create<T extends questprogressrequirementsCreateArgs>(args: SelectSubset<T, questprogressrequirementsCreateArgs<ExtArgs>>): Prisma__questprogressrequirementsClient<$Result.GetResult<Prisma.$questprogressrequirementsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Questprogressrequirements.
     * @param {questprogressrequirementsCreateManyArgs} args - Arguments to create many Questprogressrequirements.
     * @example
     * // Create many Questprogressrequirements
     * const questprogressrequirements = await prisma.questprogressrequirements.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends questprogressrequirementsCreateManyArgs>(args?: SelectSubset<T, questprogressrequirementsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Questprogressrequirements.
     * @param {questprogressrequirementsDeleteArgs} args - Arguments to delete one Questprogressrequirements.
     * @example
     * // Delete one Questprogressrequirements
     * const Questprogressrequirements = await prisma.questprogressrequirements.delete({
     *   where: {
     *     // ... filter to delete one Questprogressrequirements
     *   }
     * })
     * 
     */
    delete<T extends questprogressrequirementsDeleteArgs>(args: SelectSubset<T, questprogressrequirementsDeleteArgs<ExtArgs>>): Prisma__questprogressrequirementsClient<$Result.GetResult<Prisma.$questprogressrequirementsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Questprogressrequirements.
     * @param {questprogressrequirementsUpdateArgs} args - Arguments to update one Questprogressrequirements.
     * @example
     * // Update one Questprogressrequirements
     * const questprogressrequirements = await prisma.questprogressrequirements.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends questprogressrequirementsUpdateArgs>(args: SelectSubset<T, questprogressrequirementsUpdateArgs<ExtArgs>>): Prisma__questprogressrequirementsClient<$Result.GetResult<Prisma.$questprogressrequirementsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Questprogressrequirements.
     * @param {questprogressrequirementsDeleteManyArgs} args - Arguments to filter Questprogressrequirements to delete.
     * @example
     * // Delete a few Questprogressrequirements
     * const { count } = await prisma.questprogressrequirements.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends questprogressrequirementsDeleteManyArgs>(args?: SelectSubset<T, questprogressrequirementsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Questprogressrequirements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questprogressrequirementsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Questprogressrequirements
     * const questprogressrequirements = await prisma.questprogressrequirements.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends questprogressrequirementsUpdateManyArgs>(args: SelectSubset<T, questprogressrequirementsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Questprogressrequirements.
     * @param {questprogressrequirementsUpsertArgs} args - Arguments to update or create a Questprogressrequirements.
     * @example
     * // Update or create a Questprogressrequirements
     * const questprogressrequirements = await prisma.questprogressrequirements.upsert({
     *   create: {
     *     // ... data to create a Questprogressrequirements
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Questprogressrequirements we want to update
     *   }
     * })
     */
    upsert<T extends questprogressrequirementsUpsertArgs>(args: SelectSubset<T, questprogressrequirementsUpsertArgs<ExtArgs>>): Prisma__questprogressrequirementsClient<$Result.GetResult<Prisma.$questprogressrequirementsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Questprogressrequirements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questprogressrequirementsCountArgs} args - Arguments to filter Questprogressrequirements to count.
     * @example
     * // Count the number of Questprogressrequirements
     * const count = await prisma.questprogressrequirements.count({
     *   where: {
     *     // ... the filter for the Questprogressrequirements we want to count
     *   }
     * })
    **/
    count<T extends questprogressrequirementsCountArgs>(
      args?: Subset<T, questprogressrequirementsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestprogressrequirementsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Questprogressrequirements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestprogressrequirementsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestprogressrequirementsAggregateArgs>(args: Subset<T, QuestprogressrequirementsAggregateArgs>): Prisma.PrismaPromise<GetQuestprogressrequirementsAggregateType<T>>

    /**
     * Group by Questprogressrequirements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questprogressrequirementsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends questprogressrequirementsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: questprogressrequirementsGroupByArgs['orderBy'] }
        : { orderBy?: questprogressrequirementsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, questprogressrequirementsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestprogressrequirementsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the questprogressrequirements model
   */
  readonly fields: questprogressrequirementsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for questprogressrequirements.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__questprogressrequirementsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the questprogressrequirements model
   */ 
  interface questprogressrequirementsFieldRefs {
    readonly id: FieldRef<"questprogressrequirements", 'BigInt'>
    readonly orderNum: FieldRef<"questprogressrequirements", 'Int'>
    readonly progresstype: FieldRef<"questprogressrequirements", 'String'>
    readonly questid: FieldRef<"questprogressrequirements", 'BigInt'>
    readonly unitid: FieldRef<"questprogressrequirements", 'Int'>
    readonly requiredcount: FieldRef<"questprogressrequirements", 'Int'>
    readonly currentcount: FieldRef<"questprogressrequirements", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * questprogressrequirements findUnique
   */
  export type questprogressrequirementsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questprogressrequirements
     */
    select?: questprogressrequirementsSelect<ExtArgs> | null
    /**
     * Filter, which questprogressrequirements to fetch.
     */
    where: questprogressrequirementsWhereUniqueInput
  }

  /**
   * questprogressrequirements findUniqueOrThrow
   */
  export type questprogressrequirementsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questprogressrequirements
     */
    select?: questprogressrequirementsSelect<ExtArgs> | null
    /**
     * Filter, which questprogressrequirements to fetch.
     */
    where: questprogressrequirementsWhereUniqueInput
  }

  /**
   * questprogressrequirements findFirst
   */
  export type questprogressrequirementsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questprogressrequirements
     */
    select?: questprogressrequirementsSelect<ExtArgs> | null
    /**
     * Filter, which questprogressrequirements to fetch.
     */
    where?: questprogressrequirementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questprogressrequirements to fetch.
     */
    orderBy?: questprogressrequirementsOrderByWithRelationInput | questprogressrequirementsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for questprogressrequirements.
     */
    cursor?: questprogressrequirementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questprogressrequirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questprogressrequirements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of questprogressrequirements.
     */
    distinct?: QuestprogressrequirementsScalarFieldEnum | QuestprogressrequirementsScalarFieldEnum[]
  }

  /**
   * questprogressrequirements findFirstOrThrow
   */
  export type questprogressrequirementsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questprogressrequirements
     */
    select?: questprogressrequirementsSelect<ExtArgs> | null
    /**
     * Filter, which questprogressrequirements to fetch.
     */
    where?: questprogressrequirementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questprogressrequirements to fetch.
     */
    orderBy?: questprogressrequirementsOrderByWithRelationInput | questprogressrequirementsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for questprogressrequirements.
     */
    cursor?: questprogressrequirementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questprogressrequirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questprogressrequirements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of questprogressrequirements.
     */
    distinct?: QuestprogressrequirementsScalarFieldEnum | QuestprogressrequirementsScalarFieldEnum[]
  }

  /**
   * questprogressrequirements findMany
   */
  export type questprogressrequirementsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questprogressrequirements
     */
    select?: questprogressrequirementsSelect<ExtArgs> | null
    /**
     * Filter, which questprogressrequirements to fetch.
     */
    where?: questprogressrequirementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questprogressrequirements to fetch.
     */
    orderBy?: questprogressrequirementsOrderByWithRelationInput | questprogressrequirementsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing questprogressrequirements.
     */
    cursor?: questprogressrequirementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questprogressrequirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questprogressrequirements.
     */
    skip?: number
    distinct?: QuestprogressrequirementsScalarFieldEnum | QuestprogressrequirementsScalarFieldEnum[]
  }

  /**
   * questprogressrequirements create
   */
  export type questprogressrequirementsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questprogressrequirements
     */
    select?: questprogressrequirementsSelect<ExtArgs> | null
    /**
     * The data needed to create a questprogressrequirements.
     */
    data?: XOR<questprogressrequirementsCreateInput, questprogressrequirementsUncheckedCreateInput>
  }

  /**
   * questprogressrequirements createMany
   */
  export type questprogressrequirementsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many questprogressrequirements.
     */
    data: questprogressrequirementsCreateManyInput | questprogressrequirementsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * questprogressrequirements update
   */
  export type questprogressrequirementsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questprogressrequirements
     */
    select?: questprogressrequirementsSelect<ExtArgs> | null
    /**
     * The data needed to update a questprogressrequirements.
     */
    data: XOR<questprogressrequirementsUpdateInput, questprogressrequirementsUncheckedUpdateInput>
    /**
     * Choose, which questprogressrequirements to update.
     */
    where: questprogressrequirementsWhereUniqueInput
  }

  /**
   * questprogressrequirements updateMany
   */
  export type questprogressrequirementsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update questprogressrequirements.
     */
    data: XOR<questprogressrequirementsUpdateManyMutationInput, questprogressrequirementsUncheckedUpdateManyInput>
    /**
     * Filter which questprogressrequirements to update
     */
    where?: questprogressrequirementsWhereInput
  }

  /**
   * questprogressrequirements upsert
   */
  export type questprogressrequirementsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questprogressrequirements
     */
    select?: questprogressrequirementsSelect<ExtArgs> | null
    /**
     * The filter to search for the questprogressrequirements to update in case it exists.
     */
    where: questprogressrequirementsWhereUniqueInput
    /**
     * In case the questprogressrequirements found by the `where` argument doesn't exist, create a new questprogressrequirements with this data.
     */
    create: XOR<questprogressrequirementsCreateInput, questprogressrequirementsUncheckedCreateInput>
    /**
     * In case the questprogressrequirements was found with the provided `where` argument, update it with this data.
     */
    update: XOR<questprogressrequirementsUpdateInput, questprogressrequirementsUncheckedUpdateInput>
  }

  /**
   * questprogressrequirements delete
   */
  export type questprogressrequirementsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questprogressrequirements
     */
    select?: questprogressrequirementsSelect<ExtArgs> | null
    /**
     * Filter which questprogressrequirements to delete.
     */
    where: questprogressrequirementsWhereUniqueInput
  }

  /**
   * questprogressrequirements deleteMany
   */
  export type questprogressrequirementsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which questprogressrequirements to delete
     */
    where?: questprogressrequirementsWhereInput
  }

  /**
   * questprogressrequirements without action
   */
  export type questprogressrequirementsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questprogressrequirements
     */
    select?: questprogressrequirementsSelect<ExtArgs> | null
  }


  /**
   * Model quests
   */

  export type AggregateQuests = {
    _count: QuestsCountAggregateOutputType | null
    _avg: QuestsAvgAggregateOutputType | null
    _sum: QuestsSumAggregateOutputType | null
    _min: QuestsMinAggregateOutputType | null
    _max: QuestsMaxAggregateOutputType | null
  }

  export type QuestsAvgAggregateOutputType = {
    id: number | null
    qrkey: number | null
    status: number | null
  }

  export type QuestsSumAggregateOutputType = {
    id: bigint | null
    qrkey: number | null
    status: number | null
  }

  export type QuestsMinAggregateOutputType = {
    id: bigint | null
    qrkey: number | null
    qrvalue: string | null
    status: number | null
    completedtime: Date | null
    expireterm: Date | null
  }

  export type QuestsMaxAggregateOutputType = {
    id: bigint | null
    qrkey: number | null
    qrvalue: string | null
    status: number | null
    completedtime: Date | null
    expireterm: Date | null
  }

  export type QuestsCountAggregateOutputType = {
    id: number
    qrkey: number
    qrvalue: number
    status: number
    completedtime: number
    expireterm: number
    _all: number
  }


  export type QuestsAvgAggregateInputType = {
    id?: true
    qrkey?: true
    status?: true
  }

  export type QuestsSumAggregateInputType = {
    id?: true
    qrkey?: true
    status?: true
  }

  export type QuestsMinAggregateInputType = {
    id?: true
    qrkey?: true
    qrvalue?: true
    status?: true
    completedtime?: true
    expireterm?: true
  }

  export type QuestsMaxAggregateInputType = {
    id?: true
    qrkey?: true
    qrvalue?: true
    status?: true
    completedtime?: true
    expireterm?: true
  }

  export type QuestsCountAggregateInputType = {
    id?: true
    qrkey?: true
    qrvalue?: true
    status?: true
    completedtime?: true
    expireterm?: true
    _all?: true
  }

  export type QuestsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which quests to aggregate.
     */
    where?: questsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quests to fetch.
     */
    orderBy?: questsOrderByWithRelationInput | questsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: questsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned quests
    **/
    _count?: true | QuestsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuestsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuestsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestsMaxAggregateInputType
  }

  export type GetQuestsAggregateType<T extends QuestsAggregateArgs> = {
        [P in keyof T & keyof AggregateQuests]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuests[P]>
      : GetScalarType<T[P], AggregateQuests[P]>
  }




  export type questsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: questsWhereInput
    orderBy?: questsOrderByWithAggregationInput | questsOrderByWithAggregationInput[]
    by: QuestsScalarFieldEnum[] | QuestsScalarFieldEnum
    having?: questsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestsCountAggregateInputType | true
    _avg?: QuestsAvgAggregateInputType
    _sum?: QuestsSumAggregateInputType
    _min?: QuestsMinAggregateInputType
    _max?: QuestsMaxAggregateInputType
  }

  export type QuestsGroupByOutputType = {
    id: bigint
    qrkey: number | null
    qrvalue: string | null
    status: number | null
    completedtime: Date | null
    expireterm: Date | null
    _count: QuestsCountAggregateOutputType | null
    _avg: QuestsAvgAggregateOutputType | null
    _sum: QuestsSumAggregateOutputType | null
    _min: QuestsMinAggregateOutputType | null
    _max: QuestsMaxAggregateOutputType | null
  }

  type GetQuestsGroupByPayload<T extends questsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestsGroupByOutputType[P]>
            : GetScalarType<T[P], QuestsGroupByOutputType[P]>
        }
      >
    >


  export type questsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    qrkey?: boolean
    qrvalue?: boolean
    status?: boolean
    completedtime?: boolean
    expireterm?: boolean
  }, ExtArgs["result"]["quests"]>


  export type questsSelectScalar = {
    id?: boolean
    qrkey?: boolean
    qrvalue?: boolean
    status?: boolean
    completedtime?: boolean
    expireterm?: boolean
  }


  export type $questsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "quests"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      qrkey: number | null
      qrvalue: string | null
      status: number | null
      completedtime: Date | null
      expireterm: Date | null
    }, ExtArgs["result"]["quests"]>
    composites: {}
  }

  type questsGetPayload<S extends boolean | null | undefined | questsDefaultArgs> = $Result.GetResult<Prisma.$questsPayload, S>

  type questsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<questsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QuestsCountAggregateInputType | true
    }

  export interface questsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['quests'], meta: { name: 'quests' } }
    /**
     * Find zero or one Quests that matches the filter.
     * @param {questsFindUniqueArgs} args - Arguments to find a Quests
     * @example
     * // Get one Quests
     * const quests = await prisma.quests.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends questsFindUniqueArgs>(args: SelectSubset<T, questsFindUniqueArgs<ExtArgs>>): Prisma__questsClient<$Result.GetResult<Prisma.$questsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Quests that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {questsFindUniqueOrThrowArgs} args - Arguments to find a Quests
     * @example
     * // Get one Quests
     * const quests = await prisma.quests.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends questsFindUniqueOrThrowArgs>(args: SelectSubset<T, questsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__questsClient<$Result.GetResult<Prisma.$questsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Quests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questsFindFirstArgs} args - Arguments to find a Quests
     * @example
     * // Get one Quests
     * const quests = await prisma.quests.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends questsFindFirstArgs>(args?: SelectSubset<T, questsFindFirstArgs<ExtArgs>>): Prisma__questsClient<$Result.GetResult<Prisma.$questsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Quests that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questsFindFirstOrThrowArgs} args - Arguments to find a Quests
     * @example
     * // Get one Quests
     * const quests = await prisma.quests.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends questsFindFirstOrThrowArgs>(args?: SelectSubset<T, questsFindFirstOrThrowArgs<ExtArgs>>): Prisma__questsClient<$Result.GetResult<Prisma.$questsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Quests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Quests
     * const quests = await prisma.quests.findMany()
     * 
     * // Get first 10 Quests
     * const quests = await prisma.quests.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questsWithIdOnly = await prisma.quests.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends questsFindManyArgs>(args?: SelectSubset<T, questsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$questsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Quests.
     * @param {questsCreateArgs} args - Arguments to create a Quests.
     * @example
     * // Create one Quests
     * const Quests = await prisma.quests.create({
     *   data: {
     *     // ... data to create a Quests
     *   }
     * })
     * 
     */
    create<T extends questsCreateArgs>(args: SelectSubset<T, questsCreateArgs<ExtArgs>>): Prisma__questsClient<$Result.GetResult<Prisma.$questsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Quests.
     * @param {questsCreateManyArgs} args - Arguments to create many Quests.
     * @example
     * // Create many Quests
     * const quests = await prisma.quests.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends questsCreateManyArgs>(args?: SelectSubset<T, questsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Quests.
     * @param {questsDeleteArgs} args - Arguments to delete one Quests.
     * @example
     * // Delete one Quests
     * const Quests = await prisma.quests.delete({
     *   where: {
     *     // ... filter to delete one Quests
     *   }
     * })
     * 
     */
    delete<T extends questsDeleteArgs>(args: SelectSubset<T, questsDeleteArgs<ExtArgs>>): Prisma__questsClient<$Result.GetResult<Prisma.$questsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Quests.
     * @param {questsUpdateArgs} args - Arguments to update one Quests.
     * @example
     * // Update one Quests
     * const quests = await prisma.quests.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends questsUpdateArgs>(args: SelectSubset<T, questsUpdateArgs<ExtArgs>>): Prisma__questsClient<$Result.GetResult<Prisma.$questsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Quests.
     * @param {questsDeleteManyArgs} args - Arguments to filter Quests to delete.
     * @example
     * // Delete a few Quests
     * const { count } = await prisma.quests.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends questsDeleteManyArgs>(args?: SelectSubset<T, questsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Quests
     * const quests = await prisma.quests.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends questsUpdateManyArgs>(args: SelectSubset<T, questsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Quests.
     * @param {questsUpsertArgs} args - Arguments to update or create a Quests.
     * @example
     * // Update or create a Quests
     * const quests = await prisma.quests.upsert({
     *   create: {
     *     // ... data to create a Quests
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Quests we want to update
     *   }
     * })
     */
    upsert<T extends questsUpsertArgs>(args: SelectSubset<T, questsUpsertArgs<ExtArgs>>): Prisma__questsClient<$Result.GetResult<Prisma.$questsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Quests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questsCountArgs} args - Arguments to filter Quests to count.
     * @example
     * // Count the number of Quests
     * const count = await prisma.quests.count({
     *   where: {
     *     // ... the filter for the Quests we want to count
     *   }
     * })
    **/
    count<T extends questsCountArgs>(
      args?: Subset<T, questsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Quests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestsAggregateArgs>(args: Subset<T, QuestsAggregateArgs>): Prisma.PrismaPromise<GetQuestsAggregateType<T>>

    /**
     * Group by Quests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends questsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: questsGroupByArgs['orderBy'] }
        : { orderBy?: questsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, questsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the quests model
   */
  readonly fields: questsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for quests.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__questsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the quests model
   */ 
  interface questsFieldRefs {
    readonly id: FieldRef<"quests", 'BigInt'>
    readonly qrkey: FieldRef<"quests", 'Int'>
    readonly qrvalue: FieldRef<"quests", 'String'>
    readonly status: FieldRef<"quests", 'Int'>
    readonly completedtime: FieldRef<"quests", 'DateTime'>
    readonly expireterm: FieldRef<"quests", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * quests findUnique
   */
  export type questsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quests
     */
    select?: questsSelect<ExtArgs> | null
    /**
     * Filter, which quests to fetch.
     */
    where: questsWhereUniqueInput
  }

  /**
   * quests findUniqueOrThrow
   */
  export type questsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quests
     */
    select?: questsSelect<ExtArgs> | null
    /**
     * Filter, which quests to fetch.
     */
    where: questsWhereUniqueInput
  }

  /**
   * quests findFirst
   */
  export type questsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quests
     */
    select?: questsSelect<ExtArgs> | null
    /**
     * Filter, which quests to fetch.
     */
    where?: questsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quests to fetch.
     */
    orderBy?: questsOrderByWithRelationInput | questsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for quests.
     */
    cursor?: questsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of quests.
     */
    distinct?: QuestsScalarFieldEnum | QuestsScalarFieldEnum[]
  }

  /**
   * quests findFirstOrThrow
   */
  export type questsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quests
     */
    select?: questsSelect<ExtArgs> | null
    /**
     * Filter, which quests to fetch.
     */
    where?: questsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quests to fetch.
     */
    orderBy?: questsOrderByWithRelationInput | questsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for quests.
     */
    cursor?: questsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of quests.
     */
    distinct?: QuestsScalarFieldEnum | QuestsScalarFieldEnum[]
  }

  /**
   * quests findMany
   */
  export type questsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quests
     */
    select?: questsSelect<ExtArgs> | null
    /**
     * Filter, which quests to fetch.
     */
    where?: questsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quests to fetch.
     */
    orderBy?: questsOrderByWithRelationInput | questsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing quests.
     */
    cursor?: questsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quests.
     */
    skip?: number
    distinct?: QuestsScalarFieldEnum | QuestsScalarFieldEnum[]
  }

  /**
   * quests create
   */
  export type questsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quests
     */
    select?: questsSelect<ExtArgs> | null
    /**
     * The data needed to create a quests.
     */
    data?: XOR<questsCreateInput, questsUncheckedCreateInput>
  }

  /**
   * quests createMany
   */
  export type questsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many quests.
     */
    data: questsCreateManyInput | questsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * quests update
   */
  export type questsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quests
     */
    select?: questsSelect<ExtArgs> | null
    /**
     * The data needed to update a quests.
     */
    data: XOR<questsUpdateInput, questsUncheckedUpdateInput>
    /**
     * Choose, which quests to update.
     */
    where: questsWhereUniqueInput
  }

  /**
   * quests updateMany
   */
  export type questsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update quests.
     */
    data: XOR<questsUpdateManyMutationInput, questsUncheckedUpdateManyInput>
    /**
     * Filter which quests to update
     */
    where?: questsWhereInput
  }

  /**
   * quests upsert
   */
  export type questsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quests
     */
    select?: questsSelect<ExtArgs> | null
    /**
     * The filter to search for the quests to update in case it exists.
     */
    where: questsWhereUniqueInput
    /**
     * In case the quests found by the `where` argument doesn't exist, create a new quests with this data.
     */
    create: XOR<questsCreateInput, questsUncheckedCreateInput>
    /**
     * In case the quests was found with the provided `where` argument, update it with this data.
     */
    update: XOR<questsUpdateInput, questsUncheckedUpdateInput>
  }

  /**
   * quests delete
   */
  export type questsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quests
     */
    select?: questsSelect<ExtArgs> | null
    /**
     * Filter which quests to delete.
     */
    where: questsWhereUniqueInput
  }

  /**
   * quests deleteMany
   */
  export type questsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which quests to delete
     */
    where?: questsWhereInput
  }

  /**
   * quests without action
   */
  export type questsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quests
     */
    select?: questsSelect<ExtArgs> | null
  }


  /**
   * Model rewardinfo
   */

  export type AggregateRewardinfo = {
    _count: RewardinfoCountAggregateOutputType | null
    _avg: RewardinfoAvgAggregateOutputType | null
    _sum: RewardinfoSumAggregateOutputType | null
    _min: RewardinfoMinAggregateOutputType | null
    _max: RewardinfoMaxAggregateOutputType | null
  }

  export type RewardinfoAvgAggregateOutputType = {
    id: number | null
    charid: number | null
    itemID: number | null
    quantity: number | null
    maplePoint: number | null
    meso: number | null
    level: number | null
    exp: number | null
  }

  export type RewardinfoSumAggregateOutputType = {
    id: number | null
    charid: number | null
    itemID: number | null
    quantity: number | null
    maplePoint: number | null
    meso: number | null
    level: number | null
    exp: number | null
  }

  export type RewardinfoMinAggregateOutputType = {
    id: number | null
    charid: number | null
    charname: string | null
    rewardItemType: boolean | null
    itemID: number | null
    quantity: number | null
    maplePoint: number | null
    meso: number | null
    level: number | null
    exp: number | null
    description: string | null
    starttime: Date | null
    endtime: Date | null
  }

  export type RewardinfoMaxAggregateOutputType = {
    id: number | null
    charid: number | null
    charname: string | null
    rewardItemType: boolean | null
    itemID: number | null
    quantity: number | null
    maplePoint: number | null
    meso: number | null
    level: number | null
    exp: number | null
    description: string | null
    starttime: Date | null
    endtime: Date | null
  }

  export type RewardinfoCountAggregateOutputType = {
    id: number
    charid: number
    charname: number
    rewardItemType: number
    itemID: number
    quantity: number
    maplePoint: number
    meso: number
    level: number
    exp: number
    description: number
    starttime: number
    endtime: number
    _all: number
  }


  export type RewardinfoAvgAggregateInputType = {
    id?: true
    charid?: true
    itemID?: true
    quantity?: true
    maplePoint?: true
    meso?: true
    level?: true
    exp?: true
  }

  export type RewardinfoSumAggregateInputType = {
    id?: true
    charid?: true
    itemID?: true
    quantity?: true
    maplePoint?: true
    meso?: true
    level?: true
    exp?: true
  }

  export type RewardinfoMinAggregateInputType = {
    id?: true
    charid?: true
    charname?: true
    rewardItemType?: true
    itemID?: true
    quantity?: true
    maplePoint?: true
    meso?: true
    level?: true
    exp?: true
    description?: true
    starttime?: true
    endtime?: true
  }

  export type RewardinfoMaxAggregateInputType = {
    id?: true
    charid?: true
    charname?: true
    rewardItemType?: true
    itemID?: true
    quantity?: true
    maplePoint?: true
    meso?: true
    level?: true
    exp?: true
    description?: true
    starttime?: true
    endtime?: true
  }

  export type RewardinfoCountAggregateInputType = {
    id?: true
    charid?: true
    charname?: true
    rewardItemType?: true
    itemID?: true
    quantity?: true
    maplePoint?: true
    meso?: true
    level?: true
    exp?: true
    description?: true
    starttime?: true
    endtime?: true
    _all?: true
  }

  export type RewardinfoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rewardinfo to aggregate.
     */
    where?: rewardinfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rewardinfos to fetch.
     */
    orderBy?: rewardinfoOrderByWithRelationInput | rewardinfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: rewardinfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rewardinfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rewardinfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned rewardinfos
    **/
    _count?: true | RewardinfoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RewardinfoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RewardinfoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RewardinfoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RewardinfoMaxAggregateInputType
  }

  export type GetRewardinfoAggregateType<T extends RewardinfoAggregateArgs> = {
        [P in keyof T & keyof AggregateRewardinfo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRewardinfo[P]>
      : GetScalarType<T[P], AggregateRewardinfo[P]>
  }




  export type rewardinfoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rewardinfoWhereInput
    orderBy?: rewardinfoOrderByWithAggregationInput | rewardinfoOrderByWithAggregationInput[]
    by: RewardinfoScalarFieldEnum[] | RewardinfoScalarFieldEnum
    having?: rewardinfoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RewardinfoCountAggregateInputType | true
    _avg?: RewardinfoAvgAggregateInputType
    _sum?: RewardinfoSumAggregateInputType
    _min?: RewardinfoMinAggregateInputType
    _max?: RewardinfoMaxAggregateInputType
  }

  export type RewardinfoGroupByOutputType = {
    id: number
    charid: number
    charname: string
    rewardItemType: boolean
    itemID: number
    quantity: number
    maplePoint: number
    meso: number
    level: number
    exp: number
    description: string
    starttime: Date | null
    endtime: Date | null
    _count: RewardinfoCountAggregateOutputType | null
    _avg: RewardinfoAvgAggregateOutputType | null
    _sum: RewardinfoSumAggregateOutputType | null
    _min: RewardinfoMinAggregateOutputType | null
    _max: RewardinfoMaxAggregateOutputType | null
  }

  type GetRewardinfoGroupByPayload<T extends rewardinfoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RewardinfoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RewardinfoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RewardinfoGroupByOutputType[P]>
            : GetScalarType<T[P], RewardinfoGroupByOutputType[P]>
        }
      >
    >


  export type rewardinfoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    charid?: boolean
    charname?: boolean
    rewardItemType?: boolean
    itemID?: boolean
    quantity?: boolean
    maplePoint?: boolean
    meso?: boolean
    level?: boolean
    exp?: boolean
    description?: boolean
    starttime?: boolean
    endtime?: boolean
  }, ExtArgs["result"]["rewardinfo"]>


  export type rewardinfoSelectScalar = {
    id?: boolean
    charid?: boolean
    charname?: boolean
    rewardItemType?: boolean
    itemID?: boolean
    quantity?: boolean
    maplePoint?: boolean
    meso?: boolean
    level?: boolean
    exp?: boolean
    description?: boolean
    starttime?: boolean
    endtime?: boolean
  }


  export type $rewardinfoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "rewardinfo"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      charid: number
      charname: string
      rewardItemType: boolean
      itemID: number
      quantity: number
      maplePoint: number
      meso: number
      level: number
      exp: number
      description: string
      starttime: Date | null
      endtime: Date | null
    }, ExtArgs["result"]["rewardinfo"]>
    composites: {}
  }

  type rewardinfoGetPayload<S extends boolean | null | undefined | rewardinfoDefaultArgs> = $Result.GetResult<Prisma.$rewardinfoPayload, S>

  type rewardinfoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<rewardinfoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RewardinfoCountAggregateInputType | true
    }

  export interface rewardinfoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['rewardinfo'], meta: { name: 'rewardinfo' } }
    /**
     * Find zero or one Rewardinfo that matches the filter.
     * @param {rewardinfoFindUniqueArgs} args - Arguments to find a Rewardinfo
     * @example
     * // Get one Rewardinfo
     * const rewardinfo = await prisma.rewardinfo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends rewardinfoFindUniqueArgs>(args: SelectSubset<T, rewardinfoFindUniqueArgs<ExtArgs>>): Prisma__rewardinfoClient<$Result.GetResult<Prisma.$rewardinfoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Rewardinfo that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {rewardinfoFindUniqueOrThrowArgs} args - Arguments to find a Rewardinfo
     * @example
     * // Get one Rewardinfo
     * const rewardinfo = await prisma.rewardinfo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends rewardinfoFindUniqueOrThrowArgs>(args: SelectSubset<T, rewardinfoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__rewardinfoClient<$Result.GetResult<Prisma.$rewardinfoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Rewardinfo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rewardinfoFindFirstArgs} args - Arguments to find a Rewardinfo
     * @example
     * // Get one Rewardinfo
     * const rewardinfo = await prisma.rewardinfo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends rewardinfoFindFirstArgs>(args?: SelectSubset<T, rewardinfoFindFirstArgs<ExtArgs>>): Prisma__rewardinfoClient<$Result.GetResult<Prisma.$rewardinfoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Rewardinfo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rewardinfoFindFirstOrThrowArgs} args - Arguments to find a Rewardinfo
     * @example
     * // Get one Rewardinfo
     * const rewardinfo = await prisma.rewardinfo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends rewardinfoFindFirstOrThrowArgs>(args?: SelectSubset<T, rewardinfoFindFirstOrThrowArgs<ExtArgs>>): Prisma__rewardinfoClient<$Result.GetResult<Prisma.$rewardinfoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Rewardinfos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rewardinfoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rewardinfos
     * const rewardinfos = await prisma.rewardinfo.findMany()
     * 
     * // Get first 10 Rewardinfos
     * const rewardinfos = await prisma.rewardinfo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rewardinfoWithIdOnly = await prisma.rewardinfo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends rewardinfoFindManyArgs>(args?: SelectSubset<T, rewardinfoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rewardinfoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Rewardinfo.
     * @param {rewardinfoCreateArgs} args - Arguments to create a Rewardinfo.
     * @example
     * // Create one Rewardinfo
     * const Rewardinfo = await prisma.rewardinfo.create({
     *   data: {
     *     // ... data to create a Rewardinfo
     *   }
     * })
     * 
     */
    create<T extends rewardinfoCreateArgs>(args: SelectSubset<T, rewardinfoCreateArgs<ExtArgs>>): Prisma__rewardinfoClient<$Result.GetResult<Prisma.$rewardinfoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Rewardinfos.
     * @param {rewardinfoCreateManyArgs} args - Arguments to create many Rewardinfos.
     * @example
     * // Create many Rewardinfos
     * const rewardinfo = await prisma.rewardinfo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends rewardinfoCreateManyArgs>(args?: SelectSubset<T, rewardinfoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Rewardinfo.
     * @param {rewardinfoDeleteArgs} args - Arguments to delete one Rewardinfo.
     * @example
     * // Delete one Rewardinfo
     * const Rewardinfo = await prisma.rewardinfo.delete({
     *   where: {
     *     // ... filter to delete one Rewardinfo
     *   }
     * })
     * 
     */
    delete<T extends rewardinfoDeleteArgs>(args: SelectSubset<T, rewardinfoDeleteArgs<ExtArgs>>): Prisma__rewardinfoClient<$Result.GetResult<Prisma.$rewardinfoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Rewardinfo.
     * @param {rewardinfoUpdateArgs} args - Arguments to update one Rewardinfo.
     * @example
     * // Update one Rewardinfo
     * const rewardinfo = await prisma.rewardinfo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends rewardinfoUpdateArgs>(args: SelectSubset<T, rewardinfoUpdateArgs<ExtArgs>>): Prisma__rewardinfoClient<$Result.GetResult<Prisma.$rewardinfoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Rewardinfos.
     * @param {rewardinfoDeleteManyArgs} args - Arguments to filter Rewardinfos to delete.
     * @example
     * // Delete a few Rewardinfos
     * const { count } = await prisma.rewardinfo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends rewardinfoDeleteManyArgs>(args?: SelectSubset<T, rewardinfoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rewardinfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rewardinfoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rewardinfos
     * const rewardinfo = await prisma.rewardinfo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends rewardinfoUpdateManyArgs>(args: SelectSubset<T, rewardinfoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Rewardinfo.
     * @param {rewardinfoUpsertArgs} args - Arguments to update or create a Rewardinfo.
     * @example
     * // Update or create a Rewardinfo
     * const rewardinfo = await prisma.rewardinfo.upsert({
     *   create: {
     *     // ... data to create a Rewardinfo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rewardinfo we want to update
     *   }
     * })
     */
    upsert<T extends rewardinfoUpsertArgs>(args: SelectSubset<T, rewardinfoUpsertArgs<ExtArgs>>): Prisma__rewardinfoClient<$Result.GetResult<Prisma.$rewardinfoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Rewardinfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rewardinfoCountArgs} args - Arguments to filter Rewardinfos to count.
     * @example
     * // Count the number of Rewardinfos
     * const count = await prisma.rewardinfo.count({
     *   where: {
     *     // ... the filter for the Rewardinfos we want to count
     *   }
     * })
    **/
    count<T extends rewardinfoCountArgs>(
      args?: Subset<T, rewardinfoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RewardinfoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rewardinfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardinfoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RewardinfoAggregateArgs>(args: Subset<T, RewardinfoAggregateArgs>): Prisma.PrismaPromise<GetRewardinfoAggregateType<T>>

    /**
     * Group by Rewardinfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rewardinfoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends rewardinfoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: rewardinfoGroupByArgs['orderBy'] }
        : { orderBy?: rewardinfoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, rewardinfoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRewardinfoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the rewardinfo model
   */
  readonly fields: rewardinfoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for rewardinfo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__rewardinfoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the rewardinfo model
   */ 
  interface rewardinfoFieldRefs {
    readonly id: FieldRef<"rewardinfo", 'Int'>
    readonly charid: FieldRef<"rewardinfo", 'Int'>
    readonly charname: FieldRef<"rewardinfo", 'String'>
    readonly rewardItemType: FieldRef<"rewardinfo", 'Boolean'>
    readonly itemID: FieldRef<"rewardinfo", 'Int'>
    readonly quantity: FieldRef<"rewardinfo", 'Int'>
    readonly maplePoint: FieldRef<"rewardinfo", 'Int'>
    readonly meso: FieldRef<"rewardinfo", 'Int'>
    readonly level: FieldRef<"rewardinfo", 'Int'>
    readonly exp: FieldRef<"rewardinfo", 'Int'>
    readonly description: FieldRef<"rewardinfo", 'String'>
    readonly starttime: FieldRef<"rewardinfo", 'DateTime'>
    readonly endtime: FieldRef<"rewardinfo", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * rewardinfo findUnique
   */
  export type rewardinfoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rewardinfo
     */
    select?: rewardinfoSelect<ExtArgs> | null
    /**
     * Filter, which rewardinfo to fetch.
     */
    where: rewardinfoWhereUniqueInput
  }

  /**
   * rewardinfo findUniqueOrThrow
   */
  export type rewardinfoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rewardinfo
     */
    select?: rewardinfoSelect<ExtArgs> | null
    /**
     * Filter, which rewardinfo to fetch.
     */
    where: rewardinfoWhereUniqueInput
  }

  /**
   * rewardinfo findFirst
   */
  export type rewardinfoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rewardinfo
     */
    select?: rewardinfoSelect<ExtArgs> | null
    /**
     * Filter, which rewardinfo to fetch.
     */
    where?: rewardinfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rewardinfos to fetch.
     */
    orderBy?: rewardinfoOrderByWithRelationInput | rewardinfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rewardinfos.
     */
    cursor?: rewardinfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rewardinfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rewardinfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rewardinfos.
     */
    distinct?: RewardinfoScalarFieldEnum | RewardinfoScalarFieldEnum[]
  }

  /**
   * rewardinfo findFirstOrThrow
   */
  export type rewardinfoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rewardinfo
     */
    select?: rewardinfoSelect<ExtArgs> | null
    /**
     * Filter, which rewardinfo to fetch.
     */
    where?: rewardinfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rewardinfos to fetch.
     */
    orderBy?: rewardinfoOrderByWithRelationInput | rewardinfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rewardinfos.
     */
    cursor?: rewardinfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rewardinfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rewardinfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rewardinfos.
     */
    distinct?: RewardinfoScalarFieldEnum | RewardinfoScalarFieldEnum[]
  }

  /**
   * rewardinfo findMany
   */
  export type rewardinfoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rewardinfo
     */
    select?: rewardinfoSelect<ExtArgs> | null
    /**
     * Filter, which rewardinfos to fetch.
     */
    where?: rewardinfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rewardinfos to fetch.
     */
    orderBy?: rewardinfoOrderByWithRelationInput | rewardinfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing rewardinfos.
     */
    cursor?: rewardinfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rewardinfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rewardinfos.
     */
    skip?: number
    distinct?: RewardinfoScalarFieldEnum | RewardinfoScalarFieldEnum[]
  }

  /**
   * rewardinfo create
   */
  export type rewardinfoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rewardinfo
     */
    select?: rewardinfoSelect<ExtArgs> | null
    /**
     * The data needed to create a rewardinfo.
     */
    data: XOR<rewardinfoCreateInput, rewardinfoUncheckedCreateInput>
  }

  /**
   * rewardinfo createMany
   */
  export type rewardinfoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many rewardinfos.
     */
    data: rewardinfoCreateManyInput | rewardinfoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * rewardinfo update
   */
  export type rewardinfoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rewardinfo
     */
    select?: rewardinfoSelect<ExtArgs> | null
    /**
     * The data needed to update a rewardinfo.
     */
    data: XOR<rewardinfoUpdateInput, rewardinfoUncheckedUpdateInput>
    /**
     * Choose, which rewardinfo to update.
     */
    where: rewardinfoWhereUniqueInput
  }

  /**
   * rewardinfo updateMany
   */
  export type rewardinfoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update rewardinfos.
     */
    data: XOR<rewardinfoUpdateManyMutationInput, rewardinfoUncheckedUpdateManyInput>
    /**
     * Filter which rewardinfos to update
     */
    where?: rewardinfoWhereInput
  }

  /**
   * rewardinfo upsert
   */
  export type rewardinfoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rewardinfo
     */
    select?: rewardinfoSelect<ExtArgs> | null
    /**
     * The filter to search for the rewardinfo to update in case it exists.
     */
    where: rewardinfoWhereUniqueInput
    /**
     * In case the rewardinfo found by the `where` argument doesn't exist, create a new rewardinfo with this data.
     */
    create: XOR<rewardinfoCreateInput, rewardinfoUncheckedCreateInput>
    /**
     * In case the rewardinfo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<rewardinfoUpdateInput, rewardinfoUncheckedUpdateInput>
  }

  /**
   * rewardinfo delete
   */
  export type rewardinfoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rewardinfo
     */
    select?: rewardinfoSelect<ExtArgs> | null
    /**
     * Filter which rewardinfo to delete.
     */
    where: rewardinfoWhereUniqueInput
  }

  /**
   * rewardinfo deleteMany
   */
  export type rewardinfoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rewardinfos to delete
     */
    where?: rewardinfoWhereInput
  }

  /**
   * rewardinfo without action
   */
  export type rewardinfoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rewardinfo
     */
    select?: rewardinfoSelect<ExtArgs> | null
  }


  /**
   * Model shopitems
   */

  export type AggregateShopitems = {
    _count: ShopitemsCountAggregateOutputType | null
    _avg: ShopitemsAvgAggregateOutputType | null
    _sum: ShopitemsSumAggregateOutputType | null
    _min: ShopitemsMinAggregateOutputType | null
    _max: ShopitemsMaxAggregateOutputType | null
  }

  export type ShopitemsAvgAggregateOutputType = {
    id: number | null
    shopid: number | null
    itemid: number | null
    price: number | null
    tokenitemid: number | null
    tokenprice: number | null
    pointquestid: number | null
    pointprice: number | null
    starcoin: number | null
    questexid: number | null
    questexvalue: number | null
    itemperiod: number | null
    levellimited: number | null
    showlevmin: number | null
    showlevmax: number | null
    questid: number | null
    tabindex: number | null
    potentialgrade: number | null
    buylimit: number | null
    quantity: number | null
    unitprice: number | null
    maxperslot: number | null
    discountperc: number | null
  }

  export type ShopitemsSumAggregateOutputType = {
    id: bigint | null
    shopid: number | null
    itemid: number | null
    price: number | null
    tokenitemid: number | null
    tokenprice: number | null
    pointquestid: number | null
    pointprice: number | null
    starcoin: number | null
    questexid: number | null
    questexvalue: number | null
    itemperiod: number | null
    levellimited: number | null
    showlevmin: number | null
    showlevmax: number | null
    questid: number | null
    tabindex: number | null
    potentialgrade: number | null
    buylimit: number | null
    quantity: number | null
    unitprice: bigint | null
    maxperslot: number | null
    discountperc: number | null
  }

  export type ShopitemsMinAggregateOutputType = {
    id: bigint | null
    shopid: number | null
    itemid: number | null
    price: number | null
    tokenitemid: number | null
    tokenprice: number | null
    pointquestid: number | null
    pointprice: number | null
    starcoin: number | null
    questexid: number | null
    questexkey: string | null
    questexvalue: number | null
    itemperiod: number | null
    levellimited: number | null
    showlevmin: number | null
    showlevmax: number | null
    questid: number | null
    sellstart: Date | null
    sellend: Date | null
    tabindex: number | null
    worldblock: boolean | null
    potentialgrade: number | null
    buylimit: number | null
    quantity: number | null
    unitprice: bigint | null
    maxperslot: number | null
    discountperc: number | null
  }

  export type ShopitemsMaxAggregateOutputType = {
    id: bigint | null
    shopid: number | null
    itemid: number | null
    price: number | null
    tokenitemid: number | null
    tokenprice: number | null
    pointquestid: number | null
    pointprice: number | null
    starcoin: number | null
    questexid: number | null
    questexkey: string | null
    questexvalue: number | null
    itemperiod: number | null
    levellimited: number | null
    showlevmin: number | null
    showlevmax: number | null
    questid: number | null
    sellstart: Date | null
    sellend: Date | null
    tabindex: number | null
    worldblock: boolean | null
    potentialgrade: number | null
    buylimit: number | null
    quantity: number | null
    unitprice: bigint | null
    maxperslot: number | null
    discountperc: number | null
  }

  export type ShopitemsCountAggregateOutputType = {
    id: number
    shopid: number
    itemid: number
    price: number
    tokenitemid: number
    tokenprice: number
    pointquestid: number
    pointprice: number
    starcoin: number
    questexid: number
    questexkey: number
    questexvalue: number
    itemperiod: number
    levellimited: number
    showlevmin: number
    showlevmax: number
    questid: number
    sellstart: number
    sellend: number
    tabindex: number
    worldblock: number
    potentialgrade: number
    buylimit: number
    quantity: number
    unitprice: number
    maxperslot: number
    discountperc: number
    _all: number
  }


  export type ShopitemsAvgAggregateInputType = {
    id?: true
    shopid?: true
    itemid?: true
    price?: true
    tokenitemid?: true
    tokenprice?: true
    pointquestid?: true
    pointprice?: true
    starcoin?: true
    questexid?: true
    questexvalue?: true
    itemperiod?: true
    levellimited?: true
    showlevmin?: true
    showlevmax?: true
    questid?: true
    tabindex?: true
    potentialgrade?: true
    buylimit?: true
    quantity?: true
    unitprice?: true
    maxperslot?: true
    discountperc?: true
  }

  export type ShopitemsSumAggregateInputType = {
    id?: true
    shopid?: true
    itemid?: true
    price?: true
    tokenitemid?: true
    tokenprice?: true
    pointquestid?: true
    pointprice?: true
    starcoin?: true
    questexid?: true
    questexvalue?: true
    itemperiod?: true
    levellimited?: true
    showlevmin?: true
    showlevmax?: true
    questid?: true
    tabindex?: true
    potentialgrade?: true
    buylimit?: true
    quantity?: true
    unitprice?: true
    maxperslot?: true
    discountperc?: true
  }

  export type ShopitemsMinAggregateInputType = {
    id?: true
    shopid?: true
    itemid?: true
    price?: true
    tokenitemid?: true
    tokenprice?: true
    pointquestid?: true
    pointprice?: true
    starcoin?: true
    questexid?: true
    questexkey?: true
    questexvalue?: true
    itemperiod?: true
    levellimited?: true
    showlevmin?: true
    showlevmax?: true
    questid?: true
    sellstart?: true
    sellend?: true
    tabindex?: true
    worldblock?: true
    potentialgrade?: true
    buylimit?: true
    quantity?: true
    unitprice?: true
    maxperslot?: true
    discountperc?: true
  }

  export type ShopitemsMaxAggregateInputType = {
    id?: true
    shopid?: true
    itemid?: true
    price?: true
    tokenitemid?: true
    tokenprice?: true
    pointquestid?: true
    pointprice?: true
    starcoin?: true
    questexid?: true
    questexkey?: true
    questexvalue?: true
    itemperiod?: true
    levellimited?: true
    showlevmin?: true
    showlevmax?: true
    questid?: true
    sellstart?: true
    sellend?: true
    tabindex?: true
    worldblock?: true
    potentialgrade?: true
    buylimit?: true
    quantity?: true
    unitprice?: true
    maxperslot?: true
    discountperc?: true
  }

  export type ShopitemsCountAggregateInputType = {
    id?: true
    shopid?: true
    itemid?: true
    price?: true
    tokenitemid?: true
    tokenprice?: true
    pointquestid?: true
    pointprice?: true
    starcoin?: true
    questexid?: true
    questexkey?: true
    questexvalue?: true
    itemperiod?: true
    levellimited?: true
    showlevmin?: true
    showlevmax?: true
    questid?: true
    sellstart?: true
    sellend?: true
    tabindex?: true
    worldblock?: true
    potentialgrade?: true
    buylimit?: true
    quantity?: true
    unitprice?: true
    maxperslot?: true
    discountperc?: true
    _all?: true
  }

  export type ShopitemsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which shopitems to aggregate.
     */
    where?: shopitemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of shopitems to fetch.
     */
    orderBy?: shopitemsOrderByWithRelationInput | shopitemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: shopitemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` shopitems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` shopitems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned shopitems
    **/
    _count?: true | ShopitemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShopitemsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShopitemsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShopitemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShopitemsMaxAggregateInputType
  }

  export type GetShopitemsAggregateType<T extends ShopitemsAggregateArgs> = {
        [P in keyof T & keyof AggregateShopitems]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShopitems[P]>
      : GetScalarType<T[P], AggregateShopitems[P]>
  }




  export type shopitemsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: shopitemsWhereInput
    orderBy?: shopitemsOrderByWithAggregationInput | shopitemsOrderByWithAggregationInput[]
    by: ShopitemsScalarFieldEnum[] | ShopitemsScalarFieldEnum
    having?: shopitemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShopitemsCountAggregateInputType | true
    _avg?: ShopitemsAvgAggregateInputType
    _sum?: ShopitemsSumAggregateInputType
    _min?: ShopitemsMinAggregateInputType
    _max?: ShopitemsMaxAggregateInputType
  }

  export type ShopitemsGroupByOutputType = {
    id: bigint
    shopid: number | null
    itemid: number | null
    price: number | null
    tokenitemid: number | null
    tokenprice: number | null
    pointquestid: number | null
    pointprice: number | null
    starcoin: number | null
    questexid: number | null
    questexkey: string | null
    questexvalue: number | null
    itemperiod: number | null
    levellimited: number | null
    showlevmin: number | null
    showlevmax: number | null
    questid: number | null
    sellstart: Date | null
    sellend: Date | null
    tabindex: number | null
    worldblock: boolean | null
    potentialgrade: number | null
    buylimit: number | null
    quantity: number | null
    unitprice: bigint | null
    maxperslot: number | null
    discountperc: number | null
    _count: ShopitemsCountAggregateOutputType | null
    _avg: ShopitemsAvgAggregateOutputType | null
    _sum: ShopitemsSumAggregateOutputType | null
    _min: ShopitemsMinAggregateOutputType | null
    _max: ShopitemsMaxAggregateOutputType | null
  }

  type GetShopitemsGroupByPayload<T extends shopitemsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShopitemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShopitemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShopitemsGroupByOutputType[P]>
            : GetScalarType<T[P], ShopitemsGroupByOutputType[P]>
        }
      >
    >


  export type shopitemsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shopid?: boolean
    itemid?: boolean
    price?: boolean
    tokenitemid?: boolean
    tokenprice?: boolean
    pointquestid?: boolean
    pointprice?: boolean
    starcoin?: boolean
    questexid?: boolean
    questexkey?: boolean
    questexvalue?: boolean
    itemperiod?: boolean
    levellimited?: boolean
    showlevmin?: boolean
    showlevmax?: boolean
    questid?: boolean
    sellstart?: boolean
    sellend?: boolean
    tabindex?: boolean
    worldblock?: boolean
    potentialgrade?: boolean
    buylimit?: boolean
    quantity?: boolean
    unitprice?: boolean
    maxperslot?: boolean
    discountperc?: boolean
  }, ExtArgs["result"]["shopitems"]>


  export type shopitemsSelectScalar = {
    id?: boolean
    shopid?: boolean
    itemid?: boolean
    price?: boolean
    tokenitemid?: boolean
    tokenprice?: boolean
    pointquestid?: boolean
    pointprice?: boolean
    starcoin?: boolean
    questexid?: boolean
    questexkey?: boolean
    questexvalue?: boolean
    itemperiod?: boolean
    levellimited?: boolean
    showlevmin?: boolean
    showlevmax?: boolean
    questid?: boolean
    sellstart?: boolean
    sellend?: boolean
    tabindex?: boolean
    worldblock?: boolean
    potentialgrade?: boolean
    buylimit?: boolean
    quantity?: boolean
    unitprice?: boolean
    maxperslot?: boolean
    discountperc?: boolean
  }


  export type $shopitemsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "shopitems"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      shopid: number | null
      itemid: number | null
      price: number | null
      tokenitemid: number | null
      tokenprice: number | null
      pointquestid: number | null
      pointprice: number | null
      starcoin: number | null
      questexid: number | null
      questexkey: string | null
      questexvalue: number | null
      itemperiod: number | null
      levellimited: number | null
      showlevmin: number | null
      showlevmax: number | null
      questid: number | null
      sellstart: Date | null
      sellend: Date | null
      tabindex: number | null
      worldblock: boolean | null
      potentialgrade: number | null
      buylimit: number | null
      quantity: number | null
      unitprice: bigint | null
      maxperslot: number | null
      discountperc: number | null
    }, ExtArgs["result"]["shopitems"]>
    composites: {}
  }

  type shopitemsGetPayload<S extends boolean | null | undefined | shopitemsDefaultArgs> = $Result.GetResult<Prisma.$shopitemsPayload, S>

  type shopitemsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<shopitemsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ShopitemsCountAggregateInputType | true
    }

  export interface shopitemsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['shopitems'], meta: { name: 'shopitems' } }
    /**
     * Find zero or one Shopitems that matches the filter.
     * @param {shopitemsFindUniqueArgs} args - Arguments to find a Shopitems
     * @example
     * // Get one Shopitems
     * const shopitems = await prisma.shopitems.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends shopitemsFindUniqueArgs>(args: SelectSubset<T, shopitemsFindUniqueArgs<ExtArgs>>): Prisma__shopitemsClient<$Result.GetResult<Prisma.$shopitemsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Shopitems that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {shopitemsFindUniqueOrThrowArgs} args - Arguments to find a Shopitems
     * @example
     * // Get one Shopitems
     * const shopitems = await prisma.shopitems.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends shopitemsFindUniqueOrThrowArgs>(args: SelectSubset<T, shopitemsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__shopitemsClient<$Result.GetResult<Prisma.$shopitemsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Shopitems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shopitemsFindFirstArgs} args - Arguments to find a Shopitems
     * @example
     * // Get one Shopitems
     * const shopitems = await prisma.shopitems.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends shopitemsFindFirstArgs>(args?: SelectSubset<T, shopitemsFindFirstArgs<ExtArgs>>): Prisma__shopitemsClient<$Result.GetResult<Prisma.$shopitemsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Shopitems that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shopitemsFindFirstOrThrowArgs} args - Arguments to find a Shopitems
     * @example
     * // Get one Shopitems
     * const shopitems = await prisma.shopitems.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends shopitemsFindFirstOrThrowArgs>(args?: SelectSubset<T, shopitemsFindFirstOrThrowArgs<ExtArgs>>): Prisma__shopitemsClient<$Result.GetResult<Prisma.$shopitemsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Shopitems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shopitemsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Shopitems
     * const shopitems = await prisma.shopitems.findMany()
     * 
     * // Get first 10 Shopitems
     * const shopitems = await prisma.shopitems.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shopitemsWithIdOnly = await prisma.shopitems.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends shopitemsFindManyArgs>(args?: SelectSubset<T, shopitemsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopitemsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Shopitems.
     * @param {shopitemsCreateArgs} args - Arguments to create a Shopitems.
     * @example
     * // Create one Shopitems
     * const Shopitems = await prisma.shopitems.create({
     *   data: {
     *     // ... data to create a Shopitems
     *   }
     * })
     * 
     */
    create<T extends shopitemsCreateArgs>(args: SelectSubset<T, shopitemsCreateArgs<ExtArgs>>): Prisma__shopitemsClient<$Result.GetResult<Prisma.$shopitemsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Shopitems.
     * @param {shopitemsCreateManyArgs} args - Arguments to create many Shopitems.
     * @example
     * // Create many Shopitems
     * const shopitems = await prisma.shopitems.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends shopitemsCreateManyArgs>(args?: SelectSubset<T, shopitemsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Shopitems.
     * @param {shopitemsDeleteArgs} args - Arguments to delete one Shopitems.
     * @example
     * // Delete one Shopitems
     * const Shopitems = await prisma.shopitems.delete({
     *   where: {
     *     // ... filter to delete one Shopitems
     *   }
     * })
     * 
     */
    delete<T extends shopitemsDeleteArgs>(args: SelectSubset<T, shopitemsDeleteArgs<ExtArgs>>): Prisma__shopitemsClient<$Result.GetResult<Prisma.$shopitemsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Shopitems.
     * @param {shopitemsUpdateArgs} args - Arguments to update one Shopitems.
     * @example
     * // Update one Shopitems
     * const shopitems = await prisma.shopitems.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends shopitemsUpdateArgs>(args: SelectSubset<T, shopitemsUpdateArgs<ExtArgs>>): Prisma__shopitemsClient<$Result.GetResult<Prisma.$shopitemsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Shopitems.
     * @param {shopitemsDeleteManyArgs} args - Arguments to filter Shopitems to delete.
     * @example
     * // Delete a few Shopitems
     * const { count } = await prisma.shopitems.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends shopitemsDeleteManyArgs>(args?: SelectSubset<T, shopitemsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shopitems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shopitemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Shopitems
     * const shopitems = await prisma.shopitems.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends shopitemsUpdateManyArgs>(args: SelectSubset<T, shopitemsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Shopitems.
     * @param {shopitemsUpsertArgs} args - Arguments to update or create a Shopitems.
     * @example
     * // Update or create a Shopitems
     * const shopitems = await prisma.shopitems.upsert({
     *   create: {
     *     // ... data to create a Shopitems
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Shopitems we want to update
     *   }
     * })
     */
    upsert<T extends shopitemsUpsertArgs>(args: SelectSubset<T, shopitemsUpsertArgs<ExtArgs>>): Prisma__shopitemsClient<$Result.GetResult<Prisma.$shopitemsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Shopitems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shopitemsCountArgs} args - Arguments to filter Shopitems to count.
     * @example
     * // Count the number of Shopitems
     * const count = await prisma.shopitems.count({
     *   where: {
     *     // ... the filter for the Shopitems we want to count
     *   }
     * })
    **/
    count<T extends shopitemsCountArgs>(
      args?: Subset<T, shopitemsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShopitemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Shopitems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopitemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShopitemsAggregateArgs>(args: Subset<T, ShopitemsAggregateArgs>): Prisma.PrismaPromise<GetShopitemsAggregateType<T>>

    /**
     * Group by Shopitems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shopitemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends shopitemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: shopitemsGroupByArgs['orderBy'] }
        : { orderBy?: shopitemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, shopitemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopitemsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the shopitems model
   */
  readonly fields: shopitemsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for shopitems.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__shopitemsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the shopitems model
   */ 
  interface shopitemsFieldRefs {
    readonly id: FieldRef<"shopitems", 'BigInt'>
    readonly shopid: FieldRef<"shopitems", 'Int'>
    readonly itemid: FieldRef<"shopitems", 'Int'>
    readonly price: FieldRef<"shopitems", 'Int'>
    readonly tokenitemid: FieldRef<"shopitems", 'Int'>
    readonly tokenprice: FieldRef<"shopitems", 'Int'>
    readonly pointquestid: FieldRef<"shopitems", 'Int'>
    readonly pointprice: FieldRef<"shopitems", 'Int'>
    readonly starcoin: FieldRef<"shopitems", 'Int'>
    readonly questexid: FieldRef<"shopitems", 'Int'>
    readonly questexkey: FieldRef<"shopitems", 'String'>
    readonly questexvalue: FieldRef<"shopitems", 'Int'>
    readonly itemperiod: FieldRef<"shopitems", 'Int'>
    readonly levellimited: FieldRef<"shopitems", 'Int'>
    readonly showlevmin: FieldRef<"shopitems", 'Int'>
    readonly showlevmax: FieldRef<"shopitems", 'Int'>
    readonly questid: FieldRef<"shopitems", 'Int'>
    readonly sellstart: FieldRef<"shopitems", 'DateTime'>
    readonly sellend: FieldRef<"shopitems", 'DateTime'>
    readonly tabindex: FieldRef<"shopitems", 'Int'>
    readonly worldblock: FieldRef<"shopitems", 'Boolean'>
    readonly potentialgrade: FieldRef<"shopitems", 'Int'>
    readonly buylimit: FieldRef<"shopitems", 'Int'>
    readonly quantity: FieldRef<"shopitems", 'Int'>
    readonly unitprice: FieldRef<"shopitems", 'BigInt'>
    readonly maxperslot: FieldRef<"shopitems", 'Int'>
    readonly discountperc: FieldRef<"shopitems", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * shopitems findUnique
   */
  export type shopitemsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shopitems
     */
    select?: shopitemsSelect<ExtArgs> | null
    /**
     * Filter, which shopitems to fetch.
     */
    where: shopitemsWhereUniqueInput
  }

  /**
   * shopitems findUniqueOrThrow
   */
  export type shopitemsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shopitems
     */
    select?: shopitemsSelect<ExtArgs> | null
    /**
     * Filter, which shopitems to fetch.
     */
    where: shopitemsWhereUniqueInput
  }

  /**
   * shopitems findFirst
   */
  export type shopitemsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shopitems
     */
    select?: shopitemsSelect<ExtArgs> | null
    /**
     * Filter, which shopitems to fetch.
     */
    where?: shopitemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of shopitems to fetch.
     */
    orderBy?: shopitemsOrderByWithRelationInput | shopitemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for shopitems.
     */
    cursor?: shopitemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` shopitems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` shopitems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of shopitems.
     */
    distinct?: ShopitemsScalarFieldEnum | ShopitemsScalarFieldEnum[]
  }

  /**
   * shopitems findFirstOrThrow
   */
  export type shopitemsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shopitems
     */
    select?: shopitemsSelect<ExtArgs> | null
    /**
     * Filter, which shopitems to fetch.
     */
    where?: shopitemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of shopitems to fetch.
     */
    orderBy?: shopitemsOrderByWithRelationInput | shopitemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for shopitems.
     */
    cursor?: shopitemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` shopitems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` shopitems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of shopitems.
     */
    distinct?: ShopitemsScalarFieldEnum | ShopitemsScalarFieldEnum[]
  }

  /**
   * shopitems findMany
   */
  export type shopitemsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shopitems
     */
    select?: shopitemsSelect<ExtArgs> | null
    /**
     * Filter, which shopitems to fetch.
     */
    where?: shopitemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of shopitems to fetch.
     */
    orderBy?: shopitemsOrderByWithRelationInput | shopitemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing shopitems.
     */
    cursor?: shopitemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` shopitems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` shopitems.
     */
    skip?: number
    distinct?: ShopitemsScalarFieldEnum | ShopitemsScalarFieldEnum[]
  }

  /**
   * shopitems create
   */
  export type shopitemsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shopitems
     */
    select?: shopitemsSelect<ExtArgs> | null
    /**
     * The data needed to create a shopitems.
     */
    data?: XOR<shopitemsCreateInput, shopitemsUncheckedCreateInput>
  }

  /**
   * shopitems createMany
   */
  export type shopitemsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many shopitems.
     */
    data: shopitemsCreateManyInput | shopitemsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * shopitems update
   */
  export type shopitemsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shopitems
     */
    select?: shopitemsSelect<ExtArgs> | null
    /**
     * The data needed to update a shopitems.
     */
    data: XOR<shopitemsUpdateInput, shopitemsUncheckedUpdateInput>
    /**
     * Choose, which shopitems to update.
     */
    where: shopitemsWhereUniqueInput
  }

  /**
   * shopitems updateMany
   */
  export type shopitemsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update shopitems.
     */
    data: XOR<shopitemsUpdateManyMutationInput, shopitemsUncheckedUpdateManyInput>
    /**
     * Filter which shopitems to update
     */
    where?: shopitemsWhereInput
  }

  /**
   * shopitems upsert
   */
  export type shopitemsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shopitems
     */
    select?: shopitemsSelect<ExtArgs> | null
    /**
     * The filter to search for the shopitems to update in case it exists.
     */
    where: shopitemsWhereUniqueInput
    /**
     * In case the shopitems found by the `where` argument doesn't exist, create a new shopitems with this data.
     */
    create: XOR<shopitemsCreateInput, shopitemsUncheckedCreateInput>
    /**
     * In case the shopitems was found with the provided `where` argument, update it with this data.
     */
    update: XOR<shopitemsUpdateInput, shopitemsUncheckedUpdateInput>
  }

  /**
   * shopitems delete
   */
  export type shopitemsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shopitems
     */
    select?: shopitemsSelect<ExtArgs> | null
    /**
     * Filter which shopitems to delete.
     */
    where: shopitemsWhereUniqueInput
  }

  /**
   * shopitems deleteMany
   */
  export type shopitemsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which shopitems to delete
     */
    where?: shopitemsWhereInput
  }

  /**
   * shopitems without action
   */
  export type shopitemsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shopitems
     */
    select?: shopitemsSelect<ExtArgs> | null
  }


  /**
   * Model skillcooltimes
   */

  export type AggregateSkillcooltimes = {
    _count: SkillcooltimesCountAggregateOutputType | null
    _avg: SkillcooltimesAvgAggregateOutputType | null
    _sum: SkillcooltimesSumAggregateOutputType | null
    _min: SkillcooltimesMinAggregateOutputType | null
    _max: SkillcooltimesMaxAggregateOutputType | null
  }

  export type SkillcooltimesAvgAggregateOutputType = {
    id: number | null
    charid: number | null
    skillid: number | null
    nextusabletime: number | null
  }

  export type SkillcooltimesSumAggregateOutputType = {
    id: number | null
    charid: number | null
    skillid: number | null
    nextusabletime: bigint | null
  }

  export type SkillcooltimesMinAggregateOutputType = {
    id: number | null
    charid: number | null
    skillid: number | null
    nextusabletime: bigint | null
  }

  export type SkillcooltimesMaxAggregateOutputType = {
    id: number | null
    charid: number | null
    skillid: number | null
    nextusabletime: bigint | null
  }

  export type SkillcooltimesCountAggregateOutputType = {
    id: number
    charid: number
    skillid: number
    nextusabletime: number
    _all: number
  }


  export type SkillcooltimesAvgAggregateInputType = {
    id?: true
    charid?: true
    skillid?: true
    nextusabletime?: true
  }

  export type SkillcooltimesSumAggregateInputType = {
    id?: true
    charid?: true
    skillid?: true
    nextusabletime?: true
  }

  export type SkillcooltimesMinAggregateInputType = {
    id?: true
    charid?: true
    skillid?: true
    nextusabletime?: true
  }

  export type SkillcooltimesMaxAggregateInputType = {
    id?: true
    charid?: true
    skillid?: true
    nextusabletime?: true
  }

  export type SkillcooltimesCountAggregateInputType = {
    id?: true
    charid?: true
    skillid?: true
    nextusabletime?: true
    _all?: true
  }

  export type SkillcooltimesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which skillcooltimes to aggregate.
     */
    where?: skillcooltimesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skillcooltimes to fetch.
     */
    orderBy?: skillcooltimesOrderByWithRelationInput | skillcooltimesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: skillcooltimesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skillcooltimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skillcooltimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned skillcooltimes
    **/
    _count?: true | SkillcooltimesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SkillcooltimesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SkillcooltimesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SkillcooltimesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SkillcooltimesMaxAggregateInputType
  }

  export type GetSkillcooltimesAggregateType<T extends SkillcooltimesAggregateArgs> = {
        [P in keyof T & keyof AggregateSkillcooltimes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSkillcooltimes[P]>
      : GetScalarType<T[P], AggregateSkillcooltimes[P]>
  }




  export type skillcooltimesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: skillcooltimesWhereInput
    orderBy?: skillcooltimesOrderByWithAggregationInput | skillcooltimesOrderByWithAggregationInput[]
    by: SkillcooltimesScalarFieldEnum[] | SkillcooltimesScalarFieldEnum
    having?: skillcooltimesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SkillcooltimesCountAggregateInputType | true
    _avg?: SkillcooltimesAvgAggregateInputType
    _sum?: SkillcooltimesSumAggregateInputType
    _min?: SkillcooltimesMinAggregateInputType
    _max?: SkillcooltimesMaxAggregateInputType
  }

  export type SkillcooltimesGroupByOutputType = {
    id: number
    charid: number | null
    skillid: number | null
    nextusabletime: bigint | null
    _count: SkillcooltimesCountAggregateOutputType | null
    _avg: SkillcooltimesAvgAggregateOutputType | null
    _sum: SkillcooltimesSumAggregateOutputType | null
    _min: SkillcooltimesMinAggregateOutputType | null
    _max: SkillcooltimesMaxAggregateOutputType | null
  }

  type GetSkillcooltimesGroupByPayload<T extends skillcooltimesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SkillcooltimesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SkillcooltimesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SkillcooltimesGroupByOutputType[P]>
            : GetScalarType<T[P], SkillcooltimesGroupByOutputType[P]>
        }
      >
    >


  export type skillcooltimesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    charid?: boolean
    skillid?: boolean
    nextusabletime?: boolean
  }, ExtArgs["result"]["skillcooltimes"]>


  export type skillcooltimesSelectScalar = {
    id?: boolean
    charid?: boolean
    skillid?: boolean
    nextusabletime?: boolean
  }


  export type $skillcooltimesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "skillcooltimes"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      charid: number | null
      skillid: number | null
      nextusabletime: bigint | null
    }, ExtArgs["result"]["skillcooltimes"]>
    composites: {}
  }

  type skillcooltimesGetPayload<S extends boolean | null | undefined | skillcooltimesDefaultArgs> = $Result.GetResult<Prisma.$skillcooltimesPayload, S>

  type skillcooltimesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<skillcooltimesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SkillcooltimesCountAggregateInputType | true
    }

  export interface skillcooltimesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['skillcooltimes'], meta: { name: 'skillcooltimes' } }
    /**
     * Find zero or one Skillcooltimes that matches the filter.
     * @param {skillcooltimesFindUniqueArgs} args - Arguments to find a Skillcooltimes
     * @example
     * // Get one Skillcooltimes
     * const skillcooltimes = await prisma.skillcooltimes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends skillcooltimesFindUniqueArgs>(args: SelectSubset<T, skillcooltimesFindUniqueArgs<ExtArgs>>): Prisma__skillcooltimesClient<$Result.GetResult<Prisma.$skillcooltimesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Skillcooltimes that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {skillcooltimesFindUniqueOrThrowArgs} args - Arguments to find a Skillcooltimes
     * @example
     * // Get one Skillcooltimes
     * const skillcooltimes = await prisma.skillcooltimes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends skillcooltimesFindUniqueOrThrowArgs>(args: SelectSubset<T, skillcooltimesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__skillcooltimesClient<$Result.GetResult<Prisma.$skillcooltimesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Skillcooltimes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skillcooltimesFindFirstArgs} args - Arguments to find a Skillcooltimes
     * @example
     * // Get one Skillcooltimes
     * const skillcooltimes = await prisma.skillcooltimes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends skillcooltimesFindFirstArgs>(args?: SelectSubset<T, skillcooltimesFindFirstArgs<ExtArgs>>): Prisma__skillcooltimesClient<$Result.GetResult<Prisma.$skillcooltimesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Skillcooltimes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skillcooltimesFindFirstOrThrowArgs} args - Arguments to find a Skillcooltimes
     * @example
     * // Get one Skillcooltimes
     * const skillcooltimes = await prisma.skillcooltimes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends skillcooltimesFindFirstOrThrowArgs>(args?: SelectSubset<T, skillcooltimesFindFirstOrThrowArgs<ExtArgs>>): Prisma__skillcooltimesClient<$Result.GetResult<Prisma.$skillcooltimesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Skillcooltimes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skillcooltimesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Skillcooltimes
     * const skillcooltimes = await prisma.skillcooltimes.findMany()
     * 
     * // Get first 10 Skillcooltimes
     * const skillcooltimes = await prisma.skillcooltimes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const skillcooltimesWithIdOnly = await prisma.skillcooltimes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends skillcooltimesFindManyArgs>(args?: SelectSubset<T, skillcooltimesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$skillcooltimesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Skillcooltimes.
     * @param {skillcooltimesCreateArgs} args - Arguments to create a Skillcooltimes.
     * @example
     * // Create one Skillcooltimes
     * const Skillcooltimes = await prisma.skillcooltimes.create({
     *   data: {
     *     // ... data to create a Skillcooltimes
     *   }
     * })
     * 
     */
    create<T extends skillcooltimesCreateArgs>(args: SelectSubset<T, skillcooltimesCreateArgs<ExtArgs>>): Prisma__skillcooltimesClient<$Result.GetResult<Prisma.$skillcooltimesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Skillcooltimes.
     * @param {skillcooltimesCreateManyArgs} args - Arguments to create many Skillcooltimes.
     * @example
     * // Create many Skillcooltimes
     * const skillcooltimes = await prisma.skillcooltimes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends skillcooltimesCreateManyArgs>(args?: SelectSubset<T, skillcooltimesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Skillcooltimes.
     * @param {skillcooltimesDeleteArgs} args - Arguments to delete one Skillcooltimes.
     * @example
     * // Delete one Skillcooltimes
     * const Skillcooltimes = await prisma.skillcooltimes.delete({
     *   where: {
     *     // ... filter to delete one Skillcooltimes
     *   }
     * })
     * 
     */
    delete<T extends skillcooltimesDeleteArgs>(args: SelectSubset<T, skillcooltimesDeleteArgs<ExtArgs>>): Prisma__skillcooltimesClient<$Result.GetResult<Prisma.$skillcooltimesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Skillcooltimes.
     * @param {skillcooltimesUpdateArgs} args - Arguments to update one Skillcooltimes.
     * @example
     * // Update one Skillcooltimes
     * const skillcooltimes = await prisma.skillcooltimes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends skillcooltimesUpdateArgs>(args: SelectSubset<T, skillcooltimesUpdateArgs<ExtArgs>>): Prisma__skillcooltimesClient<$Result.GetResult<Prisma.$skillcooltimesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Skillcooltimes.
     * @param {skillcooltimesDeleteManyArgs} args - Arguments to filter Skillcooltimes to delete.
     * @example
     * // Delete a few Skillcooltimes
     * const { count } = await prisma.skillcooltimes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends skillcooltimesDeleteManyArgs>(args?: SelectSubset<T, skillcooltimesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Skillcooltimes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skillcooltimesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Skillcooltimes
     * const skillcooltimes = await prisma.skillcooltimes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends skillcooltimesUpdateManyArgs>(args: SelectSubset<T, skillcooltimesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Skillcooltimes.
     * @param {skillcooltimesUpsertArgs} args - Arguments to update or create a Skillcooltimes.
     * @example
     * // Update or create a Skillcooltimes
     * const skillcooltimes = await prisma.skillcooltimes.upsert({
     *   create: {
     *     // ... data to create a Skillcooltimes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Skillcooltimes we want to update
     *   }
     * })
     */
    upsert<T extends skillcooltimesUpsertArgs>(args: SelectSubset<T, skillcooltimesUpsertArgs<ExtArgs>>): Prisma__skillcooltimesClient<$Result.GetResult<Prisma.$skillcooltimesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Skillcooltimes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skillcooltimesCountArgs} args - Arguments to filter Skillcooltimes to count.
     * @example
     * // Count the number of Skillcooltimes
     * const count = await prisma.skillcooltimes.count({
     *   where: {
     *     // ... the filter for the Skillcooltimes we want to count
     *   }
     * })
    **/
    count<T extends skillcooltimesCountArgs>(
      args?: Subset<T, skillcooltimesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SkillcooltimesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Skillcooltimes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillcooltimesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SkillcooltimesAggregateArgs>(args: Subset<T, SkillcooltimesAggregateArgs>): Prisma.PrismaPromise<GetSkillcooltimesAggregateType<T>>

    /**
     * Group by Skillcooltimes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skillcooltimesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends skillcooltimesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: skillcooltimesGroupByArgs['orderBy'] }
        : { orderBy?: skillcooltimesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, skillcooltimesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSkillcooltimesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the skillcooltimes model
   */
  readonly fields: skillcooltimesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for skillcooltimes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__skillcooltimesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the skillcooltimes model
   */ 
  interface skillcooltimesFieldRefs {
    readonly id: FieldRef<"skillcooltimes", 'Int'>
    readonly charid: FieldRef<"skillcooltimes", 'Int'>
    readonly skillid: FieldRef<"skillcooltimes", 'Int'>
    readonly nextusabletime: FieldRef<"skillcooltimes", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * skillcooltimes findUnique
   */
  export type skillcooltimesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skillcooltimes
     */
    select?: skillcooltimesSelect<ExtArgs> | null
    /**
     * Filter, which skillcooltimes to fetch.
     */
    where: skillcooltimesWhereUniqueInput
  }

  /**
   * skillcooltimes findUniqueOrThrow
   */
  export type skillcooltimesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skillcooltimes
     */
    select?: skillcooltimesSelect<ExtArgs> | null
    /**
     * Filter, which skillcooltimes to fetch.
     */
    where: skillcooltimesWhereUniqueInput
  }

  /**
   * skillcooltimes findFirst
   */
  export type skillcooltimesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skillcooltimes
     */
    select?: skillcooltimesSelect<ExtArgs> | null
    /**
     * Filter, which skillcooltimes to fetch.
     */
    where?: skillcooltimesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skillcooltimes to fetch.
     */
    orderBy?: skillcooltimesOrderByWithRelationInput | skillcooltimesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for skillcooltimes.
     */
    cursor?: skillcooltimesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skillcooltimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skillcooltimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of skillcooltimes.
     */
    distinct?: SkillcooltimesScalarFieldEnum | SkillcooltimesScalarFieldEnum[]
  }

  /**
   * skillcooltimes findFirstOrThrow
   */
  export type skillcooltimesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skillcooltimes
     */
    select?: skillcooltimesSelect<ExtArgs> | null
    /**
     * Filter, which skillcooltimes to fetch.
     */
    where?: skillcooltimesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skillcooltimes to fetch.
     */
    orderBy?: skillcooltimesOrderByWithRelationInput | skillcooltimesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for skillcooltimes.
     */
    cursor?: skillcooltimesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skillcooltimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skillcooltimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of skillcooltimes.
     */
    distinct?: SkillcooltimesScalarFieldEnum | SkillcooltimesScalarFieldEnum[]
  }

  /**
   * skillcooltimes findMany
   */
  export type skillcooltimesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skillcooltimes
     */
    select?: skillcooltimesSelect<ExtArgs> | null
    /**
     * Filter, which skillcooltimes to fetch.
     */
    where?: skillcooltimesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skillcooltimes to fetch.
     */
    orderBy?: skillcooltimesOrderByWithRelationInput | skillcooltimesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing skillcooltimes.
     */
    cursor?: skillcooltimesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skillcooltimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skillcooltimes.
     */
    skip?: number
    distinct?: SkillcooltimesScalarFieldEnum | SkillcooltimesScalarFieldEnum[]
  }

  /**
   * skillcooltimes create
   */
  export type skillcooltimesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skillcooltimes
     */
    select?: skillcooltimesSelect<ExtArgs> | null
    /**
     * The data needed to create a skillcooltimes.
     */
    data?: XOR<skillcooltimesCreateInput, skillcooltimesUncheckedCreateInput>
  }

  /**
   * skillcooltimes createMany
   */
  export type skillcooltimesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many skillcooltimes.
     */
    data: skillcooltimesCreateManyInput | skillcooltimesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * skillcooltimes update
   */
  export type skillcooltimesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skillcooltimes
     */
    select?: skillcooltimesSelect<ExtArgs> | null
    /**
     * The data needed to update a skillcooltimes.
     */
    data: XOR<skillcooltimesUpdateInput, skillcooltimesUncheckedUpdateInput>
    /**
     * Choose, which skillcooltimes to update.
     */
    where: skillcooltimesWhereUniqueInput
  }

  /**
   * skillcooltimes updateMany
   */
  export type skillcooltimesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update skillcooltimes.
     */
    data: XOR<skillcooltimesUpdateManyMutationInput, skillcooltimesUncheckedUpdateManyInput>
    /**
     * Filter which skillcooltimes to update
     */
    where?: skillcooltimesWhereInput
  }

  /**
   * skillcooltimes upsert
   */
  export type skillcooltimesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skillcooltimes
     */
    select?: skillcooltimesSelect<ExtArgs> | null
    /**
     * The filter to search for the skillcooltimes to update in case it exists.
     */
    where: skillcooltimesWhereUniqueInput
    /**
     * In case the skillcooltimes found by the `where` argument doesn't exist, create a new skillcooltimes with this data.
     */
    create: XOR<skillcooltimesCreateInput, skillcooltimesUncheckedCreateInput>
    /**
     * In case the skillcooltimes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<skillcooltimesUpdateInput, skillcooltimesUncheckedUpdateInput>
  }

  /**
   * skillcooltimes delete
   */
  export type skillcooltimesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skillcooltimes
     */
    select?: skillcooltimesSelect<ExtArgs> | null
    /**
     * Filter which skillcooltimes to delete.
     */
    where: skillcooltimesWhereUniqueInput
  }

  /**
   * skillcooltimes deleteMany
   */
  export type skillcooltimesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which skillcooltimes to delete
     */
    where?: skillcooltimesWhereInput
  }

  /**
   * skillcooltimes without action
   */
  export type skillcooltimesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skillcooltimes
     */
    select?: skillcooltimesSelect<ExtArgs> | null
  }


  /**
   * Model skills
   */

  export type AggregateSkills = {
    _count: SkillsCountAggregateOutputType | null
    _avg: SkillsAvgAggregateOutputType | null
    _sum: SkillsSumAggregateOutputType | null
    _min: SkillsMinAggregateOutputType | null
    _max: SkillsMaxAggregateOutputType | null
  }

  export type SkillsAvgAggregateOutputType = {
    id: number | null
    charid: number | null
    skillid: number | null
    rootid: number | null
    maxlevel: number | null
    currentlevel: number | null
    masterlevel: number | null
  }

  export type SkillsSumAggregateOutputType = {
    id: number | null
    charid: number | null
    skillid: number | null
    rootid: number | null
    maxlevel: number | null
    currentlevel: number | null
    masterlevel: number | null
  }

  export type SkillsMinAggregateOutputType = {
    id: number | null
    charid: number | null
    skillid: number | null
    rootid: number | null
    maxlevel: number | null
    currentlevel: number | null
    masterlevel: number | null
  }

  export type SkillsMaxAggregateOutputType = {
    id: number | null
    charid: number | null
    skillid: number | null
    rootid: number | null
    maxlevel: number | null
    currentlevel: number | null
    masterlevel: number | null
  }

  export type SkillsCountAggregateOutputType = {
    id: number
    charid: number
    skillid: number
    rootid: number
    maxlevel: number
    currentlevel: number
    masterlevel: number
    _all: number
  }


  export type SkillsAvgAggregateInputType = {
    id?: true
    charid?: true
    skillid?: true
    rootid?: true
    maxlevel?: true
    currentlevel?: true
    masterlevel?: true
  }

  export type SkillsSumAggregateInputType = {
    id?: true
    charid?: true
    skillid?: true
    rootid?: true
    maxlevel?: true
    currentlevel?: true
    masterlevel?: true
  }

  export type SkillsMinAggregateInputType = {
    id?: true
    charid?: true
    skillid?: true
    rootid?: true
    maxlevel?: true
    currentlevel?: true
    masterlevel?: true
  }

  export type SkillsMaxAggregateInputType = {
    id?: true
    charid?: true
    skillid?: true
    rootid?: true
    maxlevel?: true
    currentlevel?: true
    masterlevel?: true
  }

  export type SkillsCountAggregateInputType = {
    id?: true
    charid?: true
    skillid?: true
    rootid?: true
    maxlevel?: true
    currentlevel?: true
    masterlevel?: true
    _all?: true
  }

  export type SkillsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which skills to aggregate.
     */
    where?: skillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skills to fetch.
     */
    orderBy?: skillsOrderByWithRelationInput | skillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: skillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned skills
    **/
    _count?: true | SkillsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SkillsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SkillsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SkillsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SkillsMaxAggregateInputType
  }

  export type GetSkillsAggregateType<T extends SkillsAggregateArgs> = {
        [P in keyof T & keyof AggregateSkills]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSkills[P]>
      : GetScalarType<T[P], AggregateSkills[P]>
  }




  export type skillsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: skillsWhereInput
    orderBy?: skillsOrderByWithAggregationInput | skillsOrderByWithAggregationInput[]
    by: SkillsScalarFieldEnum[] | SkillsScalarFieldEnum
    having?: skillsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SkillsCountAggregateInputType | true
    _avg?: SkillsAvgAggregateInputType
    _sum?: SkillsSumAggregateInputType
    _min?: SkillsMinAggregateInputType
    _max?: SkillsMaxAggregateInputType
  }

  export type SkillsGroupByOutputType = {
    id: number
    charid: number | null
    skillid: number | null
    rootid: number | null
    maxlevel: number | null
    currentlevel: number | null
    masterlevel: number | null
    _count: SkillsCountAggregateOutputType | null
    _avg: SkillsAvgAggregateOutputType | null
    _sum: SkillsSumAggregateOutputType | null
    _min: SkillsMinAggregateOutputType | null
    _max: SkillsMaxAggregateOutputType | null
  }

  type GetSkillsGroupByPayload<T extends skillsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SkillsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SkillsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SkillsGroupByOutputType[P]>
            : GetScalarType<T[P], SkillsGroupByOutputType[P]>
        }
      >
    >


  export type skillsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    charid?: boolean
    skillid?: boolean
    rootid?: boolean
    maxlevel?: boolean
    currentlevel?: boolean
    masterlevel?: boolean
  }, ExtArgs["result"]["skills"]>


  export type skillsSelectScalar = {
    id?: boolean
    charid?: boolean
    skillid?: boolean
    rootid?: boolean
    maxlevel?: boolean
    currentlevel?: boolean
    masterlevel?: boolean
  }


  export type $skillsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "skills"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      charid: number | null
      skillid: number | null
      rootid: number | null
      maxlevel: number | null
      currentlevel: number | null
      masterlevel: number | null
    }, ExtArgs["result"]["skills"]>
    composites: {}
  }

  type skillsGetPayload<S extends boolean | null | undefined | skillsDefaultArgs> = $Result.GetResult<Prisma.$skillsPayload, S>

  type skillsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<skillsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SkillsCountAggregateInputType | true
    }

  export interface skillsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['skills'], meta: { name: 'skills' } }
    /**
     * Find zero or one Skills that matches the filter.
     * @param {skillsFindUniqueArgs} args - Arguments to find a Skills
     * @example
     * // Get one Skills
     * const skills = await prisma.skills.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends skillsFindUniqueArgs>(args: SelectSubset<T, skillsFindUniqueArgs<ExtArgs>>): Prisma__skillsClient<$Result.GetResult<Prisma.$skillsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Skills that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {skillsFindUniqueOrThrowArgs} args - Arguments to find a Skills
     * @example
     * // Get one Skills
     * const skills = await prisma.skills.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends skillsFindUniqueOrThrowArgs>(args: SelectSubset<T, skillsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__skillsClient<$Result.GetResult<Prisma.$skillsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Skills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skillsFindFirstArgs} args - Arguments to find a Skills
     * @example
     * // Get one Skills
     * const skills = await prisma.skills.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends skillsFindFirstArgs>(args?: SelectSubset<T, skillsFindFirstArgs<ExtArgs>>): Prisma__skillsClient<$Result.GetResult<Prisma.$skillsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Skills that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skillsFindFirstOrThrowArgs} args - Arguments to find a Skills
     * @example
     * // Get one Skills
     * const skills = await prisma.skills.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends skillsFindFirstOrThrowArgs>(args?: SelectSubset<T, skillsFindFirstOrThrowArgs<ExtArgs>>): Prisma__skillsClient<$Result.GetResult<Prisma.$skillsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Skills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skillsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Skills
     * const skills = await prisma.skills.findMany()
     * 
     * // Get first 10 Skills
     * const skills = await prisma.skills.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const skillsWithIdOnly = await prisma.skills.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends skillsFindManyArgs>(args?: SelectSubset<T, skillsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$skillsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Skills.
     * @param {skillsCreateArgs} args - Arguments to create a Skills.
     * @example
     * // Create one Skills
     * const Skills = await prisma.skills.create({
     *   data: {
     *     // ... data to create a Skills
     *   }
     * })
     * 
     */
    create<T extends skillsCreateArgs>(args: SelectSubset<T, skillsCreateArgs<ExtArgs>>): Prisma__skillsClient<$Result.GetResult<Prisma.$skillsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Skills.
     * @param {skillsCreateManyArgs} args - Arguments to create many Skills.
     * @example
     * // Create many Skills
     * const skills = await prisma.skills.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends skillsCreateManyArgs>(args?: SelectSubset<T, skillsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Skills.
     * @param {skillsDeleteArgs} args - Arguments to delete one Skills.
     * @example
     * // Delete one Skills
     * const Skills = await prisma.skills.delete({
     *   where: {
     *     // ... filter to delete one Skills
     *   }
     * })
     * 
     */
    delete<T extends skillsDeleteArgs>(args: SelectSubset<T, skillsDeleteArgs<ExtArgs>>): Prisma__skillsClient<$Result.GetResult<Prisma.$skillsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Skills.
     * @param {skillsUpdateArgs} args - Arguments to update one Skills.
     * @example
     * // Update one Skills
     * const skills = await prisma.skills.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends skillsUpdateArgs>(args: SelectSubset<T, skillsUpdateArgs<ExtArgs>>): Prisma__skillsClient<$Result.GetResult<Prisma.$skillsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Skills.
     * @param {skillsDeleteManyArgs} args - Arguments to filter Skills to delete.
     * @example
     * // Delete a few Skills
     * const { count } = await prisma.skills.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends skillsDeleteManyArgs>(args?: SelectSubset<T, skillsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skillsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Skills
     * const skills = await prisma.skills.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends skillsUpdateManyArgs>(args: SelectSubset<T, skillsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Skills.
     * @param {skillsUpsertArgs} args - Arguments to update or create a Skills.
     * @example
     * // Update or create a Skills
     * const skills = await prisma.skills.upsert({
     *   create: {
     *     // ... data to create a Skills
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Skills we want to update
     *   }
     * })
     */
    upsert<T extends skillsUpsertArgs>(args: SelectSubset<T, skillsUpsertArgs<ExtArgs>>): Prisma__skillsClient<$Result.GetResult<Prisma.$skillsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skillsCountArgs} args - Arguments to filter Skills to count.
     * @example
     * // Count the number of Skills
     * const count = await prisma.skills.count({
     *   where: {
     *     // ... the filter for the Skills we want to count
     *   }
     * })
    **/
    count<T extends skillsCountArgs>(
      args?: Subset<T, skillsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SkillsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SkillsAggregateArgs>(args: Subset<T, SkillsAggregateArgs>): Prisma.PrismaPromise<GetSkillsAggregateType<T>>

    /**
     * Group by Skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skillsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends skillsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: skillsGroupByArgs['orderBy'] }
        : { orderBy?: skillsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, skillsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSkillsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the skills model
   */
  readonly fields: skillsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for skills.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__skillsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the skills model
   */ 
  interface skillsFieldRefs {
    readonly id: FieldRef<"skills", 'Int'>
    readonly charid: FieldRef<"skills", 'Int'>
    readonly skillid: FieldRef<"skills", 'Int'>
    readonly rootid: FieldRef<"skills", 'Int'>
    readonly maxlevel: FieldRef<"skills", 'Int'>
    readonly currentlevel: FieldRef<"skills", 'Int'>
    readonly masterlevel: FieldRef<"skills", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * skills findUnique
   */
  export type skillsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skills
     */
    select?: skillsSelect<ExtArgs> | null
    /**
     * Filter, which skills to fetch.
     */
    where: skillsWhereUniqueInput
  }

  /**
   * skills findUniqueOrThrow
   */
  export type skillsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skills
     */
    select?: skillsSelect<ExtArgs> | null
    /**
     * Filter, which skills to fetch.
     */
    where: skillsWhereUniqueInput
  }

  /**
   * skills findFirst
   */
  export type skillsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skills
     */
    select?: skillsSelect<ExtArgs> | null
    /**
     * Filter, which skills to fetch.
     */
    where?: skillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skills to fetch.
     */
    orderBy?: skillsOrderByWithRelationInput | skillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for skills.
     */
    cursor?: skillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of skills.
     */
    distinct?: SkillsScalarFieldEnum | SkillsScalarFieldEnum[]
  }

  /**
   * skills findFirstOrThrow
   */
  export type skillsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skills
     */
    select?: skillsSelect<ExtArgs> | null
    /**
     * Filter, which skills to fetch.
     */
    where?: skillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skills to fetch.
     */
    orderBy?: skillsOrderByWithRelationInput | skillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for skills.
     */
    cursor?: skillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of skills.
     */
    distinct?: SkillsScalarFieldEnum | SkillsScalarFieldEnum[]
  }

  /**
   * skills findMany
   */
  export type skillsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skills
     */
    select?: skillsSelect<ExtArgs> | null
    /**
     * Filter, which skills to fetch.
     */
    where?: skillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skills to fetch.
     */
    orderBy?: skillsOrderByWithRelationInput | skillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing skills.
     */
    cursor?: skillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skills.
     */
    skip?: number
    distinct?: SkillsScalarFieldEnum | SkillsScalarFieldEnum[]
  }

  /**
   * skills create
   */
  export type skillsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skills
     */
    select?: skillsSelect<ExtArgs> | null
    /**
     * The data needed to create a skills.
     */
    data?: XOR<skillsCreateInput, skillsUncheckedCreateInput>
  }

  /**
   * skills createMany
   */
  export type skillsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many skills.
     */
    data: skillsCreateManyInput | skillsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * skills update
   */
  export type skillsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skills
     */
    select?: skillsSelect<ExtArgs> | null
    /**
     * The data needed to update a skills.
     */
    data: XOR<skillsUpdateInput, skillsUncheckedUpdateInput>
    /**
     * Choose, which skills to update.
     */
    where: skillsWhereUniqueInput
  }

  /**
   * skills updateMany
   */
  export type skillsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update skills.
     */
    data: XOR<skillsUpdateManyMutationInput, skillsUncheckedUpdateManyInput>
    /**
     * Filter which skills to update
     */
    where?: skillsWhereInput
  }

  /**
   * skills upsert
   */
  export type skillsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skills
     */
    select?: skillsSelect<ExtArgs> | null
    /**
     * The filter to search for the skills to update in case it exists.
     */
    where: skillsWhereUniqueInput
    /**
     * In case the skills found by the `where` argument doesn't exist, create a new skills with this data.
     */
    create: XOR<skillsCreateInput, skillsUncheckedCreateInput>
    /**
     * In case the skills was found with the provided `where` argument, update it with this data.
     */
    update: XOR<skillsUpdateInput, skillsUncheckedUpdateInput>
  }

  /**
   * skills delete
   */
  export type skillsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skills
     */
    select?: skillsSelect<ExtArgs> | null
    /**
     * Filter which skills to delete.
     */
    where: skillsWhereUniqueInput
  }

  /**
   * skills deleteMany
   */
  export type skillsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which skills to delete
     */
    where?: skillsWhereInput
  }

  /**
   * skills without action
   */
  export type skillsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skills
     */
    select?: skillsSelect<ExtArgs> | null
  }


  /**
   * Model spset
   */

  export type AggregateSpset = {
    _count: SpsetCountAggregateOutputType | null
    _avg: SpsetAvgAggregateOutputType | null
    _sum: SpsetSumAggregateOutputType | null
    _min: SpsetMinAggregateOutputType | null
    _max: SpsetMaxAggregateOutputType | null
  }

  export type SpsetAvgAggregateOutputType = {
    id: number | null
    extendsp_id: number | null
    joblevel: number | null
    sp: number | null
  }

  export type SpsetSumAggregateOutputType = {
    id: number | null
    extendsp_id: number | null
    joblevel: number | null
    sp: number | null
  }

  export type SpsetMinAggregateOutputType = {
    id: number | null
    extendsp_id: number | null
    joblevel: number | null
    sp: number | null
  }

  export type SpsetMaxAggregateOutputType = {
    id: number | null
    extendsp_id: number | null
    joblevel: number | null
    sp: number | null
  }

  export type SpsetCountAggregateOutputType = {
    id: number
    extendsp_id: number
    joblevel: number
    sp: number
    _all: number
  }


  export type SpsetAvgAggregateInputType = {
    id?: true
    extendsp_id?: true
    joblevel?: true
    sp?: true
  }

  export type SpsetSumAggregateInputType = {
    id?: true
    extendsp_id?: true
    joblevel?: true
    sp?: true
  }

  export type SpsetMinAggregateInputType = {
    id?: true
    extendsp_id?: true
    joblevel?: true
    sp?: true
  }

  export type SpsetMaxAggregateInputType = {
    id?: true
    extendsp_id?: true
    joblevel?: true
    sp?: true
  }

  export type SpsetCountAggregateInputType = {
    id?: true
    extendsp_id?: true
    joblevel?: true
    sp?: true
    _all?: true
  }

  export type SpsetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which spset to aggregate.
     */
    where?: spsetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of spsets to fetch.
     */
    orderBy?: spsetOrderByWithRelationInput | spsetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: spsetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` spsets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` spsets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned spsets
    **/
    _count?: true | SpsetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SpsetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SpsetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpsetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpsetMaxAggregateInputType
  }

  export type GetSpsetAggregateType<T extends SpsetAggregateArgs> = {
        [P in keyof T & keyof AggregateSpset]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpset[P]>
      : GetScalarType<T[P], AggregateSpset[P]>
  }




  export type spsetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: spsetWhereInput
    orderBy?: spsetOrderByWithAggregationInput | spsetOrderByWithAggregationInput[]
    by: SpsetScalarFieldEnum[] | SpsetScalarFieldEnum
    having?: spsetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpsetCountAggregateInputType | true
    _avg?: SpsetAvgAggregateInputType
    _sum?: SpsetSumAggregateInputType
    _min?: SpsetMinAggregateInputType
    _max?: SpsetMaxAggregateInputType
  }

  export type SpsetGroupByOutputType = {
    id: number
    extendsp_id: number | null
    joblevel: number | null
    sp: number | null
    _count: SpsetCountAggregateOutputType | null
    _avg: SpsetAvgAggregateOutputType | null
    _sum: SpsetSumAggregateOutputType | null
    _min: SpsetMinAggregateOutputType | null
    _max: SpsetMaxAggregateOutputType | null
  }

  type GetSpsetGroupByPayload<T extends spsetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpsetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpsetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpsetGroupByOutputType[P]>
            : GetScalarType<T[P], SpsetGroupByOutputType[P]>
        }
      >
    >


  export type spsetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    extendsp_id?: boolean
    joblevel?: boolean
    sp?: boolean
  }, ExtArgs["result"]["spset"]>


  export type spsetSelectScalar = {
    id?: boolean
    extendsp_id?: boolean
    joblevel?: boolean
    sp?: boolean
  }


  export type $spsetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "spset"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      extendsp_id: number | null
      joblevel: number | null
      sp: number | null
    }, ExtArgs["result"]["spset"]>
    composites: {}
  }

  type spsetGetPayload<S extends boolean | null | undefined | spsetDefaultArgs> = $Result.GetResult<Prisma.$spsetPayload, S>

  type spsetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<spsetFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SpsetCountAggregateInputType | true
    }

  export interface spsetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['spset'], meta: { name: 'spset' } }
    /**
     * Find zero or one Spset that matches the filter.
     * @param {spsetFindUniqueArgs} args - Arguments to find a Spset
     * @example
     * // Get one Spset
     * const spset = await prisma.spset.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends spsetFindUniqueArgs>(args: SelectSubset<T, spsetFindUniqueArgs<ExtArgs>>): Prisma__spsetClient<$Result.GetResult<Prisma.$spsetPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Spset that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {spsetFindUniqueOrThrowArgs} args - Arguments to find a Spset
     * @example
     * // Get one Spset
     * const spset = await prisma.spset.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends spsetFindUniqueOrThrowArgs>(args: SelectSubset<T, spsetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__spsetClient<$Result.GetResult<Prisma.$spsetPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Spset that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {spsetFindFirstArgs} args - Arguments to find a Spset
     * @example
     * // Get one Spset
     * const spset = await prisma.spset.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends spsetFindFirstArgs>(args?: SelectSubset<T, spsetFindFirstArgs<ExtArgs>>): Prisma__spsetClient<$Result.GetResult<Prisma.$spsetPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Spset that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {spsetFindFirstOrThrowArgs} args - Arguments to find a Spset
     * @example
     * // Get one Spset
     * const spset = await prisma.spset.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends spsetFindFirstOrThrowArgs>(args?: SelectSubset<T, spsetFindFirstOrThrowArgs<ExtArgs>>): Prisma__spsetClient<$Result.GetResult<Prisma.$spsetPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Spsets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {spsetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Spsets
     * const spsets = await prisma.spset.findMany()
     * 
     * // Get first 10 Spsets
     * const spsets = await prisma.spset.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const spsetWithIdOnly = await prisma.spset.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends spsetFindManyArgs>(args?: SelectSubset<T, spsetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$spsetPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Spset.
     * @param {spsetCreateArgs} args - Arguments to create a Spset.
     * @example
     * // Create one Spset
     * const Spset = await prisma.spset.create({
     *   data: {
     *     // ... data to create a Spset
     *   }
     * })
     * 
     */
    create<T extends spsetCreateArgs>(args: SelectSubset<T, spsetCreateArgs<ExtArgs>>): Prisma__spsetClient<$Result.GetResult<Prisma.$spsetPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Spsets.
     * @param {spsetCreateManyArgs} args - Arguments to create many Spsets.
     * @example
     * // Create many Spsets
     * const spset = await prisma.spset.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends spsetCreateManyArgs>(args?: SelectSubset<T, spsetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Spset.
     * @param {spsetDeleteArgs} args - Arguments to delete one Spset.
     * @example
     * // Delete one Spset
     * const Spset = await prisma.spset.delete({
     *   where: {
     *     // ... filter to delete one Spset
     *   }
     * })
     * 
     */
    delete<T extends spsetDeleteArgs>(args: SelectSubset<T, spsetDeleteArgs<ExtArgs>>): Prisma__spsetClient<$Result.GetResult<Prisma.$spsetPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Spset.
     * @param {spsetUpdateArgs} args - Arguments to update one Spset.
     * @example
     * // Update one Spset
     * const spset = await prisma.spset.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends spsetUpdateArgs>(args: SelectSubset<T, spsetUpdateArgs<ExtArgs>>): Prisma__spsetClient<$Result.GetResult<Prisma.$spsetPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Spsets.
     * @param {spsetDeleteManyArgs} args - Arguments to filter Spsets to delete.
     * @example
     * // Delete a few Spsets
     * const { count } = await prisma.spset.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends spsetDeleteManyArgs>(args?: SelectSubset<T, spsetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Spsets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {spsetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Spsets
     * const spset = await prisma.spset.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends spsetUpdateManyArgs>(args: SelectSubset<T, spsetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Spset.
     * @param {spsetUpsertArgs} args - Arguments to update or create a Spset.
     * @example
     * // Update or create a Spset
     * const spset = await prisma.spset.upsert({
     *   create: {
     *     // ... data to create a Spset
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Spset we want to update
     *   }
     * })
     */
    upsert<T extends spsetUpsertArgs>(args: SelectSubset<T, spsetUpsertArgs<ExtArgs>>): Prisma__spsetClient<$Result.GetResult<Prisma.$spsetPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Spsets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {spsetCountArgs} args - Arguments to filter Spsets to count.
     * @example
     * // Count the number of Spsets
     * const count = await prisma.spset.count({
     *   where: {
     *     // ... the filter for the Spsets we want to count
     *   }
     * })
    **/
    count<T extends spsetCountArgs>(
      args?: Subset<T, spsetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpsetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Spset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpsetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpsetAggregateArgs>(args: Subset<T, SpsetAggregateArgs>): Prisma.PrismaPromise<GetSpsetAggregateType<T>>

    /**
     * Group by Spset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {spsetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends spsetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: spsetGroupByArgs['orderBy'] }
        : { orderBy?: spsetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, spsetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpsetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the spset model
   */
  readonly fields: spsetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for spset.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__spsetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the spset model
   */ 
  interface spsetFieldRefs {
    readonly id: FieldRef<"spset", 'Int'>
    readonly extendsp_id: FieldRef<"spset", 'Int'>
    readonly joblevel: FieldRef<"spset", 'Int'>
    readonly sp: FieldRef<"spset", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * spset findUnique
   */
  export type spsetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the spset
     */
    select?: spsetSelect<ExtArgs> | null
    /**
     * Filter, which spset to fetch.
     */
    where: spsetWhereUniqueInput
  }

  /**
   * spset findUniqueOrThrow
   */
  export type spsetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the spset
     */
    select?: spsetSelect<ExtArgs> | null
    /**
     * Filter, which spset to fetch.
     */
    where: spsetWhereUniqueInput
  }

  /**
   * spset findFirst
   */
  export type spsetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the spset
     */
    select?: spsetSelect<ExtArgs> | null
    /**
     * Filter, which spset to fetch.
     */
    where?: spsetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of spsets to fetch.
     */
    orderBy?: spsetOrderByWithRelationInput | spsetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for spsets.
     */
    cursor?: spsetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` spsets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` spsets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of spsets.
     */
    distinct?: SpsetScalarFieldEnum | SpsetScalarFieldEnum[]
  }

  /**
   * spset findFirstOrThrow
   */
  export type spsetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the spset
     */
    select?: spsetSelect<ExtArgs> | null
    /**
     * Filter, which spset to fetch.
     */
    where?: spsetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of spsets to fetch.
     */
    orderBy?: spsetOrderByWithRelationInput | spsetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for spsets.
     */
    cursor?: spsetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` spsets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` spsets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of spsets.
     */
    distinct?: SpsetScalarFieldEnum | SpsetScalarFieldEnum[]
  }

  /**
   * spset findMany
   */
  export type spsetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the spset
     */
    select?: spsetSelect<ExtArgs> | null
    /**
     * Filter, which spsets to fetch.
     */
    where?: spsetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of spsets to fetch.
     */
    orderBy?: spsetOrderByWithRelationInput | spsetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing spsets.
     */
    cursor?: spsetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` spsets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` spsets.
     */
    skip?: number
    distinct?: SpsetScalarFieldEnum | SpsetScalarFieldEnum[]
  }

  /**
   * spset create
   */
  export type spsetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the spset
     */
    select?: spsetSelect<ExtArgs> | null
    /**
     * The data needed to create a spset.
     */
    data?: XOR<spsetCreateInput, spsetUncheckedCreateInput>
  }

  /**
   * spset createMany
   */
  export type spsetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many spsets.
     */
    data: spsetCreateManyInput | spsetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * spset update
   */
  export type spsetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the spset
     */
    select?: spsetSelect<ExtArgs> | null
    /**
     * The data needed to update a spset.
     */
    data: XOR<spsetUpdateInput, spsetUncheckedUpdateInput>
    /**
     * Choose, which spset to update.
     */
    where: spsetWhereUniqueInput
  }

  /**
   * spset updateMany
   */
  export type spsetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update spsets.
     */
    data: XOR<spsetUpdateManyMutationInput, spsetUncheckedUpdateManyInput>
    /**
     * Filter which spsets to update
     */
    where?: spsetWhereInput
  }

  /**
   * spset upsert
   */
  export type spsetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the spset
     */
    select?: spsetSelect<ExtArgs> | null
    /**
     * The filter to search for the spset to update in case it exists.
     */
    where: spsetWhereUniqueInput
    /**
     * In case the spset found by the `where` argument doesn't exist, create a new spset with this data.
     */
    create: XOR<spsetCreateInput, spsetUncheckedCreateInput>
    /**
     * In case the spset was found with the provided `where` argument, update it with this data.
     */
    update: XOR<spsetUpdateInput, spsetUncheckedUpdateInput>
  }

  /**
   * spset delete
   */
  export type spsetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the spset
     */
    select?: spsetSelect<ExtArgs> | null
    /**
     * Filter which spset to delete.
     */
    where: spsetWhereUniqueInput
  }

  /**
   * spset deleteMany
   */
  export type spsetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which spsets to delete
     */
    where?: spsetWhereInput
  }

  /**
   * spset without action
   */
  export type spsetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the spset
     */
    select?: spsetSelect<ExtArgs> | null
  }


  /**
   * Model stolenskills
   */

  export type AggregateStolenskills = {
    _count: StolenskillsCountAggregateOutputType | null
    _avg: StolenskillsAvgAggregateOutputType | null
    _sum: StolenskillsSumAggregateOutputType | null
    _min: StolenskillsMinAggregateOutputType | null
    _max: StolenskillsMaxAggregateOutputType | null
  }

  export type StolenskillsAvgAggregateOutputType = {
    id: number | null
    charid: number | null
    skillid: number | null
    position: number | null
    currentlv: number | null
  }

  export type StolenskillsSumAggregateOutputType = {
    id: number | null
    charid: number | null
    skillid: number | null
    position: number | null
    currentlv: number | null
  }

  export type StolenskillsMinAggregateOutputType = {
    id: number | null
    charid: number | null
    skillid: number | null
    position: number | null
    currentlv: number | null
  }

  export type StolenskillsMaxAggregateOutputType = {
    id: number | null
    charid: number | null
    skillid: number | null
    position: number | null
    currentlv: number | null
  }

  export type StolenskillsCountAggregateOutputType = {
    id: number
    charid: number
    skillid: number
    position: number
    currentlv: number
    _all: number
  }


  export type StolenskillsAvgAggregateInputType = {
    id?: true
    charid?: true
    skillid?: true
    position?: true
    currentlv?: true
  }

  export type StolenskillsSumAggregateInputType = {
    id?: true
    charid?: true
    skillid?: true
    position?: true
    currentlv?: true
  }

  export type StolenskillsMinAggregateInputType = {
    id?: true
    charid?: true
    skillid?: true
    position?: true
    currentlv?: true
  }

  export type StolenskillsMaxAggregateInputType = {
    id?: true
    charid?: true
    skillid?: true
    position?: true
    currentlv?: true
  }

  export type StolenskillsCountAggregateInputType = {
    id?: true
    charid?: true
    skillid?: true
    position?: true
    currentlv?: true
    _all?: true
  }

  export type StolenskillsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which stolenskills to aggregate.
     */
    where?: stolenskillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of stolenskills to fetch.
     */
    orderBy?: stolenskillsOrderByWithRelationInput | stolenskillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: stolenskillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` stolenskills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` stolenskills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned stolenskills
    **/
    _count?: true | StolenskillsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StolenskillsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StolenskillsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StolenskillsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StolenskillsMaxAggregateInputType
  }

  export type GetStolenskillsAggregateType<T extends StolenskillsAggregateArgs> = {
        [P in keyof T & keyof AggregateStolenskills]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStolenskills[P]>
      : GetScalarType<T[P], AggregateStolenskills[P]>
  }




  export type stolenskillsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: stolenskillsWhereInput
    orderBy?: stolenskillsOrderByWithAggregationInput | stolenskillsOrderByWithAggregationInput[]
    by: StolenskillsScalarFieldEnum[] | StolenskillsScalarFieldEnum
    having?: stolenskillsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StolenskillsCountAggregateInputType | true
    _avg?: StolenskillsAvgAggregateInputType
    _sum?: StolenskillsSumAggregateInputType
    _min?: StolenskillsMinAggregateInputType
    _max?: StolenskillsMaxAggregateInputType
  }

  export type StolenskillsGroupByOutputType = {
    id: number
    charid: number | null
    skillid: number | null
    position: number | null
    currentlv: number | null
    _count: StolenskillsCountAggregateOutputType | null
    _avg: StolenskillsAvgAggregateOutputType | null
    _sum: StolenskillsSumAggregateOutputType | null
    _min: StolenskillsMinAggregateOutputType | null
    _max: StolenskillsMaxAggregateOutputType | null
  }

  type GetStolenskillsGroupByPayload<T extends stolenskillsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StolenskillsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StolenskillsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StolenskillsGroupByOutputType[P]>
            : GetScalarType<T[P], StolenskillsGroupByOutputType[P]>
        }
      >
    >


  export type stolenskillsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    charid?: boolean
    skillid?: boolean
    position?: boolean
    currentlv?: boolean
  }, ExtArgs["result"]["stolenskills"]>


  export type stolenskillsSelectScalar = {
    id?: boolean
    charid?: boolean
    skillid?: boolean
    position?: boolean
    currentlv?: boolean
  }


  export type $stolenskillsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "stolenskills"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      charid: number | null
      skillid: number | null
      position: number | null
      currentlv: number | null
    }, ExtArgs["result"]["stolenskills"]>
    composites: {}
  }

  type stolenskillsGetPayload<S extends boolean | null | undefined | stolenskillsDefaultArgs> = $Result.GetResult<Prisma.$stolenskillsPayload, S>

  type stolenskillsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<stolenskillsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StolenskillsCountAggregateInputType | true
    }

  export interface stolenskillsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['stolenskills'], meta: { name: 'stolenskills' } }
    /**
     * Find zero or one Stolenskills that matches the filter.
     * @param {stolenskillsFindUniqueArgs} args - Arguments to find a Stolenskills
     * @example
     * // Get one Stolenskills
     * const stolenskills = await prisma.stolenskills.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends stolenskillsFindUniqueArgs>(args: SelectSubset<T, stolenskillsFindUniqueArgs<ExtArgs>>): Prisma__stolenskillsClient<$Result.GetResult<Prisma.$stolenskillsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Stolenskills that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {stolenskillsFindUniqueOrThrowArgs} args - Arguments to find a Stolenskills
     * @example
     * // Get one Stolenskills
     * const stolenskills = await prisma.stolenskills.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends stolenskillsFindUniqueOrThrowArgs>(args: SelectSubset<T, stolenskillsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__stolenskillsClient<$Result.GetResult<Prisma.$stolenskillsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Stolenskills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stolenskillsFindFirstArgs} args - Arguments to find a Stolenskills
     * @example
     * // Get one Stolenskills
     * const stolenskills = await prisma.stolenskills.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends stolenskillsFindFirstArgs>(args?: SelectSubset<T, stolenskillsFindFirstArgs<ExtArgs>>): Prisma__stolenskillsClient<$Result.GetResult<Prisma.$stolenskillsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Stolenskills that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stolenskillsFindFirstOrThrowArgs} args - Arguments to find a Stolenskills
     * @example
     * // Get one Stolenskills
     * const stolenskills = await prisma.stolenskills.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends stolenskillsFindFirstOrThrowArgs>(args?: SelectSubset<T, stolenskillsFindFirstOrThrowArgs<ExtArgs>>): Prisma__stolenskillsClient<$Result.GetResult<Prisma.$stolenskillsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Stolenskills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stolenskillsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stolenskills
     * const stolenskills = await prisma.stolenskills.findMany()
     * 
     * // Get first 10 Stolenskills
     * const stolenskills = await prisma.stolenskills.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stolenskillsWithIdOnly = await prisma.stolenskills.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends stolenskillsFindManyArgs>(args?: SelectSubset<T, stolenskillsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$stolenskillsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Stolenskills.
     * @param {stolenskillsCreateArgs} args - Arguments to create a Stolenskills.
     * @example
     * // Create one Stolenskills
     * const Stolenskills = await prisma.stolenskills.create({
     *   data: {
     *     // ... data to create a Stolenskills
     *   }
     * })
     * 
     */
    create<T extends stolenskillsCreateArgs>(args: SelectSubset<T, stolenskillsCreateArgs<ExtArgs>>): Prisma__stolenskillsClient<$Result.GetResult<Prisma.$stolenskillsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Stolenskills.
     * @param {stolenskillsCreateManyArgs} args - Arguments to create many Stolenskills.
     * @example
     * // Create many Stolenskills
     * const stolenskills = await prisma.stolenskills.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends stolenskillsCreateManyArgs>(args?: SelectSubset<T, stolenskillsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Stolenskills.
     * @param {stolenskillsDeleteArgs} args - Arguments to delete one Stolenskills.
     * @example
     * // Delete one Stolenskills
     * const Stolenskills = await prisma.stolenskills.delete({
     *   where: {
     *     // ... filter to delete one Stolenskills
     *   }
     * })
     * 
     */
    delete<T extends stolenskillsDeleteArgs>(args: SelectSubset<T, stolenskillsDeleteArgs<ExtArgs>>): Prisma__stolenskillsClient<$Result.GetResult<Prisma.$stolenskillsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Stolenskills.
     * @param {stolenskillsUpdateArgs} args - Arguments to update one Stolenskills.
     * @example
     * // Update one Stolenskills
     * const stolenskills = await prisma.stolenskills.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends stolenskillsUpdateArgs>(args: SelectSubset<T, stolenskillsUpdateArgs<ExtArgs>>): Prisma__stolenskillsClient<$Result.GetResult<Prisma.$stolenskillsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Stolenskills.
     * @param {stolenskillsDeleteManyArgs} args - Arguments to filter Stolenskills to delete.
     * @example
     * // Delete a few Stolenskills
     * const { count } = await prisma.stolenskills.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends stolenskillsDeleteManyArgs>(args?: SelectSubset<T, stolenskillsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stolenskills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stolenskillsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stolenskills
     * const stolenskills = await prisma.stolenskills.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends stolenskillsUpdateManyArgs>(args: SelectSubset<T, stolenskillsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Stolenskills.
     * @param {stolenskillsUpsertArgs} args - Arguments to update or create a Stolenskills.
     * @example
     * // Update or create a Stolenskills
     * const stolenskills = await prisma.stolenskills.upsert({
     *   create: {
     *     // ... data to create a Stolenskills
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Stolenskills we want to update
     *   }
     * })
     */
    upsert<T extends stolenskillsUpsertArgs>(args: SelectSubset<T, stolenskillsUpsertArgs<ExtArgs>>): Prisma__stolenskillsClient<$Result.GetResult<Prisma.$stolenskillsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Stolenskills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stolenskillsCountArgs} args - Arguments to filter Stolenskills to count.
     * @example
     * // Count the number of Stolenskills
     * const count = await prisma.stolenskills.count({
     *   where: {
     *     // ... the filter for the Stolenskills we want to count
     *   }
     * })
    **/
    count<T extends stolenskillsCountArgs>(
      args?: Subset<T, stolenskillsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StolenskillsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Stolenskills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StolenskillsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StolenskillsAggregateArgs>(args: Subset<T, StolenskillsAggregateArgs>): Prisma.PrismaPromise<GetStolenskillsAggregateType<T>>

    /**
     * Group by Stolenskills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stolenskillsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends stolenskillsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: stolenskillsGroupByArgs['orderBy'] }
        : { orderBy?: stolenskillsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, stolenskillsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStolenskillsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the stolenskills model
   */
  readonly fields: stolenskillsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for stolenskills.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__stolenskillsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the stolenskills model
   */ 
  interface stolenskillsFieldRefs {
    readonly id: FieldRef<"stolenskills", 'Int'>
    readonly charid: FieldRef<"stolenskills", 'Int'>
    readonly skillid: FieldRef<"stolenskills", 'Int'>
    readonly position: FieldRef<"stolenskills", 'Int'>
    readonly currentlv: FieldRef<"stolenskills", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * stolenskills findUnique
   */
  export type stolenskillsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stolenskills
     */
    select?: stolenskillsSelect<ExtArgs> | null
    /**
     * Filter, which stolenskills to fetch.
     */
    where: stolenskillsWhereUniqueInput
  }

  /**
   * stolenskills findUniqueOrThrow
   */
  export type stolenskillsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stolenskills
     */
    select?: stolenskillsSelect<ExtArgs> | null
    /**
     * Filter, which stolenskills to fetch.
     */
    where: stolenskillsWhereUniqueInput
  }

  /**
   * stolenskills findFirst
   */
  export type stolenskillsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stolenskills
     */
    select?: stolenskillsSelect<ExtArgs> | null
    /**
     * Filter, which stolenskills to fetch.
     */
    where?: stolenskillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of stolenskills to fetch.
     */
    orderBy?: stolenskillsOrderByWithRelationInput | stolenskillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for stolenskills.
     */
    cursor?: stolenskillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` stolenskills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` stolenskills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of stolenskills.
     */
    distinct?: StolenskillsScalarFieldEnum | StolenskillsScalarFieldEnum[]
  }

  /**
   * stolenskills findFirstOrThrow
   */
  export type stolenskillsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stolenskills
     */
    select?: stolenskillsSelect<ExtArgs> | null
    /**
     * Filter, which stolenskills to fetch.
     */
    where?: stolenskillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of stolenskills to fetch.
     */
    orderBy?: stolenskillsOrderByWithRelationInput | stolenskillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for stolenskills.
     */
    cursor?: stolenskillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` stolenskills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` stolenskills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of stolenskills.
     */
    distinct?: StolenskillsScalarFieldEnum | StolenskillsScalarFieldEnum[]
  }

  /**
   * stolenskills findMany
   */
  export type stolenskillsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stolenskills
     */
    select?: stolenskillsSelect<ExtArgs> | null
    /**
     * Filter, which stolenskills to fetch.
     */
    where?: stolenskillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of stolenskills to fetch.
     */
    orderBy?: stolenskillsOrderByWithRelationInput | stolenskillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing stolenskills.
     */
    cursor?: stolenskillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` stolenskills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` stolenskills.
     */
    skip?: number
    distinct?: StolenskillsScalarFieldEnum | StolenskillsScalarFieldEnum[]
  }

  /**
   * stolenskills create
   */
  export type stolenskillsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stolenskills
     */
    select?: stolenskillsSelect<ExtArgs> | null
    /**
     * The data needed to create a stolenskills.
     */
    data?: XOR<stolenskillsCreateInput, stolenskillsUncheckedCreateInput>
  }

  /**
   * stolenskills createMany
   */
  export type stolenskillsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many stolenskills.
     */
    data: stolenskillsCreateManyInput | stolenskillsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * stolenskills update
   */
  export type stolenskillsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stolenskills
     */
    select?: stolenskillsSelect<ExtArgs> | null
    /**
     * The data needed to update a stolenskills.
     */
    data: XOR<stolenskillsUpdateInput, stolenskillsUncheckedUpdateInput>
    /**
     * Choose, which stolenskills to update.
     */
    where: stolenskillsWhereUniqueInput
  }

  /**
   * stolenskills updateMany
   */
  export type stolenskillsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update stolenskills.
     */
    data: XOR<stolenskillsUpdateManyMutationInput, stolenskillsUncheckedUpdateManyInput>
    /**
     * Filter which stolenskills to update
     */
    where?: stolenskillsWhereInput
  }

  /**
   * stolenskills upsert
   */
  export type stolenskillsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stolenskills
     */
    select?: stolenskillsSelect<ExtArgs> | null
    /**
     * The filter to search for the stolenskills to update in case it exists.
     */
    where: stolenskillsWhereUniqueInput
    /**
     * In case the stolenskills found by the `where` argument doesn't exist, create a new stolenskills with this data.
     */
    create: XOR<stolenskillsCreateInput, stolenskillsUncheckedCreateInput>
    /**
     * In case the stolenskills was found with the provided `where` argument, update it with this data.
     */
    update: XOR<stolenskillsUpdateInput, stolenskillsUncheckedUpdateInput>
  }

  /**
   * stolenskills delete
   */
  export type stolenskillsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stolenskills
     */
    select?: stolenskillsSelect<ExtArgs> | null
    /**
     * Filter which stolenskills to delete.
     */
    where: stolenskillsWhereUniqueInput
  }

  /**
   * stolenskills deleteMany
   */
  export type stolenskillsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which stolenskills to delete
     */
    where?: stolenskillsWhereInput
  }

  /**
   * stolenskills without action
   */
  export type stolenskillsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stolenskills
     */
    select?: stolenskillsSelect<ExtArgs> | null
  }


  /**
   * Model systemtimes
   */

  export type AggregateSystemtimes = {
    _count: SystemtimesCountAggregateOutputType | null
    _avg: SystemtimesAvgAggregateOutputType | null
    _sum: SystemtimesSumAggregateOutputType | null
    _min: SystemtimesMinAggregateOutputType | null
    _max: SystemtimesMaxAggregateOutputType | null
  }

  export type SystemtimesAvgAggregateOutputType = {
    id: number | null
    yr: number | null
    mnth: number | null
  }

  export type SystemtimesSumAggregateOutputType = {
    id: number | null
    yr: number | null
    mnth: number | null
  }

  export type SystemtimesMinAggregateOutputType = {
    id: number | null
    yr: number | null
    mnth: number | null
  }

  export type SystemtimesMaxAggregateOutputType = {
    id: number | null
    yr: number | null
    mnth: number | null
  }

  export type SystemtimesCountAggregateOutputType = {
    id: number
    yr: number
    mnth: number
    _all: number
  }


  export type SystemtimesAvgAggregateInputType = {
    id?: true
    yr?: true
    mnth?: true
  }

  export type SystemtimesSumAggregateInputType = {
    id?: true
    yr?: true
    mnth?: true
  }

  export type SystemtimesMinAggregateInputType = {
    id?: true
    yr?: true
    mnth?: true
  }

  export type SystemtimesMaxAggregateInputType = {
    id?: true
    yr?: true
    mnth?: true
  }

  export type SystemtimesCountAggregateInputType = {
    id?: true
    yr?: true
    mnth?: true
    _all?: true
  }

  export type SystemtimesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which systemtimes to aggregate.
     */
    where?: systemtimesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of systemtimes to fetch.
     */
    orderBy?: systemtimesOrderByWithRelationInput | systemtimesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: systemtimesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` systemtimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` systemtimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned systemtimes
    **/
    _count?: true | SystemtimesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SystemtimesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SystemtimesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemtimesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemtimesMaxAggregateInputType
  }

  export type GetSystemtimesAggregateType<T extends SystemtimesAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemtimes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemtimes[P]>
      : GetScalarType<T[P], AggregateSystemtimes[P]>
  }




  export type systemtimesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: systemtimesWhereInput
    orderBy?: systemtimesOrderByWithAggregationInput | systemtimesOrderByWithAggregationInput[]
    by: SystemtimesScalarFieldEnum[] | SystemtimesScalarFieldEnum
    having?: systemtimesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemtimesCountAggregateInputType | true
    _avg?: SystemtimesAvgAggregateInputType
    _sum?: SystemtimesSumAggregateInputType
    _min?: SystemtimesMinAggregateInputType
    _max?: SystemtimesMaxAggregateInputType
  }

  export type SystemtimesGroupByOutputType = {
    id: number
    yr: number | null
    mnth: number | null
    _count: SystemtimesCountAggregateOutputType | null
    _avg: SystemtimesAvgAggregateOutputType | null
    _sum: SystemtimesSumAggregateOutputType | null
    _min: SystemtimesMinAggregateOutputType | null
    _max: SystemtimesMaxAggregateOutputType | null
  }

  type GetSystemtimesGroupByPayload<T extends systemtimesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemtimesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemtimesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemtimesGroupByOutputType[P]>
            : GetScalarType<T[P], SystemtimesGroupByOutputType[P]>
        }
      >
    >


  export type systemtimesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    yr?: boolean
    mnth?: boolean
  }, ExtArgs["result"]["systemtimes"]>


  export type systemtimesSelectScalar = {
    id?: boolean
    yr?: boolean
    mnth?: boolean
  }


  export type $systemtimesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "systemtimes"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      yr: number | null
      mnth: number | null
    }, ExtArgs["result"]["systemtimes"]>
    composites: {}
  }

  type systemtimesGetPayload<S extends boolean | null | undefined | systemtimesDefaultArgs> = $Result.GetResult<Prisma.$systemtimesPayload, S>

  type systemtimesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<systemtimesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SystemtimesCountAggregateInputType | true
    }

  export interface systemtimesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['systemtimes'], meta: { name: 'systemtimes' } }
    /**
     * Find zero or one Systemtimes that matches the filter.
     * @param {systemtimesFindUniqueArgs} args - Arguments to find a Systemtimes
     * @example
     * // Get one Systemtimes
     * const systemtimes = await prisma.systemtimes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends systemtimesFindUniqueArgs>(args: SelectSubset<T, systemtimesFindUniqueArgs<ExtArgs>>): Prisma__systemtimesClient<$Result.GetResult<Prisma.$systemtimesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Systemtimes that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {systemtimesFindUniqueOrThrowArgs} args - Arguments to find a Systemtimes
     * @example
     * // Get one Systemtimes
     * const systemtimes = await prisma.systemtimes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends systemtimesFindUniqueOrThrowArgs>(args: SelectSubset<T, systemtimesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__systemtimesClient<$Result.GetResult<Prisma.$systemtimesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Systemtimes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {systemtimesFindFirstArgs} args - Arguments to find a Systemtimes
     * @example
     * // Get one Systemtimes
     * const systemtimes = await prisma.systemtimes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends systemtimesFindFirstArgs>(args?: SelectSubset<T, systemtimesFindFirstArgs<ExtArgs>>): Prisma__systemtimesClient<$Result.GetResult<Prisma.$systemtimesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Systemtimes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {systemtimesFindFirstOrThrowArgs} args - Arguments to find a Systemtimes
     * @example
     * // Get one Systemtimes
     * const systemtimes = await prisma.systemtimes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends systemtimesFindFirstOrThrowArgs>(args?: SelectSubset<T, systemtimesFindFirstOrThrowArgs<ExtArgs>>): Prisma__systemtimesClient<$Result.GetResult<Prisma.$systemtimesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Systemtimes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {systemtimesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Systemtimes
     * const systemtimes = await prisma.systemtimes.findMany()
     * 
     * // Get first 10 Systemtimes
     * const systemtimes = await prisma.systemtimes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemtimesWithIdOnly = await prisma.systemtimes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends systemtimesFindManyArgs>(args?: SelectSubset<T, systemtimesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$systemtimesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Systemtimes.
     * @param {systemtimesCreateArgs} args - Arguments to create a Systemtimes.
     * @example
     * // Create one Systemtimes
     * const Systemtimes = await prisma.systemtimes.create({
     *   data: {
     *     // ... data to create a Systemtimes
     *   }
     * })
     * 
     */
    create<T extends systemtimesCreateArgs>(args: SelectSubset<T, systemtimesCreateArgs<ExtArgs>>): Prisma__systemtimesClient<$Result.GetResult<Prisma.$systemtimesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Systemtimes.
     * @param {systemtimesCreateManyArgs} args - Arguments to create many Systemtimes.
     * @example
     * // Create many Systemtimes
     * const systemtimes = await prisma.systemtimes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends systemtimesCreateManyArgs>(args?: SelectSubset<T, systemtimesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Systemtimes.
     * @param {systemtimesDeleteArgs} args - Arguments to delete one Systemtimes.
     * @example
     * // Delete one Systemtimes
     * const Systemtimes = await prisma.systemtimes.delete({
     *   where: {
     *     // ... filter to delete one Systemtimes
     *   }
     * })
     * 
     */
    delete<T extends systemtimesDeleteArgs>(args: SelectSubset<T, systemtimesDeleteArgs<ExtArgs>>): Prisma__systemtimesClient<$Result.GetResult<Prisma.$systemtimesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Systemtimes.
     * @param {systemtimesUpdateArgs} args - Arguments to update one Systemtimes.
     * @example
     * // Update one Systemtimes
     * const systemtimes = await prisma.systemtimes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends systemtimesUpdateArgs>(args: SelectSubset<T, systemtimesUpdateArgs<ExtArgs>>): Prisma__systemtimesClient<$Result.GetResult<Prisma.$systemtimesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Systemtimes.
     * @param {systemtimesDeleteManyArgs} args - Arguments to filter Systemtimes to delete.
     * @example
     * // Delete a few Systemtimes
     * const { count } = await prisma.systemtimes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends systemtimesDeleteManyArgs>(args?: SelectSubset<T, systemtimesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Systemtimes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {systemtimesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Systemtimes
     * const systemtimes = await prisma.systemtimes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends systemtimesUpdateManyArgs>(args: SelectSubset<T, systemtimesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Systemtimes.
     * @param {systemtimesUpsertArgs} args - Arguments to update or create a Systemtimes.
     * @example
     * // Update or create a Systemtimes
     * const systemtimes = await prisma.systemtimes.upsert({
     *   create: {
     *     // ... data to create a Systemtimes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Systemtimes we want to update
     *   }
     * })
     */
    upsert<T extends systemtimesUpsertArgs>(args: SelectSubset<T, systemtimesUpsertArgs<ExtArgs>>): Prisma__systemtimesClient<$Result.GetResult<Prisma.$systemtimesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Systemtimes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {systemtimesCountArgs} args - Arguments to filter Systemtimes to count.
     * @example
     * // Count the number of Systemtimes
     * const count = await prisma.systemtimes.count({
     *   where: {
     *     // ... the filter for the Systemtimes we want to count
     *   }
     * })
    **/
    count<T extends systemtimesCountArgs>(
      args?: Subset<T, systemtimesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemtimesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Systemtimes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemtimesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemtimesAggregateArgs>(args: Subset<T, SystemtimesAggregateArgs>): Prisma.PrismaPromise<GetSystemtimesAggregateType<T>>

    /**
     * Group by Systemtimes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {systemtimesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends systemtimesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: systemtimesGroupByArgs['orderBy'] }
        : { orderBy?: systemtimesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, systemtimesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemtimesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the systemtimes model
   */
  readonly fields: systemtimesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for systemtimes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__systemtimesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the systemtimes model
   */ 
  interface systemtimesFieldRefs {
    readonly id: FieldRef<"systemtimes", 'Int'>
    readonly yr: FieldRef<"systemtimes", 'Int'>
    readonly mnth: FieldRef<"systemtimes", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * systemtimes findUnique
   */
  export type systemtimesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the systemtimes
     */
    select?: systemtimesSelect<ExtArgs> | null
    /**
     * Filter, which systemtimes to fetch.
     */
    where: systemtimesWhereUniqueInput
  }

  /**
   * systemtimes findUniqueOrThrow
   */
  export type systemtimesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the systemtimes
     */
    select?: systemtimesSelect<ExtArgs> | null
    /**
     * Filter, which systemtimes to fetch.
     */
    where: systemtimesWhereUniqueInput
  }

  /**
   * systemtimes findFirst
   */
  export type systemtimesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the systemtimes
     */
    select?: systemtimesSelect<ExtArgs> | null
    /**
     * Filter, which systemtimes to fetch.
     */
    where?: systemtimesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of systemtimes to fetch.
     */
    orderBy?: systemtimesOrderByWithRelationInput | systemtimesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for systemtimes.
     */
    cursor?: systemtimesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` systemtimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` systemtimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of systemtimes.
     */
    distinct?: SystemtimesScalarFieldEnum | SystemtimesScalarFieldEnum[]
  }

  /**
   * systemtimes findFirstOrThrow
   */
  export type systemtimesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the systemtimes
     */
    select?: systemtimesSelect<ExtArgs> | null
    /**
     * Filter, which systemtimes to fetch.
     */
    where?: systemtimesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of systemtimes to fetch.
     */
    orderBy?: systemtimesOrderByWithRelationInput | systemtimesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for systemtimes.
     */
    cursor?: systemtimesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` systemtimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` systemtimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of systemtimes.
     */
    distinct?: SystemtimesScalarFieldEnum | SystemtimesScalarFieldEnum[]
  }

  /**
   * systemtimes findMany
   */
  export type systemtimesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the systemtimes
     */
    select?: systemtimesSelect<ExtArgs> | null
    /**
     * Filter, which systemtimes to fetch.
     */
    where?: systemtimesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of systemtimes to fetch.
     */
    orderBy?: systemtimesOrderByWithRelationInput | systemtimesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing systemtimes.
     */
    cursor?: systemtimesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` systemtimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` systemtimes.
     */
    skip?: number
    distinct?: SystemtimesScalarFieldEnum | SystemtimesScalarFieldEnum[]
  }

  /**
   * systemtimes create
   */
  export type systemtimesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the systemtimes
     */
    select?: systemtimesSelect<ExtArgs> | null
    /**
     * The data needed to create a systemtimes.
     */
    data?: XOR<systemtimesCreateInput, systemtimesUncheckedCreateInput>
  }

  /**
   * systemtimes createMany
   */
  export type systemtimesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many systemtimes.
     */
    data: systemtimesCreateManyInput | systemtimesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * systemtimes update
   */
  export type systemtimesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the systemtimes
     */
    select?: systemtimesSelect<ExtArgs> | null
    /**
     * The data needed to update a systemtimes.
     */
    data: XOR<systemtimesUpdateInput, systemtimesUncheckedUpdateInput>
    /**
     * Choose, which systemtimes to update.
     */
    where: systemtimesWhereUniqueInput
  }

  /**
   * systemtimes updateMany
   */
  export type systemtimesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update systemtimes.
     */
    data: XOR<systemtimesUpdateManyMutationInput, systemtimesUncheckedUpdateManyInput>
    /**
     * Filter which systemtimes to update
     */
    where?: systemtimesWhereInput
  }

  /**
   * systemtimes upsert
   */
  export type systemtimesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the systemtimes
     */
    select?: systemtimesSelect<ExtArgs> | null
    /**
     * The filter to search for the systemtimes to update in case it exists.
     */
    where: systemtimesWhereUniqueInput
    /**
     * In case the systemtimes found by the `where` argument doesn't exist, create a new systemtimes with this data.
     */
    create: XOR<systemtimesCreateInput, systemtimesUncheckedCreateInput>
    /**
     * In case the systemtimes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<systemtimesUpdateInput, systemtimesUncheckedUpdateInput>
  }

  /**
   * systemtimes delete
   */
  export type systemtimesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the systemtimes
     */
    select?: systemtimesSelect<ExtArgs> | null
    /**
     * Filter which systemtimes to delete.
     */
    where: systemtimesWhereUniqueInput
  }

  /**
   * systemtimes deleteMany
   */
  export type systemtimesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which systemtimes to delete
     */
    where?: systemtimesWhereInput
  }

  /**
   * systemtimes without action
   */
  export type systemtimesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the systemtimes
     */
    select?: systemtimesSelect<ExtArgs> | null
  }


  /**
   * Model totems
   */

  export type AggregateTotems = {
    _count: TotemsCountAggregateOutputType | null
    _avg: TotemsAvgAggregateOutputType | null
    _sum: TotemsSumAggregateOutputType | null
    _min: TotemsMinAggregateOutputType | null
    _max: TotemsMaxAggregateOutputType | null
  }

  export type TotemsAvgAggregateOutputType = {
    id: number | null
    alid: number | null
    totemid: number | null
  }

  export type TotemsSumAggregateOutputType = {
    id: number | null
    alid: number | null
    totemid: number | null
  }

  export type TotemsMinAggregateOutputType = {
    id: number | null
    alid: number | null
    totemid: number | null
  }

  export type TotemsMaxAggregateOutputType = {
    id: number | null
    alid: number | null
    totemid: number | null
  }

  export type TotemsCountAggregateOutputType = {
    id: number
    alid: number
    totemid: number
    _all: number
  }


  export type TotemsAvgAggregateInputType = {
    id?: true
    alid?: true
    totemid?: true
  }

  export type TotemsSumAggregateInputType = {
    id?: true
    alid?: true
    totemid?: true
  }

  export type TotemsMinAggregateInputType = {
    id?: true
    alid?: true
    totemid?: true
  }

  export type TotemsMaxAggregateInputType = {
    id?: true
    alid?: true
    totemid?: true
  }

  export type TotemsCountAggregateInputType = {
    id?: true
    alid?: true
    totemid?: true
    _all?: true
  }

  export type TotemsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which totems to aggregate.
     */
    where?: totemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of totems to fetch.
     */
    orderBy?: totemsOrderByWithRelationInput | totemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: totemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` totems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` totems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned totems
    **/
    _count?: true | TotemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TotemsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TotemsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TotemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TotemsMaxAggregateInputType
  }

  export type GetTotemsAggregateType<T extends TotemsAggregateArgs> = {
        [P in keyof T & keyof AggregateTotems]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTotems[P]>
      : GetScalarType<T[P], AggregateTotems[P]>
  }




  export type totemsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: totemsWhereInput
    orderBy?: totemsOrderByWithAggregationInput | totemsOrderByWithAggregationInput[]
    by: TotemsScalarFieldEnum[] | TotemsScalarFieldEnum
    having?: totemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TotemsCountAggregateInputType | true
    _avg?: TotemsAvgAggregateInputType
    _sum?: TotemsSumAggregateInputType
    _min?: TotemsMinAggregateInputType
    _max?: TotemsMaxAggregateInputType
  }

  export type TotemsGroupByOutputType = {
    id: number
    alid: number | null
    totemid: number | null
    _count: TotemsCountAggregateOutputType | null
    _avg: TotemsAvgAggregateOutputType | null
    _sum: TotemsSumAggregateOutputType | null
    _min: TotemsMinAggregateOutputType | null
    _max: TotemsMaxAggregateOutputType | null
  }

  type GetTotemsGroupByPayload<T extends totemsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TotemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TotemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TotemsGroupByOutputType[P]>
            : GetScalarType<T[P], TotemsGroupByOutputType[P]>
        }
      >
    >


  export type totemsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    alid?: boolean
    totemid?: boolean
  }, ExtArgs["result"]["totems"]>


  export type totemsSelectScalar = {
    id?: boolean
    alid?: boolean
    totemid?: boolean
  }


  export type $totemsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "totems"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      alid: number | null
      totemid: number | null
    }, ExtArgs["result"]["totems"]>
    composites: {}
  }

  type totemsGetPayload<S extends boolean | null | undefined | totemsDefaultArgs> = $Result.GetResult<Prisma.$totemsPayload, S>

  type totemsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<totemsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TotemsCountAggregateInputType | true
    }

  export interface totemsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['totems'], meta: { name: 'totems' } }
    /**
     * Find zero or one Totems that matches the filter.
     * @param {totemsFindUniqueArgs} args - Arguments to find a Totems
     * @example
     * // Get one Totems
     * const totems = await prisma.totems.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends totemsFindUniqueArgs>(args: SelectSubset<T, totemsFindUniqueArgs<ExtArgs>>): Prisma__totemsClient<$Result.GetResult<Prisma.$totemsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Totems that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {totemsFindUniqueOrThrowArgs} args - Arguments to find a Totems
     * @example
     * // Get one Totems
     * const totems = await prisma.totems.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends totemsFindUniqueOrThrowArgs>(args: SelectSubset<T, totemsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__totemsClient<$Result.GetResult<Prisma.$totemsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Totems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {totemsFindFirstArgs} args - Arguments to find a Totems
     * @example
     * // Get one Totems
     * const totems = await prisma.totems.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends totemsFindFirstArgs>(args?: SelectSubset<T, totemsFindFirstArgs<ExtArgs>>): Prisma__totemsClient<$Result.GetResult<Prisma.$totemsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Totems that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {totemsFindFirstOrThrowArgs} args - Arguments to find a Totems
     * @example
     * // Get one Totems
     * const totems = await prisma.totems.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends totemsFindFirstOrThrowArgs>(args?: SelectSubset<T, totemsFindFirstOrThrowArgs<ExtArgs>>): Prisma__totemsClient<$Result.GetResult<Prisma.$totemsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Totems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {totemsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Totems
     * const totems = await prisma.totems.findMany()
     * 
     * // Get first 10 Totems
     * const totems = await prisma.totems.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const totemsWithIdOnly = await prisma.totems.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends totemsFindManyArgs>(args?: SelectSubset<T, totemsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$totemsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Totems.
     * @param {totemsCreateArgs} args - Arguments to create a Totems.
     * @example
     * // Create one Totems
     * const Totems = await prisma.totems.create({
     *   data: {
     *     // ... data to create a Totems
     *   }
     * })
     * 
     */
    create<T extends totemsCreateArgs>(args: SelectSubset<T, totemsCreateArgs<ExtArgs>>): Prisma__totemsClient<$Result.GetResult<Prisma.$totemsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Totems.
     * @param {totemsCreateManyArgs} args - Arguments to create many Totems.
     * @example
     * // Create many Totems
     * const totems = await prisma.totems.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends totemsCreateManyArgs>(args?: SelectSubset<T, totemsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Totems.
     * @param {totemsDeleteArgs} args - Arguments to delete one Totems.
     * @example
     * // Delete one Totems
     * const Totems = await prisma.totems.delete({
     *   where: {
     *     // ... filter to delete one Totems
     *   }
     * })
     * 
     */
    delete<T extends totemsDeleteArgs>(args: SelectSubset<T, totemsDeleteArgs<ExtArgs>>): Prisma__totemsClient<$Result.GetResult<Prisma.$totemsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Totems.
     * @param {totemsUpdateArgs} args - Arguments to update one Totems.
     * @example
     * // Update one Totems
     * const totems = await prisma.totems.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends totemsUpdateArgs>(args: SelectSubset<T, totemsUpdateArgs<ExtArgs>>): Prisma__totemsClient<$Result.GetResult<Prisma.$totemsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Totems.
     * @param {totemsDeleteManyArgs} args - Arguments to filter Totems to delete.
     * @example
     * // Delete a few Totems
     * const { count } = await prisma.totems.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends totemsDeleteManyArgs>(args?: SelectSubset<T, totemsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Totems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {totemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Totems
     * const totems = await prisma.totems.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends totemsUpdateManyArgs>(args: SelectSubset<T, totemsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Totems.
     * @param {totemsUpsertArgs} args - Arguments to update or create a Totems.
     * @example
     * // Update or create a Totems
     * const totems = await prisma.totems.upsert({
     *   create: {
     *     // ... data to create a Totems
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Totems we want to update
     *   }
     * })
     */
    upsert<T extends totemsUpsertArgs>(args: SelectSubset<T, totemsUpsertArgs<ExtArgs>>): Prisma__totemsClient<$Result.GetResult<Prisma.$totemsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Totems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {totemsCountArgs} args - Arguments to filter Totems to count.
     * @example
     * // Count the number of Totems
     * const count = await prisma.totems.count({
     *   where: {
     *     // ... the filter for the Totems we want to count
     *   }
     * })
    **/
    count<T extends totemsCountArgs>(
      args?: Subset<T, totemsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TotemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Totems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TotemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TotemsAggregateArgs>(args: Subset<T, TotemsAggregateArgs>): Prisma.PrismaPromise<GetTotemsAggregateType<T>>

    /**
     * Group by Totems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {totemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends totemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: totemsGroupByArgs['orderBy'] }
        : { orderBy?: totemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, totemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTotemsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the totems model
   */
  readonly fields: totemsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for totems.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__totemsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the totems model
   */ 
  interface totemsFieldRefs {
    readonly id: FieldRef<"totems", 'Int'>
    readonly alid: FieldRef<"totems", 'Int'>
    readonly totemid: FieldRef<"totems", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * totems findUnique
   */
  export type totemsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the totems
     */
    select?: totemsSelect<ExtArgs> | null
    /**
     * Filter, which totems to fetch.
     */
    where: totemsWhereUniqueInput
  }

  /**
   * totems findUniqueOrThrow
   */
  export type totemsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the totems
     */
    select?: totemsSelect<ExtArgs> | null
    /**
     * Filter, which totems to fetch.
     */
    where: totemsWhereUniqueInput
  }

  /**
   * totems findFirst
   */
  export type totemsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the totems
     */
    select?: totemsSelect<ExtArgs> | null
    /**
     * Filter, which totems to fetch.
     */
    where?: totemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of totems to fetch.
     */
    orderBy?: totemsOrderByWithRelationInput | totemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for totems.
     */
    cursor?: totemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` totems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` totems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of totems.
     */
    distinct?: TotemsScalarFieldEnum | TotemsScalarFieldEnum[]
  }

  /**
   * totems findFirstOrThrow
   */
  export type totemsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the totems
     */
    select?: totemsSelect<ExtArgs> | null
    /**
     * Filter, which totems to fetch.
     */
    where?: totemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of totems to fetch.
     */
    orderBy?: totemsOrderByWithRelationInput | totemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for totems.
     */
    cursor?: totemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` totems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` totems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of totems.
     */
    distinct?: TotemsScalarFieldEnum | TotemsScalarFieldEnum[]
  }

  /**
   * totems findMany
   */
  export type totemsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the totems
     */
    select?: totemsSelect<ExtArgs> | null
    /**
     * Filter, which totems to fetch.
     */
    where?: totemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of totems to fetch.
     */
    orderBy?: totemsOrderByWithRelationInput | totemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing totems.
     */
    cursor?: totemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` totems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` totems.
     */
    skip?: number
    distinct?: TotemsScalarFieldEnum | TotemsScalarFieldEnum[]
  }

  /**
   * totems create
   */
  export type totemsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the totems
     */
    select?: totemsSelect<ExtArgs> | null
    /**
     * The data needed to create a totems.
     */
    data?: XOR<totemsCreateInput, totemsUncheckedCreateInput>
  }

  /**
   * totems createMany
   */
  export type totemsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many totems.
     */
    data: totemsCreateManyInput | totemsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * totems update
   */
  export type totemsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the totems
     */
    select?: totemsSelect<ExtArgs> | null
    /**
     * The data needed to update a totems.
     */
    data: XOR<totemsUpdateInput, totemsUncheckedUpdateInput>
    /**
     * Choose, which totems to update.
     */
    where: totemsWhereUniqueInput
  }

  /**
   * totems updateMany
   */
  export type totemsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update totems.
     */
    data: XOR<totemsUpdateManyMutationInput, totemsUncheckedUpdateManyInput>
    /**
     * Filter which totems to update
     */
    where?: totemsWhereInput
  }

  /**
   * totems upsert
   */
  export type totemsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the totems
     */
    select?: totemsSelect<ExtArgs> | null
    /**
     * The filter to search for the totems to update in case it exists.
     */
    where: totemsWhereUniqueInput
    /**
     * In case the totems found by the `where` argument doesn't exist, create a new totems with this data.
     */
    create: XOR<totemsCreateInput, totemsUncheckedCreateInput>
    /**
     * In case the totems was found with the provided `where` argument, update it with this data.
     */
    update: XOR<totemsUpdateInput, totemsUncheckedUpdateInput>
  }

  /**
   * totems delete
   */
  export type totemsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the totems
     */
    select?: totemsSelect<ExtArgs> | null
    /**
     * Filter which totems to delete.
     */
    where: totemsWhereUniqueInput
  }

  /**
   * totems deleteMany
   */
  export type totemsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which totems to delete
     */
    where?: totemsWhereInput
  }

  /**
   * totems without action
   */
  export type totemsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the totems
     */
    select?: totemsSelect<ExtArgs> | null
  }


  /**
   * Model trunks
   */

  export type AggregateTrunks = {
    _count: TrunksCountAggregateOutputType | null
    _avg: TrunksAvgAggregateOutputType | null
    _sum: TrunksSumAggregateOutputType | null
    _min: TrunksMinAggregateOutputType | null
    _max: TrunksMaxAggregateOutputType | null
  }

  export type TrunksAvgAggregateOutputType = {
    id: number | null
    slotcount: number | null
    money: number | null
  }

  export type TrunksSumAggregateOutputType = {
    id: number | null
    slotcount: number | null
    money: bigint | null
  }

  export type TrunksMinAggregateOutputType = {
    id: number | null
    slotcount: number | null
    money: bigint | null
  }

  export type TrunksMaxAggregateOutputType = {
    id: number | null
    slotcount: number | null
    money: bigint | null
  }

  export type TrunksCountAggregateOutputType = {
    id: number
    slotcount: number
    money: number
    _all: number
  }


  export type TrunksAvgAggregateInputType = {
    id?: true
    slotcount?: true
    money?: true
  }

  export type TrunksSumAggregateInputType = {
    id?: true
    slotcount?: true
    money?: true
  }

  export type TrunksMinAggregateInputType = {
    id?: true
    slotcount?: true
    money?: true
  }

  export type TrunksMaxAggregateInputType = {
    id?: true
    slotcount?: true
    money?: true
  }

  export type TrunksCountAggregateInputType = {
    id?: true
    slotcount?: true
    money?: true
    _all?: true
  }

  export type TrunksAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which trunks to aggregate.
     */
    where?: trunksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trunks to fetch.
     */
    orderBy?: trunksOrderByWithRelationInput | trunksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: trunksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trunks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trunks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned trunks
    **/
    _count?: true | TrunksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TrunksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TrunksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrunksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrunksMaxAggregateInputType
  }

  export type GetTrunksAggregateType<T extends TrunksAggregateArgs> = {
        [P in keyof T & keyof AggregateTrunks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrunks[P]>
      : GetScalarType<T[P], AggregateTrunks[P]>
  }




  export type trunksGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: trunksWhereInput
    orderBy?: trunksOrderByWithAggregationInput | trunksOrderByWithAggregationInput[]
    by: TrunksScalarFieldEnum[] | TrunksScalarFieldEnum
    having?: trunksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrunksCountAggregateInputType | true
    _avg?: TrunksAvgAggregateInputType
    _sum?: TrunksSumAggregateInputType
    _min?: TrunksMinAggregateInputType
    _max?: TrunksMaxAggregateInputType
  }

  export type TrunksGroupByOutputType = {
    id: number
    slotcount: number | null
    money: bigint | null
    _count: TrunksCountAggregateOutputType | null
    _avg: TrunksAvgAggregateOutputType | null
    _sum: TrunksSumAggregateOutputType | null
    _min: TrunksMinAggregateOutputType | null
    _max: TrunksMaxAggregateOutputType | null
  }

  type GetTrunksGroupByPayload<T extends trunksGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrunksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrunksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrunksGroupByOutputType[P]>
            : GetScalarType<T[P], TrunksGroupByOutputType[P]>
        }
      >
    >


  export type trunksSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slotcount?: boolean
    money?: boolean
  }, ExtArgs["result"]["trunks"]>


  export type trunksSelectScalar = {
    id?: boolean
    slotcount?: boolean
    money?: boolean
  }


  export type $trunksPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "trunks"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      slotcount: number | null
      money: bigint | null
    }, ExtArgs["result"]["trunks"]>
    composites: {}
  }

  type trunksGetPayload<S extends boolean | null | undefined | trunksDefaultArgs> = $Result.GetResult<Prisma.$trunksPayload, S>

  type trunksCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<trunksFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TrunksCountAggregateInputType | true
    }

  export interface trunksDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['trunks'], meta: { name: 'trunks' } }
    /**
     * Find zero or one Trunks that matches the filter.
     * @param {trunksFindUniqueArgs} args - Arguments to find a Trunks
     * @example
     * // Get one Trunks
     * const trunks = await prisma.trunks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends trunksFindUniqueArgs>(args: SelectSubset<T, trunksFindUniqueArgs<ExtArgs>>): Prisma__trunksClient<$Result.GetResult<Prisma.$trunksPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Trunks that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {trunksFindUniqueOrThrowArgs} args - Arguments to find a Trunks
     * @example
     * // Get one Trunks
     * const trunks = await prisma.trunks.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends trunksFindUniqueOrThrowArgs>(args: SelectSubset<T, trunksFindUniqueOrThrowArgs<ExtArgs>>): Prisma__trunksClient<$Result.GetResult<Prisma.$trunksPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Trunks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trunksFindFirstArgs} args - Arguments to find a Trunks
     * @example
     * // Get one Trunks
     * const trunks = await prisma.trunks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends trunksFindFirstArgs>(args?: SelectSubset<T, trunksFindFirstArgs<ExtArgs>>): Prisma__trunksClient<$Result.GetResult<Prisma.$trunksPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Trunks that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trunksFindFirstOrThrowArgs} args - Arguments to find a Trunks
     * @example
     * // Get one Trunks
     * const trunks = await prisma.trunks.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends trunksFindFirstOrThrowArgs>(args?: SelectSubset<T, trunksFindFirstOrThrowArgs<ExtArgs>>): Prisma__trunksClient<$Result.GetResult<Prisma.$trunksPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Trunks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trunksFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Trunks
     * const trunks = await prisma.trunks.findMany()
     * 
     * // Get first 10 Trunks
     * const trunks = await prisma.trunks.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trunksWithIdOnly = await prisma.trunks.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends trunksFindManyArgs>(args?: SelectSubset<T, trunksFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$trunksPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Trunks.
     * @param {trunksCreateArgs} args - Arguments to create a Trunks.
     * @example
     * // Create one Trunks
     * const Trunks = await prisma.trunks.create({
     *   data: {
     *     // ... data to create a Trunks
     *   }
     * })
     * 
     */
    create<T extends trunksCreateArgs>(args: SelectSubset<T, trunksCreateArgs<ExtArgs>>): Prisma__trunksClient<$Result.GetResult<Prisma.$trunksPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Trunks.
     * @param {trunksCreateManyArgs} args - Arguments to create many Trunks.
     * @example
     * // Create many Trunks
     * const trunks = await prisma.trunks.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends trunksCreateManyArgs>(args?: SelectSubset<T, trunksCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Trunks.
     * @param {trunksDeleteArgs} args - Arguments to delete one Trunks.
     * @example
     * // Delete one Trunks
     * const Trunks = await prisma.trunks.delete({
     *   where: {
     *     // ... filter to delete one Trunks
     *   }
     * })
     * 
     */
    delete<T extends trunksDeleteArgs>(args: SelectSubset<T, trunksDeleteArgs<ExtArgs>>): Prisma__trunksClient<$Result.GetResult<Prisma.$trunksPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Trunks.
     * @param {trunksUpdateArgs} args - Arguments to update one Trunks.
     * @example
     * // Update one Trunks
     * const trunks = await prisma.trunks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends trunksUpdateArgs>(args: SelectSubset<T, trunksUpdateArgs<ExtArgs>>): Prisma__trunksClient<$Result.GetResult<Prisma.$trunksPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Trunks.
     * @param {trunksDeleteManyArgs} args - Arguments to filter Trunks to delete.
     * @example
     * // Delete a few Trunks
     * const { count } = await prisma.trunks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends trunksDeleteManyArgs>(args?: SelectSubset<T, trunksDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trunks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trunksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Trunks
     * const trunks = await prisma.trunks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends trunksUpdateManyArgs>(args: SelectSubset<T, trunksUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Trunks.
     * @param {trunksUpsertArgs} args - Arguments to update or create a Trunks.
     * @example
     * // Update or create a Trunks
     * const trunks = await prisma.trunks.upsert({
     *   create: {
     *     // ... data to create a Trunks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Trunks we want to update
     *   }
     * })
     */
    upsert<T extends trunksUpsertArgs>(args: SelectSubset<T, trunksUpsertArgs<ExtArgs>>): Prisma__trunksClient<$Result.GetResult<Prisma.$trunksPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Trunks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trunksCountArgs} args - Arguments to filter Trunks to count.
     * @example
     * // Count the number of Trunks
     * const count = await prisma.trunks.count({
     *   where: {
     *     // ... the filter for the Trunks we want to count
     *   }
     * })
    **/
    count<T extends trunksCountArgs>(
      args?: Subset<T, trunksCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrunksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Trunks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrunksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrunksAggregateArgs>(args: Subset<T, TrunksAggregateArgs>): Prisma.PrismaPromise<GetTrunksAggregateType<T>>

    /**
     * Group by Trunks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trunksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends trunksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: trunksGroupByArgs['orderBy'] }
        : { orderBy?: trunksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, trunksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrunksGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the trunks model
   */
  readonly fields: trunksFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for trunks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__trunksClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the trunks model
   */ 
  interface trunksFieldRefs {
    readonly id: FieldRef<"trunks", 'Int'>
    readonly slotcount: FieldRef<"trunks", 'Int'>
    readonly money: FieldRef<"trunks", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * trunks findUnique
   */
  export type trunksFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trunks
     */
    select?: trunksSelect<ExtArgs> | null
    /**
     * Filter, which trunks to fetch.
     */
    where: trunksWhereUniqueInput
  }

  /**
   * trunks findUniqueOrThrow
   */
  export type trunksFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trunks
     */
    select?: trunksSelect<ExtArgs> | null
    /**
     * Filter, which trunks to fetch.
     */
    where: trunksWhereUniqueInput
  }

  /**
   * trunks findFirst
   */
  export type trunksFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trunks
     */
    select?: trunksSelect<ExtArgs> | null
    /**
     * Filter, which trunks to fetch.
     */
    where?: trunksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trunks to fetch.
     */
    orderBy?: trunksOrderByWithRelationInput | trunksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for trunks.
     */
    cursor?: trunksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trunks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trunks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of trunks.
     */
    distinct?: TrunksScalarFieldEnum | TrunksScalarFieldEnum[]
  }

  /**
   * trunks findFirstOrThrow
   */
  export type trunksFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trunks
     */
    select?: trunksSelect<ExtArgs> | null
    /**
     * Filter, which trunks to fetch.
     */
    where?: trunksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trunks to fetch.
     */
    orderBy?: trunksOrderByWithRelationInput | trunksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for trunks.
     */
    cursor?: trunksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trunks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trunks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of trunks.
     */
    distinct?: TrunksScalarFieldEnum | TrunksScalarFieldEnum[]
  }

  /**
   * trunks findMany
   */
  export type trunksFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trunks
     */
    select?: trunksSelect<ExtArgs> | null
    /**
     * Filter, which trunks to fetch.
     */
    where?: trunksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trunks to fetch.
     */
    orderBy?: trunksOrderByWithRelationInput | trunksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing trunks.
     */
    cursor?: trunksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trunks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trunks.
     */
    skip?: number
    distinct?: TrunksScalarFieldEnum | TrunksScalarFieldEnum[]
  }

  /**
   * trunks create
   */
  export type trunksCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trunks
     */
    select?: trunksSelect<ExtArgs> | null
    /**
     * The data needed to create a trunks.
     */
    data?: XOR<trunksCreateInput, trunksUncheckedCreateInput>
  }

  /**
   * trunks createMany
   */
  export type trunksCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many trunks.
     */
    data: trunksCreateManyInput | trunksCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * trunks update
   */
  export type trunksUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trunks
     */
    select?: trunksSelect<ExtArgs> | null
    /**
     * The data needed to update a trunks.
     */
    data: XOR<trunksUpdateInput, trunksUncheckedUpdateInput>
    /**
     * Choose, which trunks to update.
     */
    where: trunksWhereUniqueInput
  }

  /**
   * trunks updateMany
   */
  export type trunksUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update trunks.
     */
    data: XOR<trunksUpdateManyMutationInput, trunksUncheckedUpdateManyInput>
    /**
     * Filter which trunks to update
     */
    where?: trunksWhereInput
  }

  /**
   * trunks upsert
   */
  export type trunksUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trunks
     */
    select?: trunksSelect<ExtArgs> | null
    /**
     * The filter to search for the trunks to update in case it exists.
     */
    where: trunksWhereUniqueInput
    /**
     * In case the trunks found by the `where` argument doesn't exist, create a new trunks with this data.
     */
    create: XOR<trunksCreateInput, trunksUncheckedCreateInput>
    /**
     * In case the trunks was found with the provided `where` argument, update it with this data.
     */
    update: XOR<trunksUpdateInput, trunksUncheckedUpdateInput>
  }

  /**
   * trunks delete
   */
  export type trunksDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trunks
     */
    select?: trunksSelect<ExtArgs> | null
    /**
     * Filter which trunks to delete.
     */
    where: trunksWhereUniqueInput
  }

  /**
   * trunks deleteMany
   */
  export type trunksDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which trunks to delete
     */
    where?: trunksWhereInput
  }

  /**
   * trunks without action
   */
  export type trunksDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trunks
     */
    select?: trunksSelect<ExtArgs> | null
  }


  /**
   * Model unseenequips
   */

  export type AggregateUnseenequips = {
    _count: UnseenequipsCountAggregateOutputType | null
    _avg: UnseenequipsAvgAggregateOutputType | null
    _sum: UnseenequipsSumAggregateOutputType | null
    _min: UnseenequipsMinAggregateOutputType | null
    _max: UnseenequipsMaxAggregateOutputType | null
  }

  export type UnseenequipsAvgAggregateOutputType = {
    id: number | null
    alid: number | null
    equipid: number | null
  }

  export type UnseenequipsSumAggregateOutputType = {
    id: number | null
    alid: number | null
    equipid: number | null
  }

  export type UnseenequipsMinAggregateOutputType = {
    id: number | null
    alid: number | null
    equipid: number | null
  }

  export type UnseenequipsMaxAggregateOutputType = {
    id: number | null
    alid: number | null
    equipid: number | null
  }

  export type UnseenequipsCountAggregateOutputType = {
    id: number
    alid: number
    equipid: number
    _all: number
  }


  export type UnseenequipsAvgAggregateInputType = {
    id?: true
    alid?: true
    equipid?: true
  }

  export type UnseenequipsSumAggregateInputType = {
    id?: true
    alid?: true
    equipid?: true
  }

  export type UnseenequipsMinAggregateInputType = {
    id?: true
    alid?: true
    equipid?: true
  }

  export type UnseenequipsMaxAggregateInputType = {
    id?: true
    alid?: true
    equipid?: true
  }

  export type UnseenequipsCountAggregateInputType = {
    id?: true
    alid?: true
    equipid?: true
    _all?: true
  }

  export type UnseenequipsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which unseenequips to aggregate.
     */
    where?: unseenequipsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of unseenequips to fetch.
     */
    orderBy?: unseenequipsOrderByWithRelationInput | unseenequipsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: unseenequipsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` unseenequips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` unseenequips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned unseenequips
    **/
    _count?: true | UnseenequipsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UnseenequipsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UnseenequipsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnseenequipsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnseenequipsMaxAggregateInputType
  }

  export type GetUnseenequipsAggregateType<T extends UnseenequipsAggregateArgs> = {
        [P in keyof T & keyof AggregateUnseenequips]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnseenequips[P]>
      : GetScalarType<T[P], AggregateUnseenequips[P]>
  }




  export type unseenequipsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: unseenequipsWhereInput
    orderBy?: unseenequipsOrderByWithAggregationInput | unseenequipsOrderByWithAggregationInput[]
    by: UnseenequipsScalarFieldEnum[] | UnseenequipsScalarFieldEnum
    having?: unseenequipsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnseenequipsCountAggregateInputType | true
    _avg?: UnseenequipsAvgAggregateInputType
    _sum?: UnseenequipsSumAggregateInputType
    _min?: UnseenequipsMinAggregateInputType
    _max?: UnseenequipsMaxAggregateInputType
  }

  export type UnseenequipsGroupByOutputType = {
    id: number
    alid: number | null
    equipid: number | null
    _count: UnseenequipsCountAggregateOutputType | null
    _avg: UnseenequipsAvgAggregateOutputType | null
    _sum: UnseenequipsSumAggregateOutputType | null
    _min: UnseenequipsMinAggregateOutputType | null
    _max: UnseenequipsMaxAggregateOutputType | null
  }

  type GetUnseenequipsGroupByPayload<T extends unseenequipsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnseenequipsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnseenequipsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnseenequipsGroupByOutputType[P]>
            : GetScalarType<T[P], UnseenequipsGroupByOutputType[P]>
        }
      >
    >


  export type unseenequipsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    alid?: boolean
    equipid?: boolean
  }, ExtArgs["result"]["unseenequips"]>


  export type unseenequipsSelectScalar = {
    id?: boolean
    alid?: boolean
    equipid?: boolean
  }


  export type $unseenequipsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "unseenequips"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      alid: number | null
      equipid: number | null
    }, ExtArgs["result"]["unseenequips"]>
    composites: {}
  }

  type unseenequipsGetPayload<S extends boolean | null | undefined | unseenequipsDefaultArgs> = $Result.GetResult<Prisma.$unseenequipsPayload, S>

  type unseenequipsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<unseenequipsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UnseenequipsCountAggregateInputType | true
    }

  export interface unseenequipsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['unseenequips'], meta: { name: 'unseenequips' } }
    /**
     * Find zero or one Unseenequips that matches the filter.
     * @param {unseenequipsFindUniqueArgs} args - Arguments to find a Unseenequips
     * @example
     * // Get one Unseenequips
     * const unseenequips = await prisma.unseenequips.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends unseenequipsFindUniqueArgs>(args: SelectSubset<T, unseenequipsFindUniqueArgs<ExtArgs>>): Prisma__unseenequipsClient<$Result.GetResult<Prisma.$unseenequipsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Unseenequips that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {unseenequipsFindUniqueOrThrowArgs} args - Arguments to find a Unseenequips
     * @example
     * // Get one Unseenequips
     * const unseenequips = await prisma.unseenequips.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends unseenequipsFindUniqueOrThrowArgs>(args: SelectSubset<T, unseenequipsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__unseenequipsClient<$Result.GetResult<Prisma.$unseenequipsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Unseenequips that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {unseenequipsFindFirstArgs} args - Arguments to find a Unseenequips
     * @example
     * // Get one Unseenequips
     * const unseenequips = await prisma.unseenequips.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends unseenequipsFindFirstArgs>(args?: SelectSubset<T, unseenequipsFindFirstArgs<ExtArgs>>): Prisma__unseenequipsClient<$Result.GetResult<Prisma.$unseenequipsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Unseenequips that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {unseenequipsFindFirstOrThrowArgs} args - Arguments to find a Unseenequips
     * @example
     * // Get one Unseenequips
     * const unseenequips = await prisma.unseenequips.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends unseenequipsFindFirstOrThrowArgs>(args?: SelectSubset<T, unseenequipsFindFirstOrThrowArgs<ExtArgs>>): Prisma__unseenequipsClient<$Result.GetResult<Prisma.$unseenequipsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Unseenequips that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {unseenequipsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Unseenequips
     * const unseenequips = await prisma.unseenequips.findMany()
     * 
     * // Get first 10 Unseenequips
     * const unseenequips = await prisma.unseenequips.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unseenequipsWithIdOnly = await prisma.unseenequips.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends unseenequipsFindManyArgs>(args?: SelectSubset<T, unseenequipsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$unseenequipsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Unseenequips.
     * @param {unseenequipsCreateArgs} args - Arguments to create a Unseenequips.
     * @example
     * // Create one Unseenequips
     * const Unseenequips = await prisma.unseenequips.create({
     *   data: {
     *     // ... data to create a Unseenequips
     *   }
     * })
     * 
     */
    create<T extends unseenequipsCreateArgs>(args: SelectSubset<T, unseenequipsCreateArgs<ExtArgs>>): Prisma__unseenequipsClient<$Result.GetResult<Prisma.$unseenequipsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Unseenequips.
     * @param {unseenequipsCreateManyArgs} args - Arguments to create many Unseenequips.
     * @example
     * // Create many Unseenequips
     * const unseenequips = await prisma.unseenequips.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends unseenequipsCreateManyArgs>(args?: SelectSubset<T, unseenequipsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Unseenequips.
     * @param {unseenequipsDeleteArgs} args - Arguments to delete one Unseenequips.
     * @example
     * // Delete one Unseenequips
     * const Unseenequips = await prisma.unseenequips.delete({
     *   where: {
     *     // ... filter to delete one Unseenequips
     *   }
     * })
     * 
     */
    delete<T extends unseenequipsDeleteArgs>(args: SelectSubset<T, unseenequipsDeleteArgs<ExtArgs>>): Prisma__unseenequipsClient<$Result.GetResult<Prisma.$unseenequipsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Unseenequips.
     * @param {unseenequipsUpdateArgs} args - Arguments to update one Unseenequips.
     * @example
     * // Update one Unseenequips
     * const unseenequips = await prisma.unseenequips.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends unseenequipsUpdateArgs>(args: SelectSubset<T, unseenequipsUpdateArgs<ExtArgs>>): Prisma__unseenequipsClient<$Result.GetResult<Prisma.$unseenequipsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Unseenequips.
     * @param {unseenequipsDeleteManyArgs} args - Arguments to filter Unseenequips to delete.
     * @example
     * // Delete a few Unseenequips
     * const { count } = await prisma.unseenequips.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends unseenequipsDeleteManyArgs>(args?: SelectSubset<T, unseenequipsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Unseenequips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {unseenequipsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Unseenequips
     * const unseenequips = await prisma.unseenequips.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends unseenequipsUpdateManyArgs>(args: SelectSubset<T, unseenequipsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Unseenequips.
     * @param {unseenequipsUpsertArgs} args - Arguments to update or create a Unseenequips.
     * @example
     * // Update or create a Unseenequips
     * const unseenequips = await prisma.unseenequips.upsert({
     *   create: {
     *     // ... data to create a Unseenequips
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Unseenequips we want to update
     *   }
     * })
     */
    upsert<T extends unseenequipsUpsertArgs>(args: SelectSubset<T, unseenequipsUpsertArgs<ExtArgs>>): Prisma__unseenequipsClient<$Result.GetResult<Prisma.$unseenequipsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Unseenequips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {unseenequipsCountArgs} args - Arguments to filter Unseenequips to count.
     * @example
     * // Count the number of Unseenequips
     * const count = await prisma.unseenequips.count({
     *   where: {
     *     // ... the filter for the Unseenequips we want to count
     *   }
     * })
    **/
    count<T extends unseenequipsCountArgs>(
      args?: Subset<T, unseenequipsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnseenequipsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Unseenequips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnseenequipsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnseenequipsAggregateArgs>(args: Subset<T, UnseenequipsAggregateArgs>): Prisma.PrismaPromise<GetUnseenequipsAggregateType<T>>

    /**
     * Group by Unseenequips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {unseenequipsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends unseenequipsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: unseenequipsGroupByArgs['orderBy'] }
        : { orderBy?: unseenequipsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, unseenequipsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnseenequipsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the unseenequips model
   */
  readonly fields: unseenequipsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for unseenequips.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__unseenequipsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the unseenequips model
   */ 
  interface unseenequipsFieldRefs {
    readonly id: FieldRef<"unseenequips", 'Int'>
    readonly alid: FieldRef<"unseenequips", 'Int'>
    readonly equipid: FieldRef<"unseenequips", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * unseenequips findUnique
   */
  export type unseenequipsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unseenequips
     */
    select?: unseenequipsSelect<ExtArgs> | null
    /**
     * Filter, which unseenequips to fetch.
     */
    where: unseenequipsWhereUniqueInput
  }

  /**
   * unseenequips findUniqueOrThrow
   */
  export type unseenequipsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unseenequips
     */
    select?: unseenequipsSelect<ExtArgs> | null
    /**
     * Filter, which unseenequips to fetch.
     */
    where: unseenequipsWhereUniqueInput
  }

  /**
   * unseenequips findFirst
   */
  export type unseenequipsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unseenequips
     */
    select?: unseenequipsSelect<ExtArgs> | null
    /**
     * Filter, which unseenequips to fetch.
     */
    where?: unseenequipsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of unseenequips to fetch.
     */
    orderBy?: unseenequipsOrderByWithRelationInput | unseenequipsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for unseenequips.
     */
    cursor?: unseenequipsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` unseenequips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` unseenequips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of unseenequips.
     */
    distinct?: UnseenequipsScalarFieldEnum | UnseenequipsScalarFieldEnum[]
  }

  /**
   * unseenequips findFirstOrThrow
   */
  export type unseenequipsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unseenequips
     */
    select?: unseenequipsSelect<ExtArgs> | null
    /**
     * Filter, which unseenequips to fetch.
     */
    where?: unseenequipsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of unseenequips to fetch.
     */
    orderBy?: unseenequipsOrderByWithRelationInput | unseenequipsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for unseenequips.
     */
    cursor?: unseenequipsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` unseenequips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` unseenequips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of unseenequips.
     */
    distinct?: UnseenequipsScalarFieldEnum | UnseenequipsScalarFieldEnum[]
  }

  /**
   * unseenequips findMany
   */
  export type unseenequipsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unseenequips
     */
    select?: unseenequipsSelect<ExtArgs> | null
    /**
     * Filter, which unseenequips to fetch.
     */
    where?: unseenequipsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of unseenequips to fetch.
     */
    orderBy?: unseenequipsOrderByWithRelationInput | unseenequipsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing unseenequips.
     */
    cursor?: unseenequipsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` unseenequips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` unseenequips.
     */
    skip?: number
    distinct?: UnseenequipsScalarFieldEnum | UnseenequipsScalarFieldEnum[]
  }

  /**
   * unseenequips create
   */
  export type unseenequipsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unseenequips
     */
    select?: unseenequipsSelect<ExtArgs> | null
    /**
     * The data needed to create a unseenequips.
     */
    data?: XOR<unseenequipsCreateInput, unseenequipsUncheckedCreateInput>
  }

  /**
   * unseenequips createMany
   */
  export type unseenequipsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many unseenequips.
     */
    data: unseenequipsCreateManyInput | unseenequipsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * unseenequips update
   */
  export type unseenequipsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unseenequips
     */
    select?: unseenequipsSelect<ExtArgs> | null
    /**
     * The data needed to update a unseenequips.
     */
    data: XOR<unseenequipsUpdateInput, unseenequipsUncheckedUpdateInput>
    /**
     * Choose, which unseenequips to update.
     */
    where: unseenequipsWhereUniqueInput
  }

  /**
   * unseenequips updateMany
   */
  export type unseenequipsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update unseenequips.
     */
    data: XOR<unseenequipsUpdateManyMutationInput, unseenequipsUncheckedUpdateManyInput>
    /**
     * Filter which unseenequips to update
     */
    where?: unseenequipsWhereInput
  }

  /**
   * unseenequips upsert
   */
  export type unseenequipsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unseenequips
     */
    select?: unseenequipsSelect<ExtArgs> | null
    /**
     * The filter to search for the unseenequips to update in case it exists.
     */
    where: unseenequipsWhereUniqueInput
    /**
     * In case the unseenequips found by the `where` argument doesn't exist, create a new unseenequips with this data.
     */
    create: XOR<unseenequipsCreateInput, unseenequipsUncheckedCreateInput>
    /**
     * In case the unseenequips was found with the provided `where` argument, update it with this data.
     */
    update: XOR<unseenequipsUpdateInput, unseenequipsUncheckedUpdateInput>
  }

  /**
   * unseenequips delete
   */
  export type unseenequipsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unseenequips
     */
    select?: unseenequipsSelect<ExtArgs> | null
    /**
     * Filter which unseenequips to delete.
     */
    where: unseenequipsWhereUniqueInput
  }

  /**
   * unseenequips deleteMany
   */
  export type unseenequipsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which unseenequips to delete
     */
    where?: unseenequipsWhereInput
  }

  /**
   * unseenequips without action
   */
  export type unseenequipsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unseenequips
     */
    select?: unseenequipsSelect<ExtArgs> | null
  }


  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    id: number | null
    age: number | null
    accounttype: number | null
    votepoints: number | null
    donationpoints: number | null
    maplePoints: number | null
    nxPrepaid: number | null
    clientstate: number | null
    vipgrade: number | null
    vippoints: number | null
    nblockreason: number | null
    offensemanager: number | null
    gender: number | null
    msg2: number | null
    purchaseexp: number | null
    pblockreason: number | null
    chatunblockdate: number | null
    gradecode: number | null
    characterslots: number | null
    bosspoints: number | null
    lastvote1: number | null
    lastvote2: number | null
    claimvote1: number | null
    claimvote2: number | null
    dojop: number | null
  }

  export type UsersSumAggregateOutputType = {
    id: number | null
    age: number | null
    accounttype: number | null
    votepoints: number | null
    donationpoints: number | null
    maplePoints: number | null
    nxPrepaid: number | null
    clientstate: number | null
    vipgrade: number | null
    vippoints: number | null
    nblockreason: number | null
    offensemanager: number | null
    gender: number | null
    msg2: number | null
    purchaseexp: number | null
    pblockreason: number | null
    chatunblockdate: bigint | null
    gradecode: number | null
    characterslots: number | null
    bosspoints: number | null
    lastvote1: number | null
    lastvote2: number | null
    claimvote1: number | null
    claimvote2: number | null
    dojop: number | null
  }

  export type UsersMinAggregateOutputType = {
    id: number | null
    name: string | null
    password: string | null
    pic: string | null
    email: string | null
    age: number | null
    accounttype: number | null
    votepoints: number | null
    donationpoints: number | null
    maplePoints: number | null
    nxPrepaid: number | null
    clientstate: number | null
    vipgrade: number | null
    vippoints: number | null
    freevippointdate: Date | null
    vipexpireddate: Date | null
    nblockreason: number | null
    banExpireDate: Date | null
    banReason: string | null
    offensemanager: number | null
    gender: number | null
    msg2: number | null
    purchaseexp: number | null
    pblockreason: number | null
    chatunblockdate: bigint | null
    hascensorednxloginid: boolean | null
    gradecode: number | null
    censorednxloginid: string | null
    characterslots: number | null
    creationdate: Date | null
    bosspoints: number | null
    lastvote1: number | null
    lastvote2: number | null
    claimvote1: number | null
    claimvote2: number | null
    dojop: number | null
    lastvotetime: Date | null
    lastvoteip: string | null
    discordid: string | null
  }

  export type UsersMaxAggregateOutputType = {
    id: number | null
    name: string | null
    password: string | null
    pic: string | null
    email: string | null
    age: number | null
    accounttype: number | null
    votepoints: number | null
    donationpoints: number | null
    maplePoints: number | null
    nxPrepaid: number | null
    clientstate: number | null
    vipgrade: number | null
    vippoints: number | null
    freevippointdate: Date | null
    vipexpireddate: Date | null
    nblockreason: number | null
    banExpireDate: Date | null
    banReason: string | null
    offensemanager: number | null
    gender: number | null
    msg2: number | null
    purchaseexp: number | null
    pblockreason: number | null
    chatunblockdate: bigint | null
    hascensorednxloginid: boolean | null
    gradecode: number | null
    censorednxloginid: string | null
    characterslots: number | null
    creationdate: Date | null
    bosspoints: number | null
    lastvote1: number | null
    lastvote2: number | null
    claimvote1: number | null
    claimvote2: number | null
    dojop: number | null
    lastvotetime: Date | null
    lastvoteip: string | null
    discordid: string | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    name: number
    password: number
    pic: number
    email: number
    age: number
    accounttype: number
    votepoints: number
    donationpoints: number
    maplePoints: number
    nxPrepaid: number
    clientstate: number
    vipgrade: number
    vippoints: number
    freevippointdate: number
    vipexpireddate: number
    nblockreason: number
    banExpireDate: number
    banReason: number
    offensemanager: number
    gender: number
    msg2: number
    purchaseexp: number
    pblockreason: number
    chatunblockdate: number
    hascensorednxloginid: number
    gradecode: number
    censorednxloginid: number
    characterslots: number
    creationdate: number
    bosspoints: number
    lastvote1: number
    lastvote2: number
    claimvote1: number
    claimvote2: number
    dojop: number
    lastvotetime: number
    lastvoteip: number
    discordid: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    id?: true
    age?: true
    accounttype?: true
    votepoints?: true
    donationpoints?: true
    maplePoints?: true
    nxPrepaid?: true
    clientstate?: true
    vipgrade?: true
    vippoints?: true
    nblockreason?: true
    offensemanager?: true
    gender?: true
    msg2?: true
    purchaseexp?: true
    pblockreason?: true
    chatunblockdate?: true
    gradecode?: true
    characterslots?: true
    bosspoints?: true
    lastvote1?: true
    lastvote2?: true
    claimvote1?: true
    claimvote2?: true
    dojop?: true
  }

  export type UsersSumAggregateInputType = {
    id?: true
    age?: true
    accounttype?: true
    votepoints?: true
    donationpoints?: true
    maplePoints?: true
    nxPrepaid?: true
    clientstate?: true
    vipgrade?: true
    vippoints?: true
    nblockreason?: true
    offensemanager?: true
    gender?: true
    msg2?: true
    purchaseexp?: true
    pblockreason?: true
    chatunblockdate?: true
    gradecode?: true
    characterslots?: true
    bosspoints?: true
    lastvote1?: true
    lastvote2?: true
    claimvote1?: true
    claimvote2?: true
    dojop?: true
  }

  export type UsersMinAggregateInputType = {
    id?: true
    name?: true
    password?: true
    pic?: true
    email?: true
    age?: true
    accounttype?: true
    votepoints?: true
    donationpoints?: true
    maplePoints?: true
    nxPrepaid?: true
    clientstate?: true
    vipgrade?: true
    vippoints?: true
    freevippointdate?: true
    vipexpireddate?: true
    nblockreason?: true
    banExpireDate?: true
    banReason?: true
    offensemanager?: true
    gender?: true
    msg2?: true
    purchaseexp?: true
    pblockreason?: true
    chatunblockdate?: true
    hascensorednxloginid?: true
    gradecode?: true
    censorednxloginid?: true
    characterslots?: true
    creationdate?: true
    bosspoints?: true
    lastvote1?: true
    lastvote2?: true
    claimvote1?: true
    claimvote2?: true
    dojop?: true
    lastvotetime?: true
    lastvoteip?: true
    discordid?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    name?: true
    password?: true
    pic?: true
    email?: true
    age?: true
    accounttype?: true
    votepoints?: true
    donationpoints?: true
    maplePoints?: true
    nxPrepaid?: true
    clientstate?: true
    vipgrade?: true
    vippoints?: true
    freevippointdate?: true
    vipexpireddate?: true
    nblockreason?: true
    banExpireDate?: true
    banReason?: true
    offensemanager?: true
    gender?: true
    msg2?: true
    purchaseexp?: true
    pblockreason?: true
    chatunblockdate?: true
    hascensorednxloginid?: true
    gradecode?: true
    censorednxloginid?: true
    characterslots?: true
    creationdate?: true
    bosspoints?: true
    lastvote1?: true
    lastvote2?: true
    claimvote1?: true
    claimvote2?: true
    dojop?: true
    lastvotetime?: true
    lastvoteip?: true
    discordid?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    name?: true
    password?: true
    pic?: true
    email?: true
    age?: true
    accounttype?: true
    votepoints?: true
    donationpoints?: true
    maplePoints?: true
    nxPrepaid?: true
    clientstate?: true
    vipgrade?: true
    vippoints?: true
    freevippointdate?: true
    vipexpireddate?: true
    nblockreason?: true
    banExpireDate?: true
    banReason?: true
    offensemanager?: true
    gender?: true
    msg2?: true
    purchaseexp?: true
    pblockreason?: true
    chatunblockdate?: true
    hascensorednxloginid?: true
    gradecode?: true
    censorednxloginid?: true
    characterslots?: true
    creationdate?: true
    bosspoints?: true
    lastvote1?: true
    lastvote2?: true
    claimvote1?: true
    claimvote2?: true
    dojop?: true
    lastvotetime?: true
    lastvoteip?: true
    discordid?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: number
    name: string | null
    password: string | null
    pic: string | null
    email: string | null
    age: number | null
    accounttype: number | null
    votepoints: number | null
    donationpoints: number | null
    maplePoints: number | null
    nxPrepaid: number | null
    clientstate: number | null
    vipgrade: number | null
    vippoints: number | null
    freevippointdate: Date | null
    vipexpireddate: Date | null
    nblockreason: number | null
    banExpireDate: Date | null
    banReason: string | null
    offensemanager: number | null
    gender: number | null
    msg2: number | null
    purchaseexp: number | null
    pblockreason: number | null
    chatunblockdate: bigint | null
    hascensorednxloginid: boolean | null
    gradecode: number | null
    censorednxloginid: string | null
    characterslots: number
    creationdate: Date | null
    bosspoints: number
    lastvote1: number
    lastvote2: number
    claimvote1: number
    claimvote2: number
    dojop: number
    lastvotetime: Date | null
    lastvoteip: string | null
    discordid: string | null
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    password?: boolean
    pic?: boolean
    email?: boolean
    age?: boolean
    accounttype?: boolean
    votepoints?: boolean
    donationpoints?: boolean
    maplePoints?: boolean
    nxPrepaid?: boolean
    clientstate?: boolean
    vipgrade?: boolean
    vippoints?: boolean
    freevippointdate?: boolean
    vipexpireddate?: boolean
    nblockreason?: boolean
    banExpireDate?: boolean
    banReason?: boolean
    offensemanager?: boolean
    gender?: boolean
    msg2?: boolean
    purchaseexp?: boolean
    pblockreason?: boolean
    chatunblockdate?: boolean
    hascensorednxloginid?: boolean
    gradecode?: boolean
    censorednxloginid?: boolean
    characterslots?: boolean
    creationdate?: boolean
    bosspoints?: boolean
    lastvote1?: boolean
    lastvote2?: boolean
    claimvote1?: boolean
    claimvote2?: boolean
    dojop?: boolean
    lastvotetime?: boolean
    lastvoteip?: boolean
    discordid?: boolean
  }, ExtArgs["result"]["users"]>


  export type usersSelectScalar = {
    id?: boolean
    name?: boolean
    password?: boolean
    pic?: boolean
    email?: boolean
    age?: boolean
    accounttype?: boolean
    votepoints?: boolean
    donationpoints?: boolean
    maplePoints?: boolean
    nxPrepaid?: boolean
    clientstate?: boolean
    vipgrade?: boolean
    vippoints?: boolean
    freevippointdate?: boolean
    vipexpireddate?: boolean
    nblockreason?: boolean
    banExpireDate?: boolean
    banReason?: boolean
    offensemanager?: boolean
    gender?: boolean
    msg2?: boolean
    purchaseexp?: boolean
    pblockreason?: boolean
    chatunblockdate?: boolean
    hascensorednxloginid?: boolean
    gradecode?: boolean
    censorednxloginid?: boolean
    characterslots?: boolean
    creationdate?: boolean
    bosspoints?: boolean
    lastvote1?: boolean
    lastvote2?: boolean
    claimvote1?: boolean
    claimvote2?: boolean
    dojop?: boolean
    lastvotetime?: boolean
    lastvoteip?: boolean
    discordid?: boolean
  }


  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string | null
      password: string | null
      pic: string | null
      email: string | null
      age: number | null
      accounttype: number | null
      votepoints: number | null
      donationpoints: number | null
      maplePoints: number | null
      nxPrepaid: number | null
      clientstate: number | null
      vipgrade: number | null
      vippoints: number | null
      freevippointdate: Date | null
      vipexpireddate: Date | null
      nblockreason: number | null
      banExpireDate: Date | null
      banReason: string | null
      offensemanager: number | null
      gender: number | null
      msg2: number | null
      purchaseexp: number | null
      pblockreason: number | null
      chatunblockdate: bigint | null
      hascensorednxloginid: boolean | null
      gradecode: number | null
      censorednxloginid: string | null
      characterslots: number
      creationdate: Date | null
      bosspoints: number
      lastvote1: number
      lastvote2: number
      claimvote1: number
      claimvote2: number
      dojop: number
      lastvotetime: Date | null
      lastvoteip: string | null
      discordid: string | null
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usersFindUniqueArgs>(args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(args: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usersFindFirstArgs>(args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends usersFindManyArgs>(args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends usersCreateArgs>(args: SelectSubset<T, usersCreateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {usersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usersCreateManyArgs>(args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends usersDeleteArgs>(args: SelectSubset<T, usersDeleteArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usersUpdateArgs>(args: SelectSubset<T, usersUpdateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usersDeleteManyArgs>(args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usersUpdateManyArgs>(args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends usersUpsertArgs>(args: SelectSubset<T, usersUpsertArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users model
   */ 
  interface usersFieldRefs {
    readonly id: FieldRef<"users", 'Int'>
    readonly name: FieldRef<"users", 'String'>
    readonly password: FieldRef<"users", 'String'>
    readonly pic: FieldRef<"users", 'String'>
    readonly email: FieldRef<"users", 'String'>
    readonly age: FieldRef<"users", 'Int'>
    readonly accounttype: FieldRef<"users", 'Int'>
    readonly votepoints: FieldRef<"users", 'Int'>
    readonly donationpoints: FieldRef<"users", 'Int'>
    readonly maplePoints: FieldRef<"users", 'Int'>
    readonly nxPrepaid: FieldRef<"users", 'Int'>
    readonly clientstate: FieldRef<"users", 'Int'>
    readonly vipgrade: FieldRef<"users", 'Int'>
    readonly vippoints: FieldRef<"users", 'Int'>
    readonly freevippointdate: FieldRef<"users", 'DateTime'>
    readonly vipexpireddate: FieldRef<"users", 'DateTime'>
    readonly nblockreason: FieldRef<"users", 'Int'>
    readonly banExpireDate: FieldRef<"users", 'DateTime'>
    readonly banReason: FieldRef<"users", 'String'>
    readonly offensemanager: FieldRef<"users", 'Int'>
    readonly gender: FieldRef<"users", 'Int'>
    readonly msg2: FieldRef<"users", 'Int'>
    readonly purchaseexp: FieldRef<"users", 'Int'>
    readonly pblockreason: FieldRef<"users", 'Int'>
    readonly chatunblockdate: FieldRef<"users", 'BigInt'>
    readonly hascensorednxloginid: FieldRef<"users", 'Boolean'>
    readonly gradecode: FieldRef<"users", 'Int'>
    readonly censorednxloginid: FieldRef<"users", 'String'>
    readonly characterslots: FieldRef<"users", 'Int'>
    readonly creationdate: FieldRef<"users", 'DateTime'>
    readonly bosspoints: FieldRef<"users", 'Int'>
    readonly lastvote1: FieldRef<"users", 'Int'>
    readonly lastvote2: FieldRef<"users", 'Int'>
    readonly claimvote1: FieldRef<"users", 'Int'>
    readonly claimvote2: FieldRef<"users", 'Int'>
    readonly dojop: FieldRef<"users", 'Int'>
    readonly lastvotetime: FieldRef<"users", 'DateTime'>
    readonly lastvoteip: FieldRef<"users", 'String'>
    readonly discordid: FieldRef<"users", 'String'>
  }
    

  // Custom InputTypes
  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data?: XOR<usersCreateInput, usersUncheckedCreateInput>
  }

  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
  }

  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }

  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
  }

  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AccountsScalarFieldEnum: {
    id: 'id',
    worldid: 'worldid',
    userid: 'userid',
    trunkid: 'trunkid',
    nxCredit: 'nxCredit',
    monstercollectionid: 'monstercollectionid',
    employeetrunkid: 'employeetrunkid'
  };

  export type AccountsScalarFieldEnum = (typeof AccountsScalarFieldEnum)[keyof typeof AccountsScalarFieldEnum]


  export const Alliance_gradenamesScalarFieldEnum: {
    id: 'id',
    gradename: 'gradename',
    allianceid: 'allianceid'
  };

  export type Alliance_gradenamesScalarFieldEnum = (typeof Alliance_gradenamesScalarFieldEnum)[keyof typeof Alliance_gradenamesScalarFieldEnum]


  export const AlliancesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    maxmembernum: 'maxmembernum',
    notice: 'notice'
  };

  export type AlliancesScalarFieldEnum = (typeof AlliancesScalarFieldEnum)[keyof typeof AlliancesScalarFieldEnum]


  export const Auction_historiesScalarFieldEnum: {
    id: 'id',
    itemid: 'itemid',
    bargain: 'bargain',
    refund: 'refund',
    ownerid: 'ownerid',
    ownername: 'ownername',
    historytype: 'historytype',
    mesos: 'mesos',
    buyer: 'buyer',
    bid: 'bid',
    expiredtime: 'expiredtime',
    buytime: 'buytime',
    starttime: 'starttime'
  };

  export type Auction_historiesScalarFieldEnum = (typeof Auction_historiesScalarFieldEnum)[keyof typeof Auction_historiesScalarFieldEnum]


  export const Auction_itemsScalarFieldEnum: {
    id: 'id',
    itemid: 'itemid',
    bargain: 'bargain',
    ownerid: 'ownerid',
    ownername: 'ownername',
    mesos: 'mesos',
    buyer: 'buyer',
    bid: 'bid',
    expiredtime: 'expiredtime',
    starttime: 'starttime'
  };

  export type Auction_itemsScalarFieldEnum = (typeof Auction_itemsScalarFieldEnum)[keyof typeof Auction_itemsScalarFieldEnum]


  export const AvatardataScalarFieldEnum: {
    id: 'id',
    characterstat: 'characterstat',
    avatarlook: 'avatarlook',
    zeroavatarlook: 'zeroavatarlook'
  };

  export type AvatardataScalarFieldEnum = (typeof AvatardataScalarFieldEnum)[keyof typeof AvatardataScalarFieldEnum]


  export const AvatarlookScalarFieldEnum: {
    id: 'id',
    gender: 'gender',
    skin: 'skin',
    face: 'face',
    hair: 'hair',
    weaponstickerid: 'weaponstickerid',
    weaponid: 'weaponid',
    subweaponid: 'subweaponid',
    job: 'job',
    drawelfear: 'drawelfear',
    demonslayerdeffaceacc: 'demonslayerdeffaceacc',
    xenondeffaceacc: 'xenondeffaceacc',
    beasttamerdeffaceacc: 'beasttamerdeffaceacc',
    iszerobetalook: 'iszerobetalook',
    mixedhaircolor: 'mixedhaircolor',
    mixhairpercent: 'mixhairpercent',
    ears: 'ears',
    tail: 'tail'
  };

  export type AvatarlookScalarFieldEnum = (typeof AvatarlookScalarFieldEnum)[keyof typeof AvatarlookScalarFieldEnum]


  export const Bbs_recordsScalarFieldEnum: {
    id: 'id',
    idforbbs: 'idforbbs',
    creatorid: 'creatorid',
    subject: 'subject',
    msg: 'msg',
    creationdate: 'creationdate',
    icon: 'icon',
    guildid: 'guildid'
  };

  export type Bbs_recordsScalarFieldEnum = (typeof Bbs_recordsScalarFieldEnum)[keyof typeof Bbs_recordsScalarFieldEnum]


  export const Bbs_repliesScalarFieldEnum: {
    id: 'id',
    idforreply: 'idforreply',
    creatorid: 'creatorid',
    creationdate: 'creationdate',
    msg: 'msg',
    recordid: 'recordid'
  };

  export type Bbs_repliesScalarFieldEnum = (typeof Bbs_repliesScalarFieldEnum)[keyof typeof Bbs_repliesScalarFieldEnum]


  export const BeautydataScalarFieldEnum: {
    id: 'id',
    charID: 'charID',
    hairSize: 'hairSize',
    faceSize: 'faceSize',
    hairString: 'hairString',
    faceString: 'faceString'
  };

  export type BeautydataScalarFieldEnum = (typeof BeautydataScalarFieldEnum)[keyof typeof BeautydataScalarFieldEnum]


  export const BosslogScalarFieldEnum: {
    id: 'id',
    accountid: 'accountid',
    bossid: 'bossid',
    lastattempt: 'lastattempt',
    pqentry: 'pqentry'
  };

  export type BosslogScalarFieldEnum = (typeof BosslogScalarFieldEnum)[keyof typeof BosslogScalarFieldEnum]


  export const CashiteminfosScalarFieldEnum: {
    id: 'id',
    accountid: 'accountid',
    characterid: 'characterid',
    commodityid: 'commodityid',
    buycharacterid: 'buycharacterid',
    paybackrate: 'paybackrate',
    discount: 'discount',
    orderno: 'orderno',
    productno: 'productno',
    refundable: 'refundable',
    sourceflag: 'sourceflag',
    storebank: 'storebank',
    itemid: 'itemid',
    trunkid: 'trunkid',
    position: 'position'
  };

  export type CashiteminfosScalarFieldEnum = (typeof CashiteminfosScalarFieldEnum)[keyof typeof CashiteminfosScalarFieldEnum]


  export const CharacterpotentialsScalarFieldEnum: {
    id: 'id',
    potkey: 'potkey',
    skillid: 'skillid',
    slv: 'slv',
    grade: 'grade',
    charid: 'charid'
  };

  export type CharacterpotentialsScalarFieldEnum = (typeof CharacterpotentialsScalarFieldEnum)[keyof typeof CharacterpotentialsScalarFieldEnum]


  export const CharactersScalarFieldEnum: {
    id: 'id',
    accid: 'accid',
    orderid: 'orderid',
    avatardata: 'avatardata',
    equippedinventory: 'equippedinventory',
    equipinventory: 'equipinventory',
    consumeinventory: 'consumeinventory',
    etcinventory: 'etcinventory',
    installinventory: 'installinventory',
    cashinventory: 'cashinventory',
    funckeymap_id: 'funckeymap_id',
    fieldid: 'fieldid',
    questmanager: 'questmanager',
    guild: 'guild',
    rewardPoints: 'rewardPoints',
    monsterbook: 'monsterbook',
    party: 'party',
    medalid: 'medalid',
    monsterparkcount: 'monsterparkcount',
    previousFieldID: 'previousFieldID',
    onlineDay: 'onlineDay',
    onlineTime: 'onlineTime',
    quickslotKeys: 'quickslotKeys'
  };

  export type CharactersScalarFieldEnum = (typeof CharactersScalarFieldEnum)[keyof typeof CharactersScalarFieldEnum]


  export const CharacterstatsScalarFieldEnum: {
    id: 'id',
    characterid: 'characterid',
    characteridforlog: 'characteridforlog',
    worldidforlog: 'worldidforlog',
    name: 'name',
    gender: 'gender',
    skin: 'skin',
    face: 'face',
    hair: 'hair',
    mixbasehaircolor: 'mixbasehaircolor',
    mixaddhaircolor: 'mixaddhaircolor',
    mixhairbaseprob: 'mixhairbaseprob',
    level: 'level',
    job: 'job',
    str: 'str',
    dex: 'dex',
    inte: 'inte',
    luk: 'luk',
    hp: 'hp',
    maxhp: 'maxhp',
    mp: 'mp',
    maxmp: 'maxmp',
    ap: 'ap',
    sp: 'sp',
    exp: 'exp',
    pop: 'pop',
    money: 'money',
    wp: 'wp',
    extendsp: 'extendsp',
    posmap: 'posmap',
    portal: 'portal',
    subjob: 'subjob',
    deffaceacc: 'deffaceacc',
    fatigue: 'fatigue',
    lastfatigueupdatetime: 'lastfatigueupdatetime',
    charismaexp: 'charismaexp',
    insightexp: 'insightexp',
    willexp: 'willexp',
    craftexp: 'craftexp',
    senseexp: 'senseexp',
    charmexp: 'charmexp',
    noncombatstatdaylimit: 'noncombatstatdaylimit',
    mcpoint: 'mcpoint',
    pvpexp: 'pvpexp',
    pvpgrade: 'pvpgrade',
    pvppoint: 'pvppoint',
    pvpmodelevel: 'pvpmodelevel',
    pvpmodetype: 'pvpmodetype',
    eventpoint: 'eventpoint',
    albaactivityid: 'albaactivityid',
    albastarttime: 'albastarttime',
    albaduration: 'albaduration',
    albaspecialreward: 'albaspecialreward',
    burning: 'burning',
    charactercard: 'charactercard',
    accountlastlogout: 'accountlastlogout',
    lastlogout: 'lastlogout',
    gachexp: 'gachexp',
    honorexp: 'honorexp',
    nextavailablefametime: 'nextavailablefametime',
    node_shards: 'node_shards',
    maxfriends: 'maxfriends'
  };

  export type CharacterstatsScalarFieldEnum = (typeof CharacterstatsScalarFieldEnum)[keyof typeof CharacterstatsScalarFieldEnum]


  export const ChosenskillsScalarFieldEnum: {
    id: 'id',
    charid: 'charid',
    skillid: 'skillid',
    position: 'position'
  };

  export type ChosenskillsScalarFieldEnum = (typeof ChosenskillsScalarFieldEnum)[keyof typeof ChosenskillsScalarFieldEnum]


  export const Cms_votesScalarFieldEnum: {
    id: 'id',
    accountid: 'accountid',
    ip: 'ip',
    time: 'time',
    vp: 'vp',
    collected: 'collected'
  };

  export type Cms_votesScalarFieldEnum = (typeof Cms_votesScalarFieldEnum)[keyof typeof Cms_votesScalarFieldEnum]


  export const CooldownsScalarFieldEnum: {
    id: 'id',
    player_name: 'player_name',
    cooldown_type: 'cooldown_type',
    expiry_time: 'expiry_time'
  };

  export type CooldownsScalarFieldEnum = (typeof CooldownsScalarFieldEnum)[keyof typeof CooldownsScalarFieldEnum]


  export const CoresScalarFieldEnum: {
    id: 'id',
    pos: 'pos',
    charid: 'charid',
    slottype: 'slottype',
    coreid: 'coreid',
    leftCount: 'leftCount'
  };

  export type CoresScalarFieldEnum = (typeof CoresScalarFieldEnum)[keyof typeof CoresScalarFieldEnum]


  export const Cs_categoriesScalarFieldEnum: {
    id: 'id',
    idx: 'idx',
    name: 'name',
    flag: 'flag',
    parentIdx: 'parentIdx',
    stock: 'stock'
  };

  export type Cs_categoriesScalarFieldEnum = (typeof Cs_categoriesScalarFieldEnum)[keyof typeof Cs_categoriesScalarFieldEnum]


  export const Cs_itemsScalarFieldEnum: {
    id: 'id',
    itemID: 'itemID',
    stock: 'stock',
    shopItemFlag: 'shopItemFlag',
    idk1: 'idk1',
    idk2: 'idk2',
    oldPrice: 'oldPrice',
    newPrice: 'newPrice',
    idkTime1: 'idkTime1',
    saleFromFT: 'saleFromFT',
    idkTime3: 'idkTime3',
    saleToFT: 'saleToFT',
    idk3: 'idk3',
    bundleQuantity: 'bundleQuantity',
    availableDays: 'availableDays',
    buyableWithMaplePoints: 'buyableWithMaplePoints',
    buyableWithCredit: 'buyableWithCredit',
    buyableWithPrepaid: 'buyableWithPrepaid',
    likable: 'likable',
    meso: 'meso',
    favoritable: 'favoritable',
    gender: 'gender',
    likes: 'likes',
    requiredLevel: 'requiredLevel',
    idk10: 'idk10',
    idk11: 'idk11',
    idk13: 'idk13',
    idk14: 'idk14',
    category: 'category'
  };

  export type Cs_itemsScalarFieldEnum = (typeof Cs_itemsScalarFieldEnum)[keyof typeof Cs_itemsScalarFieldEnum]


  export const DamageskinsScalarFieldEnum: {
    id: 'id',
    charid: 'charid',
    damageskinid: 'damageskinid',
    itemid: 'itemid',
    notsave: 'notsave',
    description: 'description'
  };

  export type DamageskinsScalarFieldEnum = (typeof DamageskinsScalarFieldEnum)[keyof typeof DamageskinsScalarFieldEnum]


  export const EmployeetrunkScalarFieldEnum: {
    id: 'id',
    money: 'money'
  };

  export type EmployeetrunkScalarFieldEnum = (typeof EmployeetrunkScalarFieldEnum)[keyof typeof EmployeetrunkScalarFieldEnum]


  export const EquipsScalarFieldEnum: {
    serialnumber: 'serialnumber',
    itemid: 'itemid',
    title: 'title',
    equippeddate: 'equippeddate',
    prevbonusexprate: 'prevbonusexprate',
    options: 'options',
    sockets: 'sockets',
    tuc: 'tuc',
    cuc: 'cuc',
    istr: 'istr',
    idex: 'idex',
    iint: 'iint',
    iluk: 'iluk',
    imaxhp: 'imaxhp',
    imaxhpr: 'imaxhpr',
    imaxmp: 'imaxmp',
    imaxmpr: 'imaxmpr',
    ipad: 'ipad',
    imad: 'imad',
    ipdd: 'ipdd',
    imdd: 'imdd',
    iacc: 'iacc',
    ieva: 'ieva',
    icraft: 'icraft',
    ispeed: 'ispeed',
    ijump: 'ijump',
    arcaneid: 'arcaneid',
    attribute: 'attribute',
    leveluptype: 'leveluptype',
    level: 'level',
    exp: 'exp',
    durability: 'durability',
    iuc: 'iuc',
    ipvpdamage: 'ipvpdamage',
    ireducereq: 'ireducereq',
    specialattribute: 'specialattribute',
    durabilitymax: 'durabilitymax',
    iincreq: 'iincreq',
    growthenchant: 'growthenchant',
    psenchant: 'psenchant',
    hyperupgrade: 'hyperupgrade',
    bdr: 'bdr',
    imdr: 'imdr',
    damr: 'damr',
    statr: 'statr',
    cuttable: 'cuttable',
    exgradeoption: 'exgradeoption',
    itemstate: 'itemstate',
    grade: 'grade',
    chuc: 'chuc',
    souloptionid: 'souloptionid',
    soulsocketid: 'soulsocketid',
    souloption: 'souloption',
    soulitemid: 'soulitemid',
    rstr: 'rstr',
    rdex: 'rdex',
    rint: 'rint',
    rluk: 'rluk',
    rlevel: 'rlevel',
    rjob: 'rjob',
    rpop: 'rpop',
    specialgrade: 'specialgrade',
    fixedpotential: 'fixedpotential',
    tradeblock: 'tradeblock',
    isonly: 'isonly',
    notsale: 'notsale',
    attackspeed: 'attackspeed',
    price: 'price',
    charmexp: 'charmexp',
    setitemid: 'setitemid',
    exitem: 'exitem',
    equiptradeblock: 'equiptradeblock',
    islot: 'islot',
    vslot: 'vslot',
    fixedgrade: 'fixedgrade',
    nopotential: 'nopotential',
    bossreward: 'bossreward',
    superioreqp: 'superioreqp',
    flameid: 'flameid',
    android: 'android',
    androidgrade: 'androidgrade',
    arcane_stat: 'arcane_stat',
    arcane_exp: 'arcane_exp',
    arcane_level: 'arcane_level',
    flame_str: 'flame_str',
    flame_dex: 'flame_dex',
    flame_int: 'flame_int',
    flame_luk: 'flame_luk',
    flame_pad: 'flame_pad',
    flame_mad: 'flame_mad',
    flame_pdd: 'flame_pdd',
    flame_hp: 'flame_hp',
    flame_mp: 'flame_mp',
    flame_speed: 'flame_speed',
    flame_jump: 'flame_jump',
    flame_allStatR: 'flame_allStatR',
    flame_bossDamageR: 'flame_bossDamageR',
    flame_damageR: 'flame_damageR',
    flame_reduceReqLevel: 'flame_reduceReqLevel'
  };

  export type EquipsScalarFieldEnum = (typeof EquipsScalarFieldEnum)[keyof typeof EquipsScalarFieldEnum]


  export const EventnametagScalarFieldEnum: {
    id: 'id',
    charid: 'charid',
    activeRed: 'activeRed',
    activeBlue: 'activeBlue',
    activeYellow: 'activeYellow',
    activeGreen: 'activeGreen',
    activePurple: 'activePurple',
    sRed: 'sRed',
    sBlue: 'sBlue',
    sYellow: 'sYellow',
    sGreen: 'sGreen',
    sPurple: 'sPurple'
  };

  export type EventnametagScalarFieldEnum = (typeof EventnametagScalarFieldEnum)[keyof typeof EventnametagScalarFieldEnum]


  export const ExtendspScalarFieldEnum: {
    id: 'id'
  };

  export type ExtendspScalarFieldEnum = (typeof ExtendspScalarFieldEnum)[keyof typeof ExtendspScalarFieldEnum]


  export const FamiliarsScalarFieldEnum: {
    id: 'id',
    charid: 'charid',
    idk1: 'idk1',
    familiarid: 'familiarid',
    name: 'name',
    idk2: 'idk2',
    idk3: 'idk3',
    fatigue: 'fatigue',
    idk4: 'idk4',
    idk5: 'idk5',
    expiration: 'expiration',
    vitality: 'vitality'
  };

  export type FamiliarsScalarFieldEnum = (typeof FamiliarsScalarFieldEnum)[keyof typeof FamiliarsScalarFieldEnum]


  export const FriendsScalarFieldEnum: {
    id: 'id',
    ownerid: 'ownerid',
    owneraccid: 'owneraccid',
    friendid: 'friendid',
    friendaccountid: 'friendaccountid',
    name: 'name',
    flag: 'flag',
    groupname: 'groupname',
    mobile: 'mobile',
    nickname: 'nickname',
    memo: 'memo'
  };

  export type FriendsScalarFieldEnum = (typeof FriendsScalarFieldEnum)[keyof typeof FriendsScalarFieldEnum]


  export const FunckeymapScalarFieldEnum: {
    id: 'id',
    charId: 'charId',
    ord: 'ord'
  };

  export type FunckeymapScalarFieldEnum = (typeof FunckeymapScalarFieldEnum)[keyof typeof FunckeymapScalarFieldEnum]


  export const GradenamesScalarFieldEnum: {
    id: 'id',
    gradename: 'gradename',
    guildid: 'guildid'
  };

  export type GradenamesScalarFieldEnum = (typeof GradenamesScalarFieldEnum)[keyof typeof GradenamesScalarFieldEnum]


  export const GuildmembersScalarFieldEnum: {
    id: 'id',
    charid: 'charid',
    guildid: 'guildid',
    grade: 'grade',
    alliancegrade: 'alliancegrade',
    commitment: 'commitment',
    daycommitment: 'daycommitment',
    igp: 'igp',
    commitmentinctime: 'commitmentinctime',
    name: 'name',
    job: 'job',
    level: 'level',
    loggedin: 'loggedin'
  };

  export type GuildmembersScalarFieldEnum = (typeof GuildmembersScalarFieldEnum)[keyof typeof GuildmembersScalarFieldEnum]


  export const GuildrequestorsScalarFieldEnum: {
    id: 'id',
    requestors_id: 'requestors_id',
    charid: 'charid',
    guildid: 'guildid',
    name: 'name',
    job: 'job',
    level: 'level',
    loggedin: 'loggedin'
  };

  export type GuildrequestorsScalarFieldEnum = (typeof GuildrequestorsScalarFieldEnum)[keyof typeof GuildrequestorsScalarFieldEnum]


  export const GuildsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    leaderid: 'leaderid',
    worldid: 'worldid',
    markbg: 'markbg',
    markbgcolor: 'markbgcolor',
    mark: 'mark',
    markcolor: 'markcolor',
    maxmembers: 'maxmembers',
    notice: 'notice',
    points: 'points',
    seasonpoints: 'seasonpoints',
    allianceid: 'allianceid',
    level: 'level',
    guildrank: 'guildrank',
    ggp: 'ggp',
    appliable: 'appliable',
    joinsetting: 'joinsetting',
    reqlevel: 'reqlevel',
    bbsNotice: 'bbsNotice',
    battleSp: 'battleSp',
    fk_allianceid: 'fk_allianceid'
  };

  export type GuildsScalarFieldEnum = (typeof GuildsScalarFieldEnum)[keyof typeof GuildsScalarFieldEnum]


  export const GuildskillScalarFieldEnum: {
    id: 'id',
    skillid: 'skillid',
    level: 'level',
    expiredate: 'expiredate',
    buycharactername: 'buycharactername',
    extendcharactername: 'extendcharactername'
  };

  export type GuildskillScalarFieldEnum = (typeof GuildskillScalarFieldEnum)[keyof typeof GuildskillScalarFieldEnum]


  export const GuildskillsScalarFieldEnum: {
    guildskill_id: 'guildskill_id',
    skills_id: 'skills_id',
    guild_id: 'guild_id',
    skillid: 'skillid',
    fk_guildskillid: 'fk_guildskillid'
  };

  export type GuildskillsScalarFieldEnum = (typeof GuildskillsScalarFieldEnum)[keyof typeof GuildskillsScalarFieldEnum]


  export const HairequipsScalarFieldEnum: {
    id: 'id',
    alid: 'alid',
    equipid: 'equipid'
  };

  export type HairequipsScalarFieldEnum = (typeof HairequipsScalarFieldEnum)[keyof typeof HairequipsScalarFieldEnum]


  export const HyperrockfieldsScalarFieldEnum: {
    id: 'id',
    charid: 'charid',
    ord: 'ord',
    fieldid: 'fieldid'
  };

  export type HyperrockfieldsScalarFieldEnum = (typeof HyperrockfieldsScalarFieldEnum)[keyof typeof HyperrockfieldsScalarFieldEnum]


  export const InventoriesScalarFieldEnum: {
    id: 'id',
    type: 'type',
    slots: 'slots'
  };

  export type InventoriesScalarFieldEnum = (typeof InventoriesScalarFieldEnum)[keyof typeof InventoriesScalarFieldEnum]


  export const ItemsScalarFieldEnum: {
    id: 'id',
    inventoryid: 'inventoryid',
    trunkid: 'trunkid',
    auctionHouseStatus: 'auctionHouseStatus',
    itemid: 'itemid',
    bagindex: 'bagindex',
    cashitemserialnumber: 'cashitemserialnumber',
    dateexpire: 'dateexpire',
    invtype: 'invtype',
    type: 'type',
    iscash: 'iscash',
    quantity: 'quantity',
    expireonlogout: 'expireonlogout',
    owner: 'owner',
    obtainedonce: 'obtainedonce',
    zeroShareItemID: 'zeroShareItemID',
    attribute: 'attribute'
  };

  export type ItemsScalarFieldEnum = (typeof ItemsScalarFieldEnum)[keyof typeof ItemsScalarFieldEnum]


  export const ItemsbuylimitScalarFieldEnum: {
    id: 'id',
    shopitemid: 'shopitemid',
    charid: 'charid',
    amountbought: 'amountbought'
  };

  export type ItemsbuylimitScalarFieldEnum = (typeof ItemsbuylimitScalarFieldEnum)[keyof typeof ItemsbuylimitScalarFieldEnum]


  export const KeymapsScalarFieldEnum: {
    id: 'id',
    fkmapid: 'fkmapid',
    idx: 'idx',
    type: 'type',
    val: 'val'
  };

  export type KeymapsScalarFieldEnum = (typeof KeymapsScalarFieldEnum)[keyof typeof KeymapsScalarFieldEnum]


  export const LinkskillsScalarFieldEnum: {
    id: 'id',
    accid: 'accid',
    ownerid: 'ownerid',
    linkedcharid: 'linkedcharid',
    linkskillid: 'linkskillid',
    level: 'level',
    addeddate: 'addeddate'
  };

  export type LinkskillsScalarFieldEnum = (typeof LinkskillsScalarFieldEnum)[keyof typeof LinkskillsScalarFieldEnum]


  export const MacrosScalarFieldEnum: {
    id: 'id',
    charid: 'charid',
    muted: 'muted',
    name: 'name'
  };

  export type MacrosScalarFieldEnum = (typeof MacrosScalarFieldEnum)[keyof typeof MacrosScalarFieldEnum]


  export const MacroskillsScalarFieldEnum: {
    id: 'id',
    ordercol: 'ordercol',
    skillid: 'skillid',
    macroid: 'macroid'
  };

  export type MacroskillsScalarFieldEnum = (typeof MacroskillsScalarFieldEnum)[keyof typeof MacroskillsScalarFieldEnum]


  export const MatrixskillScalarFieldEnum: {
    id: 'id',
    charid: 'charid',
    state: 'state',
    coreID: 'coreID',
    skillID1: 'skillID1',
    skillID2: 'skillID2',
    skillID3: 'skillID3',
    level: 'level',
    maxLevel: 'maxLevel',
    experience: 'experience',
    crc: 'crc',
    slot: 'slot'
  };

  export type MatrixskillScalarFieldEnum = (typeof MatrixskillScalarFieldEnum)[keyof typeof MatrixskillScalarFieldEnum]


  export const MedalsScalarFieldEnum: {
    id: 'id',
    charid: 'charid',
    questid: 'questid',
    itemid: 'itemid',
    completedtime: 'completedtime'
  };

  export type MedalsScalarFieldEnum = (typeof MedalsScalarFieldEnum)[keyof typeof MedalsScalarFieldEnum]


  export const Mob_dropsScalarFieldEnum: {
    id: 'id',
    mobid: 'mobid',
    itemid: 'itemid',
    chance: 'chance',
    minquant: 'minquant',
    maxquant: 'maxquant',
    reactordrop: 'reactordrop'
  };

  export type Mob_dropsScalarFieldEnum = (typeof Mob_dropsScalarFieldEnum)[keyof typeof Mob_dropsScalarFieldEnum]


  export const Monster_collectionScalarFieldEnum: {
    id: 'id',
    mobid: 'mobid',
    region: 'region',
    session: 'session',
    position: 'position'
  };

  export type Monster_collectionScalarFieldEnum = (typeof Monster_collectionScalarFieldEnum)[keyof typeof Monster_collectionScalarFieldEnum]


  export const Monster_collection_explorationsScalarFieldEnum: {
    id: 'id',
    collectionid: 'collectionid',
    collectionkey: 'collectionkey',
    monsterkey: 'monsterkey',
    endDate: 'endDate',
    position: 'position'
  };

  export type Monster_collection_explorationsScalarFieldEnum = (typeof Monster_collection_explorationsScalarFieldEnum)[keyof typeof Monster_collection_explorationsScalarFieldEnum]


  export const Monster_collection_group_rewardsScalarFieldEnum: {
    region: 'region',
    session: 'session',
    groupid: 'groupid',
    rewardid: 'rewardid',
    quantity: 'quantity'
  };

  export type Monster_collection_group_rewardsScalarFieldEnum = (typeof Monster_collection_group_rewardsScalarFieldEnum)[keyof typeof Monster_collection_group_rewardsScalarFieldEnum]


  export const Monster_collection_mobsScalarFieldEnum: {
    id: 'id',
    collectionid: 'collectionid',
    mobid: 'mobid'
  };

  export type Monster_collection_mobsScalarFieldEnum = (typeof Monster_collection_mobsScalarFieldEnum)[keyof typeof Monster_collection_mobsScalarFieldEnum]


  export const Monster_collection_rewardsScalarFieldEnum: {
    region: 'region',
    session: 'session',
    groupid: 'groupid',
    collectionid: 'collectionid'
  };

  export type Monster_collection_rewardsScalarFieldEnum = (typeof Monster_collection_rewardsScalarFieldEnum)[keyof typeof Monster_collection_rewardsScalarFieldEnum]


  export const Monster_collection_session_rewardsScalarFieldEnum: {
    region: 'region',
    session: 'session',
    rewardid: 'rewardid',
    quantity: 'quantity'
  };

  export type Monster_collection_session_rewardsScalarFieldEnum = (typeof Monster_collection_session_rewardsScalarFieldEnum)[keyof typeof Monster_collection_session_rewardsScalarFieldEnum]


  export const Monster_collectionsScalarFieldEnum: {
    id: 'id',
    templateid: 'templateid',
    accid: 'accid'
  };

  export type Monster_collectionsScalarFieldEnum = (typeof Monster_collectionsScalarFieldEnum)[keyof typeof Monster_collectionsScalarFieldEnum]


  export const MonsterbookcardsScalarFieldEnum: {
    id: 'id',
    bookid: 'bookid',
    cardid: 'cardid'
  };

  export type MonsterbookcardsScalarFieldEnum = (typeof MonsterbookcardsScalarFieldEnum)[keyof typeof MonsterbookcardsScalarFieldEnum]


  export const MonsterbookinfosScalarFieldEnum: {
    id: 'id',
    setid: 'setid',
    coverid: 'coverid'
  };

  export type MonsterbookinfosScalarFieldEnum = (typeof MonsterbookinfosScalarFieldEnum)[keyof typeof MonsterbookinfosScalarFieldEnum]


  export const NoncombatstatdaylimitScalarFieldEnum: {
    id: 'id',
    charisma: 'charisma',
    charm: 'charm',
    insight: 'insight',
    will: 'will',
    craft: 'craft',
    sense: 'sense',
    lastupdatecharmbycashpr: 'lastupdatecharmbycashpr',
    charmbycashpr: 'charmbycashpr'
  };

  export type NoncombatstatdaylimitScalarFieldEnum = (typeof NoncombatstatdaylimitScalarFieldEnum)[keyof typeof NoncombatstatdaylimitScalarFieldEnum]


  export const NpcScalarFieldEnum: {
    id: 'id',
    npcid: 'npcid',
    mapid: 'mapid',
    x: 'x',
    y: 'y',
    cy: 'cy',
    rx0: 'rx0',
    rx1: 'rx1',
    fh: 'fh'
  };

  export type NpcScalarFieldEnum = (typeof NpcScalarFieldEnum)[keyof typeof NpcScalarFieldEnum]


  export const Offense_managersScalarFieldEnum: {
    id: 'id',
    points: 'points'
  };

  export type Offense_managersScalarFieldEnum = (typeof Offense_managersScalarFieldEnum)[keyof typeof Offense_managersScalarFieldEnum]


  export const OffensesScalarFieldEnum: {
    id: 'id',
    manager_id: 'manager_id',
    charid: 'charid',
    accountid: 'accountid',
    msg: 'msg',
    type: 'type',
    issuedate: 'issuedate',
    issuer_char_id: 'issuer_char_id'
  };

  export type OffensesScalarFieldEnum = (typeof OffensesScalarFieldEnum)[keyof typeof OffensesScalarFieldEnum]


  export const PartyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    partyleaderid: 'partyleaderid',
    appliable: 'appliable',
    isprivateparty: 'isprivateparty'
  };

  export type PartyScalarFieldEnum = (typeof PartyScalarFieldEnum)[keyof typeof PartyScalarFieldEnum]


  export const PartybossScalarFieldEnum: {
    id: 'id',
    charid: 'charid',
    orderid: 'orderid',
    bossname: 'bossname',
    difficulty: 'difficulty',
    attempt: 'attempt',
    lastattempttime: 'lastattempttime'
  };

  export type PartybossScalarFieldEnum = (typeof PartybossScalarFieldEnum)[keyof typeof PartybossScalarFieldEnum]


  export const PartymembersScalarFieldEnum: {
    id: 'id',
    partyid: 'partyid',
    charid: 'charid',
    name: 'name',
    job: 'job',
    subJob: 'subJob',
    level: 'level',
    channel: 'channel',
    fieldid: 'fieldid',
    loggedin: 'loggedin'
  };

  export type PartymembersScalarFieldEnum = (typeof PartymembersScalarFieldEnum)[keyof typeof PartymembersScalarFieldEnum]


  export const PetidsScalarFieldEnum: {
    id: 'id',
    alid: 'alid',
    petid: 'petid'
  };

  export type PetidsScalarFieldEnum = (typeof PetidsScalarFieldEnum)[keyof typeof PetidsScalarFieldEnum]


  export const PetitemsScalarFieldEnum: {
    itemid: 'itemid',
    name: 'name',
    level: 'level',
    tameness: 'tameness',
    repleteness: 'repleteness',
    petattribute: 'petattribute',
    petskill: 'petskill',
    datedead: 'datedead',
    remainlife: 'remainlife',
    attribute: 'attribute',
    activestate: 'activestate',
    autobuffskill: 'autobuffskill',
    pethue: 'pethue',
    giantrate: 'giantrate',
    exceptionList: 'exceptionList'
  };

  export type PetitemsScalarFieldEnum = (typeof PetitemsScalarFieldEnum)[keyof typeof PetitemsScalarFieldEnum]


  export const QuestlistsScalarFieldEnum: {
    questlist_id: 'questlist_id',
    questmanager_id: 'questmanager_id',
    questid: 'questid',
    fk_questid: 'fk_questid'
  };

  export type QuestlistsScalarFieldEnum = (typeof QuestlistsScalarFieldEnum)[keyof typeof QuestlistsScalarFieldEnum]


  export const QuestmanagersScalarFieldEnum: {
    id: 'id'
  };

  export type QuestmanagersScalarFieldEnum = (typeof QuestmanagersScalarFieldEnum)[keyof typeof QuestmanagersScalarFieldEnum]


  export const QuestprogressrequirementsScalarFieldEnum: {
    id: 'id',
    orderNum: 'orderNum',
    progresstype: 'progresstype',
    questid: 'questid',
    unitid: 'unitid',
    requiredcount: 'requiredcount',
    currentcount: 'currentcount'
  };

  export type QuestprogressrequirementsScalarFieldEnum = (typeof QuestprogressrequirementsScalarFieldEnum)[keyof typeof QuestprogressrequirementsScalarFieldEnum]


  export const QuestsScalarFieldEnum: {
    id: 'id',
    qrkey: 'qrkey',
    qrvalue: 'qrvalue',
    status: 'status',
    completedtime: 'completedtime',
    expireterm: 'expireterm'
  };

  export type QuestsScalarFieldEnum = (typeof QuestsScalarFieldEnum)[keyof typeof QuestsScalarFieldEnum]


  export const RewardinfoScalarFieldEnum: {
    id: 'id',
    charid: 'charid',
    charname: 'charname',
    rewardItemType: 'rewardItemType',
    itemID: 'itemID',
    quantity: 'quantity',
    maplePoint: 'maplePoint',
    meso: 'meso',
    level: 'level',
    exp: 'exp',
    description: 'description',
    starttime: 'starttime',
    endtime: 'endtime'
  };

  export type RewardinfoScalarFieldEnum = (typeof RewardinfoScalarFieldEnum)[keyof typeof RewardinfoScalarFieldEnum]


  export const ShopitemsScalarFieldEnum: {
    id: 'id',
    shopid: 'shopid',
    itemid: 'itemid',
    price: 'price',
    tokenitemid: 'tokenitemid',
    tokenprice: 'tokenprice',
    pointquestid: 'pointquestid',
    pointprice: 'pointprice',
    starcoin: 'starcoin',
    questexid: 'questexid',
    questexkey: 'questexkey',
    questexvalue: 'questexvalue',
    itemperiod: 'itemperiod',
    levellimited: 'levellimited',
    showlevmin: 'showlevmin',
    showlevmax: 'showlevmax',
    questid: 'questid',
    sellstart: 'sellstart',
    sellend: 'sellend',
    tabindex: 'tabindex',
    worldblock: 'worldblock',
    potentialgrade: 'potentialgrade',
    buylimit: 'buylimit',
    quantity: 'quantity',
    unitprice: 'unitprice',
    maxperslot: 'maxperslot',
    discountperc: 'discountperc'
  };

  export type ShopitemsScalarFieldEnum = (typeof ShopitemsScalarFieldEnum)[keyof typeof ShopitemsScalarFieldEnum]


  export const SkillcooltimesScalarFieldEnum: {
    id: 'id',
    charid: 'charid',
    skillid: 'skillid',
    nextusabletime: 'nextusabletime'
  };

  export type SkillcooltimesScalarFieldEnum = (typeof SkillcooltimesScalarFieldEnum)[keyof typeof SkillcooltimesScalarFieldEnum]


  export const SkillsScalarFieldEnum: {
    id: 'id',
    charid: 'charid',
    skillid: 'skillid',
    rootid: 'rootid',
    maxlevel: 'maxlevel',
    currentlevel: 'currentlevel',
    masterlevel: 'masterlevel'
  };

  export type SkillsScalarFieldEnum = (typeof SkillsScalarFieldEnum)[keyof typeof SkillsScalarFieldEnum]


  export const SpsetScalarFieldEnum: {
    id: 'id',
    extendsp_id: 'extendsp_id',
    joblevel: 'joblevel',
    sp: 'sp'
  };

  export type SpsetScalarFieldEnum = (typeof SpsetScalarFieldEnum)[keyof typeof SpsetScalarFieldEnum]


  export const StolenskillsScalarFieldEnum: {
    id: 'id',
    charid: 'charid',
    skillid: 'skillid',
    position: 'position',
    currentlv: 'currentlv'
  };

  export type StolenskillsScalarFieldEnum = (typeof StolenskillsScalarFieldEnum)[keyof typeof StolenskillsScalarFieldEnum]


  export const SystemtimesScalarFieldEnum: {
    id: 'id',
    yr: 'yr',
    mnth: 'mnth'
  };

  export type SystemtimesScalarFieldEnum = (typeof SystemtimesScalarFieldEnum)[keyof typeof SystemtimesScalarFieldEnum]


  export const TotemsScalarFieldEnum: {
    id: 'id',
    alid: 'alid',
    totemid: 'totemid'
  };

  export type TotemsScalarFieldEnum = (typeof TotemsScalarFieldEnum)[keyof typeof TotemsScalarFieldEnum]


  export const TrunksScalarFieldEnum: {
    id: 'id',
    slotcount: 'slotcount',
    money: 'money'
  };

  export type TrunksScalarFieldEnum = (typeof TrunksScalarFieldEnum)[keyof typeof TrunksScalarFieldEnum]


  export const UnseenequipsScalarFieldEnum: {
    id: 'id',
    alid: 'alid',
    equipid: 'equipid'
  };

  export type UnseenequipsScalarFieldEnum = (typeof UnseenequipsScalarFieldEnum)[keyof typeof UnseenequipsScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    id: 'id',
    name: 'name',
    password: 'password',
    pic: 'pic',
    email: 'email',
    age: 'age',
    accounttype: 'accounttype',
    votepoints: 'votepoints',
    donationpoints: 'donationpoints',
    maplePoints: 'maplePoints',
    nxPrepaid: 'nxPrepaid',
    clientstate: 'clientstate',
    vipgrade: 'vipgrade',
    vippoints: 'vippoints',
    freevippointdate: 'freevippointdate',
    vipexpireddate: 'vipexpireddate',
    nblockreason: 'nblockreason',
    banExpireDate: 'banExpireDate',
    banReason: 'banReason',
    offensemanager: 'offensemanager',
    gender: 'gender',
    msg2: 'msg2',
    purchaseexp: 'purchaseexp',
    pblockreason: 'pblockreason',
    chatunblockdate: 'chatunblockdate',
    hascensorednxloginid: 'hascensorednxloginid',
    gradecode: 'gradecode',
    censorednxloginid: 'censorednxloginid',
    characterslots: 'characterslots',
    creationdate: 'creationdate',
    bosspoints: 'bosspoints',
    lastvote1: 'lastvote1',
    lastvote2: 'lastvote2',
    claimvote1: 'claimvote1',
    claimvote2: 'claimvote2',
    dojop: 'dojop',
    lastvotetime: 'lastvotetime',
    lastvoteip: 'lastvoteip',
    discordid: 'discordid'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type accountsWhereInput = {
    AND?: accountsWhereInput | accountsWhereInput[]
    OR?: accountsWhereInput[]
    NOT?: accountsWhereInput | accountsWhereInput[]
    id?: IntFilter<"accounts"> | number
    worldid?: IntNullableFilter<"accounts"> | number | null
    userid?: IntNullableFilter<"accounts"> | number | null
    trunkid?: IntNullableFilter<"accounts"> | number | null
    nxCredit?: IntNullableFilter<"accounts"> | number | null
    monstercollectionid?: IntNullableFilter<"accounts"> | number | null
    employeetrunkid?: IntNullableFilter<"accounts"> | number | null
  }

  export type accountsOrderByWithRelationInput = {
    id?: SortOrder
    worldid?: SortOrderInput | SortOrder
    userid?: SortOrderInput | SortOrder
    trunkid?: SortOrderInput | SortOrder
    nxCredit?: SortOrderInput | SortOrder
    monstercollectionid?: SortOrderInput | SortOrder
    employeetrunkid?: SortOrderInput | SortOrder
  }

  export type accountsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: accountsWhereInput | accountsWhereInput[]
    OR?: accountsWhereInput[]
    NOT?: accountsWhereInput | accountsWhereInput[]
    worldid?: IntNullableFilter<"accounts"> | number | null
    userid?: IntNullableFilter<"accounts"> | number | null
    trunkid?: IntNullableFilter<"accounts"> | number | null
    nxCredit?: IntNullableFilter<"accounts"> | number | null
    monstercollectionid?: IntNullableFilter<"accounts"> | number | null
    employeetrunkid?: IntNullableFilter<"accounts"> | number | null
  }, "id">

  export type accountsOrderByWithAggregationInput = {
    id?: SortOrder
    worldid?: SortOrderInput | SortOrder
    userid?: SortOrderInput | SortOrder
    trunkid?: SortOrderInput | SortOrder
    nxCredit?: SortOrderInput | SortOrder
    monstercollectionid?: SortOrderInput | SortOrder
    employeetrunkid?: SortOrderInput | SortOrder
    _count?: accountsCountOrderByAggregateInput
    _avg?: accountsAvgOrderByAggregateInput
    _max?: accountsMaxOrderByAggregateInput
    _min?: accountsMinOrderByAggregateInput
    _sum?: accountsSumOrderByAggregateInput
  }

  export type accountsScalarWhereWithAggregatesInput = {
    AND?: accountsScalarWhereWithAggregatesInput | accountsScalarWhereWithAggregatesInput[]
    OR?: accountsScalarWhereWithAggregatesInput[]
    NOT?: accountsScalarWhereWithAggregatesInput | accountsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"accounts"> | number
    worldid?: IntNullableWithAggregatesFilter<"accounts"> | number | null
    userid?: IntNullableWithAggregatesFilter<"accounts"> | number | null
    trunkid?: IntNullableWithAggregatesFilter<"accounts"> | number | null
    nxCredit?: IntNullableWithAggregatesFilter<"accounts"> | number | null
    monstercollectionid?: IntNullableWithAggregatesFilter<"accounts"> | number | null
    employeetrunkid?: IntNullableWithAggregatesFilter<"accounts"> | number | null
  }

  export type alliance_gradenamesWhereInput = {
    AND?: alliance_gradenamesWhereInput | alliance_gradenamesWhereInput[]
    OR?: alliance_gradenamesWhereInput[]
    NOT?: alliance_gradenamesWhereInput | alliance_gradenamesWhereInput[]
    id?: IntFilter<"alliance_gradenames"> | number
    gradename?: StringNullableFilter<"alliance_gradenames"> | string | null
    allianceid?: IntNullableFilter<"alliance_gradenames"> | number | null
  }

  export type alliance_gradenamesOrderByWithRelationInput = {
    id?: SortOrder
    gradename?: SortOrderInput | SortOrder
    allianceid?: SortOrderInput | SortOrder
  }

  export type alliance_gradenamesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: alliance_gradenamesWhereInput | alliance_gradenamesWhereInput[]
    OR?: alliance_gradenamesWhereInput[]
    NOT?: alliance_gradenamesWhereInput | alliance_gradenamesWhereInput[]
    gradename?: StringNullableFilter<"alliance_gradenames"> | string | null
    allianceid?: IntNullableFilter<"alliance_gradenames"> | number | null
  }, "id">

  export type alliance_gradenamesOrderByWithAggregationInput = {
    id?: SortOrder
    gradename?: SortOrderInput | SortOrder
    allianceid?: SortOrderInput | SortOrder
    _count?: alliance_gradenamesCountOrderByAggregateInput
    _avg?: alliance_gradenamesAvgOrderByAggregateInput
    _max?: alliance_gradenamesMaxOrderByAggregateInput
    _min?: alliance_gradenamesMinOrderByAggregateInput
    _sum?: alliance_gradenamesSumOrderByAggregateInput
  }

  export type alliance_gradenamesScalarWhereWithAggregatesInput = {
    AND?: alliance_gradenamesScalarWhereWithAggregatesInput | alliance_gradenamesScalarWhereWithAggregatesInput[]
    OR?: alliance_gradenamesScalarWhereWithAggregatesInput[]
    NOT?: alliance_gradenamesScalarWhereWithAggregatesInput | alliance_gradenamesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"alliance_gradenames"> | number
    gradename?: StringNullableWithAggregatesFilter<"alliance_gradenames"> | string | null
    allianceid?: IntNullableWithAggregatesFilter<"alliance_gradenames"> | number | null
  }

  export type alliancesWhereInput = {
    AND?: alliancesWhereInput | alliancesWhereInput[]
    OR?: alliancesWhereInput[]
    NOT?: alliancesWhereInput | alliancesWhereInput[]
    id?: IntFilter<"alliances"> | number
    name?: StringNullableFilter<"alliances"> | string | null
    maxmembernum?: IntNullableFilter<"alliances"> | number | null
    notice?: StringNullableFilter<"alliances"> | string | null
  }

  export type alliancesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    maxmembernum?: SortOrderInput | SortOrder
    notice?: SortOrderInput | SortOrder
  }

  export type alliancesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: alliancesWhereInput | alliancesWhereInput[]
    OR?: alliancesWhereInput[]
    NOT?: alliancesWhereInput | alliancesWhereInput[]
    name?: StringNullableFilter<"alliances"> | string | null
    maxmembernum?: IntNullableFilter<"alliances"> | number | null
    notice?: StringNullableFilter<"alliances"> | string | null
  }, "id">

  export type alliancesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    maxmembernum?: SortOrderInput | SortOrder
    notice?: SortOrderInput | SortOrder
    _count?: alliancesCountOrderByAggregateInput
    _avg?: alliancesAvgOrderByAggregateInput
    _max?: alliancesMaxOrderByAggregateInput
    _min?: alliancesMinOrderByAggregateInput
    _sum?: alliancesSumOrderByAggregateInput
  }

  export type alliancesScalarWhereWithAggregatesInput = {
    AND?: alliancesScalarWhereWithAggregatesInput | alliancesScalarWhereWithAggregatesInput[]
    OR?: alliancesScalarWhereWithAggregatesInput[]
    NOT?: alliancesScalarWhereWithAggregatesInput | alliancesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"alliances"> | number
    name?: StringNullableWithAggregatesFilter<"alliances"> | string | null
    maxmembernum?: IntNullableWithAggregatesFilter<"alliances"> | number | null
    notice?: StringNullableWithAggregatesFilter<"alliances"> | string | null
  }

  export type auction_historiesWhereInput = {
    AND?: auction_historiesWhereInput | auction_historiesWhereInput[]
    OR?: auction_historiesWhereInput[]
    NOT?: auction_historiesWhereInput | auction_historiesWhereInput[]
    id?: IntFilter<"auction_histories"> | number
    itemid?: IntNullableFilter<"auction_histories"> | number | null
    bargain?: BoolNullableFilter<"auction_histories"> | boolean | null
    refund?: BoolNullableFilter<"auction_histories"> | boolean | null
    ownerid?: IntNullableFilter<"auction_histories"> | number | null
    ownername?: StringNullableFilter<"auction_histories"> | string | null
    historytype?: IntNullableFilter<"auction_histories"> | number | null
    mesos?: BigIntNullableFilter<"auction_histories"> | bigint | number | null
    buyer?: IntNullableFilter<"auction_histories"> | number | null
    bid?: BigIntNullableFilter<"auction_histories"> | bigint | number | null
    expiredtime?: DateTimeNullableFilter<"auction_histories"> | Date | string | null
    buytime?: DateTimeNullableFilter<"auction_histories"> | Date | string | null
    starttime?: DateTimeNullableFilter<"auction_histories"> | Date | string | null
  }

  export type auction_historiesOrderByWithRelationInput = {
    id?: SortOrder
    itemid?: SortOrderInput | SortOrder
    bargain?: SortOrderInput | SortOrder
    refund?: SortOrderInput | SortOrder
    ownerid?: SortOrderInput | SortOrder
    ownername?: SortOrderInput | SortOrder
    historytype?: SortOrderInput | SortOrder
    mesos?: SortOrderInput | SortOrder
    buyer?: SortOrderInput | SortOrder
    bid?: SortOrderInput | SortOrder
    expiredtime?: SortOrderInput | SortOrder
    buytime?: SortOrderInput | SortOrder
    starttime?: SortOrderInput | SortOrder
  }

  export type auction_historiesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: auction_historiesWhereInput | auction_historiesWhereInput[]
    OR?: auction_historiesWhereInput[]
    NOT?: auction_historiesWhereInput | auction_historiesWhereInput[]
    itemid?: IntNullableFilter<"auction_histories"> | number | null
    bargain?: BoolNullableFilter<"auction_histories"> | boolean | null
    refund?: BoolNullableFilter<"auction_histories"> | boolean | null
    ownerid?: IntNullableFilter<"auction_histories"> | number | null
    ownername?: StringNullableFilter<"auction_histories"> | string | null
    historytype?: IntNullableFilter<"auction_histories"> | number | null
    mesos?: BigIntNullableFilter<"auction_histories"> | bigint | number | null
    buyer?: IntNullableFilter<"auction_histories"> | number | null
    bid?: BigIntNullableFilter<"auction_histories"> | bigint | number | null
    expiredtime?: DateTimeNullableFilter<"auction_histories"> | Date | string | null
    buytime?: DateTimeNullableFilter<"auction_histories"> | Date | string | null
    starttime?: DateTimeNullableFilter<"auction_histories"> | Date | string | null
  }, "id">

  export type auction_historiesOrderByWithAggregationInput = {
    id?: SortOrder
    itemid?: SortOrderInput | SortOrder
    bargain?: SortOrderInput | SortOrder
    refund?: SortOrderInput | SortOrder
    ownerid?: SortOrderInput | SortOrder
    ownername?: SortOrderInput | SortOrder
    historytype?: SortOrderInput | SortOrder
    mesos?: SortOrderInput | SortOrder
    buyer?: SortOrderInput | SortOrder
    bid?: SortOrderInput | SortOrder
    expiredtime?: SortOrderInput | SortOrder
    buytime?: SortOrderInput | SortOrder
    starttime?: SortOrderInput | SortOrder
    _count?: auction_historiesCountOrderByAggregateInput
    _avg?: auction_historiesAvgOrderByAggregateInput
    _max?: auction_historiesMaxOrderByAggregateInput
    _min?: auction_historiesMinOrderByAggregateInput
    _sum?: auction_historiesSumOrderByAggregateInput
  }

  export type auction_historiesScalarWhereWithAggregatesInput = {
    AND?: auction_historiesScalarWhereWithAggregatesInput | auction_historiesScalarWhereWithAggregatesInput[]
    OR?: auction_historiesScalarWhereWithAggregatesInput[]
    NOT?: auction_historiesScalarWhereWithAggregatesInput | auction_historiesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"auction_histories"> | number
    itemid?: IntNullableWithAggregatesFilter<"auction_histories"> | number | null
    bargain?: BoolNullableWithAggregatesFilter<"auction_histories"> | boolean | null
    refund?: BoolNullableWithAggregatesFilter<"auction_histories"> | boolean | null
    ownerid?: IntNullableWithAggregatesFilter<"auction_histories"> | number | null
    ownername?: StringNullableWithAggregatesFilter<"auction_histories"> | string | null
    historytype?: IntNullableWithAggregatesFilter<"auction_histories"> | number | null
    mesos?: BigIntNullableWithAggregatesFilter<"auction_histories"> | bigint | number | null
    buyer?: IntNullableWithAggregatesFilter<"auction_histories"> | number | null
    bid?: BigIntNullableWithAggregatesFilter<"auction_histories"> | bigint | number | null
    expiredtime?: DateTimeNullableWithAggregatesFilter<"auction_histories"> | Date | string | null
    buytime?: DateTimeNullableWithAggregatesFilter<"auction_histories"> | Date | string | null
    starttime?: DateTimeNullableWithAggregatesFilter<"auction_histories"> | Date | string | null
  }

  export type auction_itemsWhereInput = {
    AND?: auction_itemsWhereInput | auction_itemsWhereInput[]
    OR?: auction_itemsWhereInput[]
    NOT?: auction_itemsWhereInput | auction_itemsWhereInput[]
    id?: IntFilter<"auction_items"> | number
    itemid?: IntNullableFilter<"auction_items"> | number | null
    bargain?: BoolNullableFilter<"auction_items"> | boolean | null
    ownerid?: IntNullableFilter<"auction_items"> | number | null
    ownername?: StringNullableFilter<"auction_items"> | string | null
    mesos?: BigIntNullableFilter<"auction_items"> | bigint | number | null
    buyer?: IntNullableFilter<"auction_items"> | number | null
    bid?: BigIntNullableFilter<"auction_items"> | bigint | number | null
    expiredtime?: DateTimeNullableFilter<"auction_items"> | Date | string | null
    starttime?: DateTimeNullableFilter<"auction_items"> | Date | string | null
  }

  export type auction_itemsOrderByWithRelationInput = {
    id?: SortOrder
    itemid?: SortOrderInput | SortOrder
    bargain?: SortOrderInput | SortOrder
    ownerid?: SortOrderInput | SortOrder
    ownername?: SortOrderInput | SortOrder
    mesos?: SortOrderInput | SortOrder
    buyer?: SortOrderInput | SortOrder
    bid?: SortOrderInput | SortOrder
    expiredtime?: SortOrderInput | SortOrder
    starttime?: SortOrderInput | SortOrder
  }

  export type auction_itemsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: auction_itemsWhereInput | auction_itemsWhereInput[]
    OR?: auction_itemsWhereInput[]
    NOT?: auction_itemsWhereInput | auction_itemsWhereInput[]
    itemid?: IntNullableFilter<"auction_items"> | number | null
    bargain?: BoolNullableFilter<"auction_items"> | boolean | null
    ownerid?: IntNullableFilter<"auction_items"> | number | null
    ownername?: StringNullableFilter<"auction_items"> | string | null
    mesos?: BigIntNullableFilter<"auction_items"> | bigint | number | null
    buyer?: IntNullableFilter<"auction_items"> | number | null
    bid?: BigIntNullableFilter<"auction_items"> | bigint | number | null
    expiredtime?: DateTimeNullableFilter<"auction_items"> | Date | string | null
    starttime?: DateTimeNullableFilter<"auction_items"> | Date | string | null
  }, "id">

  export type auction_itemsOrderByWithAggregationInput = {
    id?: SortOrder
    itemid?: SortOrderInput | SortOrder
    bargain?: SortOrderInput | SortOrder
    ownerid?: SortOrderInput | SortOrder
    ownername?: SortOrderInput | SortOrder
    mesos?: SortOrderInput | SortOrder
    buyer?: SortOrderInput | SortOrder
    bid?: SortOrderInput | SortOrder
    expiredtime?: SortOrderInput | SortOrder
    starttime?: SortOrderInput | SortOrder
    _count?: auction_itemsCountOrderByAggregateInput
    _avg?: auction_itemsAvgOrderByAggregateInput
    _max?: auction_itemsMaxOrderByAggregateInput
    _min?: auction_itemsMinOrderByAggregateInput
    _sum?: auction_itemsSumOrderByAggregateInput
  }

  export type auction_itemsScalarWhereWithAggregatesInput = {
    AND?: auction_itemsScalarWhereWithAggregatesInput | auction_itemsScalarWhereWithAggregatesInput[]
    OR?: auction_itemsScalarWhereWithAggregatesInput[]
    NOT?: auction_itemsScalarWhereWithAggregatesInput | auction_itemsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"auction_items"> | number
    itemid?: IntNullableWithAggregatesFilter<"auction_items"> | number | null
    bargain?: BoolNullableWithAggregatesFilter<"auction_items"> | boolean | null
    ownerid?: IntNullableWithAggregatesFilter<"auction_items"> | number | null
    ownername?: StringNullableWithAggregatesFilter<"auction_items"> | string | null
    mesos?: BigIntNullableWithAggregatesFilter<"auction_items"> | bigint | number | null
    buyer?: IntNullableWithAggregatesFilter<"auction_items"> | number | null
    bid?: BigIntNullableWithAggregatesFilter<"auction_items"> | bigint | number | null
    expiredtime?: DateTimeNullableWithAggregatesFilter<"auction_items"> | Date | string | null
    starttime?: DateTimeNullableWithAggregatesFilter<"auction_items"> | Date | string | null
  }

  export type avatardataWhereInput = {
    AND?: avatardataWhereInput | avatardataWhereInput[]
    OR?: avatardataWhereInput[]
    NOT?: avatardataWhereInput | avatardataWhereInput[]
    id?: IntFilter<"avatardata"> | number
    characterstat?: IntNullableFilter<"avatardata"> | number | null
    avatarlook?: IntNullableFilter<"avatardata"> | number | null
    zeroavatarlook?: IntNullableFilter<"avatardata"> | number | null
  }

  export type avatardataOrderByWithRelationInput = {
    id?: SortOrder
    characterstat?: SortOrderInput | SortOrder
    avatarlook?: SortOrderInput | SortOrder
    zeroavatarlook?: SortOrderInput | SortOrder
  }

  export type avatardataWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: avatardataWhereInput | avatardataWhereInput[]
    OR?: avatardataWhereInput[]
    NOT?: avatardataWhereInput | avatardataWhereInput[]
    characterstat?: IntNullableFilter<"avatardata"> | number | null
    avatarlook?: IntNullableFilter<"avatardata"> | number | null
    zeroavatarlook?: IntNullableFilter<"avatardata"> | number | null
  }, "id">

  export type avatardataOrderByWithAggregationInput = {
    id?: SortOrder
    characterstat?: SortOrderInput | SortOrder
    avatarlook?: SortOrderInput | SortOrder
    zeroavatarlook?: SortOrderInput | SortOrder
    _count?: avatardataCountOrderByAggregateInput
    _avg?: avatardataAvgOrderByAggregateInput
    _max?: avatardataMaxOrderByAggregateInput
    _min?: avatardataMinOrderByAggregateInput
    _sum?: avatardataSumOrderByAggregateInput
  }

  export type avatardataScalarWhereWithAggregatesInput = {
    AND?: avatardataScalarWhereWithAggregatesInput | avatardataScalarWhereWithAggregatesInput[]
    OR?: avatardataScalarWhereWithAggregatesInput[]
    NOT?: avatardataScalarWhereWithAggregatesInput | avatardataScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"avatardata"> | number
    characterstat?: IntNullableWithAggregatesFilter<"avatardata"> | number | null
    avatarlook?: IntNullableWithAggregatesFilter<"avatardata"> | number | null
    zeroavatarlook?: IntNullableWithAggregatesFilter<"avatardata"> | number | null
  }

  export type avatarlookWhereInput = {
    AND?: avatarlookWhereInput | avatarlookWhereInput[]
    OR?: avatarlookWhereInput[]
    NOT?: avatarlookWhereInput | avatarlookWhereInput[]
    id?: IntFilter<"avatarlook"> | number
    gender?: IntNullableFilter<"avatarlook"> | number | null
    skin?: IntNullableFilter<"avatarlook"> | number | null
    face?: IntNullableFilter<"avatarlook"> | number | null
    hair?: IntNullableFilter<"avatarlook"> | number | null
    weaponstickerid?: IntNullableFilter<"avatarlook"> | number | null
    weaponid?: IntNullableFilter<"avatarlook"> | number | null
    subweaponid?: IntNullableFilter<"avatarlook"> | number | null
    job?: IntNullableFilter<"avatarlook"> | number | null
    drawelfear?: BoolNullableFilter<"avatarlook"> | boolean | null
    demonslayerdeffaceacc?: IntNullableFilter<"avatarlook"> | number | null
    xenondeffaceacc?: IntNullableFilter<"avatarlook"> | number | null
    beasttamerdeffaceacc?: IntNullableFilter<"avatarlook"> | number | null
    iszerobetalook?: BoolNullableFilter<"avatarlook"> | boolean | null
    mixedhaircolor?: IntNullableFilter<"avatarlook"> | number | null
    mixhairpercent?: IntNullableFilter<"avatarlook"> | number | null
    ears?: IntNullableFilter<"avatarlook"> | number | null
    tail?: IntNullableFilter<"avatarlook"> | number | null
  }

  export type avatarlookOrderByWithRelationInput = {
    id?: SortOrder
    gender?: SortOrderInput | SortOrder
    skin?: SortOrderInput | SortOrder
    face?: SortOrderInput | SortOrder
    hair?: SortOrderInput | SortOrder
    weaponstickerid?: SortOrderInput | SortOrder
    weaponid?: SortOrderInput | SortOrder
    subweaponid?: SortOrderInput | SortOrder
    job?: SortOrderInput | SortOrder
    drawelfear?: SortOrderInput | SortOrder
    demonslayerdeffaceacc?: SortOrderInput | SortOrder
    xenondeffaceacc?: SortOrderInput | SortOrder
    beasttamerdeffaceacc?: SortOrderInput | SortOrder
    iszerobetalook?: SortOrderInput | SortOrder
    mixedhaircolor?: SortOrderInput | SortOrder
    mixhairpercent?: SortOrderInput | SortOrder
    ears?: SortOrderInput | SortOrder
    tail?: SortOrderInput | SortOrder
  }

  export type avatarlookWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: avatarlookWhereInput | avatarlookWhereInput[]
    OR?: avatarlookWhereInput[]
    NOT?: avatarlookWhereInput | avatarlookWhereInput[]
    gender?: IntNullableFilter<"avatarlook"> | number | null
    skin?: IntNullableFilter<"avatarlook"> | number | null
    face?: IntNullableFilter<"avatarlook"> | number | null
    hair?: IntNullableFilter<"avatarlook"> | number | null
    weaponstickerid?: IntNullableFilter<"avatarlook"> | number | null
    weaponid?: IntNullableFilter<"avatarlook"> | number | null
    subweaponid?: IntNullableFilter<"avatarlook"> | number | null
    job?: IntNullableFilter<"avatarlook"> | number | null
    drawelfear?: BoolNullableFilter<"avatarlook"> | boolean | null
    demonslayerdeffaceacc?: IntNullableFilter<"avatarlook"> | number | null
    xenondeffaceacc?: IntNullableFilter<"avatarlook"> | number | null
    beasttamerdeffaceacc?: IntNullableFilter<"avatarlook"> | number | null
    iszerobetalook?: BoolNullableFilter<"avatarlook"> | boolean | null
    mixedhaircolor?: IntNullableFilter<"avatarlook"> | number | null
    mixhairpercent?: IntNullableFilter<"avatarlook"> | number | null
    ears?: IntNullableFilter<"avatarlook"> | number | null
    tail?: IntNullableFilter<"avatarlook"> | number | null
  }, "id">

  export type avatarlookOrderByWithAggregationInput = {
    id?: SortOrder
    gender?: SortOrderInput | SortOrder
    skin?: SortOrderInput | SortOrder
    face?: SortOrderInput | SortOrder
    hair?: SortOrderInput | SortOrder
    weaponstickerid?: SortOrderInput | SortOrder
    weaponid?: SortOrderInput | SortOrder
    subweaponid?: SortOrderInput | SortOrder
    job?: SortOrderInput | SortOrder
    drawelfear?: SortOrderInput | SortOrder
    demonslayerdeffaceacc?: SortOrderInput | SortOrder
    xenondeffaceacc?: SortOrderInput | SortOrder
    beasttamerdeffaceacc?: SortOrderInput | SortOrder
    iszerobetalook?: SortOrderInput | SortOrder
    mixedhaircolor?: SortOrderInput | SortOrder
    mixhairpercent?: SortOrderInput | SortOrder
    ears?: SortOrderInput | SortOrder
    tail?: SortOrderInput | SortOrder
    _count?: avatarlookCountOrderByAggregateInput
    _avg?: avatarlookAvgOrderByAggregateInput
    _max?: avatarlookMaxOrderByAggregateInput
    _min?: avatarlookMinOrderByAggregateInput
    _sum?: avatarlookSumOrderByAggregateInput
  }

  export type avatarlookScalarWhereWithAggregatesInput = {
    AND?: avatarlookScalarWhereWithAggregatesInput | avatarlookScalarWhereWithAggregatesInput[]
    OR?: avatarlookScalarWhereWithAggregatesInput[]
    NOT?: avatarlookScalarWhereWithAggregatesInput | avatarlookScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"avatarlook"> | number
    gender?: IntNullableWithAggregatesFilter<"avatarlook"> | number | null
    skin?: IntNullableWithAggregatesFilter<"avatarlook"> | number | null
    face?: IntNullableWithAggregatesFilter<"avatarlook"> | number | null
    hair?: IntNullableWithAggregatesFilter<"avatarlook"> | number | null
    weaponstickerid?: IntNullableWithAggregatesFilter<"avatarlook"> | number | null
    weaponid?: IntNullableWithAggregatesFilter<"avatarlook"> | number | null
    subweaponid?: IntNullableWithAggregatesFilter<"avatarlook"> | number | null
    job?: IntNullableWithAggregatesFilter<"avatarlook"> | number | null
    drawelfear?: BoolNullableWithAggregatesFilter<"avatarlook"> | boolean | null
    demonslayerdeffaceacc?: IntNullableWithAggregatesFilter<"avatarlook"> | number | null
    xenondeffaceacc?: IntNullableWithAggregatesFilter<"avatarlook"> | number | null
    beasttamerdeffaceacc?: IntNullableWithAggregatesFilter<"avatarlook"> | number | null
    iszerobetalook?: BoolNullableWithAggregatesFilter<"avatarlook"> | boolean | null
    mixedhaircolor?: IntNullableWithAggregatesFilter<"avatarlook"> | number | null
    mixhairpercent?: IntNullableWithAggregatesFilter<"avatarlook"> | number | null
    ears?: IntNullableWithAggregatesFilter<"avatarlook"> | number | null
    tail?: IntNullableWithAggregatesFilter<"avatarlook"> | number | null
  }

  export type bbs_recordsWhereInput = {
    AND?: bbs_recordsWhereInput | bbs_recordsWhereInput[]
    OR?: bbs_recordsWhereInput[]
    NOT?: bbs_recordsWhereInput | bbs_recordsWhereInput[]
    id?: IntFilter<"bbs_records"> | number
    idforbbs?: IntNullableFilter<"bbs_records"> | number | null
    creatorid?: IntNullableFilter<"bbs_records"> | number | null
    subject?: StringNullableFilter<"bbs_records"> | string | null
    msg?: StringNullableFilter<"bbs_records"> | string | null
    creationdate?: DateTimeNullableFilter<"bbs_records"> | Date | string | null
    icon?: IntNullableFilter<"bbs_records"> | number | null
    guildid?: IntNullableFilter<"bbs_records"> | number | null
  }

  export type bbs_recordsOrderByWithRelationInput = {
    id?: SortOrder
    idforbbs?: SortOrderInput | SortOrder
    creatorid?: SortOrderInput | SortOrder
    subject?: SortOrderInput | SortOrder
    msg?: SortOrderInput | SortOrder
    creationdate?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    guildid?: SortOrderInput | SortOrder
  }

  export type bbs_recordsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: bbs_recordsWhereInput | bbs_recordsWhereInput[]
    OR?: bbs_recordsWhereInput[]
    NOT?: bbs_recordsWhereInput | bbs_recordsWhereInput[]
    idforbbs?: IntNullableFilter<"bbs_records"> | number | null
    creatorid?: IntNullableFilter<"bbs_records"> | number | null
    subject?: StringNullableFilter<"bbs_records"> | string | null
    msg?: StringNullableFilter<"bbs_records"> | string | null
    creationdate?: DateTimeNullableFilter<"bbs_records"> | Date | string | null
    icon?: IntNullableFilter<"bbs_records"> | number | null
    guildid?: IntNullableFilter<"bbs_records"> | number | null
  }, "id">

  export type bbs_recordsOrderByWithAggregationInput = {
    id?: SortOrder
    idforbbs?: SortOrderInput | SortOrder
    creatorid?: SortOrderInput | SortOrder
    subject?: SortOrderInput | SortOrder
    msg?: SortOrderInput | SortOrder
    creationdate?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    guildid?: SortOrderInput | SortOrder
    _count?: bbs_recordsCountOrderByAggregateInput
    _avg?: bbs_recordsAvgOrderByAggregateInput
    _max?: bbs_recordsMaxOrderByAggregateInput
    _min?: bbs_recordsMinOrderByAggregateInput
    _sum?: bbs_recordsSumOrderByAggregateInput
  }

  export type bbs_recordsScalarWhereWithAggregatesInput = {
    AND?: bbs_recordsScalarWhereWithAggregatesInput | bbs_recordsScalarWhereWithAggregatesInput[]
    OR?: bbs_recordsScalarWhereWithAggregatesInput[]
    NOT?: bbs_recordsScalarWhereWithAggregatesInput | bbs_recordsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"bbs_records"> | number
    idforbbs?: IntNullableWithAggregatesFilter<"bbs_records"> | number | null
    creatorid?: IntNullableWithAggregatesFilter<"bbs_records"> | number | null
    subject?: StringNullableWithAggregatesFilter<"bbs_records"> | string | null
    msg?: StringNullableWithAggregatesFilter<"bbs_records"> | string | null
    creationdate?: DateTimeNullableWithAggregatesFilter<"bbs_records"> | Date | string | null
    icon?: IntNullableWithAggregatesFilter<"bbs_records"> | number | null
    guildid?: IntNullableWithAggregatesFilter<"bbs_records"> | number | null
  }

  export type bbs_repliesWhereInput = {
    AND?: bbs_repliesWhereInput | bbs_repliesWhereInput[]
    OR?: bbs_repliesWhereInput[]
    NOT?: bbs_repliesWhereInput | bbs_repliesWhereInput[]
    id?: IntFilter<"bbs_replies"> | number
    idforreply?: IntNullableFilter<"bbs_replies"> | number | null
    creatorid?: IntNullableFilter<"bbs_replies"> | number | null
    creationdate?: DateTimeNullableFilter<"bbs_replies"> | Date | string | null
    msg?: StringNullableFilter<"bbs_replies"> | string | null
    recordid?: IntNullableFilter<"bbs_replies"> | number | null
  }

  export type bbs_repliesOrderByWithRelationInput = {
    id?: SortOrder
    idforreply?: SortOrderInput | SortOrder
    creatorid?: SortOrderInput | SortOrder
    creationdate?: SortOrderInput | SortOrder
    msg?: SortOrderInput | SortOrder
    recordid?: SortOrderInput | SortOrder
  }

  export type bbs_repliesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: bbs_repliesWhereInput | bbs_repliesWhereInput[]
    OR?: bbs_repliesWhereInput[]
    NOT?: bbs_repliesWhereInput | bbs_repliesWhereInput[]
    idforreply?: IntNullableFilter<"bbs_replies"> | number | null
    creatorid?: IntNullableFilter<"bbs_replies"> | number | null
    creationdate?: DateTimeNullableFilter<"bbs_replies"> | Date | string | null
    msg?: StringNullableFilter<"bbs_replies"> | string | null
    recordid?: IntNullableFilter<"bbs_replies"> | number | null
  }, "id">

  export type bbs_repliesOrderByWithAggregationInput = {
    id?: SortOrder
    idforreply?: SortOrderInput | SortOrder
    creatorid?: SortOrderInput | SortOrder
    creationdate?: SortOrderInput | SortOrder
    msg?: SortOrderInput | SortOrder
    recordid?: SortOrderInput | SortOrder
    _count?: bbs_repliesCountOrderByAggregateInput
    _avg?: bbs_repliesAvgOrderByAggregateInput
    _max?: bbs_repliesMaxOrderByAggregateInput
    _min?: bbs_repliesMinOrderByAggregateInput
    _sum?: bbs_repliesSumOrderByAggregateInput
  }

  export type bbs_repliesScalarWhereWithAggregatesInput = {
    AND?: bbs_repliesScalarWhereWithAggregatesInput | bbs_repliesScalarWhereWithAggregatesInput[]
    OR?: bbs_repliesScalarWhereWithAggregatesInput[]
    NOT?: bbs_repliesScalarWhereWithAggregatesInput | bbs_repliesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"bbs_replies"> | number
    idforreply?: IntNullableWithAggregatesFilter<"bbs_replies"> | number | null
    creatorid?: IntNullableWithAggregatesFilter<"bbs_replies"> | number | null
    creationdate?: DateTimeNullableWithAggregatesFilter<"bbs_replies"> | Date | string | null
    msg?: StringNullableWithAggregatesFilter<"bbs_replies"> | string | null
    recordid?: IntNullableWithAggregatesFilter<"bbs_replies"> | number | null
  }

  export type beautydataWhereInput = {
    AND?: beautydataWhereInput | beautydataWhereInput[]
    OR?: beautydataWhereInput[]
    NOT?: beautydataWhereInput | beautydataWhereInput[]
    id?: IntFilter<"beautydata"> | number
    charID?: IntFilter<"beautydata"> | number
    hairSize?: IntFilter<"beautydata"> | number
    faceSize?: IntFilter<"beautydata"> | number
    hairString?: StringFilter<"beautydata"> | string
    faceString?: StringFilter<"beautydata"> | string
  }

  export type beautydataOrderByWithRelationInput = {
    id?: SortOrder
    charID?: SortOrder
    hairSize?: SortOrder
    faceSize?: SortOrder
    hairString?: SortOrder
    faceString?: SortOrder
  }

  export type beautydataWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: beautydataWhereInput | beautydataWhereInput[]
    OR?: beautydataWhereInput[]
    NOT?: beautydataWhereInput | beautydataWhereInput[]
    charID?: IntFilter<"beautydata"> | number
    hairSize?: IntFilter<"beautydata"> | number
    faceSize?: IntFilter<"beautydata"> | number
    hairString?: StringFilter<"beautydata"> | string
    faceString?: StringFilter<"beautydata"> | string
  }, "id">

  export type beautydataOrderByWithAggregationInput = {
    id?: SortOrder
    charID?: SortOrder
    hairSize?: SortOrder
    faceSize?: SortOrder
    hairString?: SortOrder
    faceString?: SortOrder
    _count?: beautydataCountOrderByAggregateInput
    _avg?: beautydataAvgOrderByAggregateInput
    _max?: beautydataMaxOrderByAggregateInput
    _min?: beautydataMinOrderByAggregateInput
    _sum?: beautydataSumOrderByAggregateInput
  }

  export type beautydataScalarWhereWithAggregatesInput = {
    AND?: beautydataScalarWhereWithAggregatesInput | beautydataScalarWhereWithAggregatesInput[]
    OR?: beautydataScalarWhereWithAggregatesInput[]
    NOT?: beautydataScalarWhereWithAggregatesInput | beautydataScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"beautydata"> | number
    charID?: IntWithAggregatesFilter<"beautydata"> | number
    hairSize?: IntWithAggregatesFilter<"beautydata"> | number
    faceSize?: IntWithAggregatesFilter<"beautydata"> | number
    hairString?: StringWithAggregatesFilter<"beautydata"> | string
    faceString?: StringWithAggregatesFilter<"beautydata"> | string
  }

  export type bosslogWhereInput = {
    AND?: bosslogWhereInput | bosslogWhereInput[]
    OR?: bosslogWhereInput[]
    NOT?: bosslogWhereInput | bosslogWhereInput[]
    id?: IntFilter<"bosslog"> | number
    accountid?: IntFilter<"bosslog"> | number
    bossid?: StringFilter<"bosslog"> | string
    lastattempt?: DateTimeFilter<"bosslog"> | Date | string
    pqentry?: IntFilter<"bosslog"> | number
  }

  export type bosslogOrderByWithRelationInput = {
    id?: SortOrder
    accountid?: SortOrder
    bossid?: SortOrder
    lastattempt?: SortOrder
    pqentry?: SortOrder
  }

  export type bosslogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: bosslogWhereInput | bosslogWhereInput[]
    OR?: bosslogWhereInput[]
    NOT?: bosslogWhereInput | bosslogWhereInput[]
    accountid?: IntFilter<"bosslog"> | number
    bossid?: StringFilter<"bosslog"> | string
    lastattempt?: DateTimeFilter<"bosslog"> | Date | string
    pqentry?: IntFilter<"bosslog"> | number
  }, "id">

  export type bosslogOrderByWithAggregationInput = {
    id?: SortOrder
    accountid?: SortOrder
    bossid?: SortOrder
    lastattempt?: SortOrder
    pqentry?: SortOrder
    _count?: bosslogCountOrderByAggregateInput
    _avg?: bosslogAvgOrderByAggregateInput
    _max?: bosslogMaxOrderByAggregateInput
    _min?: bosslogMinOrderByAggregateInput
    _sum?: bosslogSumOrderByAggregateInput
  }

  export type bosslogScalarWhereWithAggregatesInput = {
    AND?: bosslogScalarWhereWithAggregatesInput | bosslogScalarWhereWithAggregatesInput[]
    OR?: bosslogScalarWhereWithAggregatesInput[]
    NOT?: bosslogScalarWhereWithAggregatesInput | bosslogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"bosslog"> | number
    accountid?: IntWithAggregatesFilter<"bosslog"> | number
    bossid?: StringWithAggregatesFilter<"bosslog"> | string
    lastattempt?: DateTimeWithAggregatesFilter<"bosslog"> | Date | string
    pqentry?: IntWithAggregatesFilter<"bosslog"> | number
  }

  export type cashiteminfosWhereInput = {
    AND?: cashiteminfosWhereInput | cashiteminfosWhereInput[]
    OR?: cashiteminfosWhereInput[]
    NOT?: cashiteminfosWhereInput | cashiteminfosWhereInput[]
    id?: BigIntFilter<"cashiteminfos"> | bigint | number
    accountid?: IntNullableFilter<"cashiteminfos"> | number | null
    characterid?: IntNullableFilter<"cashiteminfos"> | number | null
    commodityid?: IntNullableFilter<"cashiteminfos"> | number | null
    buycharacterid?: StringNullableFilter<"cashiteminfos"> | string | null
    paybackrate?: IntNullableFilter<"cashiteminfos"> | number | null
    discount?: FloatNullableFilter<"cashiteminfos"> | number | null
    orderno?: IntNullableFilter<"cashiteminfos"> | number | null
    productno?: IntNullableFilter<"cashiteminfos"> | number | null
    refundable?: BoolNullableFilter<"cashiteminfos"> | boolean | null
    sourceflag?: IntNullableFilter<"cashiteminfos"> | number | null
    storebank?: BoolNullableFilter<"cashiteminfos"> | boolean | null
    itemid?: IntNullableFilter<"cashiteminfos"> | number | null
    trunkid?: IntNullableFilter<"cashiteminfos"> | number | null
    position?: IntNullableFilter<"cashiteminfos"> | number | null
  }

  export type cashiteminfosOrderByWithRelationInput = {
    id?: SortOrder
    accountid?: SortOrderInput | SortOrder
    characterid?: SortOrderInput | SortOrder
    commodityid?: SortOrderInput | SortOrder
    buycharacterid?: SortOrderInput | SortOrder
    paybackrate?: SortOrderInput | SortOrder
    discount?: SortOrderInput | SortOrder
    orderno?: SortOrderInput | SortOrder
    productno?: SortOrderInput | SortOrder
    refundable?: SortOrderInput | SortOrder
    sourceflag?: SortOrderInput | SortOrder
    storebank?: SortOrderInput | SortOrder
    itemid?: SortOrderInput | SortOrder
    trunkid?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
  }

  export type cashiteminfosWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: cashiteminfosWhereInput | cashiteminfosWhereInput[]
    OR?: cashiteminfosWhereInput[]
    NOT?: cashiteminfosWhereInput | cashiteminfosWhereInput[]
    accountid?: IntNullableFilter<"cashiteminfos"> | number | null
    characterid?: IntNullableFilter<"cashiteminfos"> | number | null
    commodityid?: IntNullableFilter<"cashiteminfos"> | number | null
    buycharacterid?: StringNullableFilter<"cashiteminfos"> | string | null
    paybackrate?: IntNullableFilter<"cashiteminfos"> | number | null
    discount?: FloatNullableFilter<"cashiteminfos"> | number | null
    orderno?: IntNullableFilter<"cashiteminfos"> | number | null
    productno?: IntNullableFilter<"cashiteminfos"> | number | null
    refundable?: BoolNullableFilter<"cashiteminfos"> | boolean | null
    sourceflag?: IntNullableFilter<"cashiteminfos"> | number | null
    storebank?: BoolNullableFilter<"cashiteminfos"> | boolean | null
    itemid?: IntNullableFilter<"cashiteminfos"> | number | null
    trunkid?: IntNullableFilter<"cashiteminfos"> | number | null
    position?: IntNullableFilter<"cashiteminfos"> | number | null
  }, "id">

  export type cashiteminfosOrderByWithAggregationInput = {
    id?: SortOrder
    accountid?: SortOrderInput | SortOrder
    characterid?: SortOrderInput | SortOrder
    commodityid?: SortOrderInput | SortOrder
    buycharacterid?: SortOrderInput | SortOrder
    paybackrate?: SortOrderInput | SortOrder
    discount?: SortOrderInput | SortOrder
    orderno?: SortOrderInput | SortOrder
    productno?: SortOrderInput | SortOrder
    refundable?: SortOrderInput | SortOrder
    sourceflag?: SortOrderInput | SortOrder
    storebank?: SortOrderInput | SortOrder
    itemid?: SortOrderInput | SortOrder
    trunkid?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    _count?: cashiteminfosCountOrderByAggregateInput
    _avg?: cashiteminfosAvgOrderByAggregateInput
    _max?: cashiteminfosMaxOrderByAggregateInput
    _min?: cashiteminfosMinOrderByAggregateInput
    _sum?: cashiteminfosSumOrderByAggregateInput
  }

  export type cashiteminfosScalarWhereWithAggregatesInput = {
    AND?: cashiteminfosScalarWhereWithAggregatesInput | cashiteminfosScalarWhereWithAggregatesInput[]
    OR?: cashiteminfosScalarWhereWithAggregatesInput[]
    NOT?: cashiteminfosScalarWhereWithAggregatesInput | cashiteminfosScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"cashiteminfos"> | bigint | number
    accountid?: IntNullableWithAggregatesFilter<"cashiteminfos"> | number | null
    characterid?: IntNullableWithAggregatesFilter<"cashiteminfos"> | number | null
    commodityid?: IntNullableWithAggregatesFilter<"cashiteminfos"> | number | null
    buycharacterid?: StringNullableWithAggregatesFilter<"cashiteminfos"> | string | null
    paybackrate?: IntNullableWithAggregatesFilter<"cashiteminfos"> | number | null
    discount?: FloatNullableWithAggregatesFilter<"cashiteminfos"> | number | null
    orderno?: IntNullableWithAggregatesFilter<"cashiteminfos"> | number | null
    productno?: IntNullableWithAggregatesFilter<"cashiteminfos"> | number | null
    refundable?: BoolNullableWithAggregatesFilter<"cashiteminfos"> | boolean | null
    sourceflag?: IntNullableWithAggregatesFilter<"cashiteminfos"> | number | null
    storebank?: BoolNullableWithAggregatesFilter<"cashiteminfos"> | boolean | null
    itemid?: IntNullableWithAggregatesFilter<"cashiteminfos"> | number | null
    trunkid?: IntNullableWithAggregatesFilter<"cashiteminfos"> | number | null
    position?: IntNullableWithAggregatesFilter<"cashiteminfos"> | number | null
  }

  export type characterpotentialsWhereInput = {
    AND?: characterpotentialsWhereInput | characterpotentialsWhereInput[]
    OR?: characterpotentialsWhereInput[]
    NOT?: characterpotentialsWhereInput | characterpotentialsWhereInput[]
    id?: BigIntFilter<"characterpotentials"> | bigint | number
    potkey?: IntNullableFilter<"characterpotentials"> | number | null
    skillid?: IntNullableFilter<"characterpotentials"> | number | null
    slv?: IntNullableFilter<"characterpotentials"> | number | null
    grade?: IntNullableFilter<"characterpotentials"> | number | null
    charid?: IntNullableFilter<"characterpotentials"> | number | null
  }

  export type characterpotentialsOrderByWithRelationInput = {
    id?: SortOrder
    potkey?: SortOrderInput | SortOrder
    skillid?: SortOrderInput | SortOrder
    slv?: SortOrderInput | SortOrder
    grade?: SortOrderInput | SortOrder
    charid?: SortOrderInput | SortOrder
  }

  export type characterpotentialsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: characterpotentialsWhereInput | characterpotentialsWhereInput[]
    OR?: characterpotentialsWhereInput[]
    NOT?: characterpotentialsWhereInput | characterpotentialsWhereInput[]
    potkey?: IntNullableFilter<"characterpotentials"> | number | null
    skillid?: IntNullableFilter<"characterpotentials"> | number | null
    slv?: IntNullableFilter<"characterpotentials"> | number | null
    grade?: IntNullableFilter<"characterpotentials"> | number | null
    charid?: IntNullableFilter<"characterpotentials"> | number | null
  }, "id">

  export type characterpotentialsOrderByWithAggregationInput = {
    id?: SortOrder
    potkey?: SortOrderInput | SortOrder
    skillid?: SortOrderInput | SortOrder
    slv?: SortOrderInput | SortOrder
    grade?: SortOrderInput | SortOrder
    charid?: SortOrderInput | SortOrder
    _count?: characterpotentialsCountOrderByAggregateInput
    _avg?: characterpotentialsAvgOrderByAggregateInput
    _max?: characterpotentialsMaxOrderByAggregateInput
    _min?: characterpotentialsMinOrderByAggregateInput
    _sum?: characterpotentialsSumOrderByAggregateInput
  }

  export type characterpotentialsScalarWhereWithAggregatesInput = {
    AND?: characterpotentialsScalarWhereWithAggregatesInput | characterpotentialsScalarWhereWithAggregatesInput[]
    OR?: characterpotentialsScalarWhereWithAggregatesInput[]
    NOT?: characterpotentialsScalarWhereWithAggregatesInput | characterpotentialsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"characterpotentials"> | bigint | number
    potkey?: IntNullableWithAggregatesFilter<"characterpotentials"> | number | null
    skillid?: IntNullableWithAggregatesFilter<"characterpotentials"> | number | null
    slv?: IntNullableWithAggregatesFilter<"characterpotentials"> | number | null
    grade?: IntNullableWithAggregatesFilter<"characterpotentials"> | number | null
    charid?: IntNullableWithAggregatesFilter<"characterpotentials"> | number | null
  }

  export type charactersWhereInput = {
    AND?: charactersWhereInput | charactersWhereInput[]
    OR?: charactersWhereInput[]
    NOT?: charactersWhereInput | charactersWhereInput[]
    id?: IntFilter<"characters"> | number
    accid?: IntNullableFilter<"characters"> | number | null
    orderid?: IntNullableFilter<"characters"> | number | null
    avatardata?: IntNullableFilter<"characters"> | number | null
    equippedinventory?: IntNullableFilter<"characters"> | number | null
    equipinventory?: IntNullableFilter<"characters"> | number | null
    consumeinventory?: IntNullableFilter<"characters"> | number | null
    etcinventory?: IntNullableFilter<"characters"> | number | null
    installinventory?: IntNullableFilter<"characters"> | number | null
    cashinventory?: IntNullableFilter<"characters"> | number | null
    funckeymap_id?: IntNullableFilter<"characters"> | number | null
    fieldid?: IntNullableFilter<"characters"> | number | null
    questmanager?: BigIntNullableFilter<"characters"> | bigint | number | null
    guild?: IntNullableFilter<"characters"> | number | null
    rewardPoints?: IntNullableFilter<"characters"> | number | null
    monsterbook?: IntNullableFilter<"characters"> | number | null
    party?: IntNullableFilter<"characters"> | number | null
    medalid?: IntNullableFilter<"characters"> | number | null
    monsterparkcount?: IntNullableFilter<"characters"> | number | null
    previousFieldID?: BigIntNullableFilter<"characters"> | bigint | number | null
    onlineDay?: IntNullableFilter<"characters"> | number | null
    onlineTime?: BigIntNullableFilter<"characters"> | bigint | number | null
    quickslotKeys?: StringNullableFilter<"characters"> | string | null
  }

  export type charactersOrderByWithRelationInput = {
    id?: SortOrder
    accid?: SortOrderInput | SortOrder
    orderid?: SortOrderInput | SortOrder
    avatardata?: SortOrderInput | SortOrder
    equippedinventory?: SortOrderInput | SortOrder
    equipinventory?: SortOrderInput | SortOrder
    consumeinventory?: SortOrderInput | SortOrder
    etcinventory?: SortOrderInput | SortOrder
    installinventory?: SortOrderInput | SortOrder
    cashinventory?: SortOrderInput | SortOrder
    funckeymap_id?: SortOrderInput | SortOrder
    fieldid?: SortOrderInput | SortOrder
    questmanager?: SortOrderInput | SortOrder
    guild?: SortOrderInput | SortOrder
    rewardPoints?: SortOrderInput | SortOrder
    monsterbook?: SortOrderInput | SortOrder
    party?: SortOrderInput | SortOrder
    medalid?: SortOrderInput | SortOrder
    monsterparkcount?: SortOrderInput | SortOrder
    previousFieldID?: SortOrderInput | SortOrder
    onlineDay?: SortOrderInput | SortOrder
    onlineTime?: SortOrderInput | SortOrder
    quickslotKeys?: SortOrderInput | SortOrder
  }

  export type charactersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: charactersWhereInput | charactersWhereInput[]
    OR?: charactersWhereInput[]
    NOT?: charactersWhereInput | charactersWhereInput[]
    accid?: IntNullableFilter<"characters"> | number | null
    orderid?: IntNullableFilter<"characters"> | number | null
    avatardata?: IntNullableFilter<"characters"> | number | null
    equippedinventory?: IntNullableFilter<"characters"> | number | null
    equipinventory?: IntNullableFilter<"characters"> | number | null
    consumeinventory?: IntNullableFilter<"characters"> | number | null
    etcinventory?: IntNullableFilter<"characters"> | number | null
    installinventory?: IntNullableFilter<"characters"> | number | null
    cashinventory?: IntNullableFilter<"characters"> | number | null
    funckeymap_id?: IntNullableFilter<"characters"> | number | null
    fieldid?: IntNullableFilter<"characters"> | number | null
    questmanager?: BigIntNullableFilter<"characters"> | bigint | number | null
    guild?: IntNullableFilter<"characters"> | number | null
    rewardPoints?: IntNullableFilter<"characters"> | number | null
    monsterbook?: IntNullableFilter<"characters"> | number | null
    party?: IntNullableFilter<"characters"> | number | null
    medalid?: IntNullableFilter<"characters"> | number | null
    monsterparkcount?: IntNullableFilter<"characters"> | number | null
    previousFieldID?: BigIntNullableFilter<"characters"> | bigint | number | null
    onlineDay?: IntNullableFilter<"characters"> | number | null
    onlineTime?: BigIntNullableFilter<"characters"> | bigint | number | null
    quickslotKeys?: StringNullableFilter<"characters"> | string | null
  }, "id">

  export type charactersOrderByWithAggregationInput = {
    id?: SortOrder
    accid?: SortOrderInput | SortOrder
    orderid?: SortOrderInput | SortOrder
    avatardata?: SortOrderInput | SortOrder
    equippedinventory?: SortOrderInput | SortOrder
    equipinventory?: SortOrderInput | SortOrder
    consumeinventory?: SortOrderInput | SortOrder
    etcinventory?: SortOrderInput | SortOrder
    installinventory?: SortOrderInput | SortOrder
    cashinventory?: SortOrderInput | SortOrder
    funckeymap_id?: SortOrderInput | SortOrder
    fieldid?: SortOrderInput | SortOrder
    questmanager?: SortOrderInput | SortOrder
    guild?: SortOrderInput | SortOrder
    rewardPoints?: SortOrderInput | SortOrder
    monsterbook?: SortOrderInput | SortOrder
    party?: SortOrderInput | SortOrder
    medalid?: SortOrderInput | SortOrder
    monsterparkcount?: SortOrderInput | SortOrder
    previousFieldID?: SortOrderInput | SortOrder
    onlineDay?: SortOrderInput | SortOrder
    onlineTime?: SortOrderInput | SortOrder
    quickslotKeys?: SortOrderInput | SortOrder
    _count?: charactersCountOrderByAggregateInput
    _avg?: charactersAvgOrderByAggregateInput
    _max?: charactersMaxOrderByAggregateInput
    _min?: charactersMinOrderByAggregateInput
    _sum?: charactersSumOrderByAggregateInput
  }

  export type charactersScalarWhereWithAggregatesInput = {
    AND?: charactersScalarWhereWithAggregatesInput | charactersScalarWhereWithAggregatesInput[]
    OR?: charactersScalarWhereWithAggregatesInput[]
    NOT?: charactersScalarWhereWithAggregatesInput | charactersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"characters"> | number
    accid?: IntNullableWithAggregatesFilter<"characters"> | number | null
    orderid?: IntNullableWithAggregatesFilter<"characters"> | number | null
    avatardata?: IntNullableWithAggregatesFilter<"characters"> | number | null
    equippedinventory?: IntNullableWithAggregatesFilter<"characters"> | number | null
    equipinventory?: IntNullableWithAggregatesFilter<"characters"> | number | null
    consumeinventory?: IntNullableWithAggregatesFilter<"characters"> | number | null
    etcinventory?: IntNullableWithAggregatesFilter<"characters"> | number | null
    installinventory?: IntNullableWithAggregatesFilter<"characters"> | number | null
    cashinventory?: IntNullableWithAggregatesFilter<"characters"> | number | null
    funckeymap_id?: IntNullableWithAggregatesFilter<"characters"> | number | null
    fieldid?: IntNullableWithAggregatesFilter<"characters"> | number | null
    questmanager?: BigIntNullableWithAggregatesFilter<"characters"> | bigint | number | null
    guild?: IntNullableWithAggregatesFilter<"characters"> | number | null
    rewardPoints?: IntNullableWithAggregatesFilter<"characters"> | number | null
    monsterbook?: IntNullableWithAggregatesFilter<"characters"> | number | null
    party?: IntNullableWithAggregatesFilter<"characters"> | number | null
    medalid?: IntNullableWithAggregatesFilter<"characters"> | number | null
    monsterparkcount?: IntNullableWithAggregatesFilter<"characters"> | number | null
    previousFieldID?: BigIntNullableWithAggregatesFilter<"characters"> | bigint | number | null
    onlineDay?: IntNullableWithAggregatesFilter<"characters"> | number | null
    onlineTime?: BigIntNullableWithAggregatesFilter<"characters"> | bigint | number | null
    quickslotKeys?: StringNullableWithAggregatesFilter<"characters"> | string | null
  }

  export type characterstatsWhereInput = {
    AND?: characterstatsWhereInput | characterstatsWhereInput[]
    OR?: characterstatsWhereInput[]
    NOT?: characterstatsWhereInput | characterstatsWhereInput[]
    id?: IntFilter<"characterstats"> | number
    characterid?: IntNullableFilter<"characterstats"> | number | null
    characteridforlog?: IntNullableFilter<"characterstats"> | number | null
    worldidforlog?: IntNullableFilter<"characterstats"> | number | null
    name?: StringNullableFilter<"characterstats"> | string | null
    gender?: IntNullableFilter<"characterstats"> | number | null
    skin?: IntNullableFilter<"characterstats"> | number | null
    face?: IntNullableFilter<"characterstats"> | number | null
    hair?: IntNullableFilter<"characterstats"> | number | null
    mixbasehaircolor?: IntNullableFilter<"characterstats"> | number | null
    mixaddhaircolor?: IntNullableFilter<"characterstats"> | number | null
    mixhairbaseprob?: IntNullableFilter<"characterstats"> | number | null
    level?: IntNullableFilter<"characterstats"> | number | null
    job?: IntNullableFilter<"characterstats"> | number | null
    str?: IntNullableFilter<"characterstats"> | number | null
    dex?: IntNullableFilter<"characterstats"> | number | null
    inte?: IntNullableFilter<"characterstats"> | number | null
    luk?: IntNullableFilter<"characterstats"> | number | null
    hp?: IntNullableFilter<"characterstats"> | number | null
    maxhp?: IntNullableFilter<"characterstats"> | number | null
    mp?: IntNullableFilter<"characterstats"> | number | null
    maxmp?: IntNullableFilter<"characterstats"> | number | null
    ap?: IntNullableFilter<"characterstats"> | number | null
    sp?: IntNullableFilter<"characterstats"> | number | null
    exp?: StringNullableFilter<"characterstats"> | string | null
    pop?: IntNullableFilter<"characterstats"> | number | null
    money?: StringNullableFilter<"characterstats"> | string | null
    wp?: IntNullableFilter<"characterstats"> | number | null
    extendsp?: IntNullableFilter<"characterstats"> | number | null
    posmap?: StringNullableFilter<"characterstats"> | string | null
    portal?: IntNullableFilter<"characterstats"> | number | null
    subjob?: IntNullableFilter<"characterstats"> | number | null
    deffaceacc?: IntNullableFilter<"characterstats"> | number | null
    fatigue?: IntNullableFilter<"characterstats"> | number | null
    lastfatigueupdatetime?: IntNullableFilter<"characterstats"> | number | null
    charismaexp?: IntNullableFilter<"characterstats"> | number | null
    insightexp?: IntNullableFilter<"characterstats"> | number | null
    willexp?: IntNullableFilter<"characterstats"> | number | null
    craftexp?: IntNullableFilter<"characterstats"> | number | null
    senseexp?: IntNullableFilter<"characterstats"> | number | null
    charmexp?: IntNullableFilter<"characterstats"> | number | null
    noncombatstatdaylimit?: IntNullableFilter<"characterstats"> | number | null
    mcpoint?: IntNullableFilter<"characterstats"> | number | null
    pvpexp?: IntNullableFilter<"characterstats"> | number | null
    pvpgrade?: IntNullableFilter<"characterstats"> | number | null
    pvppoint?: IntNullableFilter<"characterstats"> | number | null
    pvpmodelevel?: IntNullableFilter<"characterstats"> | number | null
    pvpmodetype?: IntNullableFilter<"characterstats"> | number | null
    eventpoint?: IntNullableFilter<"characterstats"> | number | null
    albaactivityid?: IntNullableFilter<"characterstats"> | number | null
    albastarttime?: DateTimeNullableFilter<"characterstats"> | Date | string | null
    albaduration?: IntNullableFilter<"characterstats"> | number | null
    albaspecialreward?: IntNullableFilter<"characterstats"> | number | null
    burning?: BoolNullableFilter<"characterstats"> | boolean | null
    charactercard?: IntNullableFilter<"characterstats"> | number | null
    accountlastlogout?: IntNullableFilter<"characterstats"> | number | null
    lastlogout?: DateTimeNullableFilter<"characterstats"> | Date | string | null
    gachexp?: IntNullableFilter<"characterstats"> | number | null
    honorexp?: IntNullableFilter<"characterstats"> | number | null
    nextavailablefametime?: DateTimeNullableFilter<"characterstats"> | Date | string | null
    node_shards?: IntFilter<"characterstats"> | number
    maxfriends?: IntFilter<"characterstats"> | number
  }

  export type characterstatsOrderByWithRelationInput = {
    id?: SortOrder
    characterid?: SortOrderInput | SortOrder
    characteridforlog?: SortOrderInput | SortOrder
    worldidforlog?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    skin?: SortOrderInput | SortOrder
    face?: SortOrderInput | SortOrder
    hair?: SortOrderInput | SortOrder
    mixbasehaircolor?: SortOrderInput | SortOrder
    mixaddhaircolor?: SortOrderInput | SortOrder
    mixhairbaseprob?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    job?: SortOrderInput | SortOrder
    str?: SortOrderInput | SortOrder
    dex?: SortOrderInput | SortOrder
    inte?: SortOrderInput | SortOrder
    luk?: SortOrderInput | SortOrder
    hp?: SortOrderInput | SortOrder
    maxhp?: SortOrderInput | SortOrder
    mp?: SortOrderInput | SortOrder
    maxmp?: SortOrderInput | SortOrder
    ap?: SortOrderInput | SortOrder
    sp?: SortOrderInput | SortOrder
    exp?: SortOrderInput | SortOrder
    pop?: SortOrderInput | SortOrder
    money?: SortOrderInput | SortOrder
    wp?: SortOrderInput | SortOrder
    extendsp?: SortOrderInput | SortOrder
    posmap?: SortOrderInput | SortOrder
    portal?: SortOrderInput | SortOrder
    subjob?: SortOrderInput | SortOrder
    deffaceacc?: SortOrderInput | SortOrder
    fatigue?: SortOrderInput | SortOrder
    lastfatigueupdatetime?: SortOrderInput | SortOrder
    charismaexp?: SortOrderInput | SortOrder
    insightexp?: SortOrderInput | SortOrder
    willexp?: SortOrderInput | SortOrder
    craftexp?: SortOrderInput | SortOrder
    senseexp?: SortOrderInput | SortOrder
    charmexp?: SortOrderInput | SortOrder
    noncombatstatdaylimit?: SortOrderInput | SortOrder
    mcpoint?: SortOrderInput | SortOrder
    pvpexp?: SortOrderInput | SortOrder
    pvpgrade?: SortOrderInput | SortOrder
    pvppoint?: SortOrderInput | SortOrder
    pvpmodelevel?: SortOrderInput | SortOrder
    pvpmodetype?: SortOrderInput | SortOrder
    eventpoint?: SortOrderInput | SortOrder
    albaactivityid?: SortOrderInput | SortOrder
    albastarttime?: SortOrderInput | SortOrder
    albaduration?: SortOrderInput | SortOrder
    albaspecialreward?: SortOrderInput | SortOrder
    burning?: SortOrderInput | SortOrder
    charactercard?: SortOrderInput | SortOrder
    accountlastlogout?: SortOrderInput | SortOrder
    lastlogout?: SortOrderInput | SortOrder
    gachexp?: SortOrderInput | SortOrder
    honorexp?: SortOrderInput | SortOrder
    nextavailablefametime?: SortOrderInput | SortOrder
    node_shards?: SortOrder
    maxfriends?: SortOrder
  }

  export type characterstatsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: characterstatsWhereInput | characterstatsWhereInput[]
    OR?: characterstatsWhereInput[]
    NOT?: characterstatsWhereInput | characterstatsWhereInput[]
    characterid?: IntNullableFilter<"characterstats"> | number | null
    characteridforlog?: IntNullableFilter<"characterstats"> | number | null
    worldidforlog?: IntNullableFilter<"characterstats"> | number | null
    name?: StringNullableFilter<"characterstats"> | string | null
    gender?: IntNullableFilter<"characterstats"> | number | null
    skin?: IntNullableFilter<"characterstats"> | number | null
    face?: IntNullableFilter<"characterstats"> | number | null
    hair?: IntNullableFilter<"characterstats"> | number | null
    mixbasehaircolor?: IntNullableFilter<"characterstats"> | number | null
    mixaddhaircolor?: IntNullableFilter<"characterstats"> | number | null
    mixhairbaseprob?: IntNullableFilter<"characterstats"> | number | null
    level?: IntNullableFilter<"characterstats"> | number | null
    job?: IntNullableFilter<"characterstats"> | number | null
    str?: IntNullableFilter<"characterstats"> | number | null
    dex?: IntNullableFilter<"characterstats"> | number | null
    inte?: IntNullableFilter<"characterstats"> | number | null
    luk?: IntNullableFilter<"characterstats"> | number | null
    hp?: IntNullableFilter<"characterstats"> | number | null
    maxhp?: IntNullableFilter<"characterstats"> | number | null
    mp?: IntNullableFilter<"characterstats"> | number | null
    maxmp?: IntNullableFilter<"characterstats"> | number | null
    ap?: IntNullableFilter<"characterstats"> | number | null
    sp?: IntNullableFilter<"characterstats"> | number | null
    exp?: StringNullableFilter<"characterstats"> | string | null
    pop?: IntNullableFilter<"characterstats"> | number | null
    money?: StringNullableFilter<"characterstats"> | string | null
    wp?: IntNullableFilter<"characterstats"> | number | null
    extendsp?: IntNullableFilter<"characterstats"> | number | null
    posmap?: StringNullableFilter<"characterstats"> | string | null
    portal?: IntNullableFilter<"characterstats"> | number | null
    subjob?: IntNullableFilter<"characterstats"> | number | null
    deffaceacc?: IntNullableFilter<"characterstats"> | number | null
    fatigue?: IntNullableFilter<"characterstats"> | number | null
    lastfatigueupdatetime?: IntNullableFilter<"characterstats"> | number | null
    charismaexp?: IntNullableFilter<"characterstats"> | number | null
    insightexp?: IntNullableFilter<"characterstats"> | number | null
    willexp?: IntNullableFilter<"characterstats"> | number | null
    craftexp?: IntNullableFilter<"characterstats"> | number | null
    senseexp?: IntNullableFilter<"characterstats"> | number | null
    charmexp?: IntNullableFilter<"characterstats"> | number | null
    noncombatstatdaylimit?: IntNullableFilter<"characterstats"> | number | null
    mcpoint?: IntNullableFilter<"characterstats"> | number | null
    pvpexp?: IntNullableFilter<"characterstats"> | number | null
    pvpgrade?: IntNullableFilter<"characterstats"> | number | null
    pvppoint?: IntNullableFilter<"characterstats"> | number | null
    pvpmodelevel?: IntNullableFilter<"characterstats"> | number | null
    pvpmodetype?: IntNullableFilter<"characterstats"> | number | null
    eventpoint?: IntNullableFilter<"characterstats"> | number | null
    albaactivityid?: IntNullableFilter<"characterstats"> | number | null
    albastarttime?: DateTimeNullableFilter<"characterstats"> | Date | string | null
    albaduration?: IntNullableFilter<"characterstats"> | number | null
    albaspecialreward?: IntNullableFilter<"characterstats"> | number | null
    burning?: BoolNullableFilter<"characterstats"> | boolean | null
    charactercard?: IntNullableFilter<"characterstats"> | number | null
    accountlastlogout?: IntNullableFilter<"characterstats"> | number | null
    lastlogout?: DateTimeNullableFilter<"characterstats"> | Date | string | null
    gachexp?: IntNullableFilter<"characterstats"> | number | null
    honorexp?: IntNullableFilter<"characterstats"> | number | null
    nextavailablefametime?: DateTimeNullableFilter<"characterstats"> | Date | string | null
    node_shards?: IntFilter<"characterstats"> | number
    maxfriends?: IntFilter<"characterstats"> | number
  }, "id">

  export type characterstatsOrderByWithAggregationInput = {
    id?: SortOrder
    characterid?: SortOrderInput | SortOrder
    characteridforlog?: SortOrderInput | SortOrder
    worldidforlog?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    skin?: SortOrderInput | SortOrder
    face?: SortOrderInput | SortOrder
    hair?: SortOrderInput | SortOrder
    mixbasehaircolor?: SortOrderInput | SortOrder
    mixaddhaircolor?: SortOrderInput | SortOrder
    mixhairbaseprob?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    job?: SortOrderInput | SortOrder
    str?: SortOrderInput | SortOrder
    dex?: SortOrderInput | SortOrder
    inte?: SortOrderInput | SortOrder
    luk?: SortOrderInput | SortOrder
    hp?: SortOrderInput | SortOrder
    maxhp?: SortOrderInput | SortOrder
    mp?: SortOrderInput | SortOrder
    maxmp?: SortOrderInput | SortOrder
    ap?: SortOrderInput | SortOrder
    sp?: SortOrderInput | SortOrder
    exp?: SortOrderInput | SortOrder
    pop?: SortOrderInput | SortOrder
    money?: SortOrderInput | SortOrder
    wp?: SortOrderInput | SortOrder
    extendsp?: SortOrderInput | SortOrder
    posmap?: SortOrderInput | SortOrder
    portal?: SortOrderInput | SortOrder
    subjob?: SortOrderInput | SortOrder
    deffaceacc?: SortOrderInput | SortOrder
    fatigue?: SortOrderInput | SortOrder
    lastfatigueupdatetime?: SortOrderInput | SortOrder
    charismaexp?: SortOrderInput | SortOrder
    insightexp?: SortOrderInput | SortOrder
    willexp?: SortOrderInput | SortOrder
    craftexp?: SortOrderInput | SortOrder
    senseexp?: SortOrderInput | SortOrder
    charmexp?: SortOrderInput | SortOrder
    noncombatstatdaylimit?: SortOrderInput | SortOrder
    mcpoint?: SortOrderInput | SortOrder
    pvpexp?: SortOrderInput | SortOrder
    pvpgrade?: SortOrderInput | SortOrder
    pvppoint?: SortOrderInput | SortOrder
    pvpmodelevel?: SortOrderInput | SortOrder
    pvpmodetype?: SortOrderInput | SortOrder
    eventpoint?: SortOrderInput | SortOrder
    albaactivityid?: SortOrderInput | SortOrder
    albastarttime?: SortOrderInput | SortOrder
    albaduration?: SortOrderInput | SortOrder
    albaspecialreward?: SortOrderInput | SortOrder
    burning?: SortOrderInput | SortOrder
    charactercard?: SortOrderInput | SortOrder
    accountlastlogout?: SortOrderInput | SortOrder
    lastlogout?: SortOrderInput | SortOrder
    gachexp?: SortOrderInput | SortOrder
    honorexp?: SortOrderInput | SortOrder
    nextavailablefametime?: SortOrderInput | SortOrder
    node_shards?: SortOrder
    maxfriends?: SortOrder
    _count?: characterstatsCountOrderByAggregateInput
    _avg?: characterstatsAvgOrderByAggregateInput
    _max?: characterstatsMaxOrderByAggregateInput
    _min?: characterstatsMinOrderByAggregateInput
    _sum?: characterstatsSumOrderByAggregateInput
  }

  export type characterstatsScalarWhereWithAggregatesInput = {
    AND?: characterstatsScalarWhereWithAggregatesInput | characterstatsScalarWhereWithAggregatesInput[]
    OR?: characterstatsScalarWhereWithAggregatesInput[]
    NOT?: characterstatsScalarWhereWithAggregatesInput | characterstatsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"characterstats"> | number
    characterid?: IntNullableWithAggregatesFilter<"characterstats"> | number | null
    characteridforlog?: IntNullableWithAggregatesFilter<"characterstats"> | number | null
    worldidforlog?: IntNullableWithAggregatesFilter<"characterstats"> | number | null
    name?: StringNullableWithAggregatesFilter<"characterstats"> | string | null
    gender?: IntNullableWithAggregatesFilter<"characterstats"> | number | null
    skin?: IntNullableWithAggregatesFilter<"characterstats"> | number | null
    face?: IntNullableWithAggregatesFilter<"characterstats"> | number | null
    hair?: IntNullableWithAggregatesFilter<"characterstats"> | number | null
    mixbasehaircolor?: IntNullableWithAggregatesFilter<"characterstats"> | number | null
    mixaddhaircolor?: IntNullableWithAggregatesFilter<"characterstats"> | number | null
    mixhairbaseprob?: IntNullableWithAggregatesFilter<"characterstats"> | number | null
    level?: IntNullableWithAggregatesFilter<"characterstats"> | number | null
    job?: IntNullableWithAggregatesFilter<"characterstats"> | number | null
    str?: IntNullableWithAggregatesFilter<"characterstats"> | number | null
    dex?: IntNullableWithAggregatesFilter<"characterstats"> | number | null
    inte?: IntNullableWithAggregatesFilter<"characterstats"> | number | null
    luk?: IntNullableWithAggregatesFilter<"characterstats"> | number | null
    hp?: IntNullableWithAggregatesFilter<"characterstats"> | number | null
    maxhp?: IntNullableWithAggregatesFilter<"characterstats"> | number | null
    mp?: IntNullableWithAggregatesFilter<"characterstats"> | number | null
    maxmp?: IntNullableWithAggregatesFilter<"characterstats"> | number | null
    ap?: IntNullableWithAggregatesFilter<"characterstats"> | number | null
    sp?: IntNullableWithAggregatesFilter<"characterstats"> | number | null
    exp?: StringNullableWithAggregatesFilter<"characterstats"> | string | null
    pop?: IntNullableWithAggregatesFilter<"characterstats"> | number | null
    money?: StringNullableWithAggregatesFilter<"characterstats"> | string | null
    wp?: IntNullableWithAggregatesFilter<"characterstats"> | number | null
    extendsp?: IntNullableWithAggregatesFilter<"characterstats"> | number | null
    posmap?: StringNullableWithAggregatesFilter<"characterstats"> | string | null
    portal?: IntNullableWithAggregatesFilter<"characterstats"> | number | null
    subjob?: IntNullableWithAggregatesFilter<"characterstats"> | number | null
    deffaceacc?: IntNullableWithAggregatesFilter<"characterstats"> | number | null
    fatigue?: IntNullableWithAggregatesFilter<"characterstats"> | number | null
    lastfatigueupdatetime?: IntNullableWithAggregatesFilter<"characterstats"> | number | null
    charismaexp?: IntNullableWithAggregatesFilter<"characterstats"> | number | null
    insightexp?: IntNullableWithAggregatesFilter<"characterstats"> | number | null
    willexp?: IntNullableWithAggregatesFilter<"characterstats"> | number | null
    craftexp?: IntNullableWithAggregatesFilter<"characterstats"> | number | null
    senseexp?: IntNullableWithAggregatesFilter<"characterstats"> | number | null
    charmexp?: IntNullableWithAggregatesFilter<"characterstats"> | number | null
    noncombatstatdaylimit?: IntNullableWithAggregatesFilter<"characterstats"> | number | null
    mcpoint?: IntNullableWithAggregatesFilter<"characterstats"> | number | null
    pvpexp?: IntNullableWithAggregatesFilter<"characterstats"> | number | null
    pvpgrade?: IntNullableWithAggregatesFilter<"characterstats"> | number | null
    pvppoint?: IntNullableWithAggregatesFilter<"characterstats"> | number | null
    pvpmodelevel?: IntNullableWithAggregatesFilter<"characterstats"> | number | null
    pvpmodetype?: IntNullableWithAggregatesFilter<"characterstats"> | number | null
    eventpoint?: IntNullableWithAggregatesFilter<"characterstats"> | number | null
    albaactivityid?: IntNullableWithAggregatesFilter<"characterstats"> | number | null
    albastarttime?: DateTimeNullableWithAggregatesFilter<"characterstats"> | Date | string | null
    albaduration?: IntNullableWithAggregatesFilter<"characterstats"> | number | null
    albaspecialreward?: IntNullableWithAggregatesFilter<"characterstats"> | number | null
    burning?: BoolNullableWithAggregatesFilter<"characterstats"> | boolean | null
    charactercard?: IntNullableWithAggregatesFilter<"characterstats"> | number | null
    accountlastlogout?: IntNullableWithAggregatesFilter<"characterstats"> | number | null
    lastlogout?: DateTimeNullableWithAggregatesFilter<"characterstats"> | Date | string | null
    gachexp?: IntNullableWithAggregatesFilter<"characterstats"> | number | null
    honorexp?: IntNullableWithAggregatesFilter<"characterstats"> | number | null
    nextavailablefametime?: DateTimeNullableWithAggregatesFilter<"characterstats"> | Date | string | null
    node_shards?: IntWithAggregatesFilter<"characterstats"> | number
    maxfriends?: IntWithAggregatesFilter<"characterstats"> | number
  }

  export type chosenskillsWhereInput = {
    AND?: chosenskillsWhereInput | chosenskillsWhereInput[]
    OR?: chosenskillsWhereInput[]
    NOT?: chosenskillsWhereInput | chosenskillsWhereInput[]
    id?: IntFilter<"chosenskills"> | number
    charid?: IntNullableFilter<"chosenskills"> | number | null
    skillid?: IntNullableFilter<"chosenskills"> | number | null
    position?: IntNullableFilter<"chosenskills"> | number | null
  }

  export type chosenskillsOrderByWithRelationInput = {
    id?: SortOrder
    charid?: SortOrderInput | SortOrder
    skillid?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
  }

  export type chosenskillsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: chosenskillsWhereInput | chosenskillsWhereInput[]
    OR?: chosenskillsWhereInput[]
    NOT?: chosenskillsWhereInput | chosenskillsWhereInput[]
    charid?: IntNullableFilter<"chosenskills"> | number | null
    skillid?: IntNullableFilter<"chosenskills"> | number | null
    position?: IntNullableFilter<"chosenskills"> | number | null
  }, "id">

  export type chosenskillsOrderByWithAggregationInput = {
    id?: SortOrder
    charid?: SortOrderInput | SortOrder
    skillid?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    _count?: chosenskillsCountOrderByAggregateInput
    _avg?: chosenskillsAvgOrderByAggregateInput
    _max?: chosenskillsMaxOrderByAggregateInput
    _min?: chosenskillsMinOrderByAggregateInput
    _sum?: chosenskillsSumOrderByAggregateInput
  }

  export type chosenskillsScalarWhereWithAggregatesInput = {
    AND?: chosenskillsScalarWhereWithAggregatesInput | chosenskillsScalarWhereWithAggregatesInput[]
    OR?: chosenskillsScalarWhereWithAggregatesInput[]
    NOT?: chosenskillsScalarWhereWithAggregatesInput | chosenskillsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"chosenskills"> | number
    charid?: IntNullableWithAggregatesFilter<"chosenskills"> | number | null
    skillid?: IntNullableWithAggregatesFilter<"chosenskills"> | number | null
    position?: IntNullableWithAggregatesFilter<"chosenskills"> | number | null
  }

  export type cms_votesWhereInput = {
    AND?: cms_votesWhereInput | cms_votesWhereInput[]
    OR?: cms_votesWhereInput[]
    NOT?: cms_votesWhereInput | cms_votesWhereInput[]
    id?: IntFilter<"cms_votes"> | number
    accountid?: IntFilter<"cms_votes"> | number
    ip?: StringFilter<"cms_votes"> | string
    time?: DateTimeFilter<"cms_votes"> | Date | string
    vp?: IntFilter<"cms_votes"> | number
    collected?: IntFilter<"cms_votes"> | number
  }

  export type cms_votesOrderByWithRelationInput = {
    id?: SortOrder
    accountid?: SortOrder
    ip?: SortOrder
    time?: SortOrder
    vp?: SortOrder
    collected?: SortOrder
  }

  export type cms_votesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: cms_votesWhereInput | cms_votesWhereInput[]
    OR?: cms_votesWhereInput[]
    NOT?: cms_votesWhereInput | cms_votesWhereInput[]
    accountid?: IntFilter<"cms_votes"> | number
    ip?: StringFilter<"cms_votes"> | string
    time?: DateTimeFilter<"cms_votes"> | Date | string
    vp?: IntFilter<"cms_votes"> | number
    collected?: IntFilter<"cms_votes"> | number
  }, "id">

  export type cms_votesOrderByWithAggregationInput = {
    id?: SortOrder
    accountid?: SortOrder
    ip?: SortOrder
    time?: SortOrder
    vp?: SortOrder
    collected?: SortOrder
    _count?: cms_votesCountOrderByAggregateInput
    _avg?: cms_votesAvgOrderByAggregateInput
    _max?: cms_votesMaxOrderByAggregateInput
    _min?: cms_votesMinOrderByAggregateInput
    _sum?: cms_votesSumOrderByAggregateInput
  }

  export type cms_votesScalarWhereWithAggregatesInput = {
    AND?: cms_votesScalarWhereWithAggregatesInput | cms_votesScalarWhereWithAggregatesInput[]
    OR?: cms_votesScalarWhereWithAggregatesInput[]
    NOT?: cms_votesScalarWhereWithAggregatesInput | cms_votesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"cms_votes"> | number
    accountid?: IntWithAggregatesFilter<"cms_votes"> | number
    ip?: StringWithAggregatesFilter<"cms_votes"> | string
    time?: DateTimeWithAggregatesFilter<"cms_votes"> | Date | string
    vp?: IntWithAggregatesFilter<"cms_votes"> | number
    collected?: IntWithAggregatesFilter<"cms_votes"> | number
  }

  export type cooldownsWhereInput = {
    AND?: cooldownsWhereInput | cooldownsWhereInput[]
    OR?: cooldownsWhereInput[]
    NOT?: cooldownsWhereInput | cooldownsWhereInput[]
    id?: IntFilter<"cooldowns"> | number
    player_name?: StringFilter<"cooldowns"> | string
    cooldown_type?: IntFilter<"cooldowns"> | number
    expiry_time?: DateTimeFilter<"cooldowns"> | Date | string
  }

  export type cooldownsOrderByWithRelationInput = {
    id?: SortOrder
    player_name?: SortOrder
    cooldown_type?: SortOrder
    expiry_time?: SortOrder
  }

  export type cooldownsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: cooldownsWhereInput | cooldownsWhereInput[]
    OR?: cooldownsWhereInput[]
    NOT?: cooldownsWhereInput | cooldownsWhereInput[]
    player_name?: StringFilter<"cooldowns"> | string
    cooldown_type?: IntFilter<"cooldowns"> | number
    expiry_time?: DateTimeFilter<"cooldowns"> | Date | string
  }, "id">

  export type cooldownsOrderByWithAggregationInput = {
    id?: SortOrder
    player_name?: SortOrder
    cooldown_type?: SortOrder
    expiry_time?: SortOrder
    _count?: cooldownsCountOrderByAggregateInput
    _avg?: cooldownsAvgOrderByAggregateInput
    _max?: cooldownsMaxOrderByAggregateInput
    _min?: cooldownsMinOrderByAggregateInput
    _sum?: cooldownsSumOrderByAggregateInput
  }

  export type cooldownsScalarWhereWithAggregatesInput = {
    AND?: cooldownsScalarWhereWithAggregatesInput | cooldownsScalarWhereWithAggregatesInput[]
    OR?: cooldownsScalarWhereWithAggregatesInput[]
    NOT?: cooldownsScalarWhereWithAggregatesInput | cooldownsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"cooldowns"> | number
    player_name?: StringWithAggregatesFilter<"cooldowns"> | string
    cooldown_type?: IntWithAggregatesFilter<"cooldowns"> | number
    expiry_time?: DateTimeWithAggregatesFilter<"cooldowns"> | Date | string
  }

  export type coresWhereInput = {
    AND?: coresWhereInput | coresWhereInput[]
    OR?: coresWhereInput[]
    NOT?: coresWhereInput | coresWhereInput[]
    id?: IntFilter<"cores"> | number
    pos?: IntNullableFilter<"cores"> | number | null
    charid?: IntNullableFilter<"cores"> | number | null
    slottype?: IntNullableFilter<"cores"> | number | null
    coreid?: IntNullableFilter<"cores"> | number | null
    leftCount?: IntNullableFilter<"cores"> | number | null
  }

  export type coresOrderByWithRelationInput = {
    id?: SortOrder
    pos?: SortOrderInput | SortOrder
    charid?: SortOrderInput | SortOrder
    slottype?: SortOrderInput | SortOrder
    coreid?: SortOrderInput | SortOrder
    leftCount?: SortOrderInput | SortOrder
  }

  export type coresWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: coresWhereInput | coresWhereInput[]
    OR?: coresWhereInput[]
    NOT?: coresWhereInput | coresWhereInput[]
    pos?: IntNullableFilter<"cores"> | number | null
    charid?: IntNullableFilter<"cores"> | number | null
    slottype?: IntNullableFilter<"cores"> | number | null
    coreid?: IntNullableFilter<"cores"> | number | null
    leftCount?: IntNullableFilter<"cores"> | number | null
  }, "id">

  export type coresOrderByWithAggregationInput = {
    id?: SortOrder
    pos?: SortOrderInput | SortOrder
    charid?: SortOrderInput | SortOrder
    slottype?: SortOrderInput | SortOrder
    coreid?: SortOrderInput | SortOrder
    leftCount?: SortOrderInput | SortOrder
    _count?: coresCountOrderByAggregateInput
    _avg?: coresAvgOrderByAggregateInput
    _max?: coresMaxOrderByAggregateInput
    _min?: coresMinOrderByAggregateInput
    _sum?: coresSumOrderByAggregateInput
  }

  export type coresScalarWhereWithAggregatesInput = {
    AND?: coresScalarWhereWithAggregatesInput | coresScalarWhereWithAggregatesInput[]
    OR?: coresScalarWhereWithAggregatesInput[]
    NOT?: coresScalarWhereWithAggregatesInput | coresScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"cores"> | number
    pos?: IntNullableWithAggregatesFilter<"cores"> | number | null
    charid?: IntNullableWithAggregatesFilter<"cores"> | number | null
    slottype?: IntNullableWithAggregatesFilter<"cores"> | number | null
    coreid?: IntNullableWithAggregatesFilter<"cores"> | number | null
    leftCount?: IntNullableWithAggregatesFilter<"cores"> | number | null
  }

  export type cs_categoriesWhereInput = {
    AND?: cs_categoriesWhereInput | cs_categoriesWhereInput[]
    OR?: cs_categoriesWhereInput[]
    NOT?: cs_categoriesWhereInput | cs_categoriesWhereInput[]
    id?: IntFilter<"cs_categories"> | number
    idx?: IntNullableFilter<"cs_categories"> | number | null
    name?: StringNullableFilter<"cs_categories"> | string | null
    flag?: IntNullableFilter<"cs_categories"> | number | null
    parentIdx?: IntNullableFilter<"cs_categories"> | number | null
    stock?: IntNullableFilter<"cs_categories"> | number | null
  }

  export type cs_categoriesOrderByWithRelationInput = {
    id?: SortOrder
    idx?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    flag?: SortOrderInput | SortOrder
    parentIdx?: SortOrderInput | SortOrder
    stock?: SortOrderInput | SortOrder
  }

  export type cs_categoriesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: cs_categoriesWhereInput | cs_categoriesWhereInput[]
    OR?: cs_categoriesWhereInput[]
    NOT?: cs_categoriesWhereInput | cs_categoriesWhereInput[]
    idx?: IntNullableFilter<"cs_categories"> | number | null
    name?: StringNullableFilter<"cs_categories"> | string | null
    flag?: IntNullableFilter<"cs_categories"> | number | null
    parentIdx?: IntNullableFilter<"cs_categories"> | number | null
    stock?: IntNullableFilter<"cs_categories"> | number | null
  }, "id">

  export type cs_categoriesOrderByWithAggregationInput = {
    id?: SortOrder
    idx?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    flag?: SortOrderInput | SortOrder
    parentIdx?: SortOrderInput | SortOrder
    stock?: SortOrderInput | SortOrder
    _count?: cs_categoriesCountOrderByAggregateInput
    _avg?: cs_categoriesAvgOrderByAggregateInput
    _max?: cs_categoriesMaxOrderByAggregateInput
    _min?: cs_categoriesMinOrderByAggregateInput
    _sum?: cs_categoriesSumOrderByAggregateInput
  }

  export type cs_categoriesScalarWhereWithAggregatesInput = {
    AND?: cs_categoriesScalarWhereWithAggregatesInput | cs_categoriesScalarWhereWithAggregatesInput[]
    OR?: cs_categoriesScalarWhereWithAggregatesInput[]
    NOT?: cs_categoriesScalarWhereWithAggregatesInput | cs_categoriesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"cs_categories"> | number
    idx?: IntNullableWithAggregatesFilter<"cs_categories"> | number | null
    name?: StringNullableWithAggregatesFilter<"cs_categories"> | string | null
    flag?: IntNullableWithAggregatesFilter<"cs_categories"> | number | null
    parentIdx?: IntNullableWithAggregatesFilter<"cs_categories"> | number | null
    stock?: IntNullableWithAggregatesFilter<"cs_categories"> | number | null
  }

  export type cs_itemsWhereInput = {
    AND?: cs_itemsWhereInput | cs_itemsWhereInput[]
    OR?: cs_itemsWhereInput[]
    NOT?: cs_itemsWhereInput | cs_itemsWhereInput[]
    id?: IntFilter<"cs_items"> | number
    itemID?: IntFilter<"cs_items"> | number
    stock?: IntNullableFilter<"cs_items"> | number | null
    shopItemFlag?: IntNullableFilter<"cs_items"> | number | null
    idk1?: IntNullableFilter<"cs_items"> | number | null
    idk2?: IntNullableFilter<"cs_items"> | number | null
    oldPrice?: IntNullableFilter<"cs_items"> | number | null
    newPrice?: IntNullableFilter<"cs_items"> | number | null
    idkTime1?: DateTimeNullableFilter<"cs_items"> | Date | string | null
    saleFromFT?: DateTimeNullableFilter<"cs_items"> | Date | string | null
    idkTime3?: DateTimeNullableFilter<"cs_items"> | Date | string | null
    saleToFT?: DateTimeNullableFilter<"cs_items"> | Date | string | null
    idk3?: IntNullableFilter<"cs_items"> | number | null
    bundleQuantity?: IntNullableFilter<"cs_items"> | number | null
    availableDays?: IntNullableFilter<"cs_items"> | number | null
    buyableWithMaplePoints?: IntNullableFilter<"cs_items"> | number | null
    buyableWithCredit?: IntNullableFilter<"cs_items"> | number | null
    buyableWithPrepaid?: IntNullableFilter<"cs_items"> | number | null
    likable?: IntNullableFilter<"cs_items"> | number | null
    meso?: IntNullableFilter<"cs_items"> | number | null
    favoritable?: IntNullableFilter<"cs_items"> | number | null
    gender?: IntNullableFilter<"cs_items"> | number | null
    likes?: IntNullableFilter<"cs_items"> | number | null
    requiredLevel?: IntNullableFilter<"cs_items"> | number | null
    idk10?: StringNullableFilter<"cs_items"> | string | null
    idk11?: IntNullableFilter<"cs_items"> | number | null
    idk13?: IntNullableFilter<"cs_items"> | number | null
    idk14?: IntNullableFilter<"cs_items"> | number | null
    category?: StringNullableFilter<"cs_items"> | string | null
  }

  export type cs_itemsOrderByWithRelationInput = {
    id?: SortOrder
    itemID?: SortOrder
    stock?: SortOrderInput | SortOrder
    shopItemFlag?: SortOrderInput | SortOrder
    idk1?: SortOrderInput | SortOrder
    idk2?: SortOrderInput | SortOrder
    oldPrice?: SortOrderInput | SortOrder
    newPrice?: SortOrderInput | SortOrder
    idkTime1?: SortOrderInput | SortOrder
    saleFromFT?: SortOrderInput | SortOrder
    idkTime3?: SortOrderInput | SortOrder
    saleToFT?: SortOrderInput | SortOrder
    idk3?: SortOrderInput | SortOrder
    bundleQuantity?: SortOrderInput | SortOrder
    availableDays?: SortOrderInput | SortOrder
    buyableWithMaplePoints?: SortOrderInput | SortOrder
    buyableWithCredit?: SortOrderInput | SortOrder
    buyableWithPrepaid?: SortOrderInput | SortOrder
    likable?: SortOrderInput | SortOrder
    meso?: SortOrderInput | SortOrder
    favoritable?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    likes?: SortOrderInput | SortOrder
    requiredLevel?: SortOrderInput | SortOrder
    idk10?: SortOrderInput | SortOrder
    idk11?: SortOrderInput | SortOrder
    idk13?: SortOrderInput | SortOrder
    idk14?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
  }

  export type cs_itemsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: cs_itemsWhereInput | cs_itemsWhereInput[]
    OR?: cs_itemsWhereInput[]
    NOT?: cs_itemsWhereInput | cs_itemsWhereInput[]
    itemID?: IntFilter<"cs_items"> | number
    stock?: IntNullableFilter<"cs_items"> | number | null
    shopItemFlag?: IntNullableFilter<"cs_items"> | number | null
    idk1?: IntNullableFilter<"cs_items"> | number | null
    idk2?: IntNullableFilter<"cs_items"> | number | null
    oldPrice?: IntNullableFilter<"cs_items"> | number | null
    newPrice?: IntNullableFilter<"cs_items"> | number | null
    idkTime1?: DateTimeNullableFilter<"cs_items"> | Date | string | null
    saleFromFT?: DateTimeNullableFilter<"cs_items"> | Date | string | null
    idkTime3?: DateTimeNullableFilter<"cs_items"> | Date | string | null
    saleToFT?: DateTimeNullableFilter<"cs_items"> | Date | string | null
    idk3?: IntNullableFilter<"cs_items"> | number | null
    bundleQuantity?: IntNullableFilter<"cs_items"> | number | null
    availableDays?: IntNullableFilter<"cs_items"> | number | null
    buyableWithMaplePoints?: IntNullableFilter<"cs_items"> | number | null
    buyableWithCredit?: IntNullableFilter<"cs_items"> | number | null
    buyableWithPrepaid?: IntNullableFilter<"cs_items"> | number | null
    likable?: IntNullableFilter<"cs_items"> | number | null
    meso?: IntNullableFilter<"cs_items"> | number | null
    favoritable?: IntNullableFilter<"cs_items"> | number | null
    gender?: IntNullableFilter<"cs_items"> | number | null
    likes?: IntNullableFilter<"cs_items"> | number | null
    requiredLevel?: IntNullableFilter<"cs_items"> | number | null
    idk10?: StringNullableFilter<"cs_items"> | string | null
    idk11?: IntNullableFilter<"cs_items"> | number | null
    idk13?: IntNullableFilter<"cs_items"> | number | null
    idk14?: IntNullableFilter<"cs_items"> | number | null
    category?: StringNullableFilter<"cs_items"> | string | null
  }, "id">

  export type cs_itemsOrderByWithAggregationInput = {
    id?: SortOrder
    itemID?: SortOrder
    stock?: SortOrderInput | SortOrder
    shopItemFlag?: SortOrderInput | SortOrder
    idk1?: SortOrderInput | SortOrder
    idk2?: SortOrderInput | SortOrder
    oldPrice?: SortOrderInput | SortOrder
    newPrice?: SortOrderInput | SortOrder
    idkTime1?: SortOrderInput | SortOrder
    saleFromFT?: SortOrderInput | SortOrder
    idkTime3?: SortOrderInput | SortOrder
    saleToFT?: SortOrderInput | SortOrder
    idk3?: SortOrderInput | SortOrder
    bundleQuantity?: SortOrderInput | SortOrder
    availableDays?: SortOrderInput | SortOrder
    buyableWithMaplePoints?: SortOrderInput | SortOrder
    buyableWithCredit?: SortOrderInput | SortOrder
    buyableWithPrepaid?: SortOrderInput | SortOrder
    likable?: SortOrderInput | SortOrder
    meso?: SortOrderInput | SortOrder
    favoritable?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    likes?: SortOrderInput | SortOrder
    requiredLevel?: SortOrderInput | SortOrder
    idk10?: SortOrderInput | SortOrder
    idk11?: SortOrderInput | SortOrder
    idk13?: SortOrderInput | SortOrder
    idk14?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    _count?: cs_itemsCountOrderByAggregateInput
    _avg?: cs_itemsAvgOrderByAggregateInput
    _max?: cs_itemsMaxOrderByAggregateInput
    _min?: cs_itemsMinOrderByAggregateInput
    _sum?: cs_itemsSumOrderByAggregateInput
  }

  export type cs_itemsScalarWhereWithAggregatesInput = {
    AND?: cs_itemsScalarWhereWithAggregatesInput | cs_itemsScalarWhereWithAggregatesInput[]
    OR?: cs_itemsScalarWhereWithAggregatesInput[]
    NOT?: cs_itemsScalarWhereWithAggregatesInput | cs_itemsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"cs_items"> | number
    itemID?: IntWithAggregatesFilter<"cs_items"> | number
    stock?: IntNullableWithAggregatesFilter<"cs_items"> | number | null
    shopItemFlag?: IntNullableWithAggregatesFilter<"cs_items"> | number | null
    idk1?: IntNullableWithAggregatesFilter<"cs_items"> | number | null
    idk2?: IntNullableWithAggregatesFilter<"cs_items"> | number | null
    oldPrice?: IntNullableWithAggregatesFilter<"cs_items"> | number | null
    newPrice?: IntNullableWithAggregatesFilter<"cs_items"> | number | null
    idkTime1?: DateTimeNullableWithAggregatesFilter<"cs_items"> | Date | string | null
    saleFromFT?: DateTimeNullableWithAggregatesFilter<"cs_items"> | Date | string | null
    idkTime3?: DateTimeNullableWithAggregatesFilter<"cs_items"> | Date | string | null
    saleToFT?: DateTimeNullableWithAggregatesFilter<"cs_items"> | Date | string | null
    idk3?: IntNullableWithAggregatesFilter<"cs_items"> | number | null
    bundleQuantity?: IntNullableWithAggregatesFilter<"cs_items"> | number | null
    availableDays?: IntNullableWithAggregatesFilter<"cs_items"> | number | null
    buyableWithMaplePoints?: IntNullableWithAggregatesFilter<"cs_items"> | number | null
    buyableWithCredit?: IntNullableWithAggregatesFilter<"cs_items"> | number | null
    buyableWithPrepaid?: IntNullableWithAggregatesFilter<"cs_items"> | number | null
    likable?: IntNullableWithAggregatesFilter<"cs_items"> | number | null
    meso?: IntNullableWithAggregatesFilter<"cs_items"> | number | null
    favoritable?: IntNullableWithAggregatesFilter<"cs_items"> | number | null
    gender?: IntNullableWithAggregatesFilter<"cs_items"> | number | null
    likes?: IntNullableWithAggregatesFilter<"cs_items"> | number | null
    requiredLevel?: IntNullableWithAggregatesFilter<"cs_items"> | number | null
    idk10?: StringNullableWithAggregatesFilter<"cs_items"> | string | null
    idk11?: IntNullableWithAggregatesFilter<"cs_items"> | number | null
    idk13?: IntNullableWithAggregatesFilter<"cs_items"> | number | null
    idk14?: IntNullableWithAggregatesFilter<"cs_items"> | number | null
    category?: StringNullableWithAggregatesFilter<"cs_items"> | string | null
  }

  export type damageskinsWhereInput = {
    AND?: damageskinsWhereInput | damageskinsWhereInput[]
    OR?: damageskinsWhereInput[]
    NOT?: damageskinsWhereInput | damageskinsWhereInput[]
    id?: BigIntFilter<"damageskins"> | bigint | number
    charid?: IntNullableFilter<"damageskins"> | number | null
    damageskinid?: IntNullableFilter<"damageskins"> | number | null
    itemid?: IntNullableFilter<"damageskins"> | number | null
    notsave?: BoolNullableFilter<"damageskins"> | boolean | null
    description?: StringNullableFilter<"damageskins"> | string | null
  }

  export type damageskinsOrderByWithRelationInput = {
    id?: SortOrder
    charid?: SortOrderInput | SortOrder
    damageskinid?: SortOrderInput | SortOrder
    itemid?: SortOrderInput | SortOrder
    notsave?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
  }

  export type damageskinsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: damageskinsWhereInput | damageskinsWhereInput[]
    OR?: damageskinsWhereInput[]
    NOT?: damageskinsWhereInput | damageskinsWhereInput[]
    charid?: IntNullableFilter<"damageskins"> | number | null
    damageskinid?: IntNullableFilter<"damageskins"> | number | null
    itemid?: IntNullableFilter<"damageskins"> | number | null
    notsave?: BoolNullableFilter<"damageskins"> | boolean | null
    description?: StringNullableFilter<"damageskins"> | string | null
  }, "id">

  export type damageskinsOrderByWithAggregationInput = {
    id?: SortOrder
    charid?: SortOrderInput | SortOrder
    damageskinid?: SortOrderInput | SortOrder
    itemid?: SortOrderInput | SortOrder
    notsave?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    _count?: damageskinsCountOrderByAggregateInput
    _avg?: damageskinsAvgOrderByAggregateInput
    _max?: damageskinsMaxOrderByAggregateInput
    _min?: damageskinsMinOrderByAggregateInput
    _sum?: damageskinsSumOrderByAggregateInput
  }

  export type damageskinsScalarWhereWithAggregatesInput = {
    AND?: damageskinsScalarWhereWithAggregatesInput | damageskinsScalarWhereWithAggregatesInput[]
    OR?: damageskinsScalarWhereWithAggregatesInput[]
    NOT?: damageskinsScalarWhereWithAggregatesInput | damageskinsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"damageskins"> | bigint | number
    charid?: IntNullableWithAggregatesFilter<"damageskins"> | number | null
    damageskinid?: IntNullableWithAggregatesFilter<"damageskins"> | number | null
    itemid?: IntNullableWithAggregatesFilter<"damageskins"> | number | null
    notsave?: BoolNullableWithAggregatesFilter<"damageskins"> | boolean | null
    description?: StringNullableWithAggregatesFilter<"damageskins"> | string | null
  }

  export type employeetrunkWhereInput = {
    AND?: employeetrunkWhereInput | employeetrunkWhereInput[]
    OR?: employeetrunkWhereInput[]
    NOT?: employeetrunkWhereInput | employeetrunkWhereInput[]
    id?: IntFilter<"employeetrunk"> | number
    money?: BigIntNullableFilter<"employeetrunk"> | bigint | number | null
  }

  export type employeetrunkOrderByWithRelationInput = {
    id?: SortOrder
    money?: SortOrderInput | SortOrder
  }

  export type employeetrunkWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: employeetrunkWhereInput | employeetrunkWhereInput[]
    OR?: employeetrunkWhereInput[]
    NOT?: employeetrunkWhereInput | employeetrunkWhereInput[]
    money?: BigIntNullableFilter<"employeetrunk"> | bigint | number | null
  }, "id">

  export type employeetrunkOrderByWithAggregationInput = {
    id?: SortOrder
    money?: SortOrderInput | SortOrder
    _count?: employeetrunkCountOrderByAggregateInput
    _avg?: employeetrunkAvgOrderByAggregateInput
    _max?: employeetrunkMaxOrderByAggregateInput
    _min?: employeetrunkMinOrderByAggregateInput
    _sum?: employeetrunkSumOrderByAggregateInput
  }

  export type employeetrunkScalarWhereWithAggregatesInput = {
    AND?: employeetrunkScalarWhereWithAggregatesInput | employeetrunkScalarWhereWithAggregatesInput[]
    OR?: employeetrunkScalarWhereWithAggregatesInput[]
    NOT?: employeetrunkScalarWhereWithAggregatesInput | employeetrunkScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"employeetrunk"> | number
    money?: BigIntNullableWithAggregatesFilter<"employeetrunk"> | bigint | number | null
  }

  export type equipsWhereInput = {
    AND?: equipsWhereInput | equipsWhereInput[]
    OR?: equipsWhereInput[]
    NOT?: equipsWhereInput | equipsWhereInput[]
    serialnumber?: BigIntNullableFilter<"equips"> | bigint | number | null
    itemid?: BigIntFilter<"equips"> | bigint | number
    title?: StringNullableFilter<"equips"> | string | null
    equippeddate?: DateTimeNullableFilter<"equips"> | Date | string | null
    prevbonusexprate?: IntNullableFilter<"equips"> | number | null
    options?: StringNullableFilter<"equips"> | string | null
    sockets?: StringNullableFilter<"equips"> | string | null
    tuc?: IntNullableFilter<"equips"> | number | null
    cuc?: IntNullableFilter<"equips"> | number | null
    istr?: IntNullableFilter<"equips"> | number | null
    idex?: IntNullableFilter<"equips"> | number | null
    iint?: IntNullableFilter<"equips"> | number | null
    iluk?: IntNullableFilter<"equips"> | number | null
    imaxhp?: IntNullableFilter<"equips"> | number | null
    imaxhpr?: IntFilter<"equips"> | number
    imaxmp?: IntNullableFilter<"equips"> | number | null
    imaxmpr?: IntFilter<"equips"> | number
    ipad?: IntNullableFilter<"equips"> | number | null
    imad?: IntNullableFilter<"equips"> | number | null
    ipdd?: IntNullableFilter<"equips"> | number | null
    imdd?: IntNullableFilter<"equips"> | number | null
    iacc?: IntNullableFilter<"equips"> | number | null
    ieva?: IntNullableFilter<"equips"> | number | null
    icraft?: IntNullableFilter<"equips"> | number | null
    ispeed?: IntNullableFilter<"equips"> | number | null
    ijump?: IntNullableFilter<"equips"> | number | null
    arcaneid?: BigIntNullableFilter<"equips"> | bigint | number | null
    attribute?: IntNullableFilter<"equips"> | number | null
    leveluptype?: IntNullableFilter<"equips"> | number | null
    level?: IntNullableFilter<"equips"> | number | null
    exp?: IntNullableFilter<"equips"> | number | null
    durability?: IntNullableFilter<"equips"> | number | null
    iuc?: IntNullableFilter<"equips"> | number | null
    ipvpdamage?: IntNullableFilter<"equips"> | number | null
    ireducereq?: IntNullableFilter<"equips"> | number | null
    specialattribute?: IntNullableFilter<"equips"> | number | null
    durabilitymax?: IntNullableFilter<"equips"> | number | null
    iincreq?: IntNullableFilter<"equips"> | number | null
    growthenchant?: IntNullableFilter<"equips"> | number | null
    psenchant?: IntNullableFilter<"equips"> | number | null
    hyperupgrade?: IntNullableFilter<"equips"> | number | null
    bdr?: IntNullableFilter<"equips"> | number | null
    imdr?: IntNullableFilter<"equips"> | number | null
    damr?: IntNullableFilter<"equips"> | number | null
    statr?: IntNullableFilter<"equips"> | number | null
    cuttable?: IntNullableFilter<"equips"> | number | null
    exgradeoption?: BigIntNullableFilter<"equips"> | bigint | number | null
    itemstate?: IntNullableFilter<"equips"> | number | null
    grade?: IntNullableFilter<"equips"> | number | null
    chuc?: IntNullableFilter<"equips"> | number | null
    souloptionid?: IntNullableFilter<"equips"> | number | null
    soulsocketid?: IntNullableFilter<"equips"> | number | null
    souloption?: IntNullableFilter<"equips"> | number | null
    soulitemid?: IntNullableFilter<"equips"> | number | null
    rstr?: IntNullableFilter<"equips"> | number | null
    rdex?: IntNullableFilter<"equips"> | number | null
    rint?: IntNullableFilter<"equips"> | number | null
    rluk?: IntNullableFilter<"equips"> | number | null
    rlevel?: IntNullableFilter<"equips"> | number | null
    rjob?: IntNullableFilter<"equips"> | number | null
    rpop?: IntNullableFilter<"equips"> | number | null
    specialgrade?: IntNullableFilter<"equips"> | number | null
    fixedpotential?: BoolNullableFilter<"equips"> | boolean | null
    tradeblock?: BoolNullableFilter<"equips"> | boolean | null
    isonly?: BoolNullableFilter<"equips"> | boolean | null
    notsale?: BoolNullableFilter<"equips"> | boolean | null
    attackspeed?: IntNullableFilter<"equips"> | number | null
    price?: IntNullableFilter<"equips"> | number | null
    charmexp?: IntNullableFilter<"equips"> | number | null
    setitemid?: IntNullableFilter<"equips"> | number | null
    exitem?: BoolNullableFilter<"equips"> | boolean | null
    equiptradeblock?: BoolNullableFilter<"equips"> | boolean | null
    islot?: StringNullableFilter<"equips"> | string | null
    vslot?: StringNullableFilter<"equips"> | string | null
    fixedgrade?: IntNullableFilter<"equips"> | number | null
    nopotential?: IntNullableFilter<"equips"> | number | null
    bossreward?: IntNullableFilter<"equips"> | number | null
    superioreqp?: IntNullableFilter<"equips"> | number | null
    flameid?: BigIntNullableFilter<"equips"> | bigint | number | null
    android?: IntNullableFilter<"equips"> | number | null
    androidgrade?: IntNullableFilter<"equips"> | number | null
    arcane_stat?: IntNullableFilter<"equips"> | number | null
    arcane_exp?: IntNullableFilter<"equips"> | number | null
    arcane_level?: IntNullableFilter<"equips"> | number | null
    flame_str?: IntNullableFilter<"equips"> | number | null
    flame_dex?: IntNullableFilter<"equips"> | number | null
    flame_int?: IntNullableFilter<"equips"> | number | null
    flame_luk?: IntNullableFilter<"equips"> | number | null
    flame_pad?: IntNullableFilter<"equips"> | number | null
    flame_mad?: IntNullableFilter<"equips"> | number | null
    flame_pdd?: IntNullableFilter<"equips"> | number | null
    flame_hp?: IntNullableFilter<"equips"> | number | null
    flame_mp?: IntNullableFilter<"equips"> | number | null
    flame_speed?: IntNullableFilter<"equips"> | number | null
    flame_jump?: IntNullableFilter<"equips"> | number | null
    flame_allStatR?: IntNullableFilter<"equips"> | number | null
    flame_bossDamageR?: IntNullableFilter<"equips"> | number | null
    flame_damageR?: IntNullableFilter<"equips"> | number | null
    flame_reduceReqLevel?: IntNullableFilter<"equips"> | number | null
  }

  export type equipsOrderByWithRelationInput = {
    serialnumber?: SortOrderInput | SortOrder
    itemid?: SortOrder
    title?: SortOrderInput | SortOrder
    equippeddate?: SortOrderInput | SortOrder
    prevbonusexprate?: SortOrderInput | SortOrder
    options?: SortOrderInput | SortOrder
    sockets?: SortOrderInput | SortOrder
    tuc?: SortOrderInput | SortOrder
    cuc?: SortOrderInput | SortOrder
    istr?: SortOrderInput | SortOrder
    idex?: SortOrderInput | SortOrder
    iint?: SortOrderInput | SortOrder
    iluk?: SortOrderInput | SortOrder
    imaxhp?: SortOrderInput | SortOrder
    imaxhpr?: SortOrder
    imaxmp?: SortOrderInput | SortOrder
    imaxmpr?: SortOrder
    ipad?: SortOrderInput | SortOrder
    imad?: SortOrderInput | SortOrder
    ipdd?: SortOrderInput | SortOrder
    imdd?: SortOrderInput | SortOrder
    iacc?: SortOrderInput | SortOrder
    ieva?: SortOrderInput | SortOrder
    icraft?: SortOrderInput | SortOrder
    ispeed?: SortOrderInput | SortOrder
    ijump?: SortOrderInput | SortOrder
    arcaneid?: SortOrderInput | SortOrder
    attribute?: SortOrderInput | SortOrder
    leveluptype?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    exp?: SortOrderInput | SortOrder
    durability?: SortOrderInput | SortOrder
    iuc?: SortOrderInput | SortOrder
    ipvpdamage?: SortOrderInput | SortOrder
    ireducereq?: SortOrderInput | SortOrder
    specialattribute?: SortOrderInput | SortOrder
    durabilitymax?: SortOrderInput | SortOrder
    iincreq?: SortOrderInput | SortOrder
    growthenchant?: SortOrderInput | SortOrder
    psenchant?: SortOrderInput | SortOrder
    hyperupgrade?: SortOrderInput | SortOrder
    bdr?: SortOrderInput | SortOrder
    imdr?: SortOrderInput | SortOrder
    damr?: SortOrderInput | SortOrder
    statr?: SortOrderInput | SortOrder
    cuttable?: SortOrderInput | SortOrder
    exgradeoption?: SortOrderInput | SortOrder
    itemstate?: SortOrderInput | SortOrder
    grade?: SortOrderInput | SortOrder
    chuc?: SortOrderInput | SortOrder
    souloptionid?: SortOrderInput | SortOrder
    soulsocketid?: SortOrderInput | SortOrder
    souloption?: SortOrderInput | SortOrder
    soulitemid?: SortOrderInput | SortOrder
    rstr?: SortOrderInput | SortOrder
    rdex?: SortOrderInput | SortOrder
    rint?: SortOrderInput | SortOrder
    rluk?: SortOrderInput | SortOrder
    rlevel?: SortOrderInput | SortOrder
    rjob?: SortOrderInput | SortOrder
    rpop?: SortOrderInput | SortOrder
    specialgrade?: SortOrderInput | SortOrder
    fixedpotential?: SortOrderInput | SortOrder
    tradeblock?: SortOrderInput | SortOrder
    isonly?: SortOrderInput | SortOrder
    notsale?: SortOrderInput | SortOrder
    attackspeed?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    charmexp?: SortOrderInput | SortOrder
    setitemid?: SortOrderInput | SortOrder
    exitem?: SortOrderInput | SortOrder
    equiptradeblock?: SortOrderInput | SortOrder
    islot?: SortOrderInput | SortOrder
    vslot?: SortOrderInput | SortOrder
    fixedgrade?: SortOrderInput | SortOrder
    nopotential?: SortOrderInput | SortOrder
    bossreward?: SortOrderInput | SortOrder
    superioreqp?: SortOrderInput | SortOrder
    flameid?: SortOrderInput | SortOrder
    android?: SortOrderInput | SortOrder
    androidgrade?: SortOrderInput | SortOrder
    arcane_stat?: SortOrderInput | SortOrder
    arcane_exp?: SortOrderInput | SortOrder
    arcane_level?: SortOrderInput | SortOrder
    flame_str?: SortOrderInput | SortOrder
    flame_dex?: SortOrderInput | SortOrder
    flame_int?: SortOrderInput | SortOrder
    flame_luk?: SortOrderInput | SortOrder
    flame_pad?: SortOrderInput | SortOrder
    flame_mad?: SortOrderInput | SortOrder
    flame_pdd?: SortOrderInput | SortOrder
    flame_hp?: SortOrderInput | SortOrder
    flame_mp?: SortOrderInput | SortOrder
    flame_speed?: SortOrderInput | SortOrder
    flame_jump?: SortOrderInput | SortOrder
    flame_allStatR?: SortOrderInput | SortOrder
    flame_bossDamageR?: SortOrderInput | SortOrder
    flame_damageR?: SortOrderInput | SortOrder
    flame_reduceReqLevel?: SortOrderInput | SortOrder
  }

  export type equipsWhereUniqueInput = Prisma.AtLeast<{
    itemid?: bigint | number
    AND?: equipsWhereInput | equipsWhereInput[]
    OR?: equipsWhereInput[]
    NOT?: equipsWhereInput | equipsWhereInput[]
    serialnumber?: BigIntNullableFilter<"equips"> | bigint | number | null
    title?: StringNullableFilter<"equips"> | string | null
    equippeddate?: DateTimeNullableFilter<"equips"> | Date | string | null
    prevbonusexprate?: IntNullableFilter<"equips"> | number | null
    options?: StringNullableFilter<"equips"> | string | null
    sockets?: StringNullableFilter<"equips"> | string | null
    tuc?: IntNullableFilter<"equips"> | number | null
    cuc?: IntNullableFilter<"equips"> | number | null
    istr?: IntNullableFilter<"equips"> | number | null
    idex?: IntNullableFilter<"equips"> | number | null
    iint?: IntNullableFilter<"equips"> | number | null
    iluk?: IntNullableFilter<"equips"> | number | null
    imaxhp?: IntNullableFilter<"equips"> | number | null
    imaxhpr?: IntFilter<"equips"> | number
    imaxmp?: IntNullableFilter<"equips"> | number | null
    imaxmpr?: IntFilter<"equips"> | number
    ipad?: IntNullableFilter<"equips"> | number | null
    imad?: IntNullableFilter<"equips"> | number | null
    ipdd?: IntNullableFilter<"equips"> | number | null
    imdd?: IntNullableFilter<"equips"> | number | null
    iacc?: IntNullableFilter<"equips"> | number | null
    ieva?: IntNullableFilter<"equips"> | number | null
    icraft?: IntNullableFilter<"equips"> | number | null
    ispeed?: IntNullableFilter<"equips"> | number | null
    ijump?: IntNullableFilter<"equips"> | number | null
    arcaneid?: BigIntNullableFilter<"equips"> | bigint | number | null
    attribute?: IntNullableFilter<"equips"> | number | null
    leveluptype?: IntNullableFilter<"equips"> | number | null
    level?: IntNullableFilter<"equips"> | number | null
    exp?: IntNullableFilter<"equips"> | number | null
    durability?: IntNullableFilter<"equips"> | number | null
    iuc?: IntNullableFilter<"equips"> | number | null
    ipvpdamage?: IntNullableFilter<"equips"> | number | null
    ireducereq?: IntNullableFilter<"equips"> | number | null
    specialattribute?: IntNullableFilter<"equips"> | number | null
    durabilitymax?: IntNullableFilter<"equips"> | number | null
    iincreq?: IntNullableFilter<"equips"> | number | null
    growthenchant?: IntNullableFilter<"equips"> | number | null
    psenchant?: IntNullableFilter<"equips"> | number | null
    hyperupgrade?: IntNullableFilter<"equips"> | number | null
    bdr?: IntNullableFilter<"equips"> | number | null
    imdr?: IntNullableFilter<"equips"> | number | null
    damr?: IntNullableFilter<"equips"> | number | null
    statr?: IntNullableFilter<"equips"> | number | null
    cuttable?: IntNullableFilter<"equips"> | number | null
    exgradeoption?: BigIntNullableFilter<"equips"> | bigint | number | null
    itemstate?: IntNullableFilter<"equips"> | number | null
    grade?: IntNullableFilter<"equips"> | number | null
    chuc?: IntNullableFilter<"equips"> | number | null
    souloptionid?: IntNullableFilter<"equips"> | number | null
    soulsocketid?: IntNullableFilter<"equips"> | number | null
    souloption?: IntNullableFilter<"equips"> | number | null
    soulitemid?: IntNullableFilter<"equips"> | number | null
    rstr?: IntNullableFilter<"equips"> | number | null
    rdex?: IntNullableFilter<"equips"> | number | null
    rint?: IntNullableFilter<"equips"> | number | null
    rluk?: IntNullableFilter<"equips"> | number | null
    rlevel?: IntNullableFilter<"equips"> | number | null
    rjob?: IntNullableFilter<"equips"> | number | null
    rpop?: IntNullableFilter<"equips"> | number | null
    specialgrade?: IntNullableFilter<"equips"> | number | null
    fixedpotential?: BoolNullableFilter<"equips"> | boolean | null
    tradeblock?: BoolNullableFilter<"equips"> | boolean | null
    isonly?: BoolNullableFilter<"equips"> | boolean | null
    notsale?: BoolNullableFilter<"equips"> | boolean | null
    attackspeed?: IntNullableFilter<"equips"> | number | null
    price?: IntNullableFilter<"equips"> | number | null
    charmexp?: IntNullableFilter<"equips"> | number | null
    setitemid?: IntNullableFilter<"equips"> | number | null
    exitem?: BoolNullableFilter<"equips"> | boolean | null
    equiptradeblock?: BoolNullableFilter<"equips"> | boolean | null
    islot?: StringNullableFilter<"equips"> | string | null
    vslot?: StringNullableFilter<"equips"> | string | null
    fixedgrade?: IntNullableFilter<"equips"> | number | null
    nopotential?: IntNullableFilter<"equips"> | number | null
    bossreward?: IntNullableFilter<"equips"> | number | null
    superioreqp?: IntNullableFilter<"equips"> | number | null
    flameid?: BigIntNullableFilter<"equips"> | bigint | number | null
    android?: IntNullableFilter<"equips"> | number | null
    androidgrade?: IntNullableFilter<"equips"> | number | null
    arcane_stat?: IntNullableFilter<"equips"> | number | null
    arcane_exp?: IntNullableFilter<"equips"> | number | null
    arcane_level?: IntNullableFilter<"equips"> | number | null
    flame_str?: IntNullableFilter<"equips"> | number | null
    flame_dex?: IntNullableFilter<"equips"> | number | null
    flame_int?: IntNullableFilter<"equips"> | number | null
    flame_luk?: IntNullableFilter<"equips"> | number | null
    flame_pad?: IntNullableFilter<"equips"> | number | null
    flame_mad?: IntNullableFilter<"equips"> | number | null
    flame_pdd?: IntNullableFilter<"equips"> | number | null
    flame_hp?: IntNullableFilter<"equips"> | number | null
    flame_mp?: IntNullableFilter<"equips"> | number | null
    flame_speed?: IntNullableFilter<"equips"> | number | null
    flame_jump?: IntNullableFilter<"equips"> | number | null
    flame_allStatR?: IntNullableFilter<"equips"> | number | null
    flame_bossDamageR?: IntNullableFilter<"equips"> | number | null
    flame_damageR?: IntNullableFilter<"equips"> | number | null
    flame_reduceReqLevel?: IntNullableFilter<"equips"> | number | null
  }, "itemid">

  export type equipsOrderByWithAggregationInput = {
    serialnumber?: SortOrderInput | SortOrder
    itemid?: SortOrder
    title?: SortOrderInput | SortOrder
    equippeddate?: SortOrderInput | SortOrder
    prevbonusexprate?: SortOrderInput | SortOrder
    options?: SortOrderInput | SortOrder
    sockets?: SortOrderInput | SortOrder
    tuc?: SortOrderInput | SortOrder
    cuc?: SortOrderInput | SortOrder
    istr?: SortOrderInput | SortOrder
    idex?: SortOrderInput | SortOrder
    iint?: SortOrderInput | SortOrder
    iluk?: SortOrderInput | SortOrder
    imaxhp?: SortOrderInput | SortOrder
    imaxhpr?: SortOrder
    imaxmp?: SortOrderInput | SortOrder
    imaxmpr?: SortOrder
    ipad?: SortOrderInput | SortOrder
    imad?: SortOrderInput | SortOrder
    ipdd?: SortOrderInput | SortOrder
    imdd?: SortOrderInput | SortOrder
    iacc?: SortOrderInput | SortOrder
    ieva?: SortOrderInput | SortOrder
    icraft?: SortOrderInput | SortOrder
    ispeed?: SortOrderInput | SortOrder
    ijump?: SortOrderInput | SortOrder
    arcaneid?: SortOrderInput | SortOrder
    attribute?: SortOrderInput | SortOrder
    leveluptype?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    exp?: SortOrderInput | SortOrder
    durability?: SortOrderInput | SortOrder
    iuc?: SortOrderInput | SortOrder
    ipvpdamage?: SortOrderInput | SortOrder
    ireducereq?: SortOrderInput | SortOrder
    specialattribute?: SortOrderInput | SortOrder
    durabilitymax?: SortOrderInput | SortOrder
    iincreq?: SortOrderInput | SortOrder
    growthenchant?: SortOrderInput | SortOrder
    psenchant?: SortOrderInput | SortOrder
    hyperupgrade?: SortOrderInput | SortOrder
    bdr?: SortOrderInput | SortOrder
    imdr?: SortOrderInput | SortOrder
    damr?: SortOrderInput | SortOrder
    statr?: SortOrderInput | SortOrder
    cuttable?: SortOrderInput | SortOrder
    exgradeoption?: SortOrderInput | SortOrder
    itemstate?: SortOrderInput | SortOrder
    grade?: SortOrderInput | SortOrder
    chuc?: SortOrderInput | SortOrder
    souloptionid?: SortOrderInput | SortOrder
    soulsocketid?: SortOrderInput | SortOrder
    souloption?: SortOrderInput | SortOrder
    soulitemid?: SortOrderInput | SortOrder
    rstr?: SortOrderInput | SortOrder
    rdex?: SortOrderInput | SortOrder
    rint?: SortOrderInput | SortOrder
    rluk?: SortOrderInput | SortOrder
    rlevel?: SortOrderInput | SortOrder
    rjob?: SortOrderInput | SortOrder
    rpop?: SortOrderInput | SortOrder
    specialgrade?: SortOrderInput | SortOrder
    fixedpotential?: SortOrderInput | SortOrder
    tradeblock?: SortOrderInput | SortOrder
    isonly?: SortOrderInput | SortOrder
    notsale?: SortOrderInput | SortOrder
    attackspeed?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    charmexp?: SortOrderInput | SortOrder
    setitemid?: SortOrderInput | SortOrder
    exitem?: SortOrderInput | SortOrder
    equiptradeblock?: SortOrderInput | SortOrder
    islot?: SortOrderInput | SortOrder
    vslot?: SortOrderInput | SortOrder
    fixedgrade?: SortOrderInput | SortOrder
    nopotential?: SortOrderInput | SortOrder
    bossreward?: SortOrderInput | SortOrder
    superioreqp?: SortOrderInput | SortOrder
    flameid?: SortOrderInput | SortOrder
    android?: SortOrderInput | SortOrder
    androidgrade?: SortOrderInput | SortOrder
    arcane_stat?: SortOrderInput | SortOrder
    arcane_exp?: SortOrderInput | SortOrder
    arcane_level?: SortOrderInput | SortOrder
    flame_str?: SortOrderInput | SortOrder
    flame_dex?: SortOrderInput | SortOrder
    flame_int?: SortOrderInput | SortOrder
    flame_luk?: SortOrderInput | SortOrder
    flame_pad?: SortOrderInput | SortOrder
    flame_mad?: SortOrderInput | SortOrder
    flame_pdd?: SortOrderInput | SortOrder
    flame_hp?: SortOrderInput | SortOrder
    flame_mp?: SortOrderInput | SortOrder
    flame_speed?: SortOrderInput | SortOrder
    flame_jump?: SortOrderInput | SortOrder
    flame_allStatR?: SortOrderInput | SortOrder
    flame_bossDamageR?: SortOrderInput | SortOrder
    flame_damageR?: SortOrderInput | SortOrder
    flame_reduceReqLevel?: SortOrderInput | SortOrder
    _count?: equipsCountOrderByAggregateInput
    _avg?: equipsAvgOrderByAggregateInput
    _max?: equipsMaxOrderByAggregateInput
    _min?: equipsMinOrderByAggregateInput
    _sum?: equipsSumOrderByAggregateInput
  }

  export type equipsScalarWhereWithAggregatesInput = {
    AND?: equipsScalarWhereWithAggregatesInput | equipsScalarWhereWithAggregatesInput[]
    OR?: equipsScalarWhereWithAggregatesInput[]
    NOT?: equipsScalarWhereWithAggregatesInput | equipsScalarWhereWithAggregatesInput[]
    serialnumber?: BigIntNullableWithAggregatesFilter<"equips"> | bigint | number | null
    itemid?: BigIntWithAggregatesFilter<"equips"> | bigint | number
    title?: StringNullableWithAggregatesFilter<"equips"> | string | null
    equippeddate?: DateTimeNullableWithAggregatesFilter<"equips"> | Date | string | null
    prevbonusexprate?: IntNullableWithAggregatesFilter<"equips"> | number | null
    options?: StringNullableWithAggregatesFilter<"equips"> | string | null
    sockets?: StringNullableWithAggregatesFilter<"equips"> | string | null
    tuc?: IntNullableWithAggregatesFilter<"equips"> | number | null
    cuc?: IntNullableWithAggregatesFilter<"equips"> | number | null
    istr?: IntNullableWithAggregatesFilter<"equips"> | number | null
    idex?: IntNullableWithAggregatesFilter<"equips"> | number | null
    iint?: IntNullableWithAggregatesFilter<"equips"> | number | null
    iluk?: IntNullableWithAggregatesFilter<"equips"> | number | null
    imaxhp?: IntNullableWithAggregatesFilter<"equips"> | number | null
    imaxhpr?: IntWithAggregatesFilter<"equips"> | number
    imaxmp?: IntNullableWithAggregatesFilter<"equips"> | number | null
    imaxmpr?: IntWithAggregatesFilter<"equips"> | number
    ipad?: IntNullableWithAggregatesFilter<"equips"> | number | null
    imad?: IntNullableWithAggregatesFilter<"equips"> | number | null
    ipdd?: IntNullableWithAggregatesFilter<"equips"> | number | null
    imdd?: IntNullableWithAggregatesFilter<"equips"> | number | null
    iacc?: IntNullableWithAggregatesFilter<"equips"> | number | null
    ieva?: IntNullableWithAggregatesFilter<"equips"> | number | null
    icraft?: IntNullableWithAggregatesFilter<"equips"> | number | null
    ispeed?: IntNullableWithAggregatesFilter<"equips"> | number | null
    ijump?: IntNullableWithAggregatesFilter<"equips"> | number | null
    arcaneid?: BigIntNullableWithAggregatesFilter<"equips"> | bigint | number | null
    attribute?: IntNullableWithAggregatesFilter<"equips"> | number | null
    leveluptype?: IntNullableWithAggregatesFilter<"equips"> | number | null
    level?: IntNullableWithAggregatesFilter<"equips"> | number | null
    exp?: IntNullableWithAggregatesFilter<"equips"> | number | null
    durability?: IntNullableWithAggregatesFilter<"equips"> | number | null
    iuc?: IntNullableWithAggregatesFilter<"equips"> | number | null
    ipvpdamage?: IntNullableWithAggregatesFilter<"equips"> | number | null
    ireducereq?: IntNullableWithAggregatesFilter<"equips"> | number | null
    specialattribute?: IntNullableWithAggregatesFilter<"equips"> | number | null
    durabilitymax?: IntNullableWithAggregatesFilter<"equips"> | number | null
    iincreq?: IntNullableWithAggregatesFilter<"equips"> | number | null
    growthenchant?: IntNullableWithAggregatesFilter<"equips"> | number | null
    psenchant?: IntNullableWithAggregatesFilter<"equips"> | number | null
    hyperupgrade?: IntNullableWithAggregatesFilter<"equips"> | number | null
    bdr?: IntNullableWithAggregatesFilter<"equips"> | number | null
    imdr?: IntNullableWithAggregatesFilter<"equips"> | number | null
    damr?: IntNullableWithAggregatesFilter<"equips"> | number | null
    statr?: IntNullableWithAggregatesFilter<"equips"> | number | null
    cuttable?: IntNullableWithAggregatesFilter<"equips"> | number | null
    exgradeoption?: BigIntNullableWithAggregatesFilter<"equips"> | bigint | number | null
    itemstate?: IntNullableWithAggregatesFilter<"equips"> | number | null
    grade?: IntNullableWithAggregatesFilter<"equips"> | number | null
    chuc?: IntNullableWithAggregatesFilter<"equips"> | number | null
    souloptionid?: IntNullableWithAggregatesFilter<"equips"> | number | null
    soulsocketid?: IntNullableWithAggregatesFilter<"equips"> | number | null
    souloption?: IntNullableWithAggregatesFilter<"equips"> | number | null
    soulitemid?: IntNullableWithAggregatesFilter<"equips"> | number | null
    rstr?: IntNullableWithAggregatesFilter<"equips"> | number | null
    rdex?: IntNullableWithAggregatesFilter<"equips"> | number | null
    rint?: IntNullableWithAggregatesFilter<"equips"> | number | null
    rluk?: IntNullableWithAggregatesFilter<"equips"> | number | null
    rlevel?: IntNullableWithAggregatesFilter<"equips"> | number | null
    rjob?: IntNullableWithAggregatesFilter<"equips"> | number | null
    rpop?: IntNullableWithAggregatesFilter<"equips"> | number | null
    specialgrade?: IntNullableWithAggregatesFilter<"equips"> | number | null
    fixedpotential?: BoolNullableWithAggregatesFilter<"equips"> | boolean | null
    tradeblock?: BoolNullableWithAggregatesFilter<"equips"> | boolean | null
    isonly?: BoolNullableWithAggregatesFilter<"equips"> | boolean | null
    notsale?: BoolNullableWithAggregatesFilter<"equips"> | boolean | null
    attackspeed?: IntNullableWithAggregatesFilter<"equips"> | number | null
    price?: IntNullableWithAggregatesFilter<"equips"> | number | null
    charmexp?: IntNullableWithAggregatesFilter<"equips"> | number | null
    setitemid?: IntNullableWithAggregatesFilter<"equips"> | number | null
    exitem?: BoolNullableWithAggregatesFilter<"equips"> | boolean | null
    equiptradeblock?: BoolNullableWithAggregatesFilter<"equips"> | boolean | null
    islot?: StringNullableWithAggregatesFilter<"equips"> | string | null
    vslot?: StringNullableWithAggregatesFilter<"equips"> | string | null
    fixedgrade?: IntNullableWithAggregatesFilter<"equips"> | number | null
    nopotential?: IntNullableWithAggregatesFilter<"equips"> | number | null
    bossreward?: IntNullableWithAggregatesFilter<"equips"> | number | null
    superioreqp?: IntNullableWithAggregatesFilter<"equips"> | number | null
    flameid?: BigIntNullableWithAggregatesFilter<"equips"> | bigint | number | null
    android?: IntNullableWithAggregatesFilter<"equips"> | number | null
    androidgrade?: IntNullableWithAggregatesFilter<"equips"> | number | null
    arcane_stat?: IntNullableWithAggregatesFilter<"equips"> | number | null
    arcane_exp?: IntNullableWithAggregatesFilter<"equips"> | number | null
    arcane_level?: IntNullableWithAggregatesFilter<"equips"> | number | null
    flame_str?: IntNullableWithAggregatesFilter<"equips"> | number | null
    flame_dex?: IntNullableWithAggregatesFilter<"equips"> | number | null
    flame_int?: IntNullableWithAggregatesFilter<"equips"> | number | null
    flame_luk?: IntNullableWithAggregatesFilter<"equips"> | number | null
    flame_pad?: IntNullableWithAggregatesFilter<"equips"> | number | null
    flame_mad?: IntNullableWithAggregatesFilter<"equips"> | number | null
    flame_pdd?: IntNullableWithAggregatesFilter<"equips"> | number | null
    flame_hp?: IntNullableWithAggregatesFilter<"equips"> | number | null
    flame_mp?: IntNullableWithAggregatesFilter<"equips"> | number | null
    flame_speed?: IntNullableWithAggregatesFilter<"equips"> | number | null
    flame_jump?: IntNullableWithAggregatesFilter<"equips"> | number | null
    flame_allStatR?: IntNullableWithAggregatesFilter<"equips"> | number | null
    flame_bossDamageR?: IntNullableWithAggregatesFilter<"equips"> | number | null
    flame_damageR?: IntNullableWithAggregatesFilter<"equips"> | number | null
    flame_reduceReqLevel?: IntNullableWithAggregatesFilter<"equips"> | number | null
  }

  export type eventnametagWhereInput = {
    AND?: eventnametagWhereInput | eventnametagWhereInput[]
    OR?: eventnametagWhereInput[]
    NOT?: eventnametagWhereInput | eventnametagWhereInput[]
    id?: IntFilter<"eventnametag"> | number
    charid?: IntFilter<"eventnametag"> | number
    activeRed?: IntFilter<"eventnametag"> | number
    activeBlue?: IntFilter<"eventnametag"> | number
    activeYellow?: IntFilter<"eventnametag"> | number
    activeGreen?: IntFilter<"eventnametag"> | number
    activePurple?: IntFilter<"eventnametag"> | number
    sRed?: StringFilter<"eventnametag"> | string
    sBlue?: StringFilter<"eventnametag"> | string
    sYellow?: StringFilter<"eventnametag"> | string
    sGreen?: StringFilter<"eventnametag"> | string
    sPurple?: StringFilter<"eventnametag"> | string
  }

  export type eventnametagOrderByWithRelationInput = {
    id?: SortOrder
    charid?: SortOrder
    activeRed?: SortOrder
    activeBlue?: SortOrder
    activeYellow?: SortOrder
    activeGreen?: SortOrder
    activePurple?: SortOrder
    sRed?: SortOrder
    sBlue?: SortOrder
    sYellow?: SortOrder
    sGreen?: SortOrder
    sPurple?: SortOrder
  }

  export type eventnametagWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: eventnametagWhereInput | eventnametagWhereInput[]
    OR?: eventnametagWhereInput[]
    NOT?: eventnametagWhereInput | eventnametagWhereInput[]
    charid?: IntFilter<"eventnametag"> | number
    activeRed?: IntFilter<"eventnametag"> | number
    activeBlue?: IntFilter<"eventnametag"> | number
    activeYellow?: IntFilter<"eventnametag"> | number
    activeGreen?: IntFilter<"eventnametag"> | number
    activePurple?: IntFilter<"eventnametag"> | number
    sRed?: StringFilter<"eventnametag"> | string
    sBlue?: StringFilter<"eventnametag"> | string
    sYellow?: StringFilter<"eventnametag"> | string
    sGreen?: StringFilter<"eventnametag"> | string
    sPurple?: StringFilter<"eventnametag"> | string
  }, "id">

  export type eventnametagOrderByWithAggregationInput = {
    id?: SortOrder
    charid?: SortOrder
    activeRed?: SortOrder
    activeBlue?: SortOrder
    activeYellow?: SortOrder
    activeGreen?: SortOrder
    activePurple?: SortOrder
    sRed?: SortOrder
    sBlue?: SortOrder
    sYellow?: SortOrder
    sGreen?: SortOrder
    sPurple?: SortOrder
    _count?: eventnametagCountOrderByAggregateInput
    _avg?: eventnametagAvgOrderByAggregateInput
    _max?: eventnametagMaxOrderByAggregateInput
    _min?: eventnametagMinOrderByAggregateInput
    _sum?: eventnametagSumOrderByAggregateInput
  }

  export type eventnametagScalarWhereWithAggregatesInput = {
    AND?: eventnametagScalarWhereWithAggregatesInput | eventnametagScalarWhereWithAggregatesInput[]
    OR?: eventnametagScalarWhereWithAggregatesInput[]
    NOT?: eventnametagScalarWhereWithAggregatesInput | eventnametagScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"eventnametag"> | number
    charid?: IntWithAggregatesFilter<"eventnametag"> | number
    activeRed?: IntWithAggregatesFilter<"eventnametag"> | number
    activeBlue?: IntWithAggregatesFilter<"eventnametag"> | number
    activeYellow?: IntWithAggregatesFilter<"eventnametag"> | number
    activeGreen?: IntWithAggregatesFilter<"eventnametag"> | number
    activePurple?: IntWithAggregatesFilter<"eventnametag"> | number
    sRed?: StringWithAggregatesFilter<"eventnametag"> | string
    sBlue?: StringWithAggregatesFilter<"eventnametag"> | string
    sYellow?: StringWithAggregatesFilter<"eventnametag"> | string
    sGreen?: StringWithAggregatesFilter<"eventnametag"> | string
    sPurple?: StringWithAggregatesFilter<"eventnametag"> | string
  }

  export type extendspWhereInput = {
    AND?: extendspWhereInput | extendspWhereInput[]
    OR?: extendspWhereInput[]
    NOT?: extendspWhereInput | extendspWhereInput[]
    id?: IntFilter<"extendsp"> | number
  }

  export type extendspOrderByWithRelationInput = {
    id?: SortOrder
  }

  export type extendspWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: extendspWhereInput | extendspWhereInput[]
    OR?: extendspWhereInput[]
    NOT?: extendspWhereInput | extendspWhereInput[]
  }, "id">

  export type extendspOrderByWithAggregationInput = {
    id?: SortOrder
    _count?: extendspCountOrderByAggregateInput
    _avg?: extendspAvgOrderByAggregateInput
    _max?: extendspMaxOrderByAggregateInput
    _min?: extendspMinOrderByAggregateInput
    _sum?: extendspSumOrderByAggregateInput
  }

  export type extendspScalarWhereWithAggregatesInput = {
    AND?: extendspScalarWhereWithAggregatesInput | extendspScalarWhereWithAggregatesInput[]
    OR?: extendspScalarWhereWithAggregatesInput[]
    NOT?: extendspScalarWhereWithAggregatesInput | extendspScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"extendsp"> | number
  }

  export type familiarsWhereInput = {
    AND?: familiarsWhereInput | familiarsWhereInput[]
    OR?: familiarsWhereInput[]
    NOT?: familiarsWhereInput | familiarsWhereInput[]
    id?: BigIntFilter<"familiars"> | bigint | number
    charid?: IntNullableFilter<"familiars"> | number | null
    idk1?: IntNullableFilter<"familiars"> | number | null
    familiarid?: IntNullableFilter<"familiars"> | number | null
    name?: StringNullableFilter<"familiars"> | string | null
    idk2?: BoolNullableFilter<"familiars"> | boolean | null
    idk3?: IntNullableFilter<"familiars"> | number | null
    fatigue?: IntNullableFilter<"familiars"> | number | null
    idk4?: BigIntNullableFilter<"familiars"> | bigint | number | null
    idk5?: BigIntNullableFilter<"familiars"> | bigint | number | null
    expiration?: DateTimeNullableFilter<"familiars"> | Date | string | null
    vitality?: IntNullableFilter<"familiars"> | number | null
  }

  export type familiarsOrderByWithRelationInput = {
    id?: SortOrder
    charid?: SortOrderInput | SortOrder
    idk1?: SortOrderInput | SortOrder
    familiarid?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    idk2?: SortOrderInput | SortOrder
    idk3?: SortOrderInput | SortOrder
    fatigue?: SortOrderInput | SortOrder
    idk4?: SortOrderInput | SortOrder
    idk5?: SortOrderInput | SortOrder
    expiration?: SortOrderInput | SortOrder
    vitality?: SortOrderInput | SortOrder
  }

  export type familiarsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: familiarsWhereInput | familiarsWhereInput[]
    OR?: familiarsWhereInput[]
    NOT?: familiarsWhereInput | familiarsWhereInput[]
    charid?: IntNullableFilter<"familiars"> | number | null
    idk1?: IntNullableFilter<"familiars"> | number | null
    familiarid?: IntNullableFilter<"familiars"> | number | null
    name?: StringNullableFilter<"familiars"> | string | null
    idk2?: BoolNullableFilter<"familiars"> | boolean | null
    idk3?: IntNullableFilter<"familiars"> | number | null
    fatigue?: IntNullableFilter<"familiars"> | number | null
    idk4?: BigIntNullableFilter<"familiars"> | bigint | number | null
    idk5?: BigIntNullableFilter<"familiars"> | bigint | number | null
    expiration?: DateTimeNullableFilter<"familiars"> | Date | string | null
    vitality?: IntNullableFilter<"familiars"> | number | null
  }, "id">

  export type familiarsOrderByWithAggregationInput = {
    id?: SortOrder
    charid?: SortOrderInput | SortOrder
    idk1?: SortOrderInput | SortOrder
    familiarid?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    idk2?: SortOrderInput | SortOrder
    idk3?: SortOrderInput | SortOrder
    fatigue?: SortOrderInput | SortOrder
    idk4?: SortOrderInput | SortOrder
    idk5?: SortOrderInput | SortOrder
    expiration?: SortOrderInput | SortOrder
    vitality?: SortOrderInput | SortOrder
    _count?: familiarsCountOrderByAggregateInput
    _avg?: familiarsAvgOrderByAggregateInput
    _max?: familiarsMaxOrderByAggregateInput
    _min?: familiarsMinOrderByAggregateInput
    _sum?: familiarsSumOrderByAggregateInput
  }

  export type familiarsScalarWhereWithAggregatesInput = {
    AND?: familiarsScalarWhereWithAggregatesInput | familiarsScalarWhereWithAggregatesInput[]
    OR?: familiarsScalarWhereWithAggregatesInput[]
    NOT?: familiarsScalarWhereWithAggregatesInput | familiarsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"familiars"> | bigint | number
    charid?: IntNullableWithAggregatesFilter<"familiars"> | number | null
    idk1?: IntNullableWithAggregatesFilter<"familiars"> | number | null
    familiarid?: IntNullableWithAggregatesFilter<"familiars"> | number | null
    name?: StringNullableWithAggregatesFilter<"familiars"> | string | null
    idk2?: BoolNullableWithAggregatesFilter<"familiars"> | boolean | null
    idk3?: IntNullableWithAggregatesFilter<"familiars"> | number | null
    fatigue?: IntNullableWithAggregatesFilter<"familiars"> | number | null
    idk4?: BigIntNullableWithAggregatesFilter<"familiars"> | bigint | number | null
    idk5?: BigIntNullableWithAggregatesFilter<"familiars"> | bigint | number | null
    expiration?: DateTimeNullableWithAggregatesFilter<"familiars"> | Date | string | null
    vitality?: IntNullableWithAggregatesFilter<"familiars"> | number | null
  }

  export type friendsWhereInput = {
    AND?: friendsWhereInput | friendsWhereInput[]
    OR?: friendsWhereInput[]
    NOT?: friendsWhereInput | friendsWhereInput[]
    id?: IntFilter<"friends"> | number
    ownerid?: IntNullableFilter<"friends"> | number | null
    owneraccid?: IntNullableFilter<"friends"> | number | null
    friendid?: IntNullableFilter<"friends"> | number | null
    friendaccountid?: IntNullableFilter<"friends"> | number | null
    name?: StringNullableFilter<"friends"> | string | null
    flag?: IntNullableFilter<"friends"> | number | null
    groupname?: StringNullableFilter<"friends"> | string | null
    mobile?: IntNullableFilter<"friends"> | number | null
    nickname?: StringNullableFilter<"friends"> | string | null
    memo?: StringNullableFilter<"friends"> | string | null
  }

  export type friendsOrderByWithRelationInput = {
    id?: SortOrder
    ownerid?: SortOrderInput | SortOrder
    owneraccid?: SortOrderInput | SortOrder
    friendid?: SortOrderInput | SortOrder
    friendaccountid?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    flag?: SortOrderInput | SortOrder
    groupname?: SortOrderInput | SortOrder
    mobile?: SortOrderInput | SortOrder
    nickname?: SortOrderInput | SortOrder
    memo?: SortOrderInput | SortOrder
  }

  export type friendsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: friendsWhereInput | friendsWhereInput[]
    OR?: friendsWhereInput[]
    NOT?: friendsWhereInput | friendsWhereInput[]
    ownerid?: IntNullableFilter<"friends"> | number | null
    owneraccid?: IntNullableFilter<"friends"> | number | null
    friendid?: IntNullableFilter<"friends"> | number | null
    friendaccountid?: IntNullableFilter<"friends"> | number | null
    name?: StringNullableFilter<"friends"> | string | null
    flag?: IntNullableFilter<"friends"> | number | null
    groupname?: StringNullableFilter<"friends"> | string | null
    mobile?: IntNullableFilter<"friends"> | number | null
    nickname?: StringNullableFilter<"friends"> | string | null
    memo?: StringNullableFilter<"friends"> | string | null
  }, "id">

  export type friendsOrderByWithAggregationInput = {
    id?: SortOrder
    ownerid?: SortOrderInput | SortOrder
    owneraccid?: SortOrderInput | SortOrder
    friendid?: SortOrderInput | SortOrder
    friendaccountid?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    flag?: SortOrderInput | SortOrder
    groupname?: SortOrderInput | SortOrder
    mobile?: SortOrderInput | SortOrder
    nickname?: SortOrderInput | SortOrder
    memo?: SortOrderInput | SortOrder
    _count?: friendsCountOrderByAggregateInput
    _avg?: friendsAvgOrderByAggregateInput
    _max?: friendsMaxOrderByAggregateInput
    _min?: friendsMinOrderByAggregateInput
    _sum?: friendsSumOrderByAggregateInput
  }

  export type friendsScalarWhereWithAggregatesInput = {
    AND?: friendsScalarWhereWithAggregatesInput | friendsScalarWhereWithAggregatesInput[]
    OR?: friendsScalarWhereWithAggregatesInput[]
    NOT?: friendsScalarWhereWithAggregatesInput | friendsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"friends"> | number
    ownerid?: IntNullableWithAggregatesFilter<"friends"> | number | null
    owneraccid?: IntNullableWithAggregatesFilter<"friends"> | number | null
    friendid?: IntNullableWithAggregatesFilter<"friends"> | number | null
    friendaccountid?: IntNullableWithAggregatesFilter<"friends"> | number | null
    name?: StringNullableWithAggregatesFilter<"friends"> | string | null
    flag?: IntNullableWithAggregatesFilter<"friends"> | number | null
    groupname?: StringNullableWithAggregatesFilter<"friends"> | string | null
    mobile?: IntNullableWithAggregatesFilter<"friends"> | number | null
    nickname?: StringNullableWithAggregatesFilter<"friends"> | string | null
    memo?: StringNullableWithAggregatesFilter<"friends"> | string | null
  }

  export type funckeymapWhereInput = {
    AND?: funckeymapWhereInput | funckeymapWhereInput[]
    OR?: funckeymapWhereInput[]
    NOT?: funckeymapWhereInput | funckeymapWhereInput[]
    id?: IntFilter<"funckeymap"> | number
    charId?: IntNullableFilter<"funckeymap"> | number | null
    ord?: IntNullableFilter<"funckeymap"> | number | null
  }

  export type funckeymapOrderByWithRelationInput = {
    id?: SortOrder
    charId?: SortOrderInput | SortOrder
    ord?: SortOrderInput | SortOrder
  }

  export type funckeymapWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: funckeymapWhereInput | funckeymapWhereInput[]
    OR?: funckeymapWhereInput[]
    NOT?: funckeymapWhereInput | funckeymapWhereInput[]
    charId?: IntNullableFilter<"funckeymap"> | number | null
    ord?: IntNullableFilter<"funckeymap"> | number | null
  }, "id">

  export type funckeymapOrderByWithAggregationInput = {
    id?: SortOrder
    charId?: SortOrderInput | SortOrder
    ord?: SortOrderInput | SortOrder
    _count?: funckeymapCountOrderByAggregateInput
    _avg?: funckeymapAvgOrderByAggregateInput
    _max?: funckeymapMaxOrderByAggregateInput
    _min?: funckeymapMinOrderByAggregateInput
    _sum?: funckeymapSumOrderByAggregateInput
  }

  export type funckeymapScalarWhereWithAggregatesInput = {
    AND?: funckeymapScalarWhereWithAggregatesInput | funckeymapScalarWhereWithAggregatesInput[]
    OR?: funckeymapScalarWhereWithAggregatesInput[]
    NOT?: funckeymapScalarWhereWithAggregatesInput | funckeymapScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"funckeymap"> | number
    charId?: IntNullableWithAggregatesFilter<"funckeymap"> | number | null
    ord?: IntNullableWithAggregatesFilter<"funckeymap"> | number | null
  }

  export type gradenamesWhereInput = {
    AND?: gradenamesWhereInput | gradenamesWhereInput[]
    OR?: gradenamesWhereInput[]
    NOT?: gradenamesWhereInput | gradenamesWhereInput[]
    id?: IntFilter<"gradenames"> | number
    gradename?: StringNullableFilter<"gradenames"> | string | null
    guildid?: IntNullableFilter<"gradenames"> | number | null
  }

  export type gradenamesOrderByWithRelationInput = {
    id?: SortOrder
    gradename?: SortOrderInput | SortOrder
    guildid?: SortOrderInput | SortOrder
  }

  export type gradenamesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: gradenamesWhereInput | gradenamesWhereInput[]
    OR?: gradenamesWhereInput[]
    NOT?: gradenamesWhereInput | gradenamesWhereInput[]
    gradename?: StringNullableFilter<"gradenames"> | string | null
    guildid?: IntNullableFilter<"gradenames"> | number | null
  }, "id">

  export type gradenamesOrderByWithAggregationInput = {
    id?: SortOrder
    gradename?: SortOrderInput | SortOrder
    guildid?: SortOrderInput | SortOrder
    _count?: gradenamesCountOrderByAggregateInput
    _avg?: gradenamesAvgOrderByAggregateInput
    _max?: gradenamesMaxOrderByAggregateInput
    _min?: gradenamesMinOrderByAggregateInput
    _sum?: gradenamesSumOrderByAggregateInput
  }

  export type gradenamesScalarWhereWithAggregatesInput = {
    AND?: gradenamesScalarWhereWithAggregatesInput | gradenamesScalarWhereWithAggregatesInput[]
    OR?: gradenamesScalarWhereWithAggregatesInput[]
    NOT?: gradenamesScalarWhereWithAggregatesInput | gradenamesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"gradenames"> | number
    gradename?: StringNullableWithAggregatesFilter<"gradenames"> | string | null
    guildid?: IntNullableWithAggregatesFilter<"gradenames"> | number | null
  }

  export type guildmembersWhereInput = {
    AND?: guildmembersWhereInput | guildmembersWhereInput[]
    OR?: guildmembersWhereInput[]
    NOT?: guildmembersWhereInput | guildmembersWhereInput[]
    id?: IntFilter<"guildmembers"> | number
    charid?: IntNullableFilter<"guildmembers"> | number | null
    guildid?: IntNullableFilter<"guildmembers"> | number | null
    grade?: IntNullableFilter<"guildmembers"> | number | null
    alliancegrade?: IntNullableFilter<"guildmembers"> | number | null
    commitment?: IntNullableFilter<"guildmembers"> | number | null
    daycommitment?: IntNullableFilter<"guildmembers"> | number | null
    igp?: IntNullableFilter<"guildmembers"> | number | null
    commitmentinctime?: DateTimeNullableFilter<"guildmembers"> | Date | string | null
    name?: StringNullableFilter<"guildmembers"> | string | null
    job?: IntNullableFilter<"guildmembers"> | number | null
    level?: IntNullableFilter<"guildmembers"> | number | null
    loggedin?: BoolNullableFilter<"guildmembers"> | boolean | null
  }

  export type guildmembersOrderByWithRelationInput = {
    id?: SortOrder
    charid?: SortOrderInput | SortOrder
    guildid?: SortOrderInput | SortOrder
    grade?: SortOrderInput | SortOrder
    alliancegrade?: SortOrderInput | SortOrder
    commitment?: SortOrderInput | SortOrder
    daycommitment?: SortOrderInput | SortOrder
    igp?: SortOrderInput | SortOrder
    commitmentinctime?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    job?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    loggedin?: SortOrderInput | SortOrder
  }

  export type guildmembersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: guildmembersWhereInput | guildmembersWhereInput[]
    OR?: guildmembersWhereInput[]
    NOT?: guildmembersWhereInput | guildmembersWhereInput[]
    charid?: IntNullableFilter<"guildmembers"> | number | null
    guildid?: IntNullableFilter<"guildmembers"> | number | null
    grade?: IntNullableFilter<"guildmembers"> | number | null
    alliancegrade?: IntNullableFilter<"guildmembers"> | number | null
    commitment?: IntNullableFilter<"guildmembers"> | number | null
    daycommitment?: IntNullableFilter<"guildmembers"> | number | null
    igp?: IntNullableFilter<"guildmembers"> | number | null
    commitmentinctime?: DateTimeNullableFilter<"guildmembers"> | Date | string | null
    name?: StringNullableFilter<"guildmembers"> | string | null
    job?: IntNullableFilter<"guildmembers"> | number | null
    level?: IntNullableFilter<"guildmembers"> | number | null
    loggedin?: BoolNullableFilter<"guildmembers"> | boolean | null
  }, "id">

  export type guildmembersOrderByWithAggregationInput = {
    id?: SortOrder
    charid?: SortOrderInput | SortOrder
    guildid?: SortOrderInput | SortOrder
    grade?: SortOrderInput | SortOrder
    alliancegrade?: SortOrderInput | SortOrder
    commitment?: SortOrderInput | SortOrder
    daycommitment?: SortOrderInput | SortOrder
    igp?: SortOrderInput | SortOrder
    commitmentinctime?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    job?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    loggedin?: SortOrderInput | SortOrder
    _count?: guildmembersCountOrderByAggregateInput
    _avg?: guildmembersAvgOrderByAggregateInput
    _max?: guildmembersMaxOrderByAggregateInput
    _min?: guildmembersMinOrderByAggregateInput
    _sum?: guildmembersSumOrderByAggregateInput
  }

  export type guildmembersScalarWhereWithAggregatesInput = {
    AND?: guildmembersScalarWhereWithAggregatesInput | guildmembersScalarWhereWithAggregatesInput[]
    OR?: guildmembersScalarWhereWithAggregatesInput[]
    NOT?: guildmembersScalarWhereWithAggregatesInput | guildmembersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"guildmembers"> | number
    charid?: IntNullableWithAggregatesFilter<"guildmembers"> | number | null
    guildid?: IntNullableWithAggregatesFilter<"guildmembers"> | number | null
    grade?: IntNullableWithAggregatesFilter<"guildmembers"> | number | null
    alliancegrade?: IntNullableWithAggregatesFilter<"guildmembers"> | number | null
    commitment?: IntNullableWithAggregatesFilter<"guildmembers"> | number | null
    daycommitment?: IntNullableWithAggregatesFilter<"guildmembers"> | number | null
    igp?: IntNullableWithAggregatesFilter<"guildmembers"> | number | null
    commitmentinctime?: DateTimeNullableWithAggregatesFilter<"guildmembers"> | Date | string | null
    name?: StringNullableWithAggregatesFilter<"guildmembers"> | string | null
    job?: IntNullableWithAggregatesFilter<"guildmembers"> | number | null
    level?: IntNullableWithAggregatesFilter<"guildmembers"> | number | null
    loggedin?: BoolNullableWithAggregatesFilter<"guildmembers"> | boolean | null
  }

  export type guildrequestorsWhereInput = {
    AND?: guildrequestorsWhereInput | guildrequestorsWhereInput[]
    OR?: guildrequestorsWhereInput[]
    NOT?: guildrequestorsWhereInput | guildrequestorsWhereInput[]
    id?: IntFilter<"guildrequestors"> | number
    requestors_id?: IntNullableFilter<"guildrequestors"> | number | null
    charid?: IntNullableFilter<"guildrequestors"> | number | null
    guildid?: IntNullableFilter<"guildrequestors"> | number | null
    name?: StringNullableFilter<"guildrequestors"> | string | null
    job?: IntNullableFilter<"guildrequestors"> | number | null
    level?: IntNullableFilter<"guildrequestors"> | number | null
    loggedin?: BoolNullableFilter<"guildrequestors"> | boolean | null
  }

  export type guildrequestorsOrderByWithRelationInput = {
    id?: SortOrder
    requestors_id?: SortOrderInput | SortOrder
    charid?: SortOrderInput | SortOrder
    guildid?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    job?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    loggedin?: SortOrderInput | SortOrder
  }

  export type guildrequestorsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: guildrequestorsWhereInput | guildrequestorsWhereInput[]
    OR?: guildrequestorsWhereInput[]
    NOT?: guildrequestorsWhereInput | guildrequestorsWhereInput[]
    requestors_id?: IntNullableFilter<"guildrequestors"> | number | null
    charid?: IntNullableFilter<"guildrequestors"> | number | null
    guildid?: IntNullableFilter<"guildrequestors"> | number | null
    name?: StringNullableFilter<"guildrequestors"> | string | null
    job?: IntNullableFilter<"guildrequestors"> | number | null
    level?: IntNullableFilter<"guildrequestors"> | number | null
    loggedin?: BoolNullableFilter<"guildrequestors"> | boolean | null
  }, "id">

  export type guildrequestorsOrderByWithAggregationInput = {
    id?: SortOrder
    requestors_id?: SortOrderInput | SortOrder
    charid?: SortOrderInput | SortOrder
    guildid?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    job?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    loggedin?: SortOrderInput | SortOrder
    _count?: guildrequestorsCountOrderByAggregateInput
    _avg?: guildrequestorsAvgOrderByAggregateInput
    _max?: guildrequestorsMaxOrderByAggregateInput
    _min?: guildrequestorsMinOrderByAggregateInput
    _sum?: guildrequestorsSumOrderByAggregateInput
  }

  export type guildrequestorsScalarWhereWithAggregatesInput = {
    AND?: guildrequestorsScalarWhereWithAggregatesInput | guildrequestorsScalarWhereWithAggregatesInput[]
    OR?: guildrequestorsScalarWhereWithAggregatesInput[]
    NOT?: guildrequestorsScalarWhereWithAggregatesInput | guildrequestorsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"guildrequestors"> | number
    requestors_id?: IntNullableWithAggregatesFilter<"guildrequestors"> | number | null
    charid?: IntNullableWithAggregatesFilter<"guildrequestors"> | number | null
    guildid?: IntNullableWithAggregatesFilter<"guildrequestors"> | number | null
    name?: StringNullableWithAggregatesFilter<"guildrequestors"> | string | null
    job?: IntNullableWithAggregatesFilter<"guildrequestors"> | number | null
    level?: IntNullableWithAggregatesFilter<"guildrequestors"> | number | null
    loggedin?: BoolNullableWithAggregatesFilter<"guildrequestors"> | boolean | null
  }

  export type guildsWhereInput = {
    AND?: guildsWhereInput | guildsWhereInput[]
    OR?: guildsWhereInput[]
    NOT?: guildsWhereInput | guildsWhereInput[]
    id?: IntFilter<"guilds"> | number
    name?: StringNullableFilter<"guilds"> | string | null
    leaderid?: IntNullableFilter<"guilds"> | number | null
    worldid?: IntNullableFilter<"guilds"> | number | null
    markbg?: IntNullableFilter<"guilds"> | number | null
    markbgcolor?: IntNullableFilter<"guilds"> | number | null
    mark?: IntNullableFilter<"guilds"> | number | null
    markcolor?: IntNullableFilter<"guilds"> | number | null
    maxmembers?: IntNullableFilter<"guilds"> | number | null
    notice?: StringNullableFilter<"guilds"> | string | null
    points?: IntNullableFilter<"guilds"> | number | null
    seasonpoints?: IntNullableFilter<"guilds"> | number | null
    allianceid?: IntNullableFilter<"guilds"> | number | null
    level?: IntNullableFilter<"guilds"> | number | null
    guildrank?: IntNullableFilter<"guilds"> | number | null
    ggp?: IntNullableFilter<"guilds"> | number | null
    appliable?: BoolNullableFilter<"guilds"> | boolean | null
    joinsetting?: IntNullableFilter<"guilds"> | number | null
    reqlevel?: IntNullableFilter<"guilds"> | number | null
    bbsNotice?: IntNullableFilter<"guilds"> | number | null
    battleSp?: IntNullableFilter<"guilds"> | number | null
    fk_allianceid?: IntNullableFilter<"guilds"> | number | null
  }

  export type guildsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    leaderid?: SortOrderInput | SortOrder
    worldid?: SortOrderInput | SortOrder
    markbg?: SortOrderInput | SortOrder
    markbgcolor?: SortOrderInput | SortOrder
    mark?: SortOrderInput | SortOrder
    markcolor?: SortOrderInput | SortOrder
    maxmembers?: SortOrderInput | SortOrder
    notice?: SortOrderInput | SortOrder
    points?: SortOrderInput | SortOrder
    seasonpoints?: SortOrderInput | SortOrder
    allianceid?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    guildrank?: SortOrderInput | SortOrder
    ggp?: SortOrderInput | SortOrder
    appliable?: SortOrderInput | SortOrder
    joinsetting?: SortOrderInput | SortOrder
    reqlevel?: SortOrderInput | SortOrder
    bbsNotice?: SortOrderInput | SortOrder
    battleSp?: SortOrderInput | SortOrder
    fk_allianceid?: SortOrderInput | SortOrder
  }

  export type guildsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: guildsWhereInput | guildsWhereInput[]
    OR?: guildsWhereInput[]
    NOT?: guildsWhereInput | guildsWhereInput[]
    name?: StringNullableFilter<"guilds"> | string | null
    leaderid?: IntNullableFilter<"guilds"> | number | null
    worldid?: IntNullableFilter<"guilds"> | number | null
    markbg?: IntNullableFilter<"guilds"> | number | null
    markbgcolor?: IntNullableFilter<"guilds"> | number | null
    mark?: IntNullableFilter<"guilds"> | number | null
    markcolor?: IntNullableFilter<"guilds"> | number | null
    maxmembers?: IntNullableFilter<"guilds"> | number | null
    notice?: StringNullableFilter<"guilds"> | string | null
    points?: IntNullableFilter<"guilds"> | number | null
    seasonpoints?: IntNullableFilter<"guilds"> | number | null
    allianceid?: IntNullableFilter<"guilds"> | number | null
    level?: IntNullableFilter<"guilds"> | number | null
    guildrank?: IntNullableFilter<"guilds"> | number | null
    ggp?: IntNullableFilter<"guilds"> | number | null
    appliable?: BoolNullableFilter<"guilds"> | boolean | null
    joinsetting?: IntNullableFilter<"guilds"> | number | null
    reqlevel?: IntNullableFilter<"guilds"> | number | null
    bbsNotice?: IntNullableFilter<"guilds"> | number | null
    battleSp?: IntNullableFilter<"guilds"> | number | null
    fk_allianceid?: IntNullableFilter<"guilds"> | number | null
  }, "id">

  export type guildsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    leaderid?: SortOrderInput | SortOrder
    worldid?: SortOrderInput | SortOrder
    markbg?: SortOrderInput | SortOrder
    markbgcolor?: SortOrderInput | SortOrder
    mark?: SortOrderInput | SortOrder
    markcolor?: SortOrderInput | SortOrder
    maxmembers?: SortOrderInput | SortOrder
    notice?: SortOrderInput | SortOrder
    points?: SortOrderInput | SortOrder
    seasonpoints?: SortOrderInput | SortOrder
    allianceid?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    guildrank?: SortOrderInput | SortOrder
    ggp?: SortOrderInput | SortOrder
    appliable?: SortOrderInput | SortOrder
    joinsetting?: SortOrderInput | SortOrder
    reqlevel?: SortOrderInput | SortOrder
    bbsNotice?: SortOrderInput | SortOrder
    battleSp?: SortOrderInput | SortOrder
    fk_allianceid?: SortOrderInput | SortOrder
    _count?: guildsCountOrderByAggregateInput
    _avg?: guildsAvgOrderByAggregateInput
    _max?: guildsMaxOrderByAggregateInput
    _min?: guildsMinOrderByAggregateInput
    _sum?: guildsSumOrderByAggregateInput
  }

  export type guildsScalarWhereWithAggregatesInput = {
    AND?: guildsScalarWhereWithAggregatesInput | guildsScalarWhereWithAggregatesInput[]
    OR?: guildsScalarWhereWithAggregatesInput[]
    NOT?: guildsScalarWhereWithAggregatesInput | guildsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"guilds"> | number
    name?: StringNullableWithAggregatesFilter<"guilds"> | string | null
    leaderid?: IntNullableWithAggregatesFilter<"guilds"> | number | null
    worldid?: IntNullableWithAggregatesFilter<"guilds"> | number | null
    markbg?: IntNullableWithAggregatesFilter<"guilds"> | number | null
    markbgcolor?: IntNullableWithAggregatesFilter<"guilds"> | number | null
    mark?: IntNullableWithAggregatesFilter<"guilds"> | number | null
    markcolor?: IntNullableWithAggregatesFilter<"guilds"> | number | null
    maxmembers?: IntNullableWithAggregatesFilter<"guilds"> | number | null
    notice?: StringNullableWithAggregatesFilter<"guilds"> | string | null
    points?: IntNullableWithAggregatesFilter<"guilds"> | number | null
    seasonpoints?: IntNullableWithAggregatesFilter<"guilds"> | number | null
    allianceid?: IntNullableWithAggregatesFilter<"guilds"> | number | null
    level?: IntNullableWithAggregatesFilter<"guilds"> | number | null
    guildrank?: IntNullableWithAggregatesFilter<"guilds"> | number | null
    ggp?: IntNullableWithAggregatesFilter<"guilds"> | number | null
    appliable?: BoolNullableWithAggregatesFilter<"guilds"> | boolean | null
    joinsetting?: IntNullableWithAggregatesFilter<"guilds"> | number | null
    reqlevel?: IntNullableWithAggregatesFilter<"guilds"> | number | null
    bbsNotice?: IntNullableWithAggregatesFilter<"guilds"> | number | null
    battleSp?: IntNullableWithAggregatesFilter<"guilds"> | number | null
    fk_allianceid?: IntNullableWithAggregatesFilter<"guilds"> | number | null
  }

  export type guildskillWhereInput = {
    AND?: guildskillWhereInput | guildskillWhereInput[]
    OR?: guildskillWhereInput[]
    NOT?: guildskillWhereInput | guildskillWhereInput[]
    id?: IntFilter<"guildskill"> | number
    skillid?: IntNullableFilter<"guildskill"> | number | null
    level?: IntNullableFilter<"guildskill"> | number | null
    expiredate?: DateTimeNullableFilter<"guildskill"> | Date | string | null
    buycharactername?: StringNullableFilter<"guildskill"> | string | null
    extendcharactername?: StringNullableFilter<"guildskill"> | string | null
  }

  export type guildskillOrderByWithRelationInput = {
    id?: SortOrder
    skillid?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    expiredate?: SortOrderInput | SortOrder
    buycharactername?: SortOrderInput | SortOrder
    extendcharactername?: SortOrderInput | SortOrder
  }

  export type guildskillWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: guildskillWhereInput | guildskillWhereInput[]
    OR?: guildskillWhereInput[]
    NOT?: guildskillWhereInput | guildskillWhereInput[]
    skillid?: IntNullableFilter<"guildskill"> | number | null
    level?: IntNullableFilter<"guildskill"> | number | null
    expiredate?: DateTimeNullableFilter<"guildskill"> | Date | string | null
    buycharactername?: StringNullableFilter<"guildskill"> | string | null
    extendcharactername?: StringNullableFilter<"guildskill"> | string | null
  }, "id">

  export type guildskillOrderByWithAggregationInput = {
    id?: SortOrder
    skillid?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    expiredate?: SortOrderInput | SortOrder
    buycharactername?: SortOrderInput | SortOrder
    extendcharactername?: SortOrderInput | SortOrder
    _count?: guildskillCountOrderByAggregateInput
    _avg?: guildskillAvgOrderByAggregateInput
    _max?: guildskillMaxOrderByAggregateInput
    _min?: guildskillMinOrderByAggregateInput
    _sum?: guildskillSumOrderByAggregateInput
  }

  export type guildskillScalarWhereWithAggregatesInput = {
    AND?: guildskillScalarWhereWithAggregatesInput | guildskillScalarWhereWithAggregatesInput[]
    OR?: guildskillScalarWhereWithAggregatesInput[]
    NOT?: guildskillScalarWhereWithAggregatesInput | guildskillScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"guildskill"> | number
    skillid?: IntNullableWithAggregatesFilter<"guildskill"> | number | null
    level?: IntNullableWithAggregatesFilter<"guildskill"> | number | null
    expiredate?: DateTimeNullableWithAggregatesFilter<"guildskill"> | Date | string | null
    buycharactername?: StringNullableWithAggregatesFilter<"guildskill"> | string | null
    extendcharactername?: StringNullableWithAggregatesFilter<"guildskill"> | string | null
  }

  export type guildskillsWhereInput = {
    AND?: guildskillsWhereInput | guildskillsWhereInput[]
    OR?: guildskillsWhereInput[]
    NOT?: guildskillsWhereInput | guildskillsWhereInput[]
    guildskill_id?: IntFilter<"guildskills"> | number
    skills_id?: IntNullableFilter<"guildskills"> | number | null
    guild_id?: IntNullableFilter<"guildskills"> | number | null
    skillid?: IntNullableFilter<"guildskills"> | number | null
    fk_guildskillid?: IntNullableFilter<"guildskills"> | number | null
  }

  export type guildskillsOrderByWithRelationInput = {
    guildskill_id?: SortOrder
    skills_id?: SortOrderInput | SortOrder
    guild_id?: SortOrderInput | SortOrder
    skillid?: SortOrderInput | SortOrder
    fk_guildskillid?: SortOrderInput | SortOrder
  }

  export type guildskillsWhereUniqueInput = Prisma.AtLeast<{
    guildskill_id?: number
    AND?: guildskillsWhereInput | guildskillsWhereInput[]
    OR?: guildskillsWhereInput[]
    NOT?: guildskillsWhereInput | guildskillsWhereInput[]
    skills_id?: IntNullableFilter<"guildskills"> | number | null
    guild_id?: IntNullableFilter<"guildskills"> | number | null
    skillid?: IntNullableFilter<"guildskills"> | number | null
    fk_guildskillid?: IntNullableFilter<"guildskills"> | number | null
  }, "guildskill_id">

  export type guildskillsOrderByWithAggregationInput = {
    guildskill_id?: SortOrder
    skills_id?: SortOrderInput | SortOrder
    guild_id?: SortOrderInput | SortOrder
    skillid?: SortOrderInput | SortOrder
    fk_guildskillid?: SortOrderInput | SortOrder
    _count?: guildskillsCountOrderByAggregateInput
    _avg?: guildskillsAvgOrderByAggregateInput
    _max?: guildskillsMaxOrderByAggregateInput
    _min?: guildskillsMinOrderByAggregateInput
    _sum?: guildskillsSumOrderByAggregateInput
  }

  export type guildskillsScalarWhereWithAggregatesInput = {
    AND?: guildskillsScalarWhereWithAggregatesInput | guildskillsScalarWhereWithAggregatesInput[]
    OR?: guildskillsScalarWhereWithAggregatesInput[]
    NOT?: guildskillsScalarWhereWithAggregatesInput | guildskillsScalarWhereWithAggregatesInput[]
    guildskill_id?: IntWithAggregatesFilter<"guildskills"> | number
    skills_id?: IntNullableWithAggregatesFilter<"guildskills"> | number | null
    guild_id?: IntNullableWithAggregatesFilter<"guildskills"> | number | null
    skillid?: IntNullableWithAggregatesFilter<"guildskills"> | number | null
    fk_guildskillid?: IntNullableWithAggregatesFilter<"guildskills"> | number | null
  }

  export type hairequipsWhereInput = {
    AND?: hairequipsWhereInput | hairequipsWhereInput[]
    OR?: hairequipsWhereInput[]
    NOT?: hairequipsWhereInput | hairequipsWhereInput[]
    id?: IntFilter<"hairequips"> | number
    alid?: IntNullableFilter<"hairequips"> | number | null
    equipid?: IntNullableFilter<"hairequips"> | number | null
  }

  export type hairequipsOrderByWithRelationInput = {
    id?: SortOrder
    alid?: SortOrderInput | SortOrder
    equipid?: SortOrderInput | SortOrder
  }

  export type hairequipsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: hairequipsWhereInput | hairequipsWhereInput[]
    OR?: hairequipsWhereInput[]
    NOT?: hairequipsWhereInput | hairequipsWhereInput[]
    alid?: IntNullableFilter<"hairequips"> | number | null
    equipid?: IntNullableFilter<"hairequips"> | number | null
  }, "id">

  export type hairequipsOrderByWithAggregationInput = {
    id?: SortOrder
    alid?: SortOrderInput | SortOrder
    equipid?: SortOrderInput | SortOrder
    _count?: hairequipsCountOrderByAggregateInput
    _avg?: hairequipsAvgOrderByAggregateInput
    _max?: hairequipsMaxOrderByAggregateInput
    _min?: hairequipsMinOrderByAggregateInput
    _sum?: hairequipsSumOrderByAggregateInput
  }

  export type hairequipsScalarWhereWithAggregatesInput = {
    AND?: hairequipsScalarWhereWithAggregatesInput | hairequipsScalarWhereWithAggregatesInput[]
    OR?: hairequipsScalarWhereWithAggregatesInput[]
    NOT?: hairequipsScalarWhereWithAggregatesInput | hairequipsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"hairequips"> | number
    alid?: IntNullableWithAggregatesFilter<"hairequips"> | number | null
    equipid?: IntNullableWithAggregatesFilter<"hairequips"> | number | null
  }

  export type hyperrockfieldsWhereInput = {
    AND?: hyperrockfieldsWhereInput | hyperrockfieldsWhereInput[]
    OR?: hyperrockfieldsWhereInput[]
    NOT?: hyperrockfieldsWhereInput | hyperrockfieldsWhereInput[]
    id?: BigIntFilter<"hyperrockfields"> | bigint | number
    charid?: IntNullableFilter<"hyperrockfields"> | number | null
    ord?: IntNullableFilter<"hyperrockfields"> | number | null
    fieldid?: IntNullableFilter<"hyperrockfields"> | number | null
  }

  export type hyperrockfieldsOrderByWithRelationInput = {
    id?: SortOrder
    charid?: SortOrderInput | SortOrder
    ord?: SortOrderInput | SortOrder
    fieldid?: SortOrderInput | SortOrder
  }

  export type hyperrockfieldsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: hyperrockfieldsWhereInput | hyperrockfieldsWhereInput[]
    OR?: hyperrockfieldsWhereInput[]
    NOT?: hyperrockfieldsWhereInput | hyperrockfieldsWhereInput[]
    charid?: IntNullableFilter<"hyperrockfields"> | number | null
    ord?: IntNullableFilter<"hyperrockfields"> | number | null
    fieldid?: IntNullableFilter<"hyperrockfields"> | number | null
  }, "id">

  export type hyperrockfieldsOrderByWithAggregationInput = {
    id?: SortOrder
    charid?: SortOrderInput | SortOrder
    ord?: SortOrderInput | SortOrder
    fieldid?: SortOrderInput | SortOrder
    _count?: hyperrockfieldsCountOrderByAggregateInput
    _avg?: hyperrockfieldsAvgOrderByAggregateInput
    _max?: hyperrockfieldsMaxOrderByAggregateInput
    _min?: hyperrockfieldsMinOrderByAggregateInput
    _sum?: hyperrockfieldsSumOrderByAggregateInput
  }

  export type hyperrockfieldsScalarWhereWithAggregatesInput = {
    AND?: hyperrockfieldsScalarWhereWithAggregatesInput | hyperrockfieldsScalarWhereWithAggregatesInput[]
    OR?: hyperrockfieldsScalarWhereWithAggregatesInput[]
    NOT?: hyperrockfieldsScalarWhereWithAggregatesInput | hyperrockfieldsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"hyperrockfields"> | bigint | number
    charid?: IntNullableWithAggregatesFilter<"hyperrockfields"> | number | null
    ord?: IntNullableWithAggregatesFilter<"hyperrockfields"> | number | null
    fieldid?: IntNullableWithAggregatesFilter<"hyperrockfields"> | number | null
  }

  export type inventoriesWhereInput = {
    AND?: inventoriesWhereInput | inventoriesWhereInput[]
    OR?: inventoriesWhereInput[]
    NOT?: inventoriesWhereInput | inventoriesWhereInput[]
    id?: IntFilter<"inventories"> | number
    type?: IntNullableFilter<"inventories"> | number | null
    slots?: IntNullableFilter<"inventories"> | number | null
  }

  export type inventoriesOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrderInput | SortOrder
    slots?: SortOrderInput | SortOrder
  }

  export type inventoriesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: inventoriesWhereInput | inventoriesWhereInput[]
    OR?: inventoriesWhereInput[]
    NOT?: inventoriesWhereInput | inventoriesWhereInput[]
    type?: IntNullableFilter<"inventories"> | number | null
    slots?: IntNullableFilter<"inventories"> | number | null
  }, "id">

  export type inventoriesOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrderInput | SortOrder
    slots?: SortOrderInput | SortOrder
    _count?: inventoriesCountOrderByAggregateInput
    _avg?: inventoriesAvgOrderByAggregateInput
    _max?: inventoriesMaxOrderByAggregateInput
    _min?: inventoriesMinOrderByAggregateInput
    _sum?: inventoriesSumOrderByAggregateInput
  }

  export type inventoriesScalarWhereWithAggregatesInput = {
    AND?: inventoriesScalarWhereWithAggregatesInput | inventoriesScalarWhereWithAggregatesInput[]
    OR?: inventoriesScalarWhereWithAggregatesInput[]
    NOT?: inventoriesScalarWhereWithAggregatesInput | inventoriesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"inventories"> | number
    type?: IntNullableWithAggregatesFilter<"inventories"> | number | null
    slots?: IntNullableWithAggregatesFilter<"inventories"> | number | null
  }

  export type itemsWhereInput = {
    AND?: itemsWhereInput | itemsWhereInput[]
    OR?: itemsWhereInput[]
    NOT?: itemsWhereInput | itemsWhereInput[]
    id?: BigIntFilter<"items"> | bigint | number
    inventoryid?: IntNullableFilter<"items"> | number | null
    trunkid?: IntNullableFilter<"items"> | number | null
    auctionHouseStatus?: BoolNullableFilter<"items"> | boolean | null
    itemid?: IntNullableFilter<"items"> | number | null
    bagindex?: IntNullableFilter<"items"> | number | null
    cashitemserialnumber?: BigIntNullableFilter<"items"> | bigint | number | null
    dateexpire?: DateTimeNullableFilter<"items"> | Date | string | null
    invtype?: IntNullableFilter<"items"> | number | null
    type?: IntNullableFilter<"items"> | number | null
    iscash?: BoolNullableFilter<"items"> | boolean | null
    quantity?: IntNullableFilter<"items"> | number | null
    expireonlogout?: BoolNullableFilter<"items"> | boolean | null
    owner?: StringNullableFilter<"items"> | string | null
    obtainedonce?: BoolNullableFilter<"items"> | boolean | null
    zeroShareItemID?: BigIntFilter<"items"> | bigint | number
    attribute?: IntNullableFilter<"items"> | number | null
  }

  export type itemsOrderByWithRelationInput = {
    id?: SortOrder
    inventoryid?: SortOrderInput | SortOrder
    trunkid?: SortOrderInput | SortOrder
    auctionHouseStatus?: SortOrderInput | SortOrder
    itemid?: SortOrderInput | SortOrder
    bagindex?: SortOrderInput | SortOrder
    cashitemserialnumber?: SortOrderInput | SortOrder
    dateexpire?: SortOrderInput | SortOrder
    invtype?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    iscash?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    expireonlogout?: SortOrderInput | SortOrder
    owner?: SortOrderInput | SortOrder
    obtainedonce?: SortOrderInput | SortOrder
    zeroShareItemID?: SortOrder
    attribute?: SortOrderInput | SortOrder
  }

  export type itemsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: itemsWhereInput | itemsWhereInput[]
    OR?: itemsWhereInput[]
    NOT?: itemsWhereInput | itemsWhereInput[]
    inventoryid?: IntNullableFilter<"items"> | number | null
    trunkid?: IntNullableFilter<"items"> | number | null
    auctionHouseStatus?: BoolNullableFilter<"items"> | boolean | null
    itemid?: IntNullableFilter<"items"> | number | null
    bagindex?: IntNullableFilter<"items"> | number | null
    cashitemserialnumber?: BigIntNullableFilter<"items"> | bigint | number | null
    dateexpire?: DateTimeNullableFilter<"items"> | Date | string | null
    invtype?: IntNullableFilter<"items"> | number | null
    type?: IntNullableFilter<"items"> | number | null
    iscash?: BoolNullableFilter<"items"> | boolean | null
    quantity?: IntNullableFilter<"items"> | number | null
    expireonlogout?: BoolNullableFilter<"items"> | boolean | null
    owner?: StringNullableFilter<"items"> | string | null
    obtainedonce?: BoolNullableFilter<"items"> | boolean | null
    zeroShareItemID?: BigIntFilter<"items"> | bigint | number
    attribute?: IntNullableFilter<"items"> | number | null
  }, "id">

  export type itemsOrderByWithAggregationInput = {
    id?: SortOrder
    inventoryid?: SortOrderInput | SortOrder
    trunkid?: SortOrderInput | SortOrder
    auctionHouseStatus?: SortOrderInput | SortOrder
    itemid?: SortOrderInput | SortOrder
    bagindex?: SortOrderInput | SortOrder
    cashitemserialnumber?: SortOrderInput | SortOrder
    dateexpire?: SortOrderInput | SortOrder
    invtype?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    iscash?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    expireonlogout?: SortOrderInput | SortOrder
    owner?: SortOrderInput | SortOrder
    obtainedonce?: SortOrderInput | SortOrder
    zeroShareItemID?: SortOrder
    attribute?: SortOrderInput | SortOrder
    _count?: itemsCountOrderByAggregateInput
    _avg?: itemsAvgOrderByAggregateInput
    _max?: itemsMaxOrderByAggregateInput
    _min?: itemsMinOrderByAggregateInput
    _sum?: itemsSumOrderByAggregateInput
  }

  export type itemsScalarWhereWithAggregatesInput = {
    AND?: itemsScalarWhereWithAggregatesInput | itemsScalarWhereWithAggregatesInput[]
    OR?: itemsScalarWhereWithAggregatesInput[]
    NOT?: itemsScalarWhereWithAggregatesInput | itemsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"items"> | bigint | number
    inventoryid?: IntNullableWithAggregatesFilter<"items"> | number | null
    trunkid?: IntNullableWithAggregatesFilter<"items"> | number | null
    auctionHouseStatus?: BoolNullableWithAggregatesFilter<"items"> | boolean | null
    itemid?: IntNullableWithAggregatesFilter<"items"> | number | null
    bagindex?: IntNullableWithAggregatesFilter<"items"> | number | null
    cashitemserialnumber?: BigIntNullableWithAggregatesFilter<"items"> | bigint | number | null
    dateexpire?: DateTimeNullableWithAggregatesFilter<"items"> | Date | string | null
    invtype?: IntNullableWithAggregatesFilter<"items"> | number | null
    type?: IntNullableWithAggregatesFilter<"items"> | number | null
    iscash?: BoolNullableWithAggregatesFilter<"items"> | boolean | null
    quantity?: IntNullableWithAggregatesFilter<"items"> | number | null
    expireonlogout?: BoolNullableWithAggregatesFilter<"items"> | boolean | null
    owner?: StringNullableWithAggregatesFilter<"items"> | string | null
    obtainedonce?: BoolNullableWithAggregatesFilter<"items"> | boolean | null
    zeroShareItemID?: BigIntWithAggregatesFilter<"items"> | bigint | number
    attribute?: IntNullableWithAggregatesFilter<"items"> | number | null
  }

  export type itemsbuylimitWhereInput = {
    AND?: itemsbuylimitWhereInput | itemsbuylimitWhereInput[]
    OR?: itemsbuylimitWhereInput[]
    NOT?: itemsbuylimitWhereInput | itemsbuylimitWhereInput[]
    id?: IntFilter<"itemsbuylimit"> | number
    shopitemid?: BigIntNullableFilter<"itemsbuylimit"> | bigint | number | null
    charid?: IntNullableFilter<"itemsbuylimit"> | number | null
    amountbought?: IntNullableFilter<"itemsbuylimit"> | number | null
  }

  export type itemsbuylimitOrderByWithRelationInput = {
    id?: SortOrder
    shopitemid?: SortOrderInput | SortOrder
    charid?: SortOrderInput | SortOrder
    amountbought?: SortOrderInput | SortOrder
  }

  export type itemsbuylimitWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: itemsbuylimitWhereInput | itemsbuylimitWhereInput[]
    OR?: itemsbuylimitWhereInput[]
    NOT?: itemsbuylimitWhereInput | itemsbuylimitWhereInput[]
    shopitemid?: BigIntNullableFilter<"itemsbuylimit"> | bigint | number | null
    charid?: IntNullableFilter<"itemsbuylimit"> | number | null
    amountbought?: IntNullableFilter<"itemsbuylimit"> | number | null
  }, "id">

  export type itemsbuylimitOrderByWithAggregationInput = {
    id?: SortOrder
    shopitemid?: SortOrderInput | SortOrder
    charid?: SortOrderInput | SortOrder
    amountbought?: SortOrderInput | SortOrder
    _count?: itemsbuylimitCountOrderByAggregateInput
    _avg?: itemsbuylimitAvgOrderByAggregateInput
    _max?: itemsbuylimitMaxOrderByAggregateInput
    _min?: itemsbuylimitMinOrderByAggregateInput
    _sum?: itemsbuylimitSumOrderByAggregateInput
  }

  export type itemsbuylimitScalarWhereWithAggregatesInput = {
    AND?: itemsbuylimitScalarWhereWithAggregatesInput | itemsbuylimitScalarWhereWithAggregatesInput[]
    OR?: itemsbuylimitScalarWhereWithAggregatesInput[]
    NOT?: itemsbuylimitScalarWhereWithAggregatesInput | itemsbuylimitScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"itemsbuylimit"> | number
    shopitemid?: BigIntNullableWithAggregatesFilter<"itemsbuylimit"> | bigint | number | null
    charid?: IntNullableWithAggregatesFilter<"itemsbuylimit"> | number | null
    amountbought?: IntNullableWithAggregatesFilter<"itemsbuylimit"> | number | null
  }

  export type keymapsWhereInput = {
    AND?: keymapsWhereInput | keymapsWhereInput[]
    OR?: keymapsWhereInput[]
    NOT?: keymapsWhereInput | keymapsWhereInput[]
    id?: IntFilter<"keymaps"> | number
    fkmapid?: IntNullableFilter<"keymaps"> | number | null
    idx?: IntNullableFilter<"keymaps"> | number | null
    type?: IntNullableFilter<"keymaps"> | number | null
    val?: IntNullableFilter<"keymaps"> | number | null
  }

  export type keymapsOrderByWithRelationInput = {
    id?: SortOrder
    fkmapid?: SortOrderInput | SortOrder
    idx?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    val?: SortOrderInput | SortOrder
  }

  export type keymapsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: keymapsWhereInput | keymapsWhereInput[]
    OR?: keymapsWhereInput[]
    NOT?: keymapsWhereInput | keymapsWhereInput[]
    fkmapid?: IntNullableFilter<"keymaps"> | number | null
    idx?: IntNullableFilter<"keymaps"> | number | null
    type?: IntNullableFilter<"keymaps"> | number | null
    val?: IntNullableFilter<"keymaps"> | number | null
  }, "id">

  export type keymapsOrderByWithAggregationInput = {
    id?: SortOrder
    fkmapid?: SortOrderInput | SortOrder
    idx?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    val?: SortOrderInput | SortOrder
    _count?: keymapsCountOrderByAggregateInput
    _avg?: keymapsAvgOrderByAggregateInput
    _max?: keymapsMaxOrderByAggregateInput
    _min?: keymapsMinOrderByAggregateInput
    _sum?: keymapsSumOrderByAggregateInput
  }

  export type keymapsScalarWhereWithAggregatesInput = {
    AND?: keymapsScalarWhereWithAggregatesInput | keymapsScalarWhereWithAggregatesInput[]
    OR?: keymapsScalarWhereWithAggregatesInput[]
    NOT?: keymapsScalarWhereWithAggregatesInput | keymapsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"keymaps"> | number
    fkmapid?: IntNullableWithAggregatesFilter<"keymaps"> | number | null
    idx?: IntNullableWithAggregatesFilter<"keymaps"> | number | null
    type?: IntNullableWithAggregatesFilter<"keymaps"> | number | null
    val?: IntNullableWithAggregatesFilter<"keymaps"> | number | null
  }

  export type linkskillsWhereInput = {
    AND?: linkskillsWhereInput | linkskillsWhereInput[]
    OR?: linkskillsWhereInput[]
    NOT?: linkskillsWhereInput | linkskillsWhereInput[]
    id?: IntFilter<"linkskills"> | number
    accid?: IntNullableFilter<"linkskills"> | number | null
    ownerid?: IntNullableFilter<"linkskills"> | number | null
    linkedcharid?: IntNullableFilter<"linkskills"> | number | null
    linkskillid?: IntNullableFilter<"linkskills"> | number | null
    level?: IntNullableFilter<"linkskills"> | number | null
    addeddate?: DateTimeNullableFilter<"linkskills"> | Date | string | null
  }

  export type linkskillsOrderByWithRelationInput = {
    id?: SortOrder
    accid?: SortOrderInput | SortOrder
    ownerid?: SortOrderInput | SortOrder
    linkedcharid?: SortOrderInput | SortOrder
    linkskillid?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    addeddate?: SortOrderInput | SortOrder
  }

  export type linkskillsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: linkskillsWhereInput | linkskillsWhereInput[]
    OR?: linkskillsWhereInput[]
    NOT?: linkskillsWhereInput | linkskillsWhereInput[]
    accid?: IntNullableFilter<"linkskills"> | number | null
    ownerid?: IntNullableFilter<"linkskills"> | number | null
    linkedcharid?: IntNullableFilter<"linkskills"> | number | null
    linkskillid?: IntNullableFilter<"linkskills"> | number | null
    level?: IntNullableFilter<"linkskills"> | number | null
    addeddate?: DateTimeNullableFilter<"linkskills"> | Date | string | null
  }, "id">

  export type linkskillsOrderByWithAggregationInput = {
    id?: SortOrder
    accid?: SortOrderInput | SortOrder
    ownerid?: SortOrderInput | SortOrder
    linkedcharid?: SortOrderInput | SortOrder
    linkskillid?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    addeddate?: SortOrderInput | SortOrder
    _count?: linkskillsCountOrderByAggregateInput
    _avg?: linkskillsAvgOrderByAggregateInput
    _max?: linkskillsMaxOrderByAggregateInput
    _min?: linkskillsMinOrderByAggregateInput
    _sum?: linkskillsSumOrderByAggregateInput
  }

  export type linkskillsScalarWhereWithAggregatesInput = {
    AND?: linkskillsScalarWhereWithAggregatesInput | linkskillsScalarWhereWithAggregatesInput[]
    OR?: linkskillsScalarWhereWithAggregatesInput[]
    NOT?: linkskillsScalarWhereWithAggregatesInput | linkskillsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"linkskills"> | number
    accid?: IntNullableWithAggregatesFilter<"linkskills"> | number | null
    ownerid?: IntNullableWithAggregatesFilter<"linkskills"> | number | null
    linkedcharid?: IntNullableWithAggregatesFilter<"linkskills"> | number | null
    linkskillid?: IntNullableWithAggregatesFilter<"linkskills"> | number | null
    level?: IntNullableWithAggregatesFilter<"linkskills"> | number | null
    addeddate?: DateTimeNullableWithAggregatesFilter<"linkskills"> | Date | string | null
  }

  export type macrosWhereInput = {
    AND?: macrosWhereInput | macrosWhereInput[]
    OR?: macrosWhereInput[]
    NOT?: macrosWhereInput | macrosWhereInput[]
    id?: BigIntFilter<"macros"> | bigint | number
    charid?: IntNullableFilter<"macros"> | number | null
    muted?: BoolNullableFilter<"macros"> | boolean | null
    name?: StringNullableFilter<"macros"> | string | null
  }

  export type macrosOrderByWithRelationInput = {
    id?: SortOrder
    charid?: SortOrderInput | SortOrder
    muted?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
  }

  export type macrosWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: macrosWhereInput | macrosWhereInput[]
    OR?: macrosWhereInput[]
    NOT?: macrosWhereInput | macrosWhereInput[]
    charid?: IntNullableFilter<"macros"> | number | null
    muted?: BoolNullableFilter<"macros"> | boolean | null
    name?: StringNullableFilter<"macros"> | string | null
  }, "id">

  export type macrosOrderByWithAggregationInput = {
    id?: SortOrder
    charid?: SortOrderInput | SortOrder
    muted?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    _count?: macrosCountOrderByAggregateInput
    _avg?: macrosAvgOrderByAggregateInput
    _max?: macrosMaxOrderByAggregateInput
    _min?: macrosMinOrderByAggregateInput
    _sum?: macrosSumOrderByAggregateInput
  }

  export type macrosScalarWhereWithAggregatesInput = {
    AND?: macrosScalarWhereWithAggregatesInput | macrosScalarWhereWithAggregatesInput[]
    OR?: macrosScalarWhereWithAggregatesInput[]
    NOT?: macrosScalarWhereWithAggregatesInput | macrosScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"macros"> | bigint | number
    charid?: IntNullableWithAggregatesFilter<"macros"> | number | null
    muted?: BoolNullableWithAggregatesFilter<"macros"> | boolean | null
    name?: StringNullableWithAggregatesFilter<"macros"> | string | null
  }

  export type macroskillsWhereInput = {
    AND?: macroskillsWhereInput | macroskillsWhereInput[]
    OR?: macroskillsWhereInput[]
    NOT?: macroskillsWhereInput | macroskillsWhereInput[]
    id?: BigIntFilter<"macroskills"> | bigint | number
    ordercol?: IntNullableFilter<"macroskills"> | number | null
    skillid?: IntNullableFilter<"macroskills"> | number | null
    macroid?: BigIntNullableFilter<"macroskills"> | bigint | number | null
  }

  export type macroskillsOrderByWithRelationInput = {
    id?: SortOrder
    ordercol?: SortOrderInput | SortOrder
    skillid?: SortOrderInput | SortOrder
    macroid?: SortOrderInput | SortOrder
  }

  export type macroskillsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: macroskillsWhereInput | macroskillsWhereInput[]
    OR?: macroskillsWhereInput[]
    NOT?: macroskillsWhereInput | macroskillsWhereInput[]
    ordercol?: IntNullableFilter<"macroskills"> | number | null
    skillid?: IntNullableFilter<"macroskills"> | number | null
    macroid?: BigIntNullableFilter<"macroskills"> | bigint | number | null
  }, "id">

  export type macroskillsOrderByWithAggregationInput = {
    id?: SortOrder
    ordercol?: SortOrderInput | SortOrder
    skillid?: SortOrderInput | SortOrder
    macroid?: SortOrderInput | SortOrder
    _count?: macroskillsCountOrderByAggregateInput
    _avg?: macroskillsAvgOrderByAggregateInput
    _max?: macroskillsMaxOrderByAggregateInput
    _min?: macroskillsMinOrderByAggregateInput
    _sum?: macroskillsSumOrderByAggregateInput
  }

  export type macroskillsScalarWhereWithAggregatesInput = {
    AND?: macroskillsScalarWhereWithAggregatesInput | macroskillsScalarWhereWithAggregatesInput[]
    OR?: macroskillsScalarWhereWithAggregatesInput[]
    NOT?: macroskillsScalarWhereWithAggregatesInput | macroskillsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"macroskills"> | bigint | number
    ordercol?: IntNullableWithAggregatesFilter<"macroskills"> | number | null
    skillid?: IntNullableWithAggregatesFilter<"macroskills"> | number | null
    macroid?: BigIntNullableWithAggregatesFilter<"macroskills"> | bigint | number | null
  }

  export type matrixskillWhereInput = {
    AND?: matrixskillWhereInput | matrixskillWhereInput[]
    OR?: matrixskillWhereInput[]
    NOT?: matrixskillWhereInput | matrixskillWhereInput[]
    id?: IntFilter<"matrixskill"> | number
    charid?: IntFilter<"matrixskill"> | number
    state?: BoolFilter<"matrixskill"> | boolean
    coreID?: IntFilter<"matrixskill"> | number
    skillID1?: IntFilter<"matrixskill"> | number
    skillID2?: IntFilter<"matrixskill"> | number
    skillID3?: IntFilter<"matrixskill"> | number
    level?: IntFilter<"matrixskill"> | number
    maxLevel?: IntFilter<"matrixskill"> | number
    experience?: IntFilter<"matrixskill"> | number
    crc?: BigIntFilter<"matrixskill"> | bigint | number
    slot?: IntFilter<"matrixskill"> | number
  }

  export type matrixskillOrderByWithRelationInput = {
    id?: SortOrder
    charid?: SortOrder
    state?: SortOrder
    coreID?: SortOrder
    skillID1?: SortOrder
    skillID2?: SortOrder
    skillID3?: SortOrder
    level?: SortOrder
    maxLevel?: SortOrder
    experience?: SortOrder
    crc?: SortOrder
    slot?: SortOrder
  }

  export type matrixskillWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: matrixskillWhereInput | matrixskillWhereInput[]
    OR?: matrixskillWhereInput[]
    NOT?: matrixskillWhereInput | matrixskillWhereInput[]
    charid?: IntFilter<"matrixskill"> | number
    state?: BoolFilter<"matrixskill"> | boolean
    coreID?: IntFilter<"matrixskill"> | number
    skillID1?: IntFilter<"matrixskill"> | number
    skillID2?: IntFilter<"matrixskill"> | number
    skillID3?: IntFilter<"matrixskill"> | number
    level?: IntFilter<"matrixskill"> | number
    maxLevel?: IntFilter<"matrixskill"> | number
    experience?: IntFilter<"matrixskill"> | number
    crc?: BigIntFilter<"matrixskill"> | bigint | number
    slot?: IntFilter<"matrixskill"> | number
  }, "id">

  export type matrixskillOrderByWithAggregationInput = {
    id?: SortOrder
    charid?: SortOrder
    state?: SortOrder
    coreID?: SortOrder
    skillID1?: SortOrder
    skillID2?: SortOrder
    skillID3?: SortOrder
    level?: SortOrder
    maxLevel?: SortOrder
    experience?: SortOrder
    crc?: SortOrder
    slot?: SortOrder
    _count?: matrixskillCountOrderByAggregateInput
    _avg?: matrixskillAvgOrderByAggregateInput
    _max?: matrixskillMaxOrderByAggregateInput
    _min?: matrixskillMinOrderByAggregateInput
    _sum?: matrixskillSumOrderByAggregateInput
  }

  export type matrixskillScalarWhereWithAggregatesInput = {
    AND?: matrixskillScalarWhereWithAggregatesInput | matrixskillScalarWhereWithAggregatesInput[]
    OR?: matrixskillScalarWhereWithAggregatesInput[]
    NOT?: matrixskillScalarWhereWithAggregatesInput | matrixskillScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"matrixskill"> | number
    charid?: IntWithAggregatesFilter<"matrixskill"> | number
    state?: BoolWithAggregatesFilter<"matrixskill"> | boolean
    coreID?: IntWithAggregatesFilter<"matrixskill"> | number
    skillID1?: IntWithAggregatesFilter<"matrixskill"> | number
    skillID2?: IntWithAggregatesFilter<"matrixskill"> | number
    skillID3?: IntWithAggregatesFilter<"matrixskill"> | number
    level?: IntWithAggregatesFilter<"matrixskill"> | number
    maxLevel?: IntWithAggregatesFilter<"matrixskill"> | number
    experience?: IntWithAggregatesFilter<"matrixskill"> | number
    crc?: BigIntWithAggregatesFilter<"matrixskill"> | bigint | number
    slot?: IntWithAggregatesFilter<"matrixskill"> | number
  }

  export type medalsWhereInput = {
    AND?: medalsWhereInput | medalsWhereInput[]
    OR?: medalsWhereInput[]
    NOT?: medalsWhereInput | medalsWhereInput[]
    id?: BigIntFilter<"medals"> | bigint | number
    charid?: IntNullableFilter<"medals"> | number | null
    questid?: IntNullableFilter<"medals"> | number | null
    itemid?: IntNullableFilter<"medals"> | number | null
    completedtime?: DateTimeNullableFilter<"medals"> | Date | string | null
  }

  export type medalsOrderByWithRelationInput = {
    id?: SortOrder
    charid?: SortOrderInput | SortOrder
    questid?: SortOrderInput | SortOrder
    itemid?: SortOrderInput | SortOrder
    completedtime?: SortOrderInput | SortOrder
  }

  export type medalsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: medalsWhereInput | medalsWhereInput[]
    OR?: medalsWhereInput[]
    NOT?: medalsWhereInput | medalsWhereInput[]
    charid?: IntNullableFilter<"medals"> | number | null
    questid?: IntNullableFilter<"medals"> | number | null
    itemid?: IntNullableFilter<"medals"> | number | null
    completedtime?: DateTimeNullableFilter<"medals"> | Date | string | null
  }, "id">

  export type medalsOrderByWithAggregationInput = {
    id?: SortOrder
    charid?: SortOrderInput | SortOrder
    questid?: SortOrderInput | SortOrder
    itemid?: SortOrderInput | SortOrder
    completedtime?: SortOrderInput | SortOrder
    _count?: medalsCountOrderByAggregateInput
    _avg?: medalsAvgOrderByAggregateInput
    _max?: medalsMaxOrderByAggregateInput
    _min?: medalsMinOrderByAggregateInput
    _sum?: medalsSumOrderByAggregateInput
  }

  export type medalsScalarWhereWithAggregatesInput = {
    AND?: medalsScalarWhereWithAggregatesInput | medalsScalarWhereWithAggregatesInput[]
    OR?: medalsScalarWhereWithAggregatesInput[]
    NOT?: medalsScalarWhereWithAggregatesInput | medalsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"medals"> | bigint | number
    charid?: IntNullableWithAggregatesFilter<"medals"> | number | null
    questid?: IntNullableWithAggregatesFilter<"medals"> | number | null
    itemid?: IntNullableWithAggregatesFilter<"medals"> | number | null
    completedtime?: DateTimeNullableWithAggregatesFilter<"medals"> | Date | string | null
  }

  export type mob_dropsWhereInput = {
    AND?: mob_dropsWhereInput | mob_dropsWhereInput[]
    OR?: mob_dropsWhereInput[]
    NOT?: mob_dropsWhereInput | mob_dropsWhereInput[]
    id?: BigIntFilter<"mob_drops"> | bigint | number
    mobid?: IntNullableFilter<"mob_drops"> | number | null
    itemid?: IntNullableFilter<"mob_drops"> | number | null
    chance?: IntNullableFilter<"mob_drops"> | number | null
    minquant?: IntNullableFilter<"mob_drops"> | number | null
    maxquant?: IntNullableFilter<"mob_drops"> | number | null
    reactordrop?: IntNullableFilter<"mob_drops"> | number | null
  }

  export type mob_dropsOrderByWithRelationInput = {
    id?: SortOrder
    mobid?: SortOrderInput | SortOrder
    itemid?: SortOrderInput | SortOrder
    chance?: SortOrderInput | SortOrder
    minquant?: SortOrderInput | SortOrder
    maxquant?: SortOrderInput | SortOrder
    reactordrop?: SortOrderInput | SortOrder
  }

  export type mob_dropsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: mob_dropsWhereInput | mob_dropsWhereInput[]
    OR?: mob_dropsWhereInput[]
    NOT?: mob_dropsWhereInput | mob_dropsWhereInput[]
    mobid?: IntNullableFilter<"mob_drops"> | number | null
    itemid?: IntNullableFilter<"mob_drops"> | number | null
    chance?: IntNullableFilter<"mob_drops"> | number | null
    minquant?: IntNullableFilter<"mob_drops"> | number | null
    maxquant?: IntNullableFilter<"mob_drops"> | number | null
    reactordrop?: IntNullableFilter<"mob_drops"> | number | null
  }, "id">

  export type mob_dropsOrderByWithAggregationInput = {
    id?: SortOrder
    mobid?: SortOrderInput | SortOrder
    itemid?: SortOrderInput | SortOrder
    chance?: SortOrderInput | SortOrder
    minquant?: SortOrderInput | SortOrder
    maxquant?: SortOrderInput | SortOrder
    reactordrop?: SortOrderInput | SortOrder
    _count?: mob_dropsCountOrderByAggregateInput
    _avg?: mob_dropsAvgOrderByAggregateInput
    _max?: mob_dropsMaxOrderByAggregateInput
    _min?: mob_dropsMinOrderByAggregateInput
    _sum?: mob_dropsSumOrderByAggregateInput
  }

  export type mob_dropsScalarWhereWithAggregatesInput = {
    AND?: mob_dropsScalarWhereWithAggregatesInput | mob_dropsScalarWhereWithAggregatesInput[]
    OR?: mob_dropsScalarWhereWithAggregatesInput[]
    NOT?: mob_dropsScalarWhereWithAggregatesInput | mob_dropsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"mob_drops"> | bigint | number
    mobid?: IntNullableWithAggregatesFilter<"mob_drops"> | number | null
    itemid?: IntNullableWithAggregatesFilter<"mob_drops"> | number | null
    chance?: IntNullableWithAggregatesFilter<"mob_drops"> | number | null
    minquant?: IntNullableWithAggregatesFilter<"mob_drops"> | number | null
    maxquant?: IntNullableWithAggregatesFilter<"mob_drops"> | number | null
    reactordrop?: IntNullableWithAggregatesFilter<"mob_drops"> | number | null
  }

  export type monster_collectionWhereInput = {
    AND?: monster_collectionWhereInput | monster_collectionWhereInput[]
    OR?: monster_collectionWhereInput[]
    NOT?: monster_collectionWhereInput | monster_collectionWhereInput[]
    id?: IntFilter<"monster_collection"> | number
    mobid?: IntNullableFilter<"monster_collection"> | number | null
    region?: IntNullableFilter<"monster_collection"> | number | null
    session?: IntNullableFilter<"monster_collection"> | number | null
    position?: IntNullableFilter<"monster_collection"> | number | null
  }

  export type monster_collectionOrderByWithRelationInput = {
    id?: SortOrder
    mobid?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    session?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
  }

  export type monster_collectionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: monster_collectionWhereInput | monster_collectionWhereInput[]
    OR?: monster_collectionWhereInput[]
    NOT?: monster_collectionWhereInput | monster_collectionWhereInput[]
    mobid?: IntNullableFilter<"monster_collection"> | number | null
    region?: IntNullableFilter<"monster_collection"> | number | null
    session?: IntNullableFilter<"monster_collection"> | number | null
    position?: IntNullableFilter<"monster_collection"> | number | null
  }, "id">

  export type monster_collectionOrderByWithAggregationInput = {
    id?: SortOrder
    mobid?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    session?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    _count?: monster_collectionCountOrderByAggregateInput
    _avg?: monster_collectionAvgOrderByAggregateInput
    _max?: monster_collectionMaxOrderByAggregateInput
    _min?: monster_collectionMinOrderByAggregateInput
    _sum?: monster_collectionSumOrderByAggregateInput
  }

  export type monster_collectionScalarWhereWithAggregatesInput = {
    AND?: monster_collectionScalarWhereWithAggregatesInput | monster_collectionScalarWhereWithAggregatesInput[]
    OR?: monster_collectionScalarWhereWithAggregatesInput[]
    NOT?: monster_collectionScalarWhereWithAggregatesInput | monster_collectionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"monster_collection"> | number
    mobid?: IntNullableWithAggregatesFilter<"monster_collection"> | number | null
    region?: IntNullableWithAggregatesFilter<"monster_collection"> | number | null
    session?: IntNullableWithAggregatesFilter<"monster_collection"> | number | null
    position?: IntNullableWithAggregatesFilter<"monster_collection"> | number | null
  }

  export type monster_collection_explorationsWhereInput = {
    AND?: monster_collection_explorationsWhereInput | monster_collection_explorationsWhereInput[]
    OR?: monster_collection_explorationsWhereInput[]
    NOT?: monster_collection_explorationsWhereInput | monster_collection_explorationsWhereInput[]
    id?: BigIntFilter<"monster_collection_explorations"> | bigint | number
    collectionid?: IntNullableFilter<"monster_collection_explorations"> | number | null
    collectionkey?: IntNullableFilter<"monster_collection_explorations"> | number | null
    monsterkey?: StringNullableFilter<"monster_collection_explorations"> | string | null
    endDate?: DateTimeNullableFilter<"monster_collection_explorations"> | Date | string | null
    position?: IntNullableFilter<"monster_collection_explorations"> | number | null
  }

  export type monster_collection_explorationsOrderByWithRelationInput = {
    id?: SortOrder
    collectionid?: SortOrderInput | SortOrder
    collectionkey?: SortOrderInput | SortOrder
    monsterkey?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
  }

  export type monster_collection_explorationsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: monster_collection_explorationsWhereInput | monster_collection_explorationsWhereInput[]
    OR?: monster_collection_explorationsWhereInput[]
    NOT?: monster_collection_explorationsWhereInput | monster_collection_explorationsWhereInput[]
    collectionid?: IntNullableFilter<"monster_collection_explorations"> | number | null
    collectionkey?: IntNullableFilter<"monster_collection_explorations"> | number | null
    monsterkey?: StringNullableFilter<"monster_collection_explorations"> | string | null
    endDate?: DateTimeNullableFilter<"monster_collection_explorations"> | Date | string | null
    position?: IntNullableFilter<"monster_collection_explorations"> | number | null
  }, "id">

  export type monster_collection_explorationsOrderByWithAggregationInput = {
    id?: SortOrder
    collectionid?: SortOrderInput | SortOrder
    collectionkey?: SortOrderInput | SortOrder
    monsterkey?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    _count?: monster_collection_explorationsCountOrderByAggregateInput
    _avg?: monster_collection_explorationsAvgOrderByAggregateInput
    _max?: monster_collection_explorationsMaxOrderByAggregateInput
    _min?: monster_collection_explorationsMinOrderByAggregateInput
    _sum?: monster_collection_explorationsSumOrderByAggregateInput
  }

  export type monster_collection_explorationsScalarWhereWithAggregatesInput = {
    AND?: monster_collection_explorationsScalarWhereWithAggregatesInput | monster_collection_explorationsScalarWhereWithAggregatesInput[]
    OR?: monster_collection_explorationsScalarWhereWithAggregatesInput[]
    NOT?: monster_collection_explorationsScalarWhereWithAggregatesInput | monster_collection_explorationsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"monster_collection_explorations"> | bigint | number
    collectionid?: IntNullableWithAggregatesFilter<"monster_collection_explorations"> | number | null
    collectionkey?: IntNullableWithAggregatesFilter<"monster_collection_explorations"> | number | null
    monsterkey?: StringNullableWithAggregatesFilter<"monster_collection_explorations"> | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"monster_collection_explorations"> | Date | string | null
    position?: IntNullableWithAggregatesFilter<"monster_collection_explorations"> | number | null
  }

  export type monster_collection_group_rewardsWhereInput = {
    AND?: monster_collection_group_rewardsWhereInput | monster_collection_group_rewardsWhereInput[]
    OR?: monster_collection_group_rewardsWhereInput[]
    NOT?: monster_collection_group_rewardsWhereInput | monster_collection_group_rewardsWhereInput[]
    region?: IntFilter<"monster_collection_group_rewards"> | number
    session?: IntFilter<"monster_collection_group_rewards"> | number
    groupid?: IntFilter<"monster_collection_group_rewards"> | number
    rewardid?: IntNullableFilter<"monster_collection_group_rewards"> | number | null
    quantity?: IntNullableFilter<"monster_collection_group_rewards"> | number | null
  }

  export type monster_collection_group_rewardsOrderByWithRelationInput = {
    region?: SortOrder
    session?: SortOrder
    groupid?: SortOrder
    rewardid?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
  }

  export type monster_collection_group_rewardsWhereUniqueInput = Prisma.AtLeast<{
    region_session_groupid?: monster_collection_group_rewardsRegionSessionGroupidCompoundUniqueInput
    AND?: monster_collection_group_rewardsWhereInput | monster_collection_group_rewardsWhereInput[]
    OR?: monster_collection_group_rewardsWhereInput[]
    NOT?: monster_collection_group_rewardsWhereInput | monster_collection_group_rewardsWhereInput[]
    region?: IntFilter<"monster_collection_group_rewards"> | number
    session?: IntFilter<"monster_collection_group_rewards"> | number
    groupid?: IntFilter<"monster_collection_group_rewards"> | number
    rewardid?: IntNullableFilter<"monster_collection_group_rewards"> | number | null
    quantity?: IntNullableFilter<"monster_collection_group_rewards"> | number | null
  }, "region_session_groupid">

  export type monster_collection_group_rewardsOrderByWithAggregationInput = {
    region?: SortOrder
    session?: SortOrder
    groupid?: SortOrder
    rewardid?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    _count?: monster_collection_group_rewardsCountOrderByAggregateInput
    _avg?: monster_collection_group_rewardsAvgOrderByAggregateInput
    _max?: monster_collection_group_rewardsMaxOrderByAggregateInput
    _min?: monster_collection_group_rewardsMinOrderByAggregateInput
    _sum?: monster_collection_group_rewardsSumOrderByAggregateInput
  }

  export type monster_collection_group_rewardsScalarWhereWithAggregatesInput = {
    AND?: monster_collection_group_rewardsScalarWhereWithAggregatesInput | monster_collection_group_rewardsScalarWhereWithAggregatesInput[]
    OR?: monster_collection_group_rewardsScalarWhereWithAggregatesInput[]
    NOT?: monster_collection_group_rewardsScalarWhereWithAggregatesInput | monster_collection_group_rewardsScalarWhereWithAggregatesInput[]
    region?: IntWithAggregatesFilter<"monster_collection_group_rewards"> | number
    session?: IntWithAggregatesFilter<"monster_collection_group_rewards"> | number
    groupid?: IntWithAggregatesFilter<"monster_collection_group_rewards"> | number
    rewardid?: IntNullableWithAggregatesFilter<"monster_collection_group_rewards"> | number | null
    quantity?: IntNullableWithAggregatesFilter<"monster_collection_group_rewards"> | number | null
  }

  export type monster_collection_mobsWhereInput = {
    AND?: monster_collection_mobsWhereInput | monster_collection_mobsWhereInput[]
    OR?: monster_collection_mobsWhereInput[]
    NOT?: monster_collection_mobsWhereInput | monster_collection_mobsWhereInput[]
    id?: IntFilter<"monster_collection_mobs"> | number
    collectionid?: IntNullableFilter<"monster_collection_mobs"> | number | null
    mobid?: IntNullableFilter<"monster_collection_mobs"> | number | null
  }

  export type monster_collection_mobsOrderByWithRelationInput = {
    id?: SortOrder
    collectionid?: SortOrderInput | SortOrder
    mobid?: SortOrderInput | SortOrder
  }

  export type monster_collection_mobsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: monster_collection_mobsWhereInput | monster_collection_mobsWhereInput[]
    OR?: monster_collection_mobsWhereInput[]
    NOT?: monster_collection_mobsWhereInput | monster_collection_mobsWhereInput[]
    collectionid?: IntNullableFilter<"monster_collection_mobs"> | number | null
    mobid?: IntNullableFilter<"monster_collection_mobs"> | number | null
  }, "id">

  export type monster_collection_mobsOrderByWithAggregationInput = {
    id?: SortOrder
    collectionid?: SortOrderInput | SortOrder
    mobid?: SortOrderInput | SortOrder
    _count?: monster_collection_mobsCountOrderByAggregateInput
    _avg?: monster_collection_mobsAvgOrderByAggregateInput
    _max?: monster_collection_mobsMaxOrderByAggregateInput
    _min?: monster_collection_mobsMinOrderByAggregateInput
    _sum?: monster_collection_mobsSumOrderByAggregateInput
  }

  export type monster_collection_mobsScalarWhereWithAggregatesInput = {
    AND?: monster_collection_mobsScalarWhereWithAggregatesInput | monster_collection_mobsScalarWhereWithAggregatesInput[]
    OR?: monster_collection_mobsScalarWhereWithAggregatesInput[]
    NOT?: monster_collection_mobsScalarWhereWithAggregatesInput | monster_collection_mobsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"monster_collection_mobs"> | number
    collectionid?: IntNullableWithAggregatesFilter<"monster_collection_mobs"> | number | null
    mobid?: IntNullableWithAggregatesFilter<"monster_collection_mobs"> | number | null
  }

  export type monster_collection_rewardsWhereInput = {
    AND?: monster_collection_rewardsWhereInput | monster_collection_rewardsWhereInput[]
    OR?: monster_collection_rewardsWhereInput[]
    NOT?: monster_collection_rewardsWhereInput | monster_collection_rewardsWhereInput[]
    region?: IntFilter<"monster_collection_rewards"> | number
    session?: IntFilter<"monster_collection_rewards"> | number
    groupid?: IntFilter<"monster_collection_rewards"> | number
    collectionid?: IntNullableFilter<"monster_collection_rewards"> | number | null
  }

  export type monster_collection_rewardsOrderByWithRelationInput = {
    region?: SortOrder
    session?: SortOrder
    groupid?: SortOrder
    collectionid?: SortOrderInput | SortOrder
  }

  export type monster_collection_rewardsWhereUniqueInput = Prisma.AtLeast<{
    region_session_groupid?: monster_collection_rewardsRegionSessionGroupidCompoundUniqueInput
    AND?: monster_collection_rewardsWhereInput | monster_collection_rewardsWhereInput[]
    OR?: monster_collection_rewardsWhereInput[]
    NOT?: monster_collection_rewardsWhereInput | monster_collection_rewardsWhereInput[]
    region?: IntFilter<"monster_collection_rewards"> | number
    session?: IntFilter<"monster_collection_rewards"> | number
    groupid?: IntFilter<"monster_collection_rewards"> | number
    collectionid?: IntNullableFilter<"monster_collection_rewards"> | number | null
  }, "region_session_groupid">

  export type monster_collection_rewardsOrderByWithAggregationInput = {
    region?: SortOrder
    session?: SortOrder
    groupid?: SortOrder
    collectionid?: SortOrderInput | SortOrder
    _count?: monster_collection_rewardsCountOrderByAggregateInput
    _avg?: monster_collection_rewardsAvgOrderByAggregateInput
    _max?: monster_collection_rewardsMaxOrderByAggregateInput
    _min?: monster_collection_rewardsMinOrderByAggregateInput
    _sum?: monster_collection_rewardsSumOrderByAggregateInput
  }

  export type monster_collection_rewardsScalarWhereWithAggregatesInput = {
    AND?: monster_collection_rewardsScalarWhereWithAggregatesInput | monster_collection_rewardsScalarWhereWithAggregatesInput[]
    OR?: monster_collection_rewardsScalarWhereWithAggregatesInput[]
    NOT?: monster_collection_rewardsScalarWhereWithAggregatesInput | monster_collection_rewardsScalarWhereWithAggregatesInput[]
    region?: IntWithAggregatesFilter<"monster_collection_rewards"> | number
    session?: IntWithAggregatesFilter<"monster_collection_rewards"> | number
    groupid?: IntWithAggregatesFilter<"monster_collection_rewards"> | number
    collectionid?: IntNullableWithAggregatesFilter<"monster_collection_rewards"> | number | null
  }

  export type monster_collection_session_rewardsWhereInput = {
    AND?: monster_collection_session_rewardsWhereInput | monster_collection_session_rewardsWhereInput[]
    OR?: monster_collection_session_rewardsWhereInput[]
    NOT?: monster_collection_session_rewardsWhereInput | monster_collection_session_rewardsWhereInput[]
    region?: IntFilter<"monster_collection_session_rewards"> | number
    session?: IntFilter<"monster_collection_session_rewards"> | number
    rewardid?: IntNullableFilter<"monster_collection_session_rewards"> | number | null
    quantity?: IntNullableFilter<"monster_collection_session_rewards"> | number | null
  }

  export type monster_collection_session_rewardsOrderByWithRelationInput = {
    region?: SortOrder
    session?: SortOrder
    rewardid?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
  }

  export type monster_collection_session_rewardsWhereUniqueInput = Prisma.AtLeast<{
    region_session?: monster_collection_session_rewardsRegionSessionCompoundUniqueInput
    AND?: monster_collection_session_rewardsWhereInput | monster_collection_session_rewardsWhereInput[]
    OR?: monster_collection_session_rewardsWhereInput[]
    NOT?: monster_collection_session_rewardsWhereInput | monster_collection_session_rewardsWhereInput[]
    region?: IntFilter<"monster_collection_session_rewards"> | number
    session?: IntFilter<"monster_collection_session_rewards"> | number
    rewardid?: IntNullableFilter<"monster_collection_session_rewards"> | number | null
    quantity?: IntNullableFilter<"monster_collection_session_rewards"> | number | null
  }, "region_session">

  export type monster_collection_session_rewardsOrderByWithAggregationInput = {
    region?: SortOrder
    session?: SortOrder
    rewardid?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    _count?: monster_collection_session_rewardsCountOrderByAggregateInput
    _avg?: monster_collection_session_rewardsAvgOrderByAggregateInput
    _max?: monster_collection_session_rewardsMaxOrderByAggregateInput
    _min?: monster_collection_session_rewardsMinOrderByAggregateInput
    _sum?: monster_collection_session_rewardsSumOrderByAggregateInput
  }

  export type monster_collection_session_rewardsScalarWhereWithAggregatesInput = {
    AND?: monster_collection_session_rewardsScalarWhereWithAggregatesInput | monster_collection_session_rewardsScalarWhereWithAggregatesInput[]
    OR?: monster_collection_session_rewardsScalarWhereWithAggregatesInput[]
    NOT?: monster_collection_session_rewardsScalarWhereWithAggregatesInput | monster_collection_session_rewardsScalarWhereWithAggregatesInput[]
    region?: IntWithAggregatesFilter<"monster_collection_session_rewards"> | number
    session?: IntWithAggregatesFilter<"monster_collection_session_rewards"> | number
    rewardid?: IntNullableWithAggregatesFilter<"monster_collection_session_rewards"> | number | null
    quantity?: IntNullableWithAggregatesFilter<"monster_collection_session_rewards"> | number | null
  }

  export type monster_collectionsWhereInput = {
    AND?: monster_collectionsWhereInput | monster_collectionsWhereInput[]
    OR?: monster_collectionsWhereInput[]
    NOT?: monster_collectionsWhereInput | monster_collectionsWhereInput[]
    id?: IntFilter<"monster_collections"> | number
    templateid?: IntFilter<"monster_collections"> | number
    accid?: IntFilter<"monster_collections"> | number
  }

  export type monster_collectionsOrderByWithRelationInput = {
    id?: SortOrder
    templateid?: SortOrder
    accid?: SortOrder
  }

  export type monster_collectionsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: monster_collectionsWhereInput | monster_collectionsWhereInput[]
    OR?: monster_collectionsWhereInput[]
    NOT?: monster_collectionsWhereInput | monster_collectionsWhereInput[]
    templateid?: IntFilter<"monster_collections"> | number
    accid?: IntFilter<"monster_collections"> | number
  }, "id">

  export type monster_collectionsOrderByWithAggregationInput = {
    id?: SortOrder
    templateid?: SortOrder
    accid?: SortOrder
    _count?: monster_collectionsCountOrderByAggregateInput
    _avg?: monster_collectionsAvgOrderByAggregateInput
    _max?: monster_collectionsMaxOrderByAggregateInput
    _min?: monster_collectionsMinOrderByAggregateInput
    _sum?: monster_collectionsSumOrderByAggregateInput
  }

  export type monster_collectionsScalarWhereWithAggregatesInput = {
    AND?: monster_collectionsScalarWhereWithAggregatesInput | monster_collectionsScalarWhereWithAggregatesInput[]
    OR?: monster_collectionsScalarWhereWithAggregatesInput[]
    NOT?: monster_collectionsScalarWhereWithAggregatesInput | monster_collectionsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"monster_collections"> | number
    templateid?: IntWithAggregatesFilter<"monster_collections"> | number
    accid?: IntWithAggregatesFilter<"monster_collections"> | number
  }

  export type monsterbookcardsWhereInput = {
    AND?: monsterbookcardsWhereInput | monsterbookcardsWhereInput[]
    OR?: monsterbookcardsWhereInput[]
    NOT?: monsterbookcardsWhereInput | monsterbookcardsWhereInput[]
    id?: BigIntFilter<"monsterbookcards"> | bigint | number
    bookid?: IntNullableFilter<"monsterbookcards"> | number | null
    cardid?: IntNullableFilter<"monsterbookcards"> | number | null
  }

  export type monsterbookcardsOrderByWithRelationInput = {
    id?: SortOrder
    bookid?: SortOrderInput | SortOrder
    cardid?: SortOrderInput | SortOrder
  }

  export type monsterbookcardsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: monsterbookcardsWhereInput | monsterbookcardsWhereInput[]
    OR?: monsterbookcardsWhereInput[]
    NOT?: monsterbookcardsWhereInput | monsterbookcardsWhereInput[]
    bookid?: IntNullableFilter<"monsterbookcards"> | number | null
    cardid?: IntNullableFilter<"monsterbookcards"> | number | null
  }, "id">

  export type monsterbookcardsOrderByWithAggregationInput = {
    id?: SortOrder
    bookid?: SortOrderInput | SortOrder
    cardid?: SortOrderInput | SortOrder
    _count?: monsterbookcardsCountOrderByAggregateInput
    _avg?: monsterbookcardsAvgOrderByAggregateInput
    _max?: monsterbookcardsMaxOrderByAggregateInput
    _min?: monsterbookcardsMinOrderByAggregateInput
    _sum?: monsterbookcardsSumOrderByAggregateInput
  }

  export type monsterbookcardsScalarWhereWithAggregatesInput = {
    AND?: monsterbookcardsScalarWhereWithAggregatesInput | monsterbookcardsScalarWhereWithAggregatesInput[]
    OR?: monsterbookcardsScalarWhereWithAggregatesInput[]
    NOT?: monsterbookcardsScalarWhereWithAggregatesInput | monsterbookcardsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"monsterbookcards"> | bigint | number
    bookid?: IntNullableWithAggregatesFilter<"monsterbookcards"> | number | null
    cardid?: IntNullableWithAggregatesFilter<"monsterbookcards"> | number | null
  }

  export type monsterbookinfosWhereInput = {
    AND?: monsterbookinfosWhereInput | monsterbookinfosWhereInput[]
    OR?: monsterbookinfosWhereInput[]
    NOT?: monsterbookinfosWhereInput | monsterbookinfosWhereInput[]
    id?: IntFilter<"monsterbookinfos"> | number
    setid?: IntNullableFilter<"monsterbookinfos"> | number | null
    coverid?: IntNullableFilter<"monsterbookinfos"> | number | null
  }

  export type monsterbookinfosOrderByWithRelationInput = {
    id?: SortOrder
    setid?: SortOrderInput | SortOrder
    coverid?: SortOrderInput | SortOrder
  }

  export type monsterbookinfosWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: monsterbookinfosWhereInput | monsterbookinfosWhereInput[]
    OR?: monsterbookinfosWhereInput[]
    NOT?: monsterbookinfosWhereInput | monsterbookinfosWhereInput[]
    setid?: IntNullableFilter<"monsterbookinfos"> | number | null
    coverid?: IntNullableFilter<"monsterbookinfos"> | number | null
  }, "id">

  export type monsterbookinfosOrderByWithAggregationInput = {
    id?: SortOrder
    setid?: SortOrderInput | SortOrder
    coverid?: SortOrderInput | SortOrder
    _count?: monsterbookinfosCountOrderByAggregateInput
    _avg?: monsterbookinfosAvgOrderByAggregateInput
    _max?: monsterbookinfosMaxOrderByAggregateInput
    _min?: monsterbookinfosMinOrderByAggregateInput
    _sum?: monsterbookinfosSumOrderByAggregateInput
  }

  export type monsterbookinfosScalarWhereWithAggregatesInput = {
    AND?: monsterbookinfosScalarWhereWithAggregatesInput | monsterbookinfosScalarWhereWithAggregatesInput[]
    OR?: monsterbookinfosScalarWhereWithAggregatesInput[]
    NOT?: monsterbookinfosScalarWhereWithAggregatesInput | monsterbookinfosScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"monsterbookinfos"> | number
    setid?: IntNullableWithAggregatesFilter<"monsterbookinfos"> | number | null
    coverid?: IntNullableWithAggregatesFilter<"monsterbookinfos"> | number | null
  }

  export type noncombatstatdaylimitWhereInput = {
    AND?: noncombatstatdaylimitWhereInput | noncombatstatdaylimitWhereInput[]
    OR?: noncombatstatdaylimitWhereInput[]
    NOT?: noncombatstatdaylimitWhereInput | noncombatstatdaylimitWhereInput[]
    id?: IntFilter<"noncombatstatdaylimit"> | number
    charisma?: IntNullableFilter<"noncombatstatdaylimit"> | number | null
    charm?: IntNullableFilter<"noncombatstatdaylimit"> | number | null
    insight?: IntNullableFilter<"noncombatstatdaylimit"> | number | null
    will?: IntNullableFilter<"noncombatstatdaylimit"> | number | null
    craft?: IntNullableFilter<"noncombatstatdaylimit"> | number | null
    sense?: IntNullableFilter<"noncombatstatdaylimit"> | number | null
    lastupdatecharmbycashpr?: DateTimeNullableFilter<"noncombatstatdaylimit"> | Date | string | null
    charmbycashpr?: IntNullableFilter<"noncombatstatdaylimit"> | number | null
  }

  export type noncombatstatdaylimitOrderByWithRelationInput = {
    id?: SortOrder
    charisma?: SortOrderInput | SortOrder
    charm?: SortOrderInput | SortOrder
    insight?: SortOrderInput | SortOrder
    will?: SortOrderInput | SortOrder
    craft?: SortOrderInput | SortOrder
    sense?: SortOrderInput | SortOrder
    lastupdatecharmbycashpr?: SortOrderInput | SortOrder
    charmbycashpr?: SortOrderInput | SortOrder
  }

  export type noncombatstatdaylimitWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: noncombatstatdaylimitWhereInput | noncombatstatdaylimitWhereInput[]
    OR?: noncombatstatdaylimitWhereInput[]
    NOT?: noncombatstatdaylimitWhereInput | noncombatstatdaylimitWhereInput[]
    charisma?: IntNullableFilter<"noncombatstatdaylimit"> | number | null
    charm?: IntNullableFilter<"noncombatstatdaylimit"> | number | null
    insight?: IntNullableFilter<"noncombatstatdaylimit"> | number | null
    will?: IntNullableFilter<"noncombatstatdaylimit"> | number | null
    craft?: IntNullableFilter<"noncombatstatdaylimit"> | number | null
    sense?: IntNullableFilter<"noncombatstatdaylimit"> | number | null
    lastupdatecharmbycashpr?: DateTimeNullableFilter<"noncombatstatdaylimit"> | Date | string | null
    charmbycashpr?: IntNullableFilter<"noncombatstatdaylimit"> | number | null
  }, "id">

  export type noncombatstatdaylimitOrderByWithAggregationInput = {
    id?: SortOrder
    charisma?: SortOrderInput | SortOrder
    charm?: SortOrderInput | SortOrder
    insight?: SortOrderInput | SortOrder
    will?: SortOrderInput | SortOrder
    craft?: SortOrderInput | SortOrder
    sense?: SortOrderInput | SortOrder
    lastupdatecharmbycashpr?: SortOrderInput | SortOrder
    charmbycashpr?: SortOrderInput | SortOrder
    _count?: noncombatstatdaylimitCountOrderByAggregateInput
    _avg?: noncombatstatdaylimitAvgOrderByAggregateInput
    _max?: noncombatstatdaylimitMaxOrderByAggregateInput
    _min?: noncombatstatdaylimitMinOrderByAggregateInput
    _sum?: noncombatstatdaylimitSumOrderByAggregateInput
  }

  export type noncombatstatdaylimitScalarWhereWithAggregatesInput = {
    AND?: noncombatstatdaylimitScalarWhereWithAggregatesInput | noncombatstatdaylimitScalarWhereWithAggregatesInput[]
    OR?: noncombatstatdaylimitScalarWhereWithAggregatesInput[]
    NOT?: noncombatstatdaylimitScalarWhereWithAggregatesInput | noncombatstatdaylimitScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"noncombatstatdaylimit"> | number
    charisma?: IntNullableWithAggregatesFilter<"noncombatstatdaylimit"> | number | null
    charm?: IntNullableWithAggregatesFilter<"noncombatstatdaylimit"> | number | null
    insight?: IntNullableWithAggregatesFilter<"noncombatstatdaylimit"> | number | null
    will?: IntNullableWithAggregatesFilter<"noncombatstatdaylimit"> | number | null
    craft?: IntNullableWithAggregatesFilter<"noncombatstatdaylimit"> | number | null
    sense?: IntNullableWithAggregatesFilter<"noncombatstatdaylimit"> | number | null
    lastupdatecharmbycashpr?: DateTimeNullableWithAggregatesFilter<"noncombatstatdaylimit"> | Date | string | null
    charmbycashpr?: IntNullableWithAggregatesFilter<"noncombatstatdaylimit"> | number | null
  }

  export type npcWhereInput = {
    AND?: npcWhereInput | npcWhereInput[]
    OR?: npcWhereInput[]
    NOT?: npcWhereInput | npcWhereInput[]
    id?: IntFilter<"npc"> | number
    npcid?: IntNullableFilter<"npc"> | number | null
    mapid?: IntNullableFilter<"npc"> | number | null
    x?: IntNullableFilter<"npc"> | number | null
    y?: IntNullableFilter<"npc"> | number | null
    cy?: IntNullableFilter<"npc"> | number | null
    rx0?: IntNullableFilter<"npc"> | number | null
    rx1?: IntNullableFilter<"npc"> | number | null
    fh?: IntNullableFilter<"npc"> | number | null
  }

  export type npcOrderByWithRelationInput = {
    id?: SortOrder
    npcid?: SortOrderInput | SortOrder
    mapid?: SortOrderInput | SortOrder
    x?: SortOrderInput | SortOrder
    y?: SortOrderInput | SortOrder
    cy?: SortOrderInput | SortOrder
    rx0?: SortOrderInput | SortOrder
    rx1?: SortOrderInput | SortOrder
    fh?: SortOrderInput | SortOrder
  }

  export type npcWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: npcWhereInput | npcWhereInput[]
    OR?: npcWhereInput[]
    NOT?: npcWhereInput | npcWhereInput[]
    npcid?: IntNullableFilter<"npc"> | number | null
    mapid?: IntNullableFilter<"npc"> | number | null
    x?: IntNullableFilter<"npc"> | number | null
    y?: IntNullableFilter<"npc"> | number | null
    cy?: IntNullableFilter<"npc"> | number | null
    rx0?: IntNullableFilter<"npc"> | number | null
    rx1?: IntNullableFilter<"npc"> | number | null
    fh?: IntNullableFilter<"npc"> | number | null
  }, "id">

  export type npcOrderByWithAggregationInput = {
    id?: SortOrder
    npcid?: SortOrderInput | SortOrder
    mapid?: SortOrderInput | SortOrder
    x?: SortOrderInput | SortOrder
    y?: SortOrderInput | SortOrder
    cy?: SortOrderInput | SortOrder
    rx0?: SortOrderInput | SortOrder
    rx1?: SortOrderInput | SortOrder
    fh?: SortOrderInput | SortOrder
    _count?: npcCountOrderByAggregateInput
    _avg?: npcAvgOrderByAggregateInput
    _max?: npcMaxOrderByAggregateInput
    _min?: npcMinOrderByAggregateInput
    _sum?: npcSumOrderByAggregateInput
  }

  export type npcScalarWhereWithAggregatesInput = {
    AND?: npcScalarWhereWithAggregatesInput | npcScalarWhereWithAggregatesInput[]
    OR?: npcScalarWhereWithAggregatesInput[]
    NOT?: npcScalarWhereWithAggregatesInput | npcScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"npc"> | number
    npcid?: IntNullableWithAggregatesFilter<"npc"> | number | null
    mapid?: IntNullableWithAggregatesFilter<"npc"> | number | null
    x?: IntNullableWithAggregatesFilter<"npc"> | number | null
    y?: IntNullableWithAggregatesFilter<"npc"> | number | null
    cy?: IntNullableWithAggregatesFilter<"npc"> | number | null
    rx0?: IntNullableWithAggregatesFilter<"npc"> | number | null
    rx1?: IntNullableWithAggregatesFilter<"npc"> | number | null
    fh?: IntNullableWithAggregatesFilter<"npc"> | number | null
  }

  export type offense_managersWhereInput = {
    AND?: offense_managersWhereInput | offense_managersWhereInput[]
    OR?: offense_managersWhereInput[]
    NOT?: offense_managersWhereInput | offense_managersWhereInput[]
    id?: IntFilter<"offense_managers"> | number
    points?: IntNullableFilter<"offense_managers"> | number | null
  }

  export type offense_managersOrderByWithRelationInput = {
    id?: SortOrder
    points?: SortOrderInput | SortOrder
  }

  export type offense_managersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: offense_managersWhereInput | offense_managersWhereInput[]
    OR?: offense_managersWhereInput[]
    NOT?: offense_managersWhereInput | offense_managersWhereInput[]
    points?: IntNullableFilter<"offense_managers"> | number | null
  }, "id">

  export type offense_managersOrderByWithAggregationInput = {
    id?: SortOrder
    points?: SortOrderInput | SortOrder
    _count?: offense_managersCountOrderByAggregateInput
    _avg?: offense_managersAvgOrderByAggregateInput
    _max?: offense_managersMaxOrderByAggregateInput
    _min?: offense_managersMinOrderByAggregateInput
    _sum?: offense_managersSumOrderByAggregateInput
  }

  export type offense_managersScalarWhereWithAggregatesInput = {
    AND?: offense_managersScalarWhereWithAggregatesInput | offense_managersScalarWhereWithAggregatesInput[]
    OR?: offense_managersScalarWhereWithAggregatesInput[]
    NOT?: offense_managersScalarWhereWithAggregatesInput | offense_managersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"offense_managers"> | number
    points?: IntNullableWithAggregatesFilter<"offense_managers"> | number | null
  }

  export type offensesWhereInput = {
    AND?: offensesWhereInput | offensesWhereInput[]
    OR?: offensesWhereInput[]
    NOT?: offensesWhereInput | offensesWhereInput[]
    id?: BigIntFilter<"offenses"> | bigint | number
    manager_id?: IntNullableFilter<"offenses"> | number | null
    charid?: IntNullableFilter<"offenses"> | number | null
    accountid?: IntNullableFilter<"offenses"> | number | null
    msg?: StringNullableFilter<"offenses"> | string | null
    type?: StringNullableFilter<"offenses"> | string | null
    issuedate?: DateTimeNullableFilter<"offenses"> | Date | string | null
    issuer_char_id?: IntNullableFilter<"offenses"> | number | null
  }

  export type offensesOrderByWithRelationInput = {
    id?: SortOrder
    manager_id?: SortOrderInput | SortOrder
    charid?: SortOrderInput | SortOrder
    accountid?: SortOrderInput | SortOrder
    msg?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    issuedate?: SortOrderInput | SortOrder
    issuer_char_id?: SortOrderInput | SortOrder
  }

  export type offensesWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: offensesWhereInput | offensesWhereInput[]
    OR?: offensesWhereInput[]
    NOT?: offensesWhereInput | offensesWhereInput[]
    manager_id?: IntNullableFilter<"offenses"> | number | null
    charid?: IntNullableFilter<"offenses"> | number | null
    accountid?: IntNullableFilter<"offenses"> | number | null
    msg?: StringNullableFilter<"offenses"> | string | null
    type?: StringNullableFilter<"offenses"> | string | null
    issuedate?: DateTimeNullableFilter<"offenses"> | Date | string | null
    issuer_char_id?: IntNullableFilter<"offenses"> | number | null
  }, "id">

  export type offensesOrderByWithAggregationInput = {
    id?: SortOrder
    manager_id?: SortOrderInput | SortOrder
    charid?: SortOrderInput | SortOrder
    accountid?: SortOrderInput | SortOrder
    msg?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    issuedate?: SortOrderInput | SortOrder
    issuer_char_id?: SortOrderInput | SortOrder
    _count?: offensesCountOrderByAggregateInput
    _avg?: offensesAvgOrderByAggregateInput
    _max?: offensesMaxOrderByAggregateInput
    _min?: offensesMinOrderByAggregateInput
    _sum?: offensesSumOrderByAggregateInput
  }

  export type offensesScalarWhereWithAggregatesInput = {
    AND?: offensesScalarWhereWithAggregatesInput | offensesScalarWhereWithAggregatesInput[]
    OR?: offensesScalarWhereWithAggregatesInput[]
    NOT?: offensesScalarWhereWithAggregatesInput | offensesScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"offenses"> | bigint | number
    manager_id?: IntNullableWithAggregatesFilter<"offenses"> | number | null
    charid?: IntNullableWithAggregatesFilter<"offenses"> | number | null
    accountid?: IntNullableWithAggregatesFilter<"offenses"> | number | null
    msg?: StringNullableWithAggregatesFilter<"offenses"> | string | null
    type?: StringNullableWithAggregatesFilter<"offenses"> | string | null
    issuedate?: DateTimeNullableWithAggregatesFilter<"offenses"> | Date | string | null
    issuer_char_id?: IntNullableWithAggregatesFilter<"offenses"> | number | null
  }

  export type partyWhereInput = {
    AND?: partyWhereInput | partyWhereInput[]
    OR?: partyWhereInput[]
    NOT?: partyWhereInput | partyWhereInput[]
    id?: IntFilter<"party"> | number
    name?: StringNullableFilter<"party"> | string | null
    partyleaderid?: IntNullableFilter<"party"> | number | null
    appliable?: BoolNullableFilter<"party"> | boolean | null
    isprivateparty?: BoolNullableFilter<"party"> | boolean | null
  }

  export type partyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    partyleaderid?: SortOrderInput | SortOrder
    appliable?: SortOrderInput | SortOrder
    isprivateparty?: SortOrderInput | SortOrder
  }

  export type partyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: partyWhereInput | partyWhereInput[]
    OR?: partyWhereInput[]
    NOT?: partyWhereInput | partyWhereInput[]
    name?: StringNullableFilter<"party"> | string | null
    partyleaderid?: IntNullableFilter<"party"> | number | null
    appliable?: BoolNullableFilter<"party"> | boolean | null
    isprivateparty?: BoolNullableFilter<"party"> | boolean | null
  }, "id">

  export type partyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    partyleaderid?: SortOrderInput | SortOrder
    appliable?: SortOrderInput | SortOrder
    isprivateparty?: SortOrderInput | SortOrder
    _count?: partyCountOrderByAggregateInput
    _avg?: partyAvgOrderByAggregateInput
    _max?: partyMaxOrderByAggregateInput
    _min?: partyMinOrderByAggregateInput
    _sum?: partySumOrderByAggregateInput
  }

  export type partyScalarWhereWithAggregatesInput = {
    AND?: partyScalarWhereWithAggregatesInput | partyScalarWhereWithAggregatesInput[]
    OR?: partyScalarWhereWithAggregatesInput[]
    NOT?: partyScalarWhereWithAggregatesInput | partyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"party"> | number
    name?: StringNullableWithAggregatesFilter<"party"> | string | null
    partyleaderid?: IntNullableWithAggregatesFilter<"party"> | number | null
    appliable?: BoolNullableWithAggregatesFilter<"party"> | boolean | null
    isprivateparty?: BoolNullableWithAggregatesFilter<"party"> | boolean | null
  }

  export type partybossWhereInput = {
    AND?: partybossWhereInput | partybossWhereInput[]
    OR?: partybossWhereInput[]
    NOT?: partybossWhereInput | partybossWhereInput[]
    id?: IntFilter<"partyboss"> | number
    charid?: IntNullableFilter<"partyboss"> | number | null
    orderid?: IntNullableFilter<"partyboss"> | number | null
    bossname?: StringNullableFilter<"partyboss"> | string | null
    difficulty?: IntNullableFilter<"partyboss"> | number | null
    attempt?: IntNullableFilter<"partyboss"> | number | null
    lastattempttime?: DateTimeNullableFilter<"partyboss"> | Date | string | null
  }

  export type partybossOrderByWithRelationInput = {
    id?: SortOrder
    charid?: SortOrderInput | SortOrder
    orderid?: SortOrderInput | SortOrder
    bossname?: SortOrderInput | SortOrder
    difficulty?: SortOrderInput | SortOrder
    attempt?: SortOrderInput | SortOrder
    lastattempttime?: SortOrderInput | SortOrder
  }

  export type partybossWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: partybossWhereInput | partybossWhereInput[]
    OR?: partybossWhereInput[]
    NOT?: partybossWhereInput | partybossWhereInput[]
    charid?: IntNullableFilter<"partyboss"> | number | null
    orderid?: IntNullableFilter<"partyboss"> | number | null
    bossname?: StringNullableFilter<"partyboss"> | string | null
    difficulty?: IntNullableFilter<"partyboss"> | number | null
    attempt?: IntNullableFilter<"partyboss"> | number | null
    lastattempttime?: DateTimeNullableFilter<"partyboss"> | Date | string | null
  }, "id">

  export type partybossOrderByWithAggregationInput = {
    id?: SortOrder
    charid?: SortOrderInput | SortOrder
    orderid?: SortOrderInput | SortOrder
    bossname?: SortOrderInput | SortOrder
    difficulty?: SortOrderInput | SortOrder
    attempt?: SortOrderInput | SortOrder
    lastattempttime?: SortOrderInput | SortOrder
    _count?: partybossCountOrderByAggregateInput
    _avg?: partybossAvgOrderByAggregateInput
    _max?: partybossMaxOrderByAggregateInput
    _min?: partybossMinOrderByAggregateInput
    _sum?: partybossSumOrderByAggregateInput
  }

  export type partybossScalarWhereWithAggregatesInput = {
    AND?: partybossScalarWhereWithAggregatesInput | partybossScalarWhereWithAggregatesInput[]
    OR?: partybossScalarWhereWithAggregatesInput[]
    NOT?: partybossScalarWhereWithAggregatesInput | partybossScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"partyboss"> | number
    charid?: IntNullableWithAggregatesFilter<"partyboss"> | number | null
    orderid?: IntNullableWithAggregatesFilter<"partyboss"> | number | null
    bossname?: StringNullableWithAggregatesFilter<"partyboss"> | string | null
    difficulty?: IntNullableWithAggregatesFilter<"partyboss"> | number | null
    attempt?: IntNullableWithAggregatesFilter<"partyboss"> | number | null
    lastattempttime?: DateTimeNullableWithAggregatesFilter<"partyboss"> | Date | string | null
  }

  export type partymembersWhereInput = {
    AND?: partymembersWhereInput | partymembersWhereInput[]
    OR?: partymembersWhereInput[]
    NOT?: partymembersWhereInput | partymembersWhereInput[]
    id?: IntFilter<"partymembers"> | number
    partyid?: IntNullableFilter<"partymembers"> | number | null
    charid?: IntNullableFilter<"partymembers"> | number | null
    name?: StringNullableFilter<"partymembers"> | string | null
    job?: IntNullableFilter<"partymembers"> | number | null
    subJob?: IntNullableFilter<"partymembers"> | number | null
    level?: IntNullableFilter<"partymembers"> | number | null
    channel?: IntNullableFilter<"partymembers"> | number | null
    fieldid?: IntNullableFilter<"partymembers"> | number | null
    loggedin?: BoolNullableFilter<"partymembers"> | boolean | null
  }

  export type partymembersOrderByWithRelationInput = {
    id?: SortOrder
    partyid?: SortOrderInput | SortOrder
    charid?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    job?: SortOrderInput | SortOrder
    subJob?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    channel?: SortOrderInput | SortOrder
    fieldid?: SortOrderInput | SortOrder
    loggedin?: SortOrderInput | SortOrder
  }

  export type partymembersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: partymembersWhereInput | partymembersWhereInput[]
    OR?: partymembersWhereInput[]
    NOT?: partymembersWhereInput | partymembersWhereInput[]
    partyid?: IntNullableFilter<"partymembers"> | number | null
    charid?: IntNullableFilter<"partymembers"> | number | null
    name?: StringNullableFilter<"partymembers"> | string | null
    job?: IntNullableFilter<"partymembers"> | number | null
    subJob?: IntNullableFilter<"partymembers"> | number | null
    level?: IntNullableFilter<"partymembers"> | number | null
    channel?: IntNullableFilter<"partymembers"> | number | null
    fieldid?: IntNullableFilter<"partymembers"> | number | null
    loggedin?: BoolNullableFilter<"partymembers"> | boolean | null
  }, "id">

  export type partymembersOrderByWithAggregationInput = {
    id?: SortOrder
    partyid?: SortOrderInput | SortOrder
    charid?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    job?: SortOrderInput | SortOrder
    subJob?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    channel?: SortOrderInput | SortOrder
    fieldid?: SortOrderInput | SortOrder
    loggedin?: SortOrderInput | SortOrder
    _count?: partymembersCountOrderByAggregateInput
    _avg?: partymembersAvgOrderByAggregateInput
    _max?: partymembersMaxOrderByAggregateInput
    _min?: partymembersMinOrderByAggregateInput
    _sum?: partymembersSumOrderByAggregateInput
  }

  export type partymembersScalarWhereWithAggregatesInput = {
    AND?: partymembersScalarWhereWithAggregatesInput | partymembersScalarWhereWithAggregatesInput[]
    OR?: partymembersScalarWhereWithAggregatesInput[]
    NOT?: partymembersScalarWhereWithAggregatesInput | partymembersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"partymembers"> | number
    partyid?: IntNullableWithAggregatesFilter<"partymembers"> | number | null
    charid?: IntNullableWithAggregatesFilter<"partymembers"> | number | null
    name?: StringNullableWithAggregatesFilter<"partymembers"> | string | null
    job?: IntNullableWithAggregatesFilter<"partymembers"> | number | null
    subJob?: IntNullableWithAggregatesFilter<"partymembers"> | number | null
    level?: IntNullableWithAggregatesFilter<"partymembers"> | number | null
    channel?: IntNullableWithAggregatesFilter<"partymembers"> | number | null
    fieldid?: IntNullableWithAggregatesFilter<"partymembers"> | number | null
    loggedin?: BoolNullableWithAggregatesFilter<"partymembers"> | boolean | null
  }

  export type petidsWhereInput = {
    AND?: petidsWhereInput | petidsWhereInput[]
    OR?: petidsWhereInput[]
    NOT?: petidsWhereInput | petidsWhereInput[]
    id?: IntFilter<"petids"> | number
    alid?: IntNullableFilter<"petids"> | number | null
    petid?: IntNullableFilter<"petids"> | number | null
  }

  export type petidsOrderByWithRelationInput = {
    id?: SortOrder
    alid?: SortOrderInput | SortOrder
    petid?: SortOrderInput | SortOrder
  }

  export type petidsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: petidsWhereInput | petidsWhereInput[]
    OR?: petidsWhereInput[]
    NOT?: petidsWhereInput | petidsWhereInput[]
    alid?: IntNullableFilter<"petids"> | number | null
    petid?: IntNullableFilter<"petids"> | number | null
  }, "id">

  export type petidsOrderByWithAggregationInput = {
    id?: SortOrder
    alid?: SortOrderInput | SortOrder
    petid?: SortOrderInput | SortOrder
    _count?: petidsCountOrderByAggregateInput
    _avg?: petidsAvgOrderByAggregateInput
    _max?: petidsMaxOrderByAggregateInput
    _min?: petidsMinOrderByAggregateInput
    _sum?: petidsSumOrderByAggregateInput
  }

  export type petidsScalarWhereWithAggregatesInput = {
    AND?: petidsScalarWhereWithAggregatesInput | petidsScalarWhereWithAggregatesInput[]
    OR?: petidsScalarWhereWithAggregatesInput[]
    NOT?: petidsScalarWhereWithAggregatesInput | petidsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"petids"> | number
    alid?: IntNullableWithAggregatesFilter<"petids"> | number | null
    petid?: IntNullableWithAggregatesFilter<"petids"> | number | null
  }

  export type petitemsWhereInput = {
    AND?: petitemsWhereInput | petitemsWhereInput[]
    OR?: petitemsWhereInput[]
    NOT?: petitemsWhereInput | petitemsWhereInput[]
    itemid?: BigIntFilter<"petitems"> | bigint | number
    name?: StringNullableFilter<"petitems"> | string | null
    level?: IntNullableFilter<"petitems"> | number | null
    tameness?: IntNullableFilter<"petitems"> | number | null
    repleteness?: IntNullableFilter<"petitems"> | number | null
    petattribute?: IntNullableFilter<"petitems"> | number | null
    petskill?: IntNullableFilter<"petitems"> | number | null
    datedead?: DateTimeNullableFilter<"petitems"> | Date | string | null
    remainlife?: IntNullableFilter<"petitems"> | number | null
    attribute?: IntNullableFilter<"petitems"> | number | null
    activestate?: IntNullableFilter<"petitems"> | number | null
    autobuffskill?: IntNullableFilter<"petitems"> | number | null
    pethue?: IntNullableFilter<"petitems"> | number | null
    giantrate?: IntNullableFilter<"petitems"> | number | null
    exceptionList?: StringNullableFilter<"petitems"> | string | null
  }

  export type petitemsOrderByWithRelationInput = {
    itemid?: SortOrder
    name?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    tameness?: SortOrderInput | SortOrder
    repleteness?: SortOrderInput | SortOrder
    petattribute?: SortOrderInput | SortOrder
    petskill?: SortOrderInput | SortOrder
    datedead?: SortOrderInput | SortOrder
    remainlife?: SortOrderInput | SortOrder
    attribute?: SortOrderInput | SortOrder
    activestate?: SortOrderInput | SortOrder
    autobuffskill?: SortOrderInput | SortOrder
    pethue?: SortOrderInput | SortOrder
    giantrate?: SortOrderInput | SortOrder
    exceptionList?: SortOrderInput | SortOrder
  }

  export type petitemsWhereUniqueInput = Prisma.AtLeast<{
    itemid?: bigint | number
    AND?: petitemsWhereInput | petitemsWhereInput[]
    OR?: petitemsWhereInput[]
    NOT?: petitemsWhereInput | petitemsWhereInput[]
    name?: StringNullableFilter<"petitems"> | string | null
    level?: IntNullableFilter<"petitems"> | number | null
    tameness?: IntNullableFilter<"petitems"> | number | null
    repleteness?: IntNullableFilter<"petitems"> | number | null
    petattribute?: IntNullableFilter<"petitems"> | number | null
    petskill?: IntNullableFilter<"petitems"> | number | null
    datedead?: DateTimeNullableFilter<"petitems"> | Date | string | null
    remainlife?: IntNullableFilter<"petitems"> | number | null
    attribute?: IntNullableFilter<"petitems"> | number | null
    activestate?: IntNullableFilter<"petitems"> | number | null
    autobuffskill?: IntNullableFilter<"petitems"> | number | null
    pethue?: IntNullableFilter<"petitems"> | number | null
    giantrate?: IntNullableFilter<"petitems"> | number | null
    exceptionList?: StringNullableFilter<"petitems"> | string | null
  }, "itemid">

  export type petitemsOrderByWithAggregationInput = {
    itemid?: SortOrder
    name?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    tameness?: SortOrderInput | SortOrder
    repleteness?: SortOrderInput | SortOrder
    petattribute?: SortOrderInput | SortOrder
    petskill?: SortOrderInput | SortOrder
    datedead?: SortOrderInput | SortOrder
    remainlife?: SortOrderInput | SortOrder
    attribute?: SortOrderInput | SortOrder
    activestate?: SortOrderInput | SortOrder
    autobuffskill?: SortOrderInput | SortOrder
    pethue?: SortOrderInput | SortOrder
    giantrate?: SortOrderInput | SortOrder
    exceptionList?: SortOrderInput | SortOrder
    _count?: petitemsCountOrderByAggregateInput
    _avg?: petitemsAvgOrderByAggregateInput
    _max?: petitemsMaxOrderByAggregateInput
    _min?: petitemsMinOrderByAggregateInput
    _sum?: petitemsSumOrderByAggregateInput
  }

  export type petitemsScalarWhereWithAggregatesInput = {
    AND?: petitemsScalarWhereWithAggregatesInput | petitemsScalarWhereWithAggregatesInput[]
    OR?: petitemsScalarWhereWithAggregatesInput[]
    NOT?: petitemsScalarWhereWithAggregatesInput | petitemsScalarWhereWithAggregatesInput[]
    itemid?: BigIntWithAggregatesFilter<"petitems"> | bigint | number
    name?: StringNullableWithAggregatesFilter<"petitems"> | string | null
    level?: IntNullableWithAggregatesFilter<"petitems"> | number | null
    tameness?: IntNullableWithAggregatesFilter<"petitems"> | number | null
    repleteness?: IntNullableWithAggregatesFilter<"petitems"> | number | null
    petattribute?: IntNullableWithAggregatesFilter<"petitems"> | number | null
    petskill?: IntNullableWithAggregatesFilter<"petitems"> | number | null
    datedead?: DateTimeNullableWithAggregatesFilter<"petitems"> | Date | string | null
    remainlife?: IntNullableWithAggregatesFilter<"petitems"> | number | null
    attribute?: IntNullableWithAggregatesFilter<"petitems"> | number | null
    activestate?: IntNullableWithAggregatesFilter<"petitems"> | number | null
    autobuffskill?: IntNullableWithAggregatesFilter<"petitems"> | number | null
    pethue?: IntNullableWithAggregatesFilter<"petitems"> | number | null
    giantrate?: IntNullableWithAggregatesFilter<"petitems"> | number | null
    exceptionList?: StringNullableWithAggregatesFilter<"petitems"> | string | null
  }

  export type questlistsWhereInput = {
    AND?: questlistsWhereInput | questlistsWhereInput[]
    OR?: questlistsWhereInput[]
    NOT?: questlistsWhereInput | questlistsWhereInput[]
    questlist_id?: BigIntFilter<"questlists"> | bigint | number
    questmanager_id?: BigIntNullableFilter<"questlists"> | bigint | number | null
    questid?: IntNullableFilter<"questlists"> | number | null
    fk_questid?: BigIntNullableFilter<"questlists"> | bigint | number | null
  }

  export type questlistsOrderByWithRelationInput = {
    questlist_id?: SortOrder
    questmanager_id?: SortOrderInput | SortOrder
    questid?: SortOrderInput | SortOrder
    fk_questid?: SortOrderInput | SortOrder
  }

  export type questlistsWhereUniqueInput = Prisma.AtLeast<{
    questlist_id?: bigint | number
    AND?: questlistsWhereInput | questlistsWhereInput[]
    OR?: questlistsWhereInput[]
    NOT?: questlistsWhereInput | questlistsWhereInput[]
    questmanager_id?: BigIntNullableFilter<"questlists"> | bigint | number | null
    questid?: IntNullableFilter<"questlists"> | number | null
    fk_questid?: BigIntNullableFilter<"questlists"> | bigint | number | null
  }, "questlist_id">

  export type questlistsOrderByWithAggregationInput = {
    questlist_id?: SortOrder
    questmanager_id?: SortOrderInput | SortOrder
    questid?: SortOrderInput | SortOrder
    fk_questid?: SortOrderInput | SortOrder
    _count?: questlistsCountOrderByAggregateInput
    _avg?: questlistsAvgOrderByAggregateInput
    _max?: questlistsMaxOrderByAggregateInput
    _min?: questlistsMinOrderByAggregateInput
    _sum?: questlistsSumOrderByAggregateInput
  }

  export type questlistsScalarWhereWithAggregatesInput = {
    AND?: questlistsScalarWhereWithAggregatesInput | questlistsScalarWhereWithAggregatesInput[]
    OR?: questlistsScalarWhereWithAggregatesInput[]
    NOT?: questlistsScalarWhereWithAggregatesInput | questlistsScalarWhereWithAggregatesInput[]
    questlist_id?: BigIntWithAggregatesFilter<"questlists"> | bigint | number
    questmanager_id?: BigIntNullableWithAggregatesFilter<"questlists"> | bigint | number | null
    questid?: IntNullableWithAggregatesFilter<"questlists"> | number | null
    fk_questid?: BigIntNullableWithAggregatesFilter<"questlists"> | bigint | number | null
  }

  export type questmanagersWhereInput = {
    AND?: questmanagersWhereInput | questmanagersWhereInput[]
    OR?: questmanagersWhereInput[]
    NOT?: questmanagersWhereInput | questmanagersWhereInput[]
    id?: BigIntFilter<"questmanagers"> | bigint | number
  }

  export type questmanagersOrderByWithRelationInput = {
    id?: SortOrder
  }

  export type questmanagersWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: questmanagersWhereInput | questmanagersWhereInput[]
    OR?: questmanagersWhereInput[]
    NOT?: questmanagersWhereInput | questmanagersWhereInput[]
  }, "id">

  export type questmanagersOrderByWithAggregationInput = {
    id?: SortOrder
    _count?: questmanagersCountOrderByAggregateInput
    _avg?: questmanagersAvgOrderByAggregateInput
    _max?: questmanagersMaxOrderByAggregateInput
    _min?: questmanagersMinOrderByAggregateInput
    _sum?: questmanagersSumOrderByAggregateInput
  }

  export type questmanagersScalarWhereWithAggregatesInput = {
    AND?: questmanagersScalarWhereWithAggregatesInput | questmanagersScalarWhereWithAggregatesInput[]
    OR?: questmanagersScalarWhereWithAggregatesInput[]
    NOT?: questmanagersScalarWhereWithAggregatesInput | questmanagersScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"questmanagers"> | bigint | number
  }

  export type questprogressrequirementsWhereInput = {
    AND?: questprogressrequirementsWhereInput | questprogressrequirementsWhereInput[]
    OR?: questprogressrequirementsWhereInput[]
    NOT?: questprogressrequirementsWhereInput | questprogressrequirementsWhereInput[]
    id?: BigIntFilter<"questprogressrequirements"> | bigint | number
    orderNum?: IntNullableFilter<"questprogressrequirements"> | number | null
    progresstype?: StringNullableFilter<"questprogressrequirements"> | string | null
    questid?: BigIntNullableFilter<"questprogressrequirements"> | bigint | number | null
    unitid?: IntNullableFilter<"questprogressrequirements"> | number | null
    requiredcount?: IntNullableFilter<"questprogressrequirements"> | number | null
    currentcount?: IntNullableFilter<"questprogressrequirements"> | number | null
  }

  export type questprogressrequirementsOrderByWithRelationInput = {
    id?: SortOrder
    orderNum?: SortOrderInput | SortOrder
    progresstype?: SortOrderInput | SortOrder
    questid?: SortOrderInput | SortOrder
    unitid?: SortOrderInput | SortOrder
    requiredcount?: SortOrderInput | SortOrder
    currentcount?: SortOrderInput | SortOrder
  }

  export type questprogressrequirementsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: questprogressrequirementsWhereInput | questprogressrequirementsWhereInput[]
    OR?: questprogressrequirementsWhereInput[]
    NOT?: questprogressrequirementsWhereInput | questprogressrequirementsWhereInput[]
    orderNum?: IntNullableFilter<"questprogressrequirements"> | number | null
    progresstype?: StringNullableFilter<"questprogressrequirements"> | string | null
    questid?: BigIntNullableFilter<"questprogressrequirements"> | bigint | number | null
    unitid?: IntNullableFilter<"questprogressrequirements"> | number | null
    requiredcount?: IntNullableFilter<"questprogressrequirements"> | number | null
    currentcount?: IntNullableFilter<"questprogressrequirements"> | number | null
  }, "id">

  export type questprogressrequirementsOrderByWithAggregationInput = {
    id?: SortOrder
    orderNum?: SortOrderInput | SortOrder
    progresstype?: SortOrderInput | SortOrder
    questid?: SortOrderInput | SortOrder
    unitid?: SortOrderInput | SortOrder
    requiredcount?: SortOrderInput | SortOrder
    currentcount?: SortOrderInput | SortOrder
    _count?: questprogressrequirementsCountOrderByAggregateInput
    _avg?: questprogressrequirementsAvgOrderByAggregateInput
    _max?: questprogressrequirementsMaxOrderByAggregateInput
    _min?: questprogressrequirementsMinOrderByAggregateInput
    _sum?: questprogressrequirementsSumOrderByAggregateInput
  }

  export type questprogressrequirementsScalarWhereWithAggregatesInput = {
    AND?: questprogressrequirementsScalarWhereWithAggregatesInput | questprogressrequirementsScalarWhereWithAggregatesInput[]
    OR?: questprogressrequirementsScalarWhereWithAggregatesInput[]
    NOT?: questprogressrequirementsScalarWhereWithAggregatesInput | questprogressrequirementsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"questprogressrequirements"> | bigint | number
    orderNum?: IntNullableWithAggregatesFilter<"questprogressrequirements"> | number | null
    progresstype?: StringNullableWithAggregatesFilter<"questprogressrequirements"> | string | null
    questid?: BigIntNullableWithAggregatesFilter<"questprogressrequirements"> | bigint | number | null
    unitid?: IntNullableWithAggregatesFilter<"questprogressrequirements"> | number | null
    requiredcount?: IntNullableWithAggregatesFilter<"questprogressrequirements"> | number | null
    currentcount?: IntNullableWithAggregatesFilter<"questprogressrequirements"> | number | null
  }

  export type questsWhereInput = {
    AND?: questsWhereInput | questsWhereInput[]
    OR?: questsWhereInput[]
    NOT?: questsWhereInput | questsWhereInput[]
    id?: BigIntFilter<"quests"> | bigint | number
    qrkey?: IntNullableFilter<"quests"> | number | null
    qrvalue?: StringNullableFilter<"quests"> | string | null
    status?: IntNullableFilter<"quests"> | number | null
    completedtime?: DateTimeNullableFilter<"quests"> | Date | string | null
    expireterm?: DateTimeNullableFilter<"quests"> | Date | string | null
  }

  export type questsOrderByWithRelationInput = {
    id?: SortOrder
    qrkey?: SortOrderInput | SortOrder
    qrvalue?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    completedtime?: SortOrderInput | SortOrder
    expireterm?: SortOrderInput | SortOrder
  }

  export type questsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: questsWhereInput | questsWhereInput[]
    OR?: questsWhereInput[]
    NOT?: questsWhereInput | questsWhereInput[]
    qrkey?: IntNullableFilter<"quests"> | number | null
    qrvalue?: StringNullableFilter<"quests"> | string | null
    status?: IntNullableFilter<"quests"> | number | null
    completedtime?: DateTimeNullableFilter<"quests"> | Date | string | null
    expireterm?: DateTimeNullableFilter<"quests"> | Date | string | null
  }, "id">

  export type questsOrderByWithAggregationInput = {
    id?: SortOrder
    qrkey?: SortOrderInput | SortOrder
    qrvalue?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    completedtime?: SortOrderInput | SortOrder
    expireterm?: SortOrderInput | SortOrder
    _count?: questsCountOrderByAggregateInput
    _avg?: questsAvgOrderByAggregateInput
    _max?: questsMaxOrderByAggregateInput
    _min?: questsMinOrderByAggregateInput
    _sum?: questsSumOrderByAggregateInput
  }

  export type questsScalarWhereWithAggregatesInput = {
    AND?: questsScalarWhereWithAggregatesInput | questsScalarWhereWithAggregatesInput[]
    OR?: questsScalarWhereWithAggregatesInput[]
    NOT?: questsScalarWhereWithAggregatesInput | questsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"quests"> | bigint | number
    qrkey?: IntNullableWithAggregatesFilter<"quests"> | number | null
    qrvalue?: StringNullableWithAggregatesFilter<"quests"> | string | null
    status?: IntNullableWithAggregatesFilter<"quests"> | number | null
    completedtime?: DateTimeNullableWithAggregatesFilter<"quests"> | Date | string | null
    expireterm?: DateTimeNullableWithAggregatesFilter<"quests"> | Date | string | null
  }

  export type rewardinfoWhereInput = {
    AND?: rewardinfoWhereInput | rewardinfoWhereInput[]
    OR?: rewardinfoWhereInput[]
    NOT?: rewardinfoWhereInput | rewardinfoWhereInput[]
    id?: IntFilter<"rewardinfo"> | number
    charid?: IntFilter<"rewardinfo"> | number
    charname?: StringFilter<"rewardinfo"> | string
    rewardItemType?: BoolFilter<"rewardinfo"> | boolean
    itemID?: IntFilter<"rewardinfo"> | number
    quantity?: IntFilter<"rewardinfo"> | number
    maplePoint?: IntFilter<"rewardinfo"> | number
    meso?: IntFilter<"rewardinfo"> | number
    level?: IntFilter<"rewardinfo"> | number
    exp?: IntFilter<"rewardinfo"> | number
    description?: StringFilter<"rewardinfo"> | string
    starttime?: DateTimeNullableFilter<"rewardinfo"> | Date | string | null
    endtime?: DateTimeNullableFilter<"rewardinfo"> | Date | string | null
  }

  export type rewardinfoOrderByWithRelationInput = {
    id?: SortOrder
    charid?: SortOrder
    charname?: SortOrder
    rewardItemType?: SortOrder
    itemID?: SortOrder
    quantity?: SortOrder
    maplePoint?: SortOrder
    meso?: SortOrder
    level?: SortOrder
    exp?: SortOrder
    description?: SortOrder
    starttime?: SortOrderInput | SortOrder
    endtime?: SortOrderInput | SortOrder
  }

  export type rewardinfoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: rewardinfoWhereInput | rewardinfoWhereInput[]
    OR?: rewardinfoWhereInput[]
    NOT?: rewardinfoWhereInput | rewardinfoWhereInput[]
    charid?: IntFilter<"rewardinfo"> | number
    charname?: StringFilter<"rewardinfo"> | string
    rewardItemType?: BoolFilter<"rewardinfo"> | boolean
    itemID?: IntFilter<"rewardinfo"> | number
    quantity?: IntFilter<"rewardinfo"> | number
    maplePoint?: IntFilter<"rewardinfo"> | number
    meso?: IntFilter<"rewardinfo"> | number
    level?: IntFilter<"rewardinfo"> | number
    exp?: IntFilter<"rewardinfo"> | number
    description?: StringFilter<"rewardinfo"> | string
    starttime?: DateTimeNullableFilter<"rewardinfo"> | Date | string | null
    endtime?: DateTimeNullableFilter<"rewardinfo"> | Date | string | null
  }, "id">

  export type rewardinfoOrderByWithAggregationInput = {
    id?: SortOrder
    charid?: SortOrder
    charname?: SortOrder
    rewardItemType?: SortOrder
    itemID?: SortOrder
    quantity?: SortOrder
    maplePoint?: SortOrder
    meso?: SortOrder
    level?: SortOrder
    exp?: SortOrder
    description?: SortOrder
    starttime?: SortOrderInput | SortOrder
    endtime?: SortOrderInput | SortOrder
    _count?: rewardinfoCountOrderByAggregateInput
    _avg?: rewardinfoAvgOrderByAggregateInput
    _max?: rewardinfoMaxOrderByAggregateInput
    _min?: rewardinfoMinOrderByAggregateInput
    _sum?: rewardinfoSumOrderByAggregateInput
  }

  export type rewardinfoScalarWhereWithAggregatesInput = {
    AND?: rewardinfoScalarWhereWithAggregatesInput | rewardinfoScalarWhereWithAggregatesInput[]
    OR?: rewardinfoScalarWhereWithAggregatesInput[]
    NOT?: rewardinfoScalarWhereWithAggregatesInput | rewardinfoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"rewardinfo"> | number
    charid?: IntWithAggregatesFilter<"rewardinfo"> | number
    charname?: StringWithAggregatesFilter<"rewardinfo"> | string
    rewardItemType?: BoolWithAggregatesFilter<"rewardinfo"> | boolean
    itemID?: IntWithAggregatesFilter<"rewardinfo"> | number
    quantity?: IntWithAggregatesFilter<"rewardinfo"> | number
    maplePoint?: IntWithAggregatesFilter<"rewardinfo"> | number
    meso?: IntWithAggregatesFilter<"rewardinfo"> | number
    level?: IntWithAggregatesFilter<"rewardinfo"> | number
    exp?: IntWithAggregatesFilter<"rewardinfo"> | number
    description?: StringWithAggregatesFilter<"rewardinfo"> | string
    starttime?: DateTimeNullableWithAggregatesFilter<"rewardinfo"> | Date | string | null
    endtime?: DateTimeNullableWithAggregatesFilter<"rewardinfo"> | Date | string | null
  }

  export type shopitemsWhereInput = {
    AND?: shopitemsWhereInput | shopitemsWhereInput[]
    OR?: shopitemsWhereInput[]
    NOT?: shopitemsWhereInput | shopitemsWhereInput[]
    id?: BigIntFilter<"shopitems"> | bigint | number
    shopid?: IntNullableFilter<"shopitems"> | number | null
    itemid?: IntNullableFilter<"shopitems"> | number | null
    price?: IntNullableFilter<"shopitems"> | number | null
    tokenitemid?: IntNullableFilter<"shopitems"> | number | null
    tokenprice?: IntNullableFilter<"shopitems"> | number | null
    pointquestid?: IntNullableFilter<"shopitems"> | number | null
    pointprice?: IntNullableFilter<"shopitems"> | number | null
    starcoin?: IntNullableFilter<"shopitems"> | number | null
    questexid?: IntNullableFilter<"shopitems"> | number | null
    questexkey?: StringNullableFilter<"shopitems"> | string | null
    questexvalue?: IntNullableFilter<"shopitems"> | number | null
    itemperiod?: IntNullableFilter<"shopitems"> | number | null
    levellimited?: IntNullableFilter<"shopitems"> | number | null
    showlevmin?: IntNullableFilter<"shopitems"> | number | null
    showlevmax?: IntNullableFilter<"shopitems"> | number | null
    questid?: IntNullableFilter<"shopitems"> | number | null
    sellstart?: DateTimeNullableFilter<"shopitems"> | Date | string | null
    sellend?: DateTimeNullableFilter<"shopitems"> | Date | string | null
    tabindex?: IntNullableFilter<"shopitems"> | number | null
    worldblock?: BoolNullableFilter<"shopitems"> | boolean | null
    potentialgrade?: IntNullableFilter<"shopitems"> | number | null
    buylimit?: IntNullableFilter<"shopitems"> | number | null
    quantity?: IntNullableFilter<"shopitems"> | number | null
    unitprice?: BigIntNullableFilter<"shopitems"> | bigint | number | null
    maxperslot?: IntNullableFilter<"shopitems"> | number | null
    discountperc?: IntNullableFilter<"shopitems"> | number | null
  }

  export type shopitemsOrderByWithRelationInput = {
    id?: SortOrder
    shopid?: SortOrderInput | SortOrder
    itemid?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    tokenitemid?: SortOrderInput | SortOrder
    tokenprice?: SortOrderInput | SortOrder
    pointquestid?: SortOrderInput | SortOrder
    pointprice?: SortOrderInput | SortOrder
    starcoin?: SortOrderInput | SortOrder
    questexid?: SortOrderInput | SortOrder
    questexkey?: SortOrderInput | SortOrder
    questexvalue?: SortOrderInput | SortOrder
    itemperiod?: SortOrderInput | SortOrder
    levellimited?: SortOrderInput | SortOrder
    showlevmin?: SortOrderInput | SortOrder
    showlevmax?: SortOrderInput | SortOrder
    questid?: SortOrderInput | SortOrder
    sellstart?: SortOrderInput | SortOrder
    sellend?: SortOrderInput | SortOrder
    tabindex?: SortOrderInput | SortOrder
    worldblock?: SortOrderInput | SortOrder
    potentialgrade?: SortOrderInput | SortOrder
    buylimit?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    unitprice?: SortOrderInput | SortOrder
    maxperslot?: SortOrderInput | SortOrder
    discountperc?: SortOrderInput | SortOrder
  }

  export type shopitemsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: shopitemsWhereInput | shopitemsWhereInput[]
    OR?: shopitemsWhereInput[]
    NOT?: shopitemsWhereInput | shopitemsWhereInput[]
    shopid?: IntNullableFilter<"shopitems"> | number | null
    itemid?: IntNullableFilter<"shopitems"> | number | null
    price?: IntNullableFilter<"shopitems"> | number | null
    tokenitemid?: IntNullableFilter<"shopitems"> | number | null
    tokenprice?: IntNullableFilter<"shopitems"> | number | null
    pointquestid?: IntNullableFilter<"shopitems"> | number | null
    pointprice?: IntNullableFilter<"shopitems"> | number | null
    starcoin?: IntNullableFilter<"shopitems"> | number | null
    questexid?: IntNullableFilter<"shopitems"> | number | null
    questexkey?: StringNullableFilter<"shopitems"> | string | null
    questexvalue?: IntNullableFilter<"shopitems"> | number | null
    itemperiod?: IntNullableFilter<"shopitems"> | number | null
    levellimited?: IntNullableFilter<"shopitems"> | number | null
    showlevmin?: IntNullableFilter<"shopitems"> | number | null
    showlevmax?: IntNullableFilter<"shopitems"> | number | null
    questid?: IntNullableFilter<"shopitems"> | number | null
    sellstart?: DateTimeNullableFilter<"shopitems"> | Date | string | null
    sellend?: DateTimeNullableFilter<"shopitems"> | Date | string | null
    tabindex?: IntNullableFilter<"shopitems"> | number | null
    worldblock?: BoolNullableFilter<"shopitems"> | boolean | null
    potentialgrade?: IntNullableFilter<"shopitems"> | number | null
    buylimit?: IntNullableFilter<"shopitems"> | number | null
    quantity?: IntNullableFilter<"shopitems"> | number | null
    unitprice?: BigIntNullableFilter<"shopitems"> | bigint | number | null
    maxperslot?: IntNullableFilter<"shopitems"> | number | null
    discountperc?: IntNullableFilter<"shopitems"> | number | null
  }, "id">

  export type shopitemsOrderByWithAggregationInput = {
    id?: SortOrder
    shopid?: SortOrderInput | SortOrder
    itemid?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    tokenitemid?: SortOrderInput | SortOrder
    tokenprice?: SortOrderInput | SortOrder
    pointquestid?: SortOrderInput | SortOrder
    pointprice?: SortOrderInput | SortOrder
    starcoin?: SortOrderInput | SortOrder
    questexid?: SortOrderInput | SortOrder
    questexkey?: SortOrderInput | SortOrder
    questexvalue?: SortOrderInput | SortOrder
    itemperiod?: SortOrderInput | SortOrder
    levellimited?: SortOrderInput | SortOrder
    showlevmin?: SortOrderInput | SortOrder
    showlevmax?: SortOrderInput | SortOrder
    questid?: SortOrderInput | SortOrder
    sellstart?: SortOrderInput | SortOrder
    sellend?: SortOrderInput | SortOrder
    tabindex?: SortOrderInput | SortOrder
    worldblock?: SortOrderInput | SortOrder
    potentialgrade?: SortOrderInput | SortOrder
    buylimit?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    unitprice?: SortOrderInput | SortOrder
    maxperslot?: SortOrderInput | SortOrder
    discountperc?: SortOrderInput | SortOrder
    _count?: shopitemsCountOrderByAggregateInput
    _avg?: shopitemsAvgOrderByAggregateInput
    _max?: shopitemsMaxOrderByAggregateInput
    _min?: shopitemsMinOrderByAggregateInput
    _sum?: shopitemsSumOrderByAggregateInput
  }

  export type shopitemsScalarWhereWithAggregatesInput = {
    AND?: shopitemsScalarWhereWithAggregatesInput | shopitemsScalarWhereWithAggregatesInput[]
    OR?: shopitemsScalarWhereWithAggregatesInput[]
    NOT?: shopitemsScalarWhereWithAggregatesInput | shopitemsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"shopitems"> | bigint | number
    shopid?: IntNullableWithAggregatesFilter<"shopitems"> | number | null
    itemid?: IntNullableWithAggregatesFilter<"shopitems"> | number | null
    price?: IntNullableWithAggregatesFilter<"shopitems"> | number | null
    tokenitemid?: IntNullableWithAggregatesFilter<"shopitems"> | number | null
    tokenprice?: IntNullableWithAggregatesFilter<"shopitems"> | number | null
    pointquestid?: IntNullableWithAggregatesFilter<"shopitems"> | number | null
    pointprice?: IntNullableWithAggregatesFilter<"shopitems"> | number | null
    starcoin?: IntNullableWithAggregatesFilter<"shopitems"> | number | null
    questexid?: IntNullableWithAggregatesFilter<"shopitems"> | number | null
    questexkey?: StringNullableWithAggregatesFilter<"shopitems"> | string | null
    questexvalue?: IntNullableWithAggregatesFilter<"shopitems"> | number | null
    itemperiod?: IntNullableWithAggregatesFilter<"shopitems"> | number | null
    levellimited?: IntNullableWithAggregatesFilter<"shopitems"> | number | null
    showlevmin?: IntNullableWithAggregatesFilter<"shopitems"> | number | null
    showlevmax?: IntNullableWithAggregatesFilter<"shopitems"> | number | null
    questid?: IntNullableWithAggregatesFilter<"shopitems"> | number | null
    sellstart?: DateTimeNullableWithAggregatesFilter<"shopitems"> | Date | string | null
    sellend?: DateTimeNullableWithAggregatesFilter<"shopitems"> | Date | string | null
    tabindex?: IntNullableWithAggregatesFilter<"shopitems"> | number | null
    worldblock?: BoolNullableWithAggregatesFilter<"shopitems"> | boolean | null
    potentialgrade?: IntNullableWithAggregatesFilter<"shopitems"> | number | null
    buylimit?: IntNullableWithAggregatesFilter<"shopitems"> | number | null
    quantity?: IntNullableWithAggregatesFilter<"shopitems"> | number | null
    unitprice?: BigIntNullableWithAggregatesFilter<"shopitems"> | bigint | number | null
    maxperslot?: IntNullableWithAggregatesFilter<"shopitems"> | number | null
    discountperc?: IntNullableWithAggregatesFilter<"shopitems"> | number | null
  }

  export type skillcooltimesWhereInput = {
    AND?: skillcooltimesWhereInput | skillcooltimesWhereInput[]
    OR?: skillcooltimesWhereInput[]
    NOT?: skillcooltimesWhereInput | skillcooltimesWhereInput[]
    id?: IntFilter<"skillcooltimes"> | number
    charid?: IntNullableFilter<"skillcooltimes"> | number | null
    skillid?: IntNullableFilter<"skillcooltimes"> | number | null
    nextusabletime?: BigIntNullableFilter<"skillcooltimes"> | bigint | number | null
  }

  export type skillcooltimesOrderByWithRelationInput = {
    id?: SortOrder
    charid?: SortOrderInput | SortOrder
    skillid?: SortOrderInput | SortOrder
    nextusabletime?: SortOrderInput | SortOrder
  }

  export type skillcooltimesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: skillcooltimesWhereInput | skillcooltimesWhereInput[]
    OR?: skillcooltimesWhereInput[]
    NOT?: skillcooltimesWhereInput | skillcooltimesWhereInput[]
    charid?: IntNullableFilter<"skillcooltimes"> | number | null
    skillid?: IntNullableFilter<"skillcooltimes"> | number | null
    nextusabletime?: BigIntNullableFilter<"skillcooltimes"> | bigint | number | null
  }, "id">

  export type skillcooltimesOrderByWithAggregationInput = {
    id?: SortOrder
    charid?: SortOrderInput | SortOrder
    skillid?: SortOrderInput | SortOrder
    nextusabletime?: SortOrderInput | SortOrder
    _count?: skillcooltimesCountOrderByAggregateInput
    _avg?: skillcooltimesAvgOrderByAggregateInput
    _max?: skillcooltimesMaxOrderByAggregateInput
    _min?: skillcooltimesMinOrderByAggregateInput
    _sum?: skillcooltimesSumOrderByAggregateInput
  }

  export type skillcooltimesScalarWhereWithAggregatesInput = {
    AND?: skillcooltimesScalarWhereWithAggregatesInput | skillcooltimesScalarWhereWithAggregatesInput[]
    OR?: skillcooltimesScalarWhereWithAggregatesInput[]
    NOT?: skillcooltimesScalarWhereWithAggregatesInput | skillcooltimesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"skillcooltimes"> | number
    charid?: IntNullableWithAggregatesFilter<"skillcooltimes"> | number | null
    skillid?: IntNullableWithAggregatesFilter<"skillcooltimes"> | number | null
    nextusabletime?: BigIntNullableWithAggregatesFilter<"skillcooltimes"> | bigint | number | null
  }

  export type skillsWhereInput = {
    AND?: skillsWhereInput | skillsWhereInput[]
    OR?: skillsWhereInput[]
    NOT?: skillsWhereInput | skillsWhereInput[]
    id?: IntFilter<"skills"> | number
    charid?: IntNullableFilter<"skills"> | number | null
    skillid?: IntNullableFilter<"skills"> | number | null
    rootid?: IntNullableFilter<"skills"> | number | null
    maxlevel?: IntNullableFilter<"skills"> | number | null
    currentlevel?: IntNullableFilter<"skills"> | number | null
    masterlevel?: IntNullableFilter<"skills"> | number | null
  }

  export type skillsOrderByWithRelationInput = {
    id?: SortOrder
    charid?: SortOrderInput | SortOrder
    skillid?: SortOrderInput | SortOrder
    rootid?: SortOrderInput | SortOrder
    maxlevel?: SortOrderInput | SortOrder
    currentlevel?: SortOrderInput | SortOrder
    masterlevel?: SortOrderInput | SortOrder
  }

  export type skillsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: skillsWhereInput | skillsWhereInput[]
    OR?: skillsWhereInput[]
    NOT?: skillsWhereInput | skillsWhereInput[]
    charid?: IntNullableFilter<"skills"> | number | null
    skillid?: IntNullableFilter<"skills"> | number | null
    rootid?: IntNullableFilter<"skills"> | number | null
    maxlevel?: IntNullableFilter<"skills"> | number | null
    currentlevel?: IntNullableFilter<"skills"> | number | null
    masterlevel?: IntNullableFilter<"skills"> | number | null
  }, "id">

  export type skillsOrderByWithAggregationInput = {
    id?: SortOrder
    charid?: SortOrderInput | SortOrder
    skillid?: SortOrderInput | SortOrder
    rootid?: SortOrderInput | SortOrder
    maxlevel?: SortOrderInput | SortOrder
    currentlevel?: SortOrderInput | SortOrder
    masterlevel?: SortOrderInput | SortOrder
    _count?: skillsCountOrderByAggregateInput
    _avg?: skillsAvgOrderByAggregateInput
    _max?: skillsMaxOrderByAggregateInput
    _min?: skillsMinOrderByAggregateInput
    _sum?: skillsSumOrderByAggregateInput
  }

  export type skillsScalarWhereWithAggregatesInput = {
    AND?: skillsScalarWhereWithAggregatesInput | skillsScalarWhereWithAggregatesInput[]
    OR?: skillsScalarWhereWithAggregatesInput[]
    NOT?: skillsScalarWhereWithAggregatesInput | skillsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"skills"> | number
    charid?: IntNullableWithAggregatesFilter<"skills"> | number | null
    skillid?: IntNullableWithAggregatesFilter<"skills"> | number | null
    rootid?: IntNullableWithAggregatesFilter<"skills"> | number | null
    maxlevel?: IntNullableWithAggregatesFilter<"skills"> | number | null
    currentlevel?: IntNullableWithAggregatesFilter<"skills"> | number | null
    masterlevel?: IntNullableWithAggregatesFilter<"skills"> | number | null
  }

  export type spsetWhereInput = {
    AND?: spsetWhereInput | spsetWhereInput[]
    OR?: spsetWhereInput[]
    NOT?: spsetWhereInput | spsetWhereInput[]
    id?: IntFilter<"spset"> | number
    extendsp_id?: IntNullableFilter<"spset"> | number | null
    joblevel?: IntNullableFilter<"spset"> | number | null
    sp?: IntNullableFilter<"spset"> | number | null
  }

  export type spsetOrderByWithRelationInput = {
    id?: SortOrder
    extendsp_id?: SortOrderInput | SortOrder
    joblevel?: SortOrderInput | SortOrder
    sp?: SortOrderInput | SortOrder
  }

  export type spsetWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: spsetWhereInput | spsetWhereInput[]
    OR?: spsetWhereInput[]
    NOT?: spsetWhereInput | spsetWhereInput[]
    extendsp_id?: IntNullableFilter<"spset"> | number | null
    joblevel?: IntNullableFilter<"spset"> | number | null
    sp?: IntNullableFilter<"spset"> | number | null
  }, "id">

  export type spsetOrderByWithAggregationInput = {
    id?: SortOrder
    extendsp_id?: SortOrderInput | SortOrder
    joblevel?: SortOrderInput | SortOrder
    sp?: SortOrderInput | SortOrder
    _count?: spsetCountOrderByAggregateInput
    _avg?: spsetAvgOrderByAggregateInput
    _max?: spsetMaxOrderByAggregateInput
    _min?: spsetMinOrderByAggregateInput
    _sum?: spsetSumOrderByAggregateInput
  }

  export type spsetScalarWhereWithAggregatesInput = {
    AND?: spsetScalarWhereWithAggregatesInput | spsetScalarWhereWithAggregatesInput[]
    OR?: spsetScalarWhereWithAggregatesInput[]
    NOT?: spsetScalarWhereWithAggregatesInput | spsetScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"spset"> | number
    extendsp_id?: IntNullableWithAggregatesFilter<"spset"> | number | null
    joblevel?: IntNullableWithAggregatesFilter<"spset"> | number | null
    sp?: IntNullableWithAggregatesFilter<"spset"> | number | null
  }

  export type stolenskillsWhereInput = {
    AND?: stolenskillsWhereInput | stolenskillsWhereInput[]
    OR?: stolenskillsWhereInput[]
    NOT?: stolenskillsWhereInput | stolenskillsWhereInput[]
    id?: IntFilter<"stolenskills"> | number
    charid?: IntNullableFilter<"stolenskills"> | number | null
    skillid?: IntNullableFilter<"stolenskills"> | number | null
    position?: IntNullableFilter<"stolenskills"> | number | null
    currentlv?: IntNullableFilter<"stolenskills"> | number | null
  }

  export type stolenskillsOrderByWithRelationInput = {
    id?: SortOrder
    charid?: SortOrderInput | SortOrder
    skillid?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    currentlv?: SortOrderInput | SortOrder
  }

  export type stolenskillsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: stolenskillsWhereInput | stolenskillsWhereInput[]
    OR?: stolenskillsWhereInput[]
    NOT?: stolenskillsWhereInput | stolenskillsWhereInput[]
    charid?: IntNullableFilter<"stolenskills"> | number | null
    skillid?: IntNullableFilter<"stolenskills"> | number | null
    position?: IntNullableFilter<"stolenskills"> | number | null
    currentlv?: IntNullableFilter<"stolenskills"> | number | null
  }, "id">

  export type stolenskillsOrderByWithAggregationInput = {
    id?: SortOrder
    charid?: SortOrderInput | SortOrder
    skillid?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    currentlv?: SortOrderInput | SortOrder
    _count?: stolenskillsCountOrderByAggregateInput
    _avg?: stolenskillsAvgOrderByAggregateInput
    _max?: stolenskillsMaxOrderByAggregateInput
    _min?: stolenskillsMinOrderByAggregateInput
    _sum?: stolenskillsSumOrderByAggregateInput
  }

  export type stolenskillsScalarWhereWithAggregatesInput = {
    AND?: stolenskillsScalarWhereWithAggregatesInput | stolenskillsScalarWhereWithAggregatesInput[]
    OR?: stolenskillsScalarWhereWithAggregatesInput[]
    NOT?: stolenskillsScalarWhereWithAggregatesInput | stolenskillsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"stolenskills"> | number
    charid?: IntNullableWithAggregatesFilter<"stolenskills"> | number | null
    skillid?: IntNullableWithAggregatesFilter<"stolenskills"> | number | null
    position?: IntNullableWithAggregatesFilter<"stolenskills"> | number | null
    currentlv?: IntNullableWithAggregatesFilter<"stolenskills"> | number | null
  }

  export type systemtimesWhereInput = {
    AND?: systemtimesWhereInput | systemtimesWhereInput[]
    OR?: systemtimesWhereInput[]
    NOT?: systemtimesWhereInput | systemtimesWhereInput[]
    id?: IntFilter<"systemtimes"> | number
    yr?: IntNullableFilter<"systemtimes"> | number | null
    mnth?: IntNullableFilter<"systemtimes"> | number | null
  }

  export type systemtimesOrderByWithRelationInput = {
    id?: SortOrder
    yr?: SortOrderInput | SortOrder
    mnth?: SortOrderInput | SortOrder
  }

  export type systemtimesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: systemtimesWhereInput | systemtimesWhereInput[]
    OR?: systemtimesWhereInput[]
    NOT?: systemtimesWhereInput | systemtimesWhereInput[]
    yr?: IntNullableFilter<"systemtimes"> | number | null
    mnth?: IntNullableFilter<"systemtimes"> | number | null
  }, "id">

  export type systemtimesOrderByWithAggregationInput = {
    id?: SortOrder
    yr?: SortOrderInput | SortOrder
    mnth?: SortOrderInput | SortOrder
    _count?: systemtimesCountOrderByAggregateInput
    _avg?: systemtimesAvgOrderByAggregateInput
    _max?: systemtimesMaxOrderByAggregateInput
    _min?: systemtimesMinOrderByAggregateInput
    _sum?: systemtimesSumOrderByAggregateInput
  }

  export type systemtimesScalarWhereWithAggregatesInput = {
    AND?: systemtimesScalarWhereWithAggregatesInput | systemtimesScalarWhereWithAggregatesInput[]
    OR?: systemtimesScalarWhereWithAggregatesInput[]
    NOT?: systemtimesScalarWhereWithAggregatesInput | systemtimesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"systemtimes"> | number
    yr?: IntNullableWithAggregatesFilter<"systemtimes"> | number | null
    mnth?: IntNullableWithAggregatesFilter<"systemtimes"> | number | null
  }

  export type totemsWhereInput = {
    AND?: totemsWhereInput | totemsWhereInput[]
    OR?: totemsWhereInput[]
    NOT?: totemsWhereInput | totemsWhereInput[]
    id?: IntFilter<"totems"> | number
    alid?: IntNullableFilter<"totems"> | number | null
    totemid?: IntNullableFilter<"totems"> | number | null
  }

  export type totemsOrderByWithRelationInput = {
    id?: SortOrder
    alid?: SortOrderInput | SortOrder
    totemid?: SortOrderInput | SortOrder
  }

  export type totemsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: totemsWhereInput | totemsWhereInput[]
    OR?: totemsWhereInput[]
    NOT?: totemsWhereInput | totemsWhereInput[]
    alid?: IntNullableFilter<"totems"> | number | null
    totemid?: IntNullableFilter<"totems"> | number | null
  }, "id">

  export type totemsOrderByWithAggregationInput = {
    id?: SortOrder
    alid?: SortOrderInput | SortOrder
    totemid?: SortOrderInput | SortOrder
    _count?: totemsCountOrderByAggregateInput
    _avg?: totemsAvgOrderByAggregateInput
    _max?: totemsMaxOrderByAggregateInput
    _min?: totemsMinOrderByAggregateInput
    _sum?: totemsSumOrderByAggregateInput
  }

  export type totemsScalarWhereWithAggregatesInput = {
    AND?: totemsScalarWhereWithAggregatesInput | totemsScalarWhereWithAggregatesInput[]
    OR?: totemsScalarWhereWithAggregatesInput[]
    NOT?: totemsScalarWhereWithAggregatesInput | totemsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"totems"> | number
    alid?: IntNullableWithAggregatesFilter<"totems"> | number | null
    totemid?: IntNullableWithAggregatesFilter<"totems"> | number | null
  }

  export type trunksWhereInput = {
    AND?: trunksWhereInput | trunksWhereInput[]
    OR?: trunksWhereInput[]
    NOT?: trunksWhereInput | trunksWhereInput[]
    id?: IntFilter<"trunks"> | number
    slotcount?: IntNullableFilter<"trunks"> | number | null
    money?: BigIntNullableFilter<"trunks"> | bigint | number | null
  }

  export type trunksOrderByWithRelationInput = {
    id?: SortOrder
    slotcount?: SortOrderInput | SortOrder
    money?: SortOrderInput | SortOrder
  }

  export type trunksWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: trunksWhereInput | trunksWhereInput[]
    OR?: trunksWhereInput[]
    NOT?: trunksWhereInput | trunksWhereInput[]
    slotcount?: IntNullableFilter<"trunks"> | number | null
    money?: BigIntNullableFilter<"trunks"> | bigint | number | null
  }, "id">

  export type trunksOrderByWithAggregationInput = {
    id?: SortOrder
    slotcount?: SortOrderInput | SortOrder
    money?: SortOrderInput | SortOrder
    _count?: trunksCountOrderByAggregateInput
    _avg?: trunksAvgOrderByAggregateInput
    _max?: trunksMaxOrderByAggregateInput
    _min?: trunksMinOrderByAggregateInput
    _sum?: trunksSumOrderByAggregateInput
  }

  export type trunksScalarWhereWithAggregatesInput = {
    AND?: trunksScalarWhereWithAggregatesInput | trunksScalarWhereWithAggregatesInput[]
    OR?: trunksScalarWhereWithAggregatesInput[]
    NOT?: trunksScalarWhereWithAggregatesInput | trunksScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"trunks"> | number
    slotcount?: IntNullableWithAggregatesFilter<"trunks"> | number | null
    money?: BigIntNullableWithAggregatesFilter<"trunks"> | bigint | number | null
  }

  export type unseenequipsWhereInput = {
    AND?: unseenequipsWhereInput | unseenequipsWhereInput[]
    OR?: unseenequipsWhereInput[]
    NOT?: unseenequipsWhereInput | unseenequipsWhereInput[]
    id?: IntFilter<"unseenequips"> | number
    alid?: IntNullableFilter<"unseenequips"> | number | null
    equipid?: IntNullableFilter<"unseenequips"> | number | null
  }

  export type unseenequipsOrderByWithRelationInput = {
    id?: SortOrder
    alid?: SortOrderInput | SortOrder
    equipid?: SortOrderInput | SortOrder
  }

  export type unseenequipsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: unseenequipsWhereInput | unseenequipsWhereInput[]
    OR?: unseenequipsWhereInput[]
    NOT?: unseenequipsWhereInput | unseenequipsWhereInput[]
    alid?: IntNullableFilter<"unseenequips"> | number | null
    equipid?: IntNullableFilter<"unseenequips"> | number | null
  }, "id">

  export type unseenequipsOrderByWithAggregationInput = {
    id?: SortOrder
    alid?: SortOrderInput | SortOrder
    equipid?: SortOrderInput | SortOrder
    _count?: unseenequipsCountOrderByAggregateInput
    _avg?: unseenequipsAvgOrderByAggregateInput
    _max?: unseenequipsMaxOrderByAggregateInput
    _min?: unseenequipsMinOrderByAggregateInput
    _sum?: unseenequipsSumOrderByAggregateInput
  }

  export type unseenequipsScalarWhereWithAggregatesInput = {
    AND?: unseenequipsScalarWhereWithAggregatesInput | unseenequipsScalarWhereWithAggregatesInput[]
    OR?: unseenequipsScalarWhereWithAggregatesInput[]
    NOT?: unseenequipsScalarWhereWithAggregatesInput | unseenequipsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"unseenequips"> | number
    alid?: IntNullableWithAggregatesFilter<"unseenequips"> | number | null
    equipid?: IntNullableWithAggregatesFilter<"unseenequips"> | number | null
  }

  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    id?: IntFilter<"users"> | number
    name?: StringNullableFilter<"users"> | string | null
    password?: StringNullableFilter<"users"> | string | null
    pic?: StringNullableFilter<"users"> | string | null
    email?: StringNullableFilter<"users"> | string | null
    age?: IntNullableFilter<"users"> | number | null
    accounttype?: IntNullableFilter<"users"> | number | null
    votepoints?: IntNullableFilter<"users"> | number | null
    donationpoints?: IntNullableFilter<"users"> | number | null
    maplePoints?: IntNullableFilter<"users"> | number | null
    nxPrepaid?: IntNullableFilter<"users"> | number | null
    clientstate?: IntNullableFilter<"users"> | number | null
    vipgrade?: IntNullableFilter<"users"> | number | null
    vippoints?: IntNullableFilter<"users"> | number | null
    freevippointdate?: DateTimeNullableFilter<"users"> | Date | string | null
    vipexpireddate?: DateTimeNullableFilter<"users"> | Date | string | null
    nblockreason?: IntNullableFilter<"users"> | number | null
    banExpireDate?: DateTimeNullableFilter<"users"> | Date | string | null
    banReason?: StringNullableFilter<"users"> | string | null
    offensemanager?: IntNullableFilter<"users"> | number | null
    gender?: IntNullableFilter<"users"> | number | null
    msg2?: IntNullableFilter<"users"> | number | null
    purchaseexp?: IntNullableFilter<"users"> | number | null
    pblockreason?: IntNullableFilter<"users"> | number | null
    chatunblockdate?: BigIntNullableFilter<"users"> | bigint | number | null
    hascensorednxloginid?: BoolNullableFilter<"users"> | boolean | null
    gradecode?: IntNullableFilter<"users"> | number | null
    censorednxloginid?: StringNullableFilter<"users"> | string | null
    characterslots?: IntFilter<"users"> | number
    creationdate?: DateTimeNullableFilter<"users"> | Date | string | null
    bosspoints?: IntFilter<"users"> | number
    lastvote1?: IntFilter<"users"> | number
    lastvote2?: IntFilter<"users"> | number
    claimvote1?: IntFilter<"users"> | number
    claimvote2?: IntFilter<"users"> | number
    dojop?: IntFilter<"users"> | number
    lastvotetime?: DateTimeNullableFilter<"users"> | Date | string | null
    lastvoteip?: StringNullableFilter<"users"> | string | null
    discordid?: StringNullableFilter<"users"> | string | null
  }

  export type usersOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    pic?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    age?: SortOrderInput | SortOrder
    accounttype?: SortOrderInput | SortOrder
    votepoints?: SortOrderInput | SortOrder
    donationpoints?: SortOrderInput | SortOrder
    maplePoints?: SortOrderInput | SortOrder
    nxPrepaid?: SortOrderInput | SortOrder
    clientstate?: SortOrderInput | SortOrder
    vipgrade?: SortOrderInput | SortOrder
    vippoints?: SortOrderInput | SortOrder
    freevippointdate?: SortOrderInput | SortOrder
    vipexpireddate?: SortOrderInput | SortOrder
    nblockreason?: SortOrderInput | SortOrder
    banExpireDate?: SortOrderInput | SortOrder
    banReason?: SortOrderInput | SortOrder
    offensemanager?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    msg2?: SortOrderInput | SortOrder
    purchaseexp?: SortOrderInput | SortOrder
    pblockreason?: SortOrderInput | SortOrder
    chatunblockdate?: SortOrderInput | SortOrder
    hascensorednxloginid?: SortOrderInput | SortOrder
    gradecode?: SortOrderInput | SortOrder
    censorednxloginid?: SortOrderInput | SortOrder
    characterslots?: SortOrder
    creationdate?: SortOrderInput | SortOrder
    bosspoints?: SortOrder
    lastvote1?: SortOrder
    lastvote2?: SortOrder
    claimvote1?: SortOrder
    claimvote2?: SortOrder
    dojop?: SortOrder
    lastvotetime?: SortOrderInput | SortOrder
    lastvoteip?: SortOrderInput | SortOrder
    discordid?: SortOrderInput | SortOrder
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    name?: StringNullableFilter<"users"> | string | null
    password?: StringNullableFilter<"users"> | string | null
    pic?: StringNullableFilter<"users"> | string | null
    email?: StringNullableFilter<"users"> | string | null
    age?: IntNullableFilter<"users"> | number | null
    accounttype?: IntNullableFilter<"users"> | number | null
    votepoints?: IntNullableFilter<"users"> | number | null
    donationpoints?: IntNullableFilter<"users"> | number | null
    maplePoints?: IntNullableFilter<"users"> | number | null
    nxPrepaid?: IntNullableFilter<"users"> | number | null
    clientstate?: IntNullableFilter<"users"> | number | null
    vipgrade?: IntNullableFilter<"users"> | number | null
    vippoints?: IntNullableFilter<"users"> | number | null
    freevippointdate?: DateTimeNullableFilter<"users"> | Date | string | null
    vipexpireddate?: DateTimeNullableFilter<"users"> | Date | string | null
    nblockreason?: IntNullableFilter<"users"> | number | null
    banExpireDate?: DateTimeNullableFilter<"users"> | Date | string | null
    banReason?: StringNullableFilter<"users"> | string | null
    offensemanager?: IntNullableFilter<"users"> | number | null
    gender?: IntNullableFilter<"users"> | number | null
    msg2?: IntNullableFilter<"users"> | number | null
    purchaseexp?: IntNullableFilter<"users"> | number | null
    pblockreason?: IntNullableFilter<"users"> | number | null
    chatunblockdate?: BigIntNullableFilter<"users"> | bigint | number | null
    hascensorednxloginid?: BoolNullableFilter<"users"> | boolean | null
    gradecode?: IntNullableFilter<"users"> | number | null
    censorednxloginid?: StringNullableFilter<"users"> | string | null
    characterslots?: IntFilter<"users"> | number
    creationdate?: DateTimeNullableFilter<"users"> | Date | string | null
    bosspoints?: IntFilter<"users"> | number
    lastvote1?: IntFilter<"users"> | number
    lastvote2?: IntFilter<"users"> | number
    claimvote1?: IntFilter<"users"> | number
    claimvote2?: IntFilter<"users"> | number
    dojop?: IntFilter<"users"> | number
    lastvotetime?: DateTimeNullableFilter<"users"> | Date | string | null
    lastvoteip?: StringNullableFilter<"users"> | string | null
    discordid?: StringNullableFilter<"users"> | string | null
  }, "id">

  export type usersOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    pic?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    age?: SortOrderInput | SortOrder
    accounttype?: SortOrderInput | SortOrder
    votepoints?: SortOrderInput | SortOrder
    donationpoints?: SortOrderInput | SortOrder
    maplePoints?: SortOrderInput | SortOrder
    nxPrepaid?: SortOrderInput | SortOrder
    clientstate?: SortOrderInput | SortOrder
    vipgrade?: SortOrderInput | SortOrder
    vippoints?: SortOrderInput | SortOrder
    freevippointdate?: SortOrderInput | SortOrder
    vipexpireddate?: SortOrderInput | SortOrder
    nblockreason?: SortOrderInput | SortOrder
    banExpireDate?: SortOrderInput | SortOrder
    banReason?: SortOrderInput | SortOrder
    offensemanager?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    msg2?: SortOrderInput | SortOrder
    purchaseexp?: SortOrderInput | SortOrder
    pblockreason?: SortOrderInput | SortOrder
    chatunblockdate?: SortOrderInput | SortOrder
    hascensorednxloginid?: SortOrderInput | SortOrder
    gradecode?: SortOrderInput | SortOrder
    censorednxloginid?: SortOrderInput | SortOrder
    characterslots?: SortOrder
    creationdate?: SortOrderInput | SortOrder
    bosspoints?: SortOrder
    lastvote1?: SortOrder
    lastvote2?: SortOrder
    claimvote1?: SortOrder
    claimvote2?: SortOrder
    dojop?: SortOrder
    lastvotetime?: SortOrderInput | SortOrder
    lastvoteip?: SortOrderInput | SortOrder
    discordid?: SortOrderInput | SortOrder
    _count?: usersCountOrderByAggregateInput
    _avg?: usersAvgOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
    _sum?: usersSumOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"users"> | number
    name?: StringNullableWithAggregatesFilter<"users"> | string | null
    password?: StringNullableWithAggregatesFilter<"users"> | string | null
    pic?: StringNullableWithAggregatesFilter<"users"> | string | null
    email?: StringNullableWithAggregatesFilter<"users"> | string | null
    age?: IntNullableWithAggregatesFilter<"users"> | number | null
    accounttype?: IntNullableWithAggregatesFilter<"users"> | number | null
    votepoints?: IntNullableWithAggregatesFilter<"users"> | number | null
    donationpoints?: IntNullableWithAggregatesFilter<"users"> | number | null
    maplePoints?: IntNullableWithAggregatesFilter<"users"> | number | null
    nxPrepaid?: IntNullableWithAggregatesFilter<"users"> | number | null
    clientstate?: IntNullableWithAggregatesFilter<"users"> | number | null
    vipgrade?: IntNullableWithAggregatesFilter<"users"> | number | null
    vippoints?: IntNullableWithAggregatesFilter<"users"> | number | null
    freevippointdate?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    vipexpireddate?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    nblockreason?: IntNullableWithAggregatesFilter<"users"> | number | null
    banExpireDate?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    banReason?: StringNullableWithAggregatesFilter<"users"> | string | null
    offensemanager?: IntNullableWithAggregatesFilter<"users"> | number | null
    gender?: IntNullableWithAggregatesFilter<"users"> | number | null
    msg2?: IntNullableWithAggregatesFilter<"users"> | number | null
    purchaseexp?: IntNullableWithAggregatesFilter<"users"> | number | null
    pblockreason?: IntNullableWithAggregatesFilter<"users"> | number | null
    chatunblockdate?: BigIntNullableWithAggregatesFilter<"users"> | bigint | number | null
    hascensorednxloginid?: BoolNullableWithAggregatesFilter<"users"> | boolean | null
    gradecode?: IntNullableWithAggregatesFilter<"users"> | number | null
    censorednxloginid?: StringNullableWithAggregatesFilter<"users"> | string | null
    characterslots?: IntWithAggregatesFilter<"users"> | number
    creationdate?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    bosspoints?: IntWithAggregatesFilter<"users"> | number
    lastvote1?: IntWithAggregatesFilter<"users"> | number
    lastvote2?: IntWithAggregatesFilter<"users"> | number
    claimvote1?: IntWithAggregatesFilter<"users"> | number
    claimvote2?: IntWithAggregatesFilter<"users"> | number
    dojop?: IntWithAggregatesFilter<"users"> | number
    lastvotetime?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    lastvoteip?: StringNullableWithAggregatesFilter<"users"> | string | null
    discordid?: StringNullableWithAggregatesFilter<"users"> | string | null
  }

  export type accountsCreateInput = {
    worldid?: number | null
    userid?: number | null
    trunkid?: number | null
    nxCredit?: number | null
    monstercollectionid?: number | null
    employeetrunkid?: number | null
  }

  export type accountsUncheckedCreateInput = {
    id?: number
    worldid?: number | null
    userid?: number | null
    trunkid?: number | null
    nxCredit?: number | null
    monstercollectionid?: number | null
    employeetrunkid?: number | null
  }

  export type accountsUpdateInput = {
    worldid?: NullableIntFieldUpdateOperationsInput | number | null
    userid?: NullableIntFieldUpdateOperationsInput | number | null
    trunkid?: NullableIntFieldUpdateOperationsInput | number | null
    nxCredit?: NullableIntFieldUpdateOperationsInput | number | null
    monstercollectionid?: NullableIntFieldUpdateOperationsInput | number | null
    employeetrunkid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type accountsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    worldid?: NullableIntFieldUpdateOperationsInput | number | null
    userid?: NullableIntFieldUpdateOperationsInput | number | null
    trunkid?: NullableIntFieldUpdateOperationsInput | number | null
    nxCredit?: NullableIntFieldUpdateOperationsInput | number | null
    monstercollectionid?: NullableIntFieldUpdateOperationsInput | number | null
    employeetrunkid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type accountsCreateManyInput = {
    id?: number
    worldid?: number | null
    userid?: number | null
    trunkid?: number | null
    nxCredit?: number | null
    monstercollectionid?: number | null
    employeetrunkid?: number | null
  }

  export type accountsUpdateManyMutationInput = {
    worldid?: NullableIntFieldUpdateOperationsInput | number | null
    userid?: NullableIntFieldUpdateOperationsInput | number | null
    trunkid?: NullableIntFieldUpdateOperationsInput | number | null
    nxCredit?: NullableIntFieldUpdateOperationsInput | number | null
    monstercollectionid?: NullableIntFieldUpdateOperationsInput | number | null
    employeetrunkid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type accountsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    worldid?: NullableIntFieldUpdateOperationsInput | number | null
    userid?: NullableIntFieldUpdateOperationsInput | number | null
    trunkid?: NullableIntFieldUpdateOperationsInput | number | null
    nxCredit?: NullableIntFieldUpdateOperationsInput | number | null
    monstercollectionid?: NullableIntFieldUpdateOperationsInput | number | null
    employeetrunkid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type alliance_gradenamesCreateInput = {
    gradename?: string | null
    allianceid?: number | null
  }

  export type alliance_gradenamesUncheckedCreateInput = {
    id?: number
    gradename?: string | null
    allianceid?: number | null
  }

  export type alliance_gradenamesUpdateInput = {
    gradename?: NullableStringFieldUpdateOperationsInput | string | null
    allianceid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type alliance_gradenamesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    gradename?: NullableStringFieldUpdateOperationsInput | string | null
    allianceid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type alliance_gradenamesCreateManyInput = {
    id?: number
    gradename?: string | null
    allianceid?: number | null
  }

  export type alliance_gradenamesUpdateManyMutationInput = {
    gradename?: NullableStringFieldUpdateOperationsInput | string | null
    allianceid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type alliance_gradenamesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    gradename?: NullableStringFieldUpdateOperationsInput | string | null
    allianceid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type alliancesCreateInput = {
    name?: string | null
    maxmembernum?: number | null
    notice?: string | null
  }

  export type alliancesUncheckedCreateInput = {
    id?: number
    name?: string | null
    maxmembernum?: number | null
    notice?: string | null
  }

  export type alliancesUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    maxmembernum?: NullableIntFieldUpdateOperationsInput | number | null
    notice?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type alliancesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    maxmembernum?: NullableIntFieldUpdateOperationsInput | number | null
    notice?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type alliancesCreateManyInput = {
    id?: number
    name?: string | null
    maxmembernum?: number | null
    notice?: string | null
  }

  export type alliancesUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    maxmembernum?: NullableIntFieldUpdateOperationsInput | number | null
    notice?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type alliancesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    maxmembernum?: NullableIntFieldUpdateOperationsInput | number | null
    notice?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type auction_historiesCreateInput = {
    itemid?: number | null
    bargain?: boolean | null
    refund?: boolean | null
    ownerid?: number | null
    ownername?: string | null
    historytype?: number | null
    mesos?: bigint | number | null
    buyer?: number | null
    bid?: bigint | number | null
    expiredtime?: Date | string | null
    buytime?: Date | string | null
    starttime?: Date | string | null
  }

  export type auction_historiesUncheckedCreateInput = {
    id?: number
    itemid?: number | null
    bargain?: boolean | null
    refund?: boolean | null
    ownerid?: number | null
    ownername?: string | null
    historytype?: number | null
    mesos?: bigint | number | null
    buyer?: number | null
    bid?: bigint | number | null
    expiredtime?: Date | string | null
    buytime?: Date | string | null
    starttime?: Date | string | null
  }

  export type auction_historiesUpdateInput = {
    itemid?: NullableIntFieldUpdateOperationsInput | number | null
    bargain?: NullableBoolFieldUpdateOperationsInput | boolean | null
    refund?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ownerid?: NullableIntFieldUpdateOperationsInput | number | null
    ownername?: NullableStringFieldUpdateOperationsInput | string | null
    historytype?: NullableIntFieldUpdateOperationsInput | number | null
    mesos?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    buyer?: NullableIntFieldUpdateOperationsInput | number | null
    bid?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    expiredtime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    buytime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    starttime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type auction_historiesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemid?: NullableIntFieldUpdateOperationsInput | number | null
    bargain?: NullableBoolFieldUpdateOperationsInput | boolean | null
    refund?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ownerid?: NullableIntFieldUpdateOperationsInput | number | null
    ownername?: NullableStringFieldUpdateOperationsInput | string | null
    historytype?: NullableIntFieldUpdateOperationsInput | number | null
    mesos?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    buyer?: NullableIntFieldUpdateOperationsInput | number | null
    bid?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    expiredtime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    buytime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    starttime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type auction_historiesCreateManyInput = {
    id?: number
    itemid?: number | null
    bargain?: boolean | null
    refund?: boolean | null
    ownerid?: number | null
    ownername?: string | null
    historytype?: number | null
    mesos?: bigint | number | null
    buyer?: number | null
    bid?: bigint | number | null
    expiredtime?: Date | string | null
    buytime?: Date | string | null
    starttime?: Date | string | null
  }

  export type auction_historiesUpdateManyMutationInput = {
    itemid?: NullableIntFieldUpdateOperationsInput | number | null
    bargain?: NullableBoolFieldUpdateOperationsInput | boolean | null
    refund?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ownerid?: NullableIntFieldUpdateOperationsInput | number | null
    ownername?: NullableStringFieldUpdateOperationsInput | string | null
    historytype?: NullableIntFieldUpdateOperationsInput | number | null
    mesos?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    buyer?: NullableIntFieldUpdateOperationsInput | number | null
    bid?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    expiredtime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    buytime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    starttime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type auction_historiesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemid?: NullableIntFieldUpdateOperationsInput | number | null
    bargain?: NullableBoolFieldUpdateOperationsInput | boolean | null
    refund?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ownerid?: NullableIntFieldUpdateOperationsInput | number | null
    ownername?: NullableStringFieldUpdateOperationsInput | string | null
    historytype?: NullableIntFieldUpdateOperationsInput | number | null
    mesos?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    buyer?: NullableIntFieldUpdateOperationsInput | number | null
    bid?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    expiredtime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    buytime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    starttime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type auction_itemsCreateInput = {
    itemid?: number | null
    bargain?: boolean | null
    ownerid?: number | null
    ownername?: string | null
    mesos?: bigint | number | null
    buyer?: number | null
    bid?: bigint | number | null
    expiredtime?: Date | string | null
    starttime?: Date | string | null
  }

  export type auction_itemsUncheckedCreateInput = {
    id?: number
    itemid?: number | null
    bargain?: boolean | null
    ownerid?: number | null
    ownername?: string | null
    mesos?: bigint | number | null
    buyer?: number | null
    bid?: bigint | number | null
    expiredtime?: Date | string | null
    starttime?: Date | string | null
  }

  export type auction_itemsUpdateInput = {
    itemid?: NullableIntFieldUpdateOperationsInput | number | null
    bargain?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ownerid?: NullableIntFieldUpdateOperationsInput | number | null
    ownername?: NullableStringFieldUpdateOperationsInput | string | null
    mesos?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    buyer?: NullableIntFieldUpdateOperationsInput | number | null
    bid?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    expiredtime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    starttime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type auction_itemsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemid?: NullableIntFieldUpdateOperationsInput | number | null
    bargain?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ownerid?: NullableIntFieldUpdateOperationsInput | number | null
    ownername?: NullableStringFieldUpdateOperationsInput | string | null
    mesos?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    buyer?: NullableIntFieldUpdateOperationsInput | number | null
    bid?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    expiredtime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    starttime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type auction_itemsCreateManyInput = {
    id?: number
    itemid?: number | null
    bargain?: boolean | null
    ownerid?: number | null
    ownername?: string | null
    mesos?: bigint | number | null
    buyer?: number | null
    bid?: bigint | number | null
    expiredtime?: Date | string | null
    starttime?: Date | string | null
  }

  export type auction_itemsUpdateManyMutationInput = {
    itemid?: NullableIntFieldUpdateOperationsInput | number | null
    bargain?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ownerid?: NullableIntFieldUpdateOperationsInput | number | null
    ownername?: NullableStringFieldUpdateOperationsInput | string | null
    mesos?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    buyer?: NullableIntFieldUpdateOperationsInput | number | null
    bid?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    expiredtime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    starttime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type auction_itemsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemid?: NullableIntFieldUpdateOperationsInput | number | null
    bargain?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ownerid?: NullableIntFieldUpdateOperationsInput | number | null
    ownername?: NullableStringFieldUpdateOperationsInput | string | null
    mesos?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    buyer?: NullableIntFieldUpdateOperationsInput | number | null
    bid?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    expiredtime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    starttime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type avatardataCreateInput = {
    characterstat?: number | null
    avatarlook?: number | null
    zeroavatarlook?: number | null
  }

  export type avatardataUncheckedCreateInput = {
    id?: number
    characterstat?: number | null
    avatarlook?: number | null
    zeroavatarlook?: number | null
  }

  export type avatardataUpdateInput = {
    characterstat?: NullableIntFieldUpdateOperationsInput | number | null
    avatarlook?: NullableIntFieldUpdateOperationsInput | number | null
    zeroavatarlook?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type avatardataUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    characterstat?: NullableIntFieldUpdateOperationsInput | number | null
    avatarlook?: NullableIntFieldUpdateOperationsInput | number | null
    zeroavatarlook?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type avatardataCreateManyInput = {
    id?: number
    characterstat?: number | null
    avatarlook?: number | null
    zeroavatarlook?: number | null
  }

  export type avatardataUpdateManyMutationInput = {
    characterstat?: NullableIntFieldUpdateOperationsInput | number | null
    avatarlook?: NullableIntFieldUpdateOperationsInput | number | null
    zeroavatarlook?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type avatardataUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    characterstat?: NullableIntFieldUpdateOperationsInput | number | null
    avatarlook?: NullableIntFieldUpdateOperationsInput | number | null
    zeroavatarlook?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type avatarlookCreateInput = {
    gender?: number | null
    skin?: number | null
    face?: number | null
    hair?: number | null
    weaponstickerid?: number | null
    weaponid?: number | null
    subweaponid?: number | null
    job?: number | null
    drawelfear?: boolean | null
    demonslayerdeffaceacc?: number | null
    xenondeffaceacc?: number | null
    beasttamerdeffaceacc?: number | null
    iszerobetalook?: boolean | null
    mixedhaircolor?: number | null
    mixhairpercent?: number | null
    ears?: number | null
    tail?: number | null
  }

  export type avatarlookUncheckedCreateInput = {
    id?: number
    gender?: number | null
    skin?: number | null
    face?: number | null
    hair?: number | null
    weaponstickerid?: number | null
    weaponid?: number | null
    subweaponid?: number | null
    job?: number | null
    drawelfear?: boolean | null
    demonslayerdeffaceacc?: number | null
    xenondeffaceacc?: number | null
    beasttamerdeffaceacc?: number | null
    iszerobetalook?: boolean | null
    mixedhaircolor?: number | null
    mixhairpercent?: number | null
    ears?: number | null
    tail?: number | null
  }

  export type avatarlookUpdateInput = {
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    skin?: NullableIntFieldUpdateOperationsInput | number | null
    face?: NullableIntFieldUpdateOperationsInput | number | null
    hair?: NullableIntFieldUpdateOperationsInput | number | null
    weaponstickerid?: NullableIntFieldUpdateOperationsInput | number | null
    weaponid?: NullableIntFieldUpdateOperationsInput | number | null
    subweaponid?: NullableIntFieldUpdateOperationsInput | number | null
    job?: NullableIntFieldUpdateOperationsInput | number | null
    drawelfear?: NullableBoolFieldUpdateOperationsInput | boolean | null
    demonslayerdeffaceacc?: NullableIntFieldUpdateOperationsInput | number | null
    xenondeffaceacc?: NullableIntFieldUpdateOperationsInput | number | null
    beasttamerdeffaceacc?: NullableIntFieldUpdateOperationsInput | number | null
    iszerobetalook?: NullableBoolFieldUpdateOperationsInput | boolean | null
    mixedhaircolor?: NullableIntFieldUpdateOperationsInput | number | null
    mixhairpercent?: NullableIntFieldUpdateOperationsInput | number | null
    ears?: NullableIntFieldUpdateOperationsInput | number | null
    tail?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type avatarlookUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    skin?: NullableIntFieldUpdateOperationsInput | number | null
    face?: NullableIntFieldUpdateOperationsInput | number | null
    hair?: NullableIntFieldUpdateOperationsInput | number | null
    weaponstickerid?: NullableIntFieldUpdateOperationsInput | number | null
    weaponid?: NullableIntFieldUpdateOperationsInput | number | null
    subweaponid?: NullableIntFieldUpdateOperationsInput | number | null
    job?: NullableIntFieldUpdateOperationsInput | number | null
    drawelfear?: NullableBoolFieldUpdateOperationsInput | boolean | null
    demonslayerdeffaceacc?: NullableIntFieldUpdateOperationsInput | number | null
    xenondeffaceacc?: NullableIntFieldUpdateOperationsInput | number | null
    beasttamerdeffaceacc?: NullableIntFieldUpdateOperationsInput | number | null
    iszerobetalook?: NullableBoolFieldUpdateOperationsInput | boolean | null
    mixedhaircolor?: NullableIntFieldUpdateOperationsInput | number | null
    mixhairpercent?: NullableIntFieldUpdateOperationsInput | number | null
    ears?: NullableIntFieldUpdateOperationsInput | number | null
    tail?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type avatarlookCreateManyInput = {
    id?: number
    gender?: number | null
    skin?: number | null
    face?: number | null
    hair?: number | null
    weaponstickerid?: number | null
    weaponid?: number | null
    subweaponid?: number | null
    job?: number | null
    drawelfear?: boolean | null
    demonslayerdeffaceacc?: number | null
    xenondeffaceacc?: number | null
    beasttamerdeffaceacc?: number | null
    iszerobetalook?: boolean | null
    mixedhaircolor?: number | null
    mixhairpercent?: number | null
    ears?: number | null
    tail?: number | null
  }

  export type avatarlookUpdateManyMutationInput = {
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    skin?: NullableIntFieldUpdateOperationsInput | number | null
    face?: NullableIntFieldUpdateOperationsInput | number | null
    hair?: NullableIntFieldUpdateOperationsInput | number | null
    weaponstickerid?: NullableIntFieldUpdateOperationsInput | number | null
    weaponid?: NullableIntFieldUpdateOperationsInput | number | null
    subweaponid?: NullableIntFieldUpdateOperationsInput | number | null
    job?: NullableIntFieldUpdateOperationsInput | number | null
    drawelfear?: NullableBoolFieldUpdateOperationsInput | boolean | null
    demonslayerdeffaceacc?: NullableIntFieldUpdateOperationsInput | number | null
    xenondeffaceacc?: NullableIntFieldUpdateOperationsInput | number | null
    beasttamerdeffaceacc?: NullableIntFieldUpdateOperationsInput | number | null
    iszerobetalook?: NullableBoolFieldUpdateOperationsInput | boolean | null
    mixedhaircolor?: NullableIntFieldUpdateOperationsInput | number | null
    mixhairpercent?: NullableIntFieldUpdateOperationsInput | number | null
    ears?: NullableIntFieldUpdateOperationsInput | number | null
    tail?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type avatarlookUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    skin?: NullableIntFieldUpdateOperationsInput | number | null
    face?: NullableIntFieldUpdateOperationsInput | number | null
    hair?: NullableIntFieldUpdateOperationsInput | number | null
    weaponstickerid?: NullableIntFieldUpdateOperationsInput | number | null
    weaponid?: NullableIntFieldUpdateOperationsInput | number | null
    subweaponid?: NullableIntFieldUpdateOperationsInput | number | null
    job?: NullableIntFieldUpdateOperationsInput | number | null
    drawelfear?: NullableBoolFieldUpdateOperationsInput | boolean | null
    demonslayerdeffaceacc?: NullableIntFieldUpdateOperationsInput | number | null
    xenondeffaceacc?: NullableIntFieldUpdateOperationsInput | number | null
    beasttamerdeffaceacc?: NullableIntFieldUpdateOperationsInput | number | null
    iszerobetalook?: NullableBoolFieldUpdateOperationsInput | boolean | null
    mixedhaircolor?: NullableIntFieldUpdateOperationsInput | number | null
    mixhairpercent?: NullableIntFieldUpdateOperationsInput | number | null
    ears?: NullableIntFieldUpdateOperationsInput | number | null
    tail?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type bbs_recordsCreateInput = {
    idforbbs?: number | null
    creatorid?: number | null
    subject?: string | null
    msg?: string | null
    creationdate?: Date | string | null
    icon?: number | null
    guildid?: number | null
  }

  export type bbs_recordsUncheckedCreateInput = {
    id?: number
    idforbbs?: number | null
    creatorid?: number | null
    subject?: string | null
    msg?: string | null
    creationdate?: Date | string | null
    icon?: number | null
    guildid?: number | null
  }

  export type bbs_recordsUpdateInput = {
    idforbbs?: NullableIntFieldUpdateOperationsInput | number | null
    creatorid?: NullableIntFieldUpdateOperationsInput | number | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    msg?: NullableStringFieldUpdateOperationsInput | string | null
    creationdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    icon?: NullableIntFieldUpdateOperationsInput | number | null
    guildid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type bbs_recordsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    idforbbs?: NullableIntFieldUpdateOperationsInput | number | null
    creatorid?: NullableIntFieldUpdateOperationsInput | number | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    msg?: NullableStringFieldUpdateOperationsInput | string | null
    creationdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    icon?: NullableIntFieldUpdateOperationsInput | number | null
    guildid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type bbs_recordsCreateManyInput = {
    id?: number
    idforbbs?: number | null
    creatorid?: number | null
    subject?: string | null
    msg?: string | null
    creationdate?: Date | string | null
    icon?: number | null
    guildid?: number | null
  }

  export type bbs_recordsUpdateManyMutationInput = {
    idforbbs?: NullableIntFieldUpdateOperationsInput | number | null
    creatorid?: NullableIntFieldUpdateOperationsInput | number | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    msg?: NullableStringFieldUpdateOperationsInput | string | null
    creationdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    icon?: NullableIntFieldUpdateOperationsInput | number | null
    guildid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type bbs_recordsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    idforbbs?: NullableIntFieldUpdateOperationsInput | number | null
    creatorid?: NullableIntFieldUpdateOperationsInput | number | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    msg?: NullableStringFieldUpdateOperationsInput | string | null
    creationdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    icon?: NullableIntFieldUpdateOperationsInput | number | null
    guildid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type bbs_repliesCreateInput = {
    idforreply?: number | null
    creatorid?: number | null
    creationdate?: Date | string | null
    msg?: string | null
    recordid?: number | null
  }

  export type bbs_repliesUncheckedCreateInput = {
    id?: number
    idforreply?: number | null
    creatorid?: number | null
    creationdate?: Date | string | null
    msg?: string | null
    recordid?: number | null
  }

  export type bbs_repliesUpdateInput = {
    idforreply?: NullableIntFieldUpdateOperationsInput | number | null
    creatorid?: NullableIntFieldUpdateOperationsInput | number | null
    creationdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    msg?: NullableStringFieldUpdateOperationsInput | string | null
    recordid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type bbs_repliesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    idforreply?: NullableIntFieldUpdateOperationsInput | number | null
    creatorid?: NullableIntFieldUpdateOperationsInput | number | null
    creationdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    msg?: NullableStringFieldUpdateOperationsInput | string | null
    recordid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type bbs_repliesCreateManyInput = {
    id?: number
    idforreply?: number | null
    creatorid?: number | null
    creationdate?: Date | string | null
    msg?: string | null
    recordid?: number | null
  }

  export type bbs_repliesUpdateManyMutationInput = {
    idforreply?: NullableIntFieldUpdateOperationsInput | number | null
    creatorid?: NullableIntFieldUpdateOperationsInput | number | null
    creationdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    msg?: NullableStringFieldUpdateOperationsInput | string | null
    recordid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type bbs_repliesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    idforreply?: NullableIntFieldUpdateOperationsInput | number | null
    creatorid?: NullableIntFieldUpdateOperationsInput | number | null
    creationdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    msg?: NullableStringFieldUpdateOperationsInput | string | null
    recordid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type beautydataCreateInput = {
    charID?: number
    hairSize?: number
    faceSize?: number
    hairString: string
    faceString: string
  }

  export type beautydataUncheckedCreateInput = {
    id?: number
    charID?: number
    hairSize?: number
    faceSize?: number
    hairString: string
    faceString: string
  }

  export type beautydataUpdateInput = {
    charID?: IntFieldUpdateOperationsInput | number
    hairSize?: IntFieldUpdateOperationsInput | number
    faceSize?: IntFieldUpdateOperationsInput | number
    hairString?: StringFieldUpdateOperationsInput | string
    faceString?: StringFieldUpdateOperationsInput | string
  }

  export type beautydataUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    charID?: IntFieldUpdateOperationsInput | number
    hairSize?: IntFieldUpdateOperationsInput | number
    faceSize?: IntFieldUpdateOperationsInput | number
    hairString?: StringFieldUpdateOperationsInput | string
    faceString?: StringFieldUpdateOperationsInput | string
  }

  export type beautydataCreateManyInput = {
    id?: number
    charID?: number
    hairSize?: number
    faceSize?: number
    hairString: string
    faceString: string
  }

  export type beautydataUpdateManyMutationInput = {
    charID?: IntFieldUpdateOperationsInput | number
    hairSize?: IntFieldUpdateOperationsInput | number
    faceSize?: IntFieldUpdateOperationsInput | number
    hairString?: StringFieldUpdateOperationsInput | string
    faceString?: StringFieldUpdateOperationsInput | string
  }

  export type beautydataUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    charID?: IntFieldUpdateOperationsInput | number
    hairSize?: IntFieldUpdateOperationsInput | number
    faceSize?: IntFieldUpdateOperationsInput | number
    hairString?: StringFieldUpdateOperationsInput | string
    faceString?: StringFieldUpdateOperationsInput | string
  }

  export type bosslogCreateInput = {
    accountid: number
    bossid: string
    lastattempt?: Date | string
    pqentry?: number
  }

  export type bosslogUncheckedCreateInput = {
    id?: number
    accountid: number
    bossid: string
    lastattempt?: Date | string
    pqentry?: number
  }

  export type bosslogUpdateInput = {
    accountid?: IntFieldUpdateOperationsInput | number
    bossid?: StringFieldUpdateOperationsInput | string
    lastattempt?: DateTimeFieldUpdateOperationsInput | Date | string
    pqentry?: IntFieldUpdateOperationsInput | number
  }

  export type bosslogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    accountid?: IntFieldUpdateOperationsInput | number
    bossid?: StringFieldUpdateOperationsInput | string
    lastattempt?: DateTimeFieldUpdateOperationsInput | Date | string
    pqentry?: IntFieldUpdateOperationsInput | number
  }

  export type bosslogCreateManyInput = {
    id?: number
    accountid: number
    bossid: string
    lastattempt?: Date | string
    pqentry?: number
  }

  export type bosslogUpdateManyMutationInput = {
    accountid?: IntFieldUpdateOperationsInput | number
    bossid?: StringFieldUpdateOperationsInput | string
    lastattempt?: DateTimeFieldUpdateOperationsInput | Date | string
    pqentry?: IntFieldUpdateOperationsInput | number
  }

  export type bosslogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    accountid?: IntFieldUpdateOperationsInput | number
    bossid?: StringFieldUpdateOperationsInput | string
    lastattempt?: DateTimeFieldUpdateOperationsInput | Date | string
    pqentry?: IntFieldUpdateOperationsInput | number
  }

  export type cashiteminfosCreateInput = {
    id?: bigint | number
    accountid?: number | null
    characterid?: number | null
    commodityid?: number | null
    buycharacterid?: string | null
    paybackrate?: number | null
    discount?: number | null
    orderno?: number | null
    productno?: number | null
    refundable?: boolean | null
    sourceflag?: number | null
    storebank?: boolean | null
    itemid?: number | null
    trunkid?: number | null
    position?: number | null
  }

  export type cashiteminfosUncheckedCreateInput = {
    id?: bigint | number
    accountid?: number | null
    characterid?: number | null
    commodityid?: number | null
    buycharacterid?: string | null
    paybackrate?: number | null
    discount?: number | null
    orderno?: number | null
    productno?: number | null
    refundable?: boolean | null
    sourceflag?: number | null
    storebank?: boolean | null
    itemid?: number | null
    trunkid?: number | null
    position?: number | null
  }

  export type cashiteminfosUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    accountid?: NullableIntFieldUpdateOperationsInput | number | null
    characterid?: NullableIntFieldUpdateOperationsInput | number | null
    commodityid?: NullableIntFieldUpdateOperationsInput | number | null
    buycharacterid?: NullableStringFieldUpdateOperationsInput | string | null
    paybackrate?: NullableIntFieldUpdateOperationsInput | number | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    orderno?: NullableIntFieldUpdateOperationsInput | number | null
    productno?: NullableIntFieldUpdateOperationsInput | number | null
    refundable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sourceflag?: NullableIntFieldUpdateOperationsInput | number | null
    storebank?: NullableBoolFieldUpdateOperationsInput | boolean | null
    itemid?: NullableIntFieldUpdateOperationsInput | number | null
    trunkid?: NullableIntFieldUpdateOperationsInput | number | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type cashiteminfosUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    accountid?: NullableIntFieldUpdateOperationsInput | number | null
    characterid?: NullableIntFieldUpdateOperationsInput | number | null
    commodityid?: NullableIntFieldUpdateOperationsInput | number | null
    buycharacterid?: NullableStringFieldUpdateOperationsInput | string | null
    paybackrate?: NullableIntFieldUpdateOperationsInput | number | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    orderno?: NullableIntFieldUpdateOperationsInput | number | null
    productno?: NullableIntFieldUpdateOperationsInput | number | null
    refundable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sourceflag?: NullableIntFieldUpdateOperationsInput | number | null
    storebank?: NullableBoolFieldUpdateOperationsInput | boolean | null
    itemid?: NullableIntFieldUpdateOperationsInput | number | null
    trunkid?: NullableIntFieldUpdateOperationsInput | number | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type cashiteminfosCreateManyInput = {
    id?: bigint | number
    accountid?: number | null
    characterid?: number | null
    commodityid?: number | null
    buycharacterid?: string | null
    paybackrate?: number | null
    discount?: number | null
    orderno?: number | null
    productno?: number | null
    refundable?: boolean | null
    sourceflag?: number | null
    storebank?: boolean | null
    itemid?: number | null
    trunkid?: number | null
    position?: number | null
  }

  export type cashiteminfosUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    accountid?: NullableIntFieldUpdateOperationsInput | number | null
    characterid?: NullableIntFieldUpdateOperationsInput | number | null
    commodityid?: NullableIntFieldUpdateOperationsInput | number | null
    buycharacterid?: NullableStringFieldUpdateOperationsInput | string | null
    paybackrate?: NullableIntFieldUpdateOperationsInput | number | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    orderno?: NullableIntFieldUpdateOperationsInput | number | null
    productno?: NullableIntFieldUpdateOperationsInput | number | null
    refundable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sourceflag?: NullableIntFieldUpdateOperationsInput | number | null
    storebank?: NullableBoolFieldUpdateOperationsInput | boolean | null
    itemid?: NullableIntFieldUpdateOperationsInput | number | null
    trunkid?: NullableIntFieldUpdateOperationsInput | number | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type cashiteminfosUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    accountid?: NullableIntFieldUpdateOperationsInput | number | null
    characterid?: NullableIntFieldUpdateOperationsInput | number | null
    commodityid?: NullableIntFieldUpdateOperationsInput | number | null
    buycharacterid?: NullableStringFieldUpdateOperationsInput | string | null
    paybackrate?: NullableIntFieldUpdateOperationsInput | number | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    orderno?: NullableIntFieldUpdateOperationsInput | number | null
    productno?: NullableIntFieldUpdateOperationsInput | number | null
    refundable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sourceflag?: NullableIntFieldUpdateOperationsInput | number | null
    storebank?: NullableBoolFieldUpdateOperationsInput | boolean | null
    itemid?: NullableIntFieldUpdateOperationsInput | number | null
    trunkid?: NullableIntFieldUpdateOperationsInput | number | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type characterpotentialsCreateInput = {
    id?: bigint | number
    potkey?: number | null
    skillid?: number | null
    slv?: number | null
    grade?: number | null
    charid?: number | null
  }

  export type characterpotentialsUncheckedCreateInput = {
    id?: bigint | number
    potkey?: number | null
    skillid?: number | null
    slv?: number | null
    grade?: number | null
    charid?: number | null
  }

  export type characterpotentialsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    potkey?: NullableIntFieldUpdateOperationsInput | number | null
    skillid?: NullableIntFieldUpdateOperationsInput | number | null
    slv?: NullableIntFieldUpdateOperationsInput | number | null
    grade?: NullableIntFieldUpdateOperationsInput | number | null
    charid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type characterpotentialsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    potkey?: NullableIntFieldUpdateOperationsInput | number | null
    skillid?: NullableIntFieldUpdateOperationsInput | number | null
    slv?: NullableIntFieldUpdateOperationsInput | number | null
    grade?: NullableIntFieldUpdateOperationsInput | number | null
    charid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type characterpotentialsCreateManyInput = {
    id?: bigint | number
    potkey?: number | null
    skillid?: number | null
    slv?: number | null
    grade?: number | null
    charid?: number | null
  }

  export type characterpotentialsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    potkey?: NullableIntFieldUpdateOperationsInput | number | null
    skillid?: NullableIntFieldUpdateOperationsInput | number | null
    slv?: NullableIntFieldUpdateOperationsInput | number | null
    grade?: NullableIntFieldUpdateOperationsInput | number | null
    charid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type characterpotentialsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    potkey?: NullableIntFieldUpdateOperationsInput | number | null
    skillid?: NullableIntFieldUpdateOperationsInput | number | null
    slv?: NullableIntFieldUpdateOperationsInput | number | null
    grade?: NullableIntFieldUpdateOperationsInput | number | null
    charid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type charactersCreateInput = {
    accid?: number | null
    orderid?: number | null
    avatardata?: number | null
    equippedinventory?: number | null
    equipinventory?: number | null
    consumeinventory?: number | null
    etcinventory?: number | null
    installinventory?: number | null
    cashinventory?: number | null
    funckeymap_id?: number | null
    fieldid?: number | null
    questmanager?: bigint | number | null
    guild?: number | null
    rewardPoints?: number | null
    monsterbook?: number | null
    party?: number | null
    medalid?: number | null
    monsterparkcount?: number | null
    previousFieldID?: bigint | number | null
    onlineDay?: number | null
    onlineTime?: bigint | number | null
    quickslotKeys?: string | null
  }

  export type charactersUncheckedCreateInput = {
    id?: number
    accid?: number | null
    orderid?: number | null
    avatardata?: number | null
    equippedinventory?: number | null
    equipinventory?: number | null
    consumeinventory?: number | null
    etcinventory?: number | null
    installinventory?: number | null
    cashinventory?: number | null
    funckeymap_id?: number | null
    fieldid?: number | null
    questmanager?: bigint | number | null
    guild?: number | null
    rewardPoints?: number | null
    monsterbook?: number | null
    party?: number | null
    medalid?: number | null
    monsterparkcount?: number | null
    previousFieldID?: bigint | number | null
    onlineDay?: number | null
    onlineTime?: bigint | number | null
    quickslotKeys?: string | null
  }

  export type charactersUpdateInput = {
    accid?: NullableIntFieldUpdateOperationsInput | number | null
    orderid?: NullableIntFieldUpdateOperationsInput | number | null
    avatardata?: NullableIntFieldUpdateOperationsInput | number | null
    equippedinventory?: NullableIntFieldUpdateOperationsInput | number | null
    equipinventory?: NullableIntFieldUpdateOperationsInput | number | null
    consumeinventory?: NullableIntFieldUpdateOperationsInput | number | null
    etcinventory?: NullableIntFieldUpdateOperationsInput | number | null
    installinventory?: NullableIntFieldUpdateOperationsInput | number | null
    cashinventory?: NullableIntFieldUpdateOperationsInput | number | null
    funckeymap_id?: NullableIntFieldUpdateOperationsInput | number | null
    fieldid?: NullableIntFieldUpdateOperationsInput | number | null
    questmanager?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    guild?: NullableIntFieldUpdateOperationsInput | number | null
    rewardPoints?: NullableIntFieldUpdateOperationsInput | number | null
    monsterbook?: NullableIntFieldUpdateOperationsInput | number | null
    party?: NullableIntFieldUpdateOperationsInput | number | null
    medalid?: NullableIntFieldUpdateOperationsInput | number | null
    monsterparkcount?: NullableIntFieldUpdateOperationsInput | number | null
    previousFieldID?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    onlineDay?: NullableIntFieldUpdateOperationsInput | number | null
    onlineTime?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    quickslotKeys?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type charactersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    accid?: NullableIntFieldUpdateOperationsInput | number | null
    orderid?: NullableIntFieldUpdateOperationsInput | number | null
    avatardata?: NullableIntFieldUpdateOperationsInput | number | null
    equippedinventory?: NullableIntFieldUpdateOperationsInput | number | null
    equipinventory?: NullableIntFieldUpdateOperationsInput | number | null
    consumeinventory?: NullableIntFieldUpdateOperationsInput | number | null
    etcinventory?: NullableIntFieldUpdateOperationsInput | number | null
    installinventory?: NullableIntFieldUpdateOperationsInput | number | null
    cashinventory?: NullableIntFieldUpdateOperationsInput | number | null
    funckeymap_id?: NullableIntFieldUpdateOperationsInput | number | null
    fieldid?: NullableIntFieldUpdateOperationsInput | number | null
    questmanager?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    guild?: NullableIntFieldUpdateOperationsInput | number | null
    rewardPoints?: NullableIntFieldUpdateOperationsInput | number | null
    monsterbook?: NullableIntFieldUpdateOperationsInput | number | null
    party?: NullableIntFieldUpdateOperationsInput | number | null
    medalid?: NullableIntFieldUpdateOperationsInput | number | null
    monsterparkcount?: NullableIntFieldUpdateOperationsInput | number | null
    previousFieldID?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    onlineDay?: NullableIntFieldUpdateOperationsInput | number | null
    onlineTime?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    quickslotKeys?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type charactersCreateManyInput = {
    id?: number
    accid?: number | null
    orderid?: number | null
    avatardata?: number | null
    equippedinventory?: number | null
    equipinventory?: number | null
    consumeinventory?: number | null
    etcinventory?: number | null
    installinventory?: number | null
    cashinventory?: number | null
    funckeymap_id?: number | null
    fieldid?: number | null
    questmanager?: bigint | number | null
    guild?: number | null
    rewardPoints?: number | null
    monsterbook?: number | null
    party?: number | null
    medalid?: number | null
    monsterparkcount?: number | null
    previousFieldID?: bigint | number | null
    onlineDay?: number | null
    onlineTime?: bigint | number | null
    quickslotKeys?: string | null
  }

  export type charactersUpdateManyMutationInput = {
    accid?: NullableIntFieldUpdateOperationsInput | number | null
    orderid?: NullableIntFieldUpdateOperationsInput | number | null
    avatardata?: NullableIntFieldUpdateOperationsInput | number | null
    equippedinventory?: NullableIntFieldUpdateOperationsInput | number | null
    equipinventory?: NullableIntFieldUpdateOperationsInput | number | null
    consumeinventory?: NullableIntFieldUpdateOperationsInput | number | null
    etcinventory?: NullableIntFieldUpdateOperationsInput | number | null
    installinventory?: NullableIntFieldUpdateOperationsInput | number | null
    cashinventory?: NullableIntFieldUpdateOperationsInput | number | null
    funckeymap_id?: NullableIntFieldUpdateOperationsInput | number | null
    fieldid?: NullableIntFieldUpdateOperationsInput | number | null
    questmanager?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    guild?: NullableIntFieldUpdateOperationsInput | number | null
    rewardPoints?: NullableIntFieldUpdateOperationsInput | number | null
    monsterbook?: NullableIntFieldUpdateOperationsInput | number | null
    party?: NullableIntFieldUpdateOperationsInput | number | null
    medalid?: NullableIntFieldUpdateOperationsInput | number | null
    monsterparkcount?: NullableIntFieldUpdateOperationsInput | number | null
    previousFieldID?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    onlineDay?: NullableIntFieldUpdateOperationsInput | number | null
    onlineTime?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    quickslotKeys?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type charactersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    accid?: NullableIntFieldUpdateOperationsInput | number | null
    orderid?: NullableIntFieldUpdateOperationsInput | number | null
    avatardata?: NullableIntFieldUpdateOperationsInput | number | null
    equippedinventory?: NullableIntFieldUpdateOperationsInput | number | null
    equipinventory?: NullableIntFieldUpdateOperationsInput | number | null
    consumeinventory?: NullableIntFieldUpdateOperationsInput | number | null
    etcinventory?: NullableIntFieldUpdateOperationsInput | number | null
    installinventory?: NullableIntFieldUpdateOperationsInput | number | null
    cashinventory?: NullableIntFieldUpdateOperationsInput | number | null
    funckeymap_id?: NullableIntFieldUpdateOperationsInput | number | null
    fieldid?: NullableIntFieldUpdateOperationsInput | number | null
    questmanager?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    guild?: NullableIntFieldUpdateOperationsInput | number | null
    rewardPoints?: NullableIntFieldUpdateOperationsInput | number | null
    monsterbook?: NullableIntFieldUpdateOperationsInput | number | null
    party?: NullableIntFieldUpdateOperationsInput | number | null
    medalid?: NullableIntFieldUpdateOperationsInput | number | null
    monsterparkcount?: NullableIntFieldUpdateOperationsInput | number | null
    previousFieldID?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    onlineDay?: NullableIntFieldUpdateOperationsInput | number | null
    onlineTime?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    quickslotKeys?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type characterstatsCreateInput = {
    characterid?: number | null
    characteridforlog?: number | null
    worldidforlog?: number | null
    name?: string | null
    gender?: number | null
    skin?: number | null
    face?: number | null
    hair?: number | null
    mixbasehaircolor?: number | null
    mixaddhaircolor?: number | null
    mixhairbaseprob?: number | null
    level?: number | null
    job?: number | null
    str?: number | null
    dex?: number | null
    inte?: number | null
    luk?: number | null
    hp?: number | null
    maxhp?: number | null
    mp?: number | null
    maxmp?: number | null
    ap?: number | null
    sp?: number | null
    exp?: string | null
    pop?: number | null
    money?: string | null
    wp?: number | null
    extendsp?: number | null
    posmap?: string | null
    portal?: number | null
    subjob?: number | null
    deffaceacc?: number | null
    fatigue?: number | null
    lastfatigueupdatetime?: number | null
    charismaexp?: number | null
    insightexp?: number | null
    willexp?: number | null
    craftexp?: number | null
    senseexp?: number | null
    charmexp?: number | null
    noncombatstatdaylimit?: number | null
    mcpoint?: number | null
    pvpexp?: number | null
    pvpgrade?: number | null
    pvppoint?: number | null
    pvpmodelevel?: number | null
    pvpmodetype?: number | null
    eventpoint?: number | null
    albaactivityid?: number | null
    albastarttime?: Date | string | null
    albaduration?: number | null
    albaspecialreward?: number | null
    burning?: boolean | null
    charactercard?: number | null
    accountlastlogout?: number | null
    lastlogout?: Date | string | null
    gachexp?: number | null
    honorexp?: number | null
    nextavailablefametime?: Date | string | null
    node_shards?: number
    maxfriends?: number
  }

  export type characterstatsUncheckedCreateInput = {
    id?: number
    characterid?: number | null
    characteridforlog?: number | null
    worldidforlog?: number | null
    name?: string | null
    gender?: number | null
    skin?: number | null
    face?: number | null
    hair?: number | null
    mixbasehaircolor?: number | null
    mixaddhaircolor?: number | null
    mixhairbaseprob?: number | null
    level?: number | null
    job?: number | null
    str?: number | null
    dex?: number | null
    inte?: number | null
    luk?: number | null
    hp?: number | null
    maxhp?: number | null
    mp?: number | null
    maxmp?: number | null
    ap?: number | null
    sp?: number | null
    exp?: string | null
    pop?: number | null
    money?: string | null
    wp?: number | null
    extendsp?: number | null
    posmap?: string | null
    portal?: number | null
    subjob?: number | null
    deffaceacc?: number | null
    fatigue?: number | null
    lastfatigueupdatetime?: number | null
    charismaexp?: number | null
    insightexp?: number | null
    willexp?: number | null
    craftexp?: number | null
    senseexp?: number | null
    charmexp?: number | null
    noncombatstatdaylimit?: number | null
    mcpoint?: number | null
    pvpexp?: number | null
    pvpgrade?: number | null
    pvppoint?: number | null
    pvpmodelevel?: number | null
    pvpmodetype?: number | null
    eventpoint?: number | null
    albaactivityid?: number | null
    albastarttime?: Date | string | null
    albaduration?: number | null
    albaspecialreward?: number | null
    burning?: boolean | null
    charactercard?: number | null
    accountlastlogout?: number | null
    lastlogout?: Date | string | null
    gachexp?: number | null
    honorexp?: number | null
    nextavailablefametime?: Date | string | null
    node_shards?: number
    maxfriends?: number
  }

  export type characterstatsUpdateInput = {
    characterid?: NullableIntFieldUpdateOperationsInput | number | null
    characteridforlog?: NullableIntFieldUpdateOperationsInput | number | null
    worldidforlog?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    skin?: NullableIntFieldUpdateOperationsInput | number | null
    face?: NullableIntFieldUpdateOperationsInput | number | null
    hair?: NullableIntFieldUpdateOperationsInput | number | null
    mixbasehaircolor?: NullableIntFieldUpdateOperationsInput | number | null
    mixaddhaircolor?: NullableIntFieldUpdateOperationsInput | number | null
    mixhairbaseprob?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    job?: NullableIntFieldUpdateOperationsInput | number | null
    str?: NullableIntFieldUpdateOperationsInput | number | null
    dex?: NullableIntFieldUpdateOperationsInput | number | null
    inte?: NullableIntFieldUpdateOperationsInput | number | null
    luk?: NullableIntFieldUpdateOperationsInput | number | null
    hp?: NullableIntFieldUpdateOperationsInput | number | null
    maxhp?: NullableIntFieldUpdateOperationsInput | number | null
    mp?: NullableIntFieldUpdateOperationsInput | number | null
    maxmp?: NullableIntFieldUpdateOperationsInput | number | null
    ap?: NullableIntFieldUpdateOperationsInput | number | null
    sp?: NullableIntFieldUpdateOperationsInput | number | null
    exp?: NullableStringFieldUpdateOperationsInput | string | null
    pop?: NullableIntFieldUpdateOperationsInput | number | null
    money?: NullableStringFieldUpdateOperationsInput | string | null
    wp?: NullableIntFieldUpdateOperationsInput | number | null
    extendsp?: NullableIntFieldUpdateOperationsInput | number | null
    posmap?: NullableStringFieldUpdateOperationsInput | string | null
    portal?: NullableIntFieldUpdateOperationsInput | number | null
    subjob?: NullableIntFieldUpdateOperationsInput | number | null
    deffaceacc?: NullableIntFieldUpdateOperationsInput | number | null
    fatigue?: NullableIntFieldUpdateOperationsInput | number | null
    lastfatigueupdatetime?: NullableIntFieldUpdateOperationsInput | number | null
    charismaexp?: NullableIntFieldUpdateOperationsInput | number | null
    insightexp?: NullableIntFieldUpdateOperationsInput | number | null
    willexp?: NullableIntFieldUpdateOperationsInput | number | null
    craftexp?: NullableIntFieldUpdateOperationsInput | number | null
    senseexp?: NullableIntFieldUpdateOperationsInput | number | null
    charmexp?: NullableIntFieldUpdateOperationsInput | number | null
    noncombatstatdaylimit?: NullableIntFieldUpdateOperationsInput | number | null
    mcpoint?: NullableIntFieldUpdateOperationsInput | number | null
    pvpexp?: NullableIntFieldUpdateOperationsInput | number | null
    pvpgrade?: NullableIntFieldUpdateOperationsInput | number | null
    pvppoint?: NullableIntFieldUpdateOperationsInput | number | null
    pvpmodelevel?: NullableIntFieldUpdateOperationsInput | number | null
    pvpmodetype?: NullableIntFieldUpdateOperationsInput | number | null
    eventpoint?: NullableIntFieldUpdateOperationsInput | number | null
    albaactivityid?: NullableIntFieldUpdateOperationsInput | number | null
    albastarttime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    albaduration?: NullableIntFieldUpdateOperationsInput | number | null
    albaspecialreward?: NullableIntFieldUpdateOperationsInput | number | null
    burning?: NullableBoolFieldUpdateOperationsInput | boolean | null
    charactercard?: NullableIntFieldUpdateOperationsInput | number | null
    accountlastlogout?: NullableIntFieldUpdateOperationsInput | number | null
    lastlogout?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gachexp?: NullableIntFieldUpdateOperationsInput | number | null
    honorexp?: NullableIntFieldUpdateOperationsInput | number | null
    nextavailablefametime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    node_shards?: IntFieldUpdateOperationsInput | number
    maxfriends?: IntFieldUpdateOperationsInput | number
  }

  export type characterstatsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    characterid?: NullableIntFieldUpdateOperationsInput | number | null
    characteridforlog?: NullableIntFieldUpdateOperationsInput | number | null
    worldidforlog?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    skin?: NullableIntFieldUpdateOperationsInput | number | null
    face?: NullableIntFieldUpdateOperationsInput | number | null
    hair?: NullableIntFieldUpdateOperationsInput | number | null
    mixbasehaircolor?: NullableIntFieldUpdateOperationsInput | number | null
    mixaddhaircolor?: NullableIntFieldUpdateOperationsInput | number | null
    mixhairbaseprob?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    job?: NullableIntFieldUpdateOperationsInput | number | null
    str?: NullableIntFieldUpdateOperationsInput | number | null
    dex?: NullableIntFieldUpdateOperationsInput | number | null
    inte?: NullableIntFieldUpdateOperationsInput | number | null
    luk?: NullableIntFieldUpdateOperationsInput | number | null
    hp?: NullableIntFieldUpdateOperationsInput | number | null
    maxhp?: NullableIntFieldUpdateOperationsInput | number | null
    mp?: NullableIntFieldUpdateOperationsInput | number | null
    maxmp?: NullableIntFieldUpdateOperationsInput | number | null
    ap?: NullableIntFieldUpdateOperationsInput | number | null
    sp?: NullableIntFieldUpdateOperationsInput | number | null
    exp?: NullableStringFieldUpdateOperationsInput | string | null
    pop?: NullableIntFieldUpdateOperationsInput | number | null
    money?: NullableStringFieldUpdateOperationsInput | string | null
    wp?: NullableIntFieldUpdateOperationsInput | number | null
    extendsp?: NullableIntFieldUpdateOperationsInput | number | null
    posmap?: NullableStringFieldUpdateOperationsInput | string | null
    portal?: NullableIntFieldUpdateOperationsInput | number | null
    subjob?: NullableIntFieldUpdateOperationsInput | number | null
    deffaceacc?: NullableIntFieldUpdateOperationsInput | number | null
    fatigue?: NullableIntFieldUpdateOperationsInput | number | null
    lastfatigueupdatetime?: NullableIntFieldUpdateOperationsInput | number | null
    charismaexp?: NullableIntFieldUpdateOperationsInput | number | null
    insightexp?: NullableIntFieldUpdateOperationsInput | number | null
    willexp?: NullableIntFieldUpdateOperationsInput | number | null
    craftexp?: NullableIntFieldUpdateOperationsInput | number | null
    senseexp?: NullableIntFieldUpdateOperationsInput | number | null
    charmexp?: NullableIntFieldUpdateOperationsInput | number | null
    noncombatstatdaylimit?: NullableIntFieldUpdateOperationsInput | number | null
    mcpoint?: NullableIntFieldUpdateOperationsInput | number | null
    pvpexp?: NullableIntFieldUpdateOperationsInput | number | null
    pvpgrade?: NullableIntFieldUpdateOperationsInput | number | null
    pvppoint?: NullableIntFieldUpdateOperationsInput | number | null
    pvpmodelevel?: NullableIntFieldUpdateOperationsInput | number | null
    pvpmodetype?: NullableIntFieldUpdateOperationsInput | number | null
    eventpoint?: NullableIntFieldUpdateOperationsInput | number | null
    albaactivityid?: NullableIntFieldUpdateOperationsInput | number | null
    albastarttime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    albaduration?: NullableIntFieldUpdateOperationsInput | number | null
    albaspecialreward?: NullableIntFieldUpdateOperationsInput | number | null
    burning?: NullableBoolFieldUpdateOperationsInput | boolean | null
    charactercard?: NullableIntFieldUpdateOperationsInput | number | null
    accountlastlogout?: NullableIntFieldUpdateOperationsInput | number | null
    lastlogout?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gachexp?: NullableIntFieldUpdateOperationsInput | number | null
    honorexp?: NullableIntFieldUpdateOperationsInput | number | null
    nextavailablefametime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    node_shards?: IntFieldUpdateOperationsInput | number
    maxfriends?: IntFieldUpdateOperationsInput | number
  }

  export type characterstatsCreateManyInput = {
    id?: number
    characterid?: number | null
    characteridforlog?: number | null
    worldidforlog?: number | null
    name?: string | null
    gender?: number | null
    skin?: number | null
    face?: number | null
    hair?: number | null
    mixbasehaircolor?: number | null
    mixaddhaircolor?: number | null
    mixhairbaseprob?: number | null
    level?: number | null
    job?: number | null
    str?: number | null
    dex?: number | null
    inte?: number | null
    luk?: number | null
    hp?: number | null
    maxhp?: number | null
    mp?: number | null
    maxmp?: number | null
    ap?: number | null
    sp?: number | null
    exp?: string | null
    pop?: number | null
    money?: string | null
    wp?: number | null
    extendsp?: number | null
    posmap?: string | null
    portal?: number | null
    subjob?: number | null
    deffaceacc?: number | null
    fatigue?: number | null
    lastfatigueupdatetime?: number | null
    charismaexp?: number | null
    insightexp?: number | null
    willexp?: number | null
    craftexp?: number | null
    senseexp?: number | null
    charmexp?: number | null
    noncombatstatdaylimit?: number | null
    mcpoint?: number | null
    pvpexp?: number | null
    pvpgrade?: number | null
    pvppoint?: number | null
    pvpmodelevel?: number | null
    pvpmodetype?: number | null
    eventpoint?: number | null
    albaactivityid?: number | null
    albastarttime?: Date | string | null
    albaduration?: number | null
    albaspecialreward?: number | null
    burning?: boolean | null
    charactercard?: number | null
    accountlastlogout?: number | null
    lastlogout?: Date | string | null
    gachexp?: number | null
    honorexp?: number | null
    nextavailablefametime?: Date | string | null
    node_shards?: number
    maxfriends?: number
  }

  export type characterstatsUpdateManyMutationInput = {
    characterid?: NullableIntFieldUpdateOperationsInput | number | null
    characteridforlog?: NullableIntFieldUpdateOperationsInput | number | null
    worldidforlog?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    skin?: NullableIntFieldUpdateOperationsInput | number | null
    face?: NullableIntFieldUpdateOperationsInput | number | null
    hair?: NullableIntFieldUpdateOperationsInput | number | null
    mixbasehaircolor?: NullableIntFieldUpdateOperationsInput | number | null
    mixaddhaircolor?: NullableIntFieldUpdateOperationsInput | number | null
    mixhairbaseprob?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    job?: NullableIntFieldUpdateOperationsInput | number | null
    str?: NullableIntFieldUpdateOperationsInput | number | null
    dex?: NullableIntFieldUpdateOperationsInput | number | null
    inte?: NullableIntFieldUpdateOperationsInput | number | null
    luk?: NullableIntFieldUpdateOperationsInput | number | null
    hp?: NullableIntFieldUpdateOperationsInput | number | null
    maxhp?: NullableIntFieldUpdateOperationsInput | number | null
    mp?: NullableIntFieldUpdateOperationsInput | number | null
    maxmp?: NullableIntFieldUpdateOperationsInput | number | null
    ap?: NullableIntFieldUpdateOperationsInput | number | null
    sp?: NullableIntFieldUpdateOperationsInput | number | null
    exp?: NullableStringFieldUpdateOperationsInput | string | null
    pop?: NullableIntFieldUpdateOperationsInput | number | null
    money?: NullableStringFieldUpdateOperationsInput | string | null
    wp?: NullableIntFieldUpdateOperationsInput | number | null
    extendsp?: NullableIntFieldUpdateOperationsInput | number | null
    posmap?: NullableStringFieldUpdateOperationsInput | string | null
    portal?: NullableIntFieldUpdateOperationsInput | number | null
    subjob?: NullableIntFieldUpdateOperationsInput | number | null
    deffaceacc?: NullableIntFieldUpdateOperationsInput | number | null
    fatigue?: NullableIntFieldUpdateOperationsInput | number | null
    lastfatigueupdatetime?: NullableIntFieldUpdateOperationsInput | number | null
    charismaexp?: NullableIntFieldUpdateOperationsInput | number | null
    insightexp?: NullableIntFieldUpdateOperationsInput | number | null
    willexp?: NullableIntFieldUpdateOperationsInput | number | null
    craftexp?: NullableIntFieldUpdateOperationsInput | number | null
    senseexp?: NullableIntFieldUpdateOperationsInput | number | null
    charmexp?: NullableIntFieldUpdateOperationsInput | number | null
    noncombatstatdaylimit?: NullableIntFieldUpdateOperationsInput | number | null
    mcpoint?: NullableIntFieldUpdateOperationsInput | number | null
    pvpexp?: NullableIntFieldUpdateOperationsInput | number | null
    pvpgrade?: NullableIntFieldUpdateOperationsInput | number | null
    pvppoint?: NullableIntFieldUpdateOperationsInput | number | null
    pvpmodelevel?: NullableIntFieldUpdateOperationsInput | number | null
    pvpmodetype?: NullableIntFieldUpdateOperationsInput | number | null
    eventpoint?: NullableIntFieldUpdateOperationsInput | number | null
    albaactivityid?: NullableIntFieldUpdateOperationsInput | number | null
    albastarttime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    albaduration?: NullableIntFieldUpdateOperationsInput | number | null
    albaspecialreward?: NullableIntFieldUpdateOperationsInput | number | null
    burning?: NullableBoolFieldUpdateOperationsInput | boolean | null
    charactercard?: NullableIntFieldUpdateOperationsInput | number | null
    accountlastlogout?: NullableIntFieldUpdateOperationsInput | number | null
    lastlogout?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gachexp?: NullableIntFieldUpdateOperationsInput | number | null
    honorexp?: NullableIntFieldUpdateOperationsInput | number | null
    nextavailablefametime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    node_shards?: IntFieldUpdateOperationsInput | number
    maxfriends?: IntFieldUpdateOperationsInput | number
  }

  export type characterstatsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    characterid?: NullableIntFieldUpdateOperationsInput | number | null
    characteridforlog?: NullableIntFieldUpdateOperationsInput | number | null
    worldidforlog?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    skin?: NullableIntFieldUpdateOperationsInput | number | null
    face?: NullableIntFieldUpdateOperationsInput | number | null
    hair?: NullableIntFieldUpdateOperationsInput | number | null
    mixbasehaircolor?: NullableIntFieldUpdateOperationsInput | number | null
    mixaddhaircolor?: NullableIntFieldUpdateOperationsInput | number | null
    mixhairbaseprob?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    job?: NullableIntFieldUpdateOperationsInput | number | null
    str?: NullableIntFieldUpdateOperationsInput | number | null
    dex?: NullableIntFieldUpdateOperationsInput | number | null
    inte?: NullableIntFieldUpdateOperationsInput | number | null
    luk?: NullableIntFieldUpdateOperationsInput | number | null
    hp?: NullableIntFieldUpdateOperationsInput | number | null
    maxhp?: NullableIntFieldUpdateOperationsInput | number | null
    mp?: NullableIntFieldUpdateOperationsInput | number | null
    maxmp?: NullableIntFieldUpdateOperationsInput | number | null
    ap?: NullableIntFieldUpdateOperationsInput | number | null
    sp?: NullableIntFieldUpdateOperationsInput | number | null
    exp?: NullableStringFieldUpdateOperationsInput | string | null
    pop?: NullableIntFieldUpdateOperationsInput | number | null
    money?: NullableStringFieldUpdateOperationsInput | string | null
    wp?: NullableIntFieldUpdateOperationsInput | number | null
    extendsp?: NullableIntFieldUpdateOperationsInput | number | null
    posmap?: NullableStringFieldUpdateOperationsInput | string | null
    portal?: NullableIntFieldUpdateOperationsInput | number | null
    subjob?: NullableIntFieldUpdateOperationsInput | number | null
    deffaceacc?: NullableIntFieldUpdateOperationsInput | number | null
    fatigue?: NullableIntFieldUpdateOperationsInput | number | null
    lastfatigueupdatetime?: NullableIntFieldUpdateOperationsInput | number | null
    charismaexp?: NullableIntFieldUpdateOperationsInput | number | null
    insightexp?: NullableIntFieldUpdateOperationsInput | number | null
    willexp?: NullableIntFieldUpdateOperationsInput | number | null
    craftexp?: NullableIntFieldUpdateOperationsInput | number | null
    senseexp?: NullableIntFieldUpdateOperationsInput | number | null
    charmexp?: NullableIntFieldUpdateOperationsInput | number | null
    noncombatstatdaylimit?: NullableIntFieldUpdateOperationsInput | number | null
    mcpoint?: NullableIntFieldUpdateOperationsInput | number | null
    pvpexp?: NullableIntFieldUpdateOperationsInput | number | null
    pvpgrade?: NullableIntFieldUpdateOperationsInput | number | null
    pvppoint?: NullableIntFieldUpdateOperationsInput | number | null
    pvpmodelevel?: NullableIntFieldUpdateOperationsInput | number | null
    pvpmodetype?: NullableIntFieldUpdateOperationsInput | number | null
    eventpoint?: NullableIntFieldUpdateOperationsInput | number | null
    albaactivityid?: NullableIntFieldUpdateOperationsInput | number | null
    albastarttime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    albaduration?: NullableIntFieldUpdateOperationsInput | number | null
    albaspecialreward?: NullableIntFieldUpdateOperationsInput | number | null
    burning?: NullableBoolFieldUpdateOperationsInput | boolean | null
    charactercard?: NullableIntFieldUpdateOperationsInput | number | null
    accountlastlogout?: NullableIntFieldUpdateOperationsInput | number | null
    lastlogout?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gachexp?: NullableIntFieldUpdateOperationsInput | number | null
    honorexp?: NullableIntFieldUpdateOperationsInput | number | null
    nextavailablefametime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    node_shards?: IntFieldUpdateOperationsInput | number
    maxfriends?: IntFieldUpdateOperationsInput | number
  }

  export type chosenskillsCreateInput = {
    charid?: number | null
    skillid?: number | null
    position?: number | null
  }

  export type chosenskillsUncheckedCreateInput = {
    id?: number
    charid?: number | null
    skillid?: number | null
    position?: number | null
  }

  export type chosenskillsUpdateInput = {
    charid?: NullableIntFieldUpdateOperationsInput | number | null
    skillid?: NullableIntFieldUpdateOperationsInput | number | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type chosenskillsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    charid?: NullableIntFieldUpdateOperationsInput | number | null
    skillid?: NullableIntFieldUpdateOperationsInput | number | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type chosenskillsCreateManyInput = {
    id?: number
    charid?: number | null
    skillid?: number | null
    position?: number | null
  }

  export type chosenskillsUpdateManyMutationInput = {
    charid?: NullableIntFieldUpdateOperationsInput | number | null
    skillid?: NullableIntFieldUpdateOperationsInput | number | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type chosenskillsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    charid?: NullableIntFieldUpdateOperationsInput | number | null
    skillid?: NullableIntFieldUpdateOperationsInput | number | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type cms_votesCreateInput = {
    accountid: number
    ip: string
    time?: Date | string
    vp: number
    collected: number
  }

  export type cms_votesUncheckedCreateInput = {
    id?: number
    accountid: number
    ip: string
    time?: Date | string
    vp: number
    collected: number
  }

  export type cms_votesUpdateInput = {
    accountid?: IntFieldUpdateOperationsInput | number
    ip?: StringFieldUpdateOperationsInput | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    vp?: IntFieldUpdateOperationsInput | number
    collected?: IntFieldUpdateOperationsInput | number
  }

  export type cms_votesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    accountid?: IntFieldUpdateOperationsInput | number
    ip?: StringFieldUpdateOperationsInput | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    vp?: IntFieldUpdateOperationsInput | number
    collected?: IntFieldUpdateOperationsInput | number
  }

  export type cms_votesCreateManyInput = {
    id?: number
    accountid: number
    ip: string
    time?: Date | string
    vp: number
    collected: number
  }

  export type cms_votesUpdateManyMutationInput = {
    accountid?: IntFieldUpdateOperationsInput | number
    ip?: StringFieldUpdateOperationsInput | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    vp?: IntFieldUpdateOperationsInput | number
    collected?: IntFieldUpdateOperationsInput | number
  }

  export type cms_votesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    accountid?: IntFieldUpdateOperationsInput | number
    ip?: StringFieldUpdateOperationsInput | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    vp?: IntFieldUpdateOperationsInput | number
    collected?: IntFieldUpdateOperationsInput | number
  }

  export type cooldownsCreateInput = {
    player_name: string
    cooldown_type: number
    expiry_time: Date | string
  }

  export type cooldownsUncheckedCreateInput = {
    id?: number
    player_name: string
    cooldown_type: number
    expiry_time: Date | string
  }

  export type cooldownsUpdateInput = {
    player_name?: StringFieldUpdateOperationsInput | string
    cooldown_type?: IntFieldUpdateOperationsInput | number
    expiry_time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cooldownsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    player_name?: StringFieldUpdateOperationsInput | string
    cooldown_type?: IntFieldUpdateOperationsInput | number
    expiry_time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cooldownsCreateManyInput = {
    id?: number
    player_name: string
    cooldown_type: number
    expiry_time: Date | string
  }

  export type cooldownsUpdateManyMutationInput = {
    player_name?: StringFieldUpdateOperationsInput | string
    cooldown_type?: IntFieldUpdateOperationsInput | number
    expiry_time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cooldownsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    player_name?: StringFieldUpdateOperationsInput | string
    cooldown_type?: IntFieldUpdateOperationsInput | number
    expiry_time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type coresCreateInput = {
    pos?: number | null
    charid?: number | null
    slottype?: number | null
    coreid?: number | null
    leftCount?: number | null
  }

  export type coresUncheckedCreateInput = {
    id?: number
    pos?: number | null
    charid?: number | null
    slottype?: number | null
    coreid?: number | null
    leftCount?: number | null
  }

  export type coresUpdateInput = {
    pos?: NullableIntFieldUpdateOperationsInput | number | null
    charid?: NullableIntFieldUpdateOperationsInput | number | null
    slottype?: NullableIntFieldUpdateOperationsInput | number | null
    coreid?: NullableIntFieldUpdateOperationsInput | number | null
    leftCount?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type coresUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pos?: NullableIntFieldUpdateOperationsInput | number | null
    charid?: NullableIntFieldUpdateOperationsInput | number | null
    slottype?: NullableIntFieldUpdateOperationsInput | number | null
    coreid?: NullableIntFieldUpdateOperationsInput | number | null
    leftCount?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type coresCreateManyInput = {
    id?: number
    pos?: number | null
    charid?: number | null
    slottype?: number | null
    coreid?: number | null
    leftCount?: number | null
  }

  export type coresUpdateManyMutationInput = {
    pos?: NullableIntFieldUpdateOperationsInput | number | null
    charid?: NullableIntFieldUpdateOperationsInput | number | null
    slottype?: NullableIntFieldUpdateOperationsInput | number | null
    coreid?: NullableIntFieldUpdateOperationsInput | number | null
    leftCount?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type coresUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pos?: NullableIntFieldUpdateOperationsInput | number | null
    charid?: NullableIntFieldUpdateOperationsInput | number | null
    slottype?: NullableIntFieldUpdateOperationsInput | number | null
    coreid?: NullableIntFieldUpdateOperationsInput | number | null
    leftCount?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type cs_categoriesCreateInput = {
    idx?: number | null
    name?: string | null
    flag?: number | null
    parentIdx?: number | null
    stock?: number | null
  }

  export type cs_categoriesUncheckedCreateInput = {
    id?: number
    idx?: number | null
    name?: string | null
    flag?: number | null
    parentIdx?: number | null
    stock?: number | null
  }

  export type cs_categoriesUpdateInput = {
    idx?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    flag?: NullableIntFieldUpdateOperationsInput | number | null
    parentIdx?: NullableIntFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type cs_categoriesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    idx?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    flag?: NullableIntFieldUpdateOperationsInput | number | null
    parentIdx?: NullableIntFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type cs_categoriesCreateManyInput = {
    id?: number
    idx?: number | null
    name?: string | null
    flag?: number | null
    parentIdx?: number | null
    stock?: number | null
  }

  export type cs_categoriesUpdateManyMutationInput = {
    idx?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    flag?: NullableIntFieldUpdateOperationsInput | number | null
    parentIdx?: NullableIntFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type cs_categoriesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    idx?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    flag?: NullableIntFieldUpdateOperationsInput | number | null
    parentIdx?: NullableIntFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type cs_itemsCreateInput = {
    itemID: number
    stock?: number | null
    shopItemFlag?: number | null
    idk1?: number | null
    idk2?: number | null
    oldPrice?: number | null
    newPrice?: number | null
    idkTime1?: Date | string | null
    saleFromFT?: Date | string | null
    idkTime3?: Date | string | null
    saleToFT?: Date | string | null
    idk3?: number | null
    bundleQuantity?: number | null
    availableDays?: number | null
    buyableWithMaplePoints?: number | null
    buyableWithCredit?: number | null
    buyableWithPrepaid?: number | null
    likable?: number | null
    meso?: number | null
    favoritable?: number | null
    gender?: number | null
    likes?: number | null
    requiredLevel?: number | null
    idk10?: string | null
    idk11?: number | null
    idk13?: number | null
    idk14?: number | null
    category?: string | null
  }

  export type cs_itemsUncheckedCreateInput = {
    id?: number
    itemID: number
    stock?: number | null
    shopItemFlag?: number | null
    idk1?: number | null
    idk2?: number | null
    oldPrice?: number | null
    newPrice?: number | null
    idkTime1?: Date | string | null
    saleFromFT?: Date | string | null
    idkTime3?: Date | string | null
    saleToFT?: Date | string | null
    idk3?: number | null
    bundleQuantity?: number | null
    availableDays?: number | null
    buyableWithMaplePoints?: number | null
    buyableWithCredit?: number | null
    buyableWithPrepaid?: number | null
    likable?: number | null
    meso?: number | null
    favoritable?: number | null
    gender?: number | null
    likes?: number | null
    requiredLevel?: number | null
    idk10?: string | null
    idk11?: number | null
    idk13?: number | null
    idk14?: number | null
    category?: string | null
  }

  export type cs_itemsUpdateInput = {
    itemID?: IntFieldUpdateOperationsInput | number
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    shopItemFlag?: NullableIntFieldUpdateOperationsInput | number | null
    idk1?: NullableIntFieldUpdateOperationsInput | number | null
    idk2?: NullableIntFieldUpdateOperationsInput | number | null
    oldPrice?: NullableIntFieldUpdateOperationsInput | number | null
    newPrice?: NullableIntFieldUpdateOperationsInput | number | null
    idkTime1?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    saleFromFT?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idkTime3?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    saleToFT?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idk3?: NullableIntFieldUpdateOperationsInput | number | null
    bundleQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    availableDays?: NullableIntFieldUpdateOperationsInput | number | null
    buyableWithMaplePoints?: NullableIntFieldUpdateOperationsInput | number | null
    buyableWithCredit?: NullableIntFieldUpdateOperationsInput | number | null
    buyableWithPrepaid?: NullableIntFieldUpdateOperationsInput | number | null
    likable?: NullableIntFieldUpdateOperationsInput | number | null
    meso?: NullableIntFieldUpdateOperationsInput | number | null
    favoritable?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    likes?: NullableIntFieldUpdateOperationsInput | number | null
    requiredLevel?: NullableIntFieldUpdateOperationsInput | number | null
    idk10?: NullableStringFieldUpdateOperationsInput | string | null
    idk11?: NullableIntFieldUpdateOperationsInput | number | null
    idk13?: NullableIntFieldUpdateOperationsInput | number | null
    idk14?: NullableIntFieldUpdateOperationsInput | number | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type cs_itemsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemID?: IntFieldUpdateOperationsInput | number
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    shopItemFlag?: NullableIntFieldUpdateOperationsInput | number | null
    idk1?: NullableIntFieldUpdateOperationsInput | number | null
    idk2?: NullableIntFieldUpdateOperationsInput | number | null
    oldPrice?: NullableIntFieldUpdateOperationsInput | number | null
    newPrice?: NullableIntFieldUpdateOperationsInput | number | null
    idkTime1?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    saleFromFT?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idkTime3?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    saleToFT?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idk3?: NullableIntFieldUpdateOperationsInput | number | null
    bundleQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    availableDays?: NullableIntFieldUpdateOperationsInput | number | null
    buyableWithMaplePoints?: NullableIntFieldUpdateOperationsInput | number | null
    buyableWithCredit?: NullableIntFieldUpdateOperationsInput | number | null
    buyableWithPrepaid?: NullableIntFieldUpdateOperationsInput | number | null
    likable?: NullableIntFieldUpdateOperationsInput | number | null
    meso?: NullableIntFieldUpdateOperationsInput | number | null
    favoritable?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    likes?: NullableIntFieldUpdateOperationsInput | number | null
    requiredLevel?: NullableIntFieldUpdateOperationsInput | number | null
    idk10?: NullableStringFieldUpdateOperationsInput | string | null
    idk11?: NullableIntFieldUpdateOperationsInput | number | null
    idk13?: NullableIntFieldUpdateOperationsInput | number | null
    idk14?: NullableIntFieldUpdateOperationsInput | number | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type cs_itemsCreateManyInput = {
    id?: number
    itemID: number
    stock?: number | null
    shopItemFlag?: number | null
    idk1?: number | null
    idk2?: number | null
    oldPrice?: number | null
    newPrice?: number | null
    idkTime1?: Date | string | null
    saleFromFT?: Date | string | null
    idkTime3?: Date | string | null
    saleToFT?: Date | string | null
    idk3?: number | null
    bundleQuantity?: number | null
    availableDays?: number | null
    buyableWithMaplePoints?: number | null
    buyableWithCredit?: number | null
    buyableWithPrepaid?: number | null
    likable?: number | null
    meso?: number | null
    favoritable?: number | null
    gender?: number | null
    likes?: number | null
    requiredLevel?: number | null
    idk10?: string | null
    idk11?: number | null
    idk13?: number | null
    idk14?: number | null
    category?: string | null
  }

  export type cs_itemsUpdateManyMutationInput = {
    itemID?: IntFieldUpdateOperationsInput | number
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    shopItemFlag?: NullableIntFieldUpdateOperationsInput | number | null
    idk1?: NullableIntFieldUpdateOperationsInput | number | null
    idk2?: NullableIntFieldUpdateOperationsInput | number | null
    oldPrice?: NullableIntFieldUpdateOperationsInput | number | null
    newPrice?: NullableIntFieldUpdateOperationsInput | number | null
    idkTime1?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    saleFromFT?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idkTime3?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    saleToFT?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idk3?: NullableIntFieldUpdateOperationsInput | number | null
    bundleQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    availableDays?: NullableIntFieldUpdateOperationsInput | number | null
    buyableWithMaplePoints?: NullableIntFieldUpdateOperationsInput | number | null
    buyableWithCredit?: NullableIntFieldUpdateOperationsInput | number | null
    buyableWithPrepaid?: NullableIntFieldUpdateOperationsInput | number | null
    likable?: NullableIntFieldUpdateOperationsInput | number | null
    meso?: NullableIntFieldUpdateOperationsInput | number | null
    favoritable?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    likes?: NullableIntFieldUpdateOperationsInput | number | null
    requiredLevel?: NullableIntFieldUpdateOperationsInput | number | null
    idk10?: NullableStringFieldUpdateOperationsInput | string | null
    idk11?: NullableIntFieldUpdateOperationsInput | number | null
    idk13?: NullableIntFieldUpdateOperationsInput | number | null
    idk14?: NullableIntFieldUpdateOperationsInput | number | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type cs_itemsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemID?: IntFieldUpdateOperationsInput | number
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    shopItemFlag?: NullableIntFieldUpdateOperationsInput | number | null
    idk1?: NullableIntFieldUpdateOperationsInput | number | null
    idk2?: NullableIntFieldUpdateOperationsInput | number | null
    oldPrice?: NullableIntFieldUpdateOperationsInput | number | null
    newPrice?: NullableIntFieldUpdateOperationsInput | number | null
    idkTime1?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    saleFromFT?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idkTime3?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    saleToFT?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idk3?: NullableIntFieldUpdateOperationsInput | number | null
    bundleQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    availableDays?: NullableIntFieldUpdateOperationsInput | number | null
    buyableWithMaplePoints?: NullableIntFieldUpdateOperationsInput | number | null
    buyableWithCredit?: NullableIntFieldUpdateOperationsInput | number | null
    buyableWithPrepaid?: NullableIntFieldUpdateOperationsInput | number | null
    likable?: NullableIntFieldUpdateOperationsInput | number | null
    meso?: NullableIntFieldUpdateOperationsInput | number | null
    favoritable?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    likes?: NullableIntFieldUpdateOperationsInput | number | null
    requiredLevel?: NullableIntFieldUpdateOperationsInput | number | null
    idk10?: NullableStringFieldUpdateOperationsInput | string | null
    idk11?: NullableIntFieldUpdateOperationsInput | number | null
    idk13?: NullableIntFieldUpdateOperationsInput | number | null
    idk14?: NullableIntFieldUpdateOperationsInput | number | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type damageskinsCreateInput = {
    id?: bigint | number
    charid?: number | null
    damageskinid?: number | null
    itemid?: number | null
    notsave?: boolean | null
    description?: string | null
  }

  export type damageskinsUncheckedCreateInput = {
    id?: bigint | number
    charid?: number | null
    damageskinid?: number | null
    itemid?: number | null
    notsave?: boolean | null
    description?: string | null
  }

  export type damageskinsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    charid?: NullableIntFieldUpdateOperationsInput | number | null
    damageskinid?: NullableIntFieldUpdateOperationsInput | number | null
    itemid?: NullableIntFieldUpdateOperationsInput | number | null
    notsave?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type damageskinsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    charid?: NullableIntFieldUpdateOperationsInput | number | null
    damageskinid?: NullableIntFieldUpdateOperationsInput | number | null
    itemid?: NullableIntFieldUpdateOperationsInput | number | null
    notsave?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type damageskinsCreateManyInput = {
    id?: bigint | number
    charid?: number | null
    damageskinid?: number | null
    itemid?: number | null
    notsave?: boolean | null
    description?: string | null
  }

  export type damageskinsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    charid?: NullableIntFieldUpdateOperationsInput | number | null
    damageskinid?: NullableIntFieldUpdateOperationsInput | number | null
    itemid?: NullableIntFieldUpdateOperationsInput | number | null
    notsave?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type damageskinsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    charid?: NullableIntFieldUpdateOperationsInput | number | null
    damageskinid?: NullableIntFieldUpdateOperationsInput | number | null
    itemid?: NullableIntFieldUpdateOperationsInput | number | null
    notsave?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type employeetrunkCreateInput = {
    money?: bigint | number | null
  }

  export type employeetrunkUncheckedCreateInput = {
    id?: number
    money?: bigint | number | null
  }

  export type employeetrunkUpdateInput = {
    money?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type employeetrunkUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    money?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type employeetrunkCreateManyInput = {
    id?: number
    money?: bigint | number | null
  }

  export type employeetrunkUpdateManyMutationInput = {
    money?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type employeetrunkUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    money?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type equipsCreateInput = {
    serialnumber?: bigint | number | null
    itemid: bigint | number
    title?: string | null
    equippeddate?: Date | string | null
    prevbonusexprate?: number | null
    options?: string | null
    sockets?: string | null
    tuc?: number | null
    cuc?: number | null
    istr?: number | null
    idex?: number | null
    iint?: number | null
    iluk?: number | null
    imaxhp?: number | null
    imaxhpr: number
    imaxmp?: number | null
    imaxmpr: number
    ipad?: number | null
    imad?: number | null
    ipdd?: number | null
    imdd?: number | null
    iacc?: number | null
    ieva?: number | null
    icraft?: number | null
    ispeed?: number | null
    ijump?: number | null
    arcaneid?: bigint | number | null
    attribute?: number | null
    leveluptype?: number | null
    level?: number | null
    exp?: number | null
    durability?: number | null
    iuc?: number | null
    ipvpdamage?: number | null
    ireducereq?: number | null
    specialattribute?: number | null
    durabilitymax?: number | null
    iincreq?: number | null
    growthenchant?: number | null
    psenchant?: number | null
    hyperupgrade?: number | null
    bdr?: number | null
    imdr?: number | null
    damr?: number | null
    statr?: number | null
    cuttable?: number | null
    exgradeoption?: bigint | number | null
    itemstate?: number | null
    grade?: number | null
    chuc?: number | null
    souloptionid?: number | null
    soulsocketid?: number | null
    souloption?: number | null
    soulitemid?: number | null
    rstr?: number | null
    rdex?: number | null
    rint?: number | null
    rluk?: number | null
    rlevel?: number | null
    rjob?: number | null
    rpop?: number | null
    specialgrade?: number | null
    fixedpotential?: boolean | null
    tradeblock?: boolean | null
    isonly?: boolean | null
    notsale?: boolean | null
    attackspeed?: number | null
    price?: number | null
    charmexp?: number | null
    setitemid?: number | null
    exitem?: boolean | null
    equiptradeblock?: boolean | null
    islot?: string | null
    vslot?: string | null
    fixedgrade?: number | null
    nopotential?: number | null
    bossreward?: number | null
    superioreqp?: number | null
    flameid?: bigint | number | null
    android?: number | null
    androidgrade?: number | null
    arcane_stat?: number | null
    arcane_exp?: number | null
    arcane_level?: number | null
    flame_str?: number | null
    flame_dex?: number | null
    flame_int?: number | null
    flame_luk?: number | null
    flame_pad?: number | null
    flame_mad?: number | null
    flame_pdd?: number | null
    flame_hp?: number | null
    flame_mp?: number | null
    flame_speed?: number | null
    flame_jump?: number | null
    flame_allStatR?: number | null
    flame_bossDamageR?: number | null
    flame_damageR?: number | null
    flame_reduceReqLevel?: number | null
  }

  export type equipsUncheckedCreateInput = {
    serialnumber?: bigint | number | null
    itemid: bigint | number
    title?: string | null
    equippeddate?: Date | string | null
    prevbonusexprate?: number | null
    options?: string | null
    sockets?: string | null
    tuc?: number | null
    cuc?: number | null
    istr?: number | null
    idex?: number | null
    iint?: number | null
    iluk?: number | null
    imaxhp?: number | null
    imaxhpr: number
    imaxmp?: number | null
    imaxmpr: number
    ipad?: number | null
    imad?: number | null
    ipdd?: number | null
    imdd?: number | null
    iacc?: number | null
    ieva?: number | null
    icraft?: number | null
    ispeed?: number | null
    ijump?: number | null
    arcaneid?: bigint | number | null
    attribute?: number | null
    leveluptype?: number | null
    level?: number | null
    exp?: number | null
    durability?: number | null
    iuc?: number | null
    ipvpdamage?: number | null
    ireducereq?: number | null
    specialattribute?: number | null
    durabilitymax?: number | null
    iincreq?: number | null
    growthenchant?: number | null
    psenchant?: number | null
    hyperupgrade?: number | null
    bdr?: number | null
    imdr?: number | null
    damr?: number | null
    statr?: number | null
    cuttable?: number | null
    exgradeoption?: bigint | number | null
    itemstate?: number | null
    grade?: number | null
    chuc?: number | null
    souloptionid?: number | null
    soulsocketid?: number | null
    souloption?: number | null
    soulitemid?: number | null
    rstr?: number | null
    rdex?: number | null
    rint?: number | null
    rluk?: number | null
    rlevel?: number | null
    rjob?: number | null
    rpop?: number | null
    specialgrade?: number | null
    fixedpotential?: boolean | null
    tradeblock?: boolean | null
    isonly?: boolean | null
    notsale?: boolean | null
    attackspeed?: number | null
    price?: number | null
    charmexp?: number | null
    setitemid?: number | null
    exitem?: boolean | null
    equiptradeblock?: boolean | null
    islot?: string | null
    vslot?: string | null
    fixedgrade?: number | null
    nopotential?: number | null
    bossreward?: number | null
    superioreqp?: number | null
    flameid?: bigint | number | null
    android?: number | null
    androidgrade?: number | null
    arcane_stat?: number | null
    arcane_exp?: number | null
    arcane_level?: number | null
    flame_str?: number | null
    flame_dex?: number | null
    flame_int?: number | null
    flame_luk?: number | null
    flame_pad?: number | null
    flame_mad?: number | null
    flame_pdd?: number | null
    flame_hp?: number | null
    flame_mp?: number | null
    flame_speed?: number | null
    flame_jump?: number | null
    flame_allStatR?: number | null
    flame_bossDamageR?: number | null
    flame_damageR?: number | null
    flame_reduceReqLevel?: number | null
  }

  export type equipsUpdateInput = {
    serialnumber?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    itemid?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    equippeddate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prevbonusexprate?: NullableIntFieldUpdateOperationsInput | number | null
    options?: NullableStringFieldUpdateOperationsInput | string | null
    sockets?: NullableStringFieldUpdateOperationsInput | string | null
    tuc?: NullableIntFieldUpdateOperationsInput | number | null
    cuc?: NullableIntFieldUpdateOperationsInput | number | null
    istr?: NullableIntFieldUpdateOperationsInput | number | null
    idex?: NullableIntFieldUpdateOperationsInput | number | null
    iint?: NullableIntFieldUpdateOperationsInput | number | null
    iluk?: NullableIntFieldUpdateOperationsInput | number | null
    imaxhp?: NullableIntFieldUpdateOperationsInput | number | null
    imaxhpr?: IntFieldUpdateOperationsInput | number
    imaxmp?: NullableIntFieldUpdateOperationsInput | number | null
    imaxmpr?: IntFieldUpdateOperationsInput | number
    ipad?: NullableIntFieldUpdateOperationsInput | number | null
    imad?: NullableIntFieldUpdateOperationsInput | number | null
    ipdd?: NullableIntFieldUpdateOperationsInput | number | null
    imdd?: NullableIntFieldUpdateOperationsInput | number | null
    iacc?: NullableIntFieldUpdateOperationsInput | number | null
    ieva?: NullableIntFieldUpdateOperationsInput | number | null
    icraft?: NullableIntFieldUpdateOperationsInput | number | null
    ispeed?: NullableIntFieldUpdateOperationsInput | number | null
    ijump?: NullableIntFieldUpdateOperationsInput | number | null
    arcaneid?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    attribute?: NullableIntFieldUpdateOperationsInput | number | null
    leveluptype?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    exp?: NullableIntFieldUpdateOperationsInput | number | null
    durability?: NullableIntFieldUpdateOperationsInput | number | null
    iuc?: NullableIntFieldUpdateOperationsInput | number | null
    ipvpdamage?: NullableIntFieldUpdateOperationsInput | number | null
    ireducereq?: NullableIntFieldUpdateOperationsInput | number | null
    specialattribute?: NullableIntFieldUpdateOperationsInput | number | null
    durabilitymax?: NullableIntFieldUpdateOperationsInput | number | null
    iincreq?: NullableIntFieldUpdateOperationsInput | number | null
    growthenchant?: NullableIntFieldUpdateOperationsInput | number | null
    psenchant?: NullableIntFieldUpdateOperationsInput | number | null
    hyperupgrade?: NullableIntFieldUpdateOperationsInput | number | null
    bdr?: NullableIntFieldUpdateOperationsInput | number | null
    imdr?: NullableIntFieldUpdateOperationsInput | number | null
    damr?: NullableIntFieldUpdateOperationsInput | number | null
    statr?: NullableIntFieldUpdateOperationsInput | number | null
    cuttable?: NullableIntFieldUpdateOperationsInput | number | null
    exgradeoption?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    itemstate?: NullableIntFieldUpdateOperationsInput | number | null
    grade?: NullableIntFieldUpdateOperationsInput | number | null
    chuc?: NullableIntFieldUpdateOperationsInput | number | null
    souloptionid?: NullableIntFieldUpdateOperationsInput | number | null
    soulsocketid?: NullableIntFieldUpdateOperationsInput | number | null
    souloption?: NullableIntFieldUpdateOperationsInput | number | null
    soulitemid?: NullableIntFieldUpdateOperationsInput | number | null
    rstr?: NullableIntFieldUpdateOperationsInput | number | null
    rdex?: NullableIntFieldUpdateOperationsInput | number | null
    rint?: NullableIntFieldUpdateOperationsInput | number | null
    rluk?: NullableIntFieldUpdateOperationsInput | number | null
    rlevel?: NullableIntFieldUpdateOperationsInput | number | null
    rjob?: NullableIntFieldUpdateOperationsInput | number | null
    rpop?: NullableIntFieldUpdateOperationsInput | number | null
    specialgrade?: NullableIntFieldUpdateOperationsInput | number | null
    fixedpotential?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tradeblock?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isonly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    notsale?: NullableBoolFieldUpdateOperationsInput | boolean | null
    attackspeed?: NullableIntFieldUpdateOperationsInput | number | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    charmexp?: NullableIntFieldUpdateOperationsInput | number | null
    setitemid?: NullableIntFieldUpdateOperationsInput | number | null
    exitem?: NullableBoolFieldUpdateOperationsInput | boolean | null
    equiptradeblock?: NullableBoolFieldUpdateOperationsInput | boolean | null
    islot?: NullableStringFieldUpdateOperationsInput | string | null
    vslot?: NullableStringFieldUpdateOperationsInput | string | null
    fixedgrade?: NullableIntFieldUpdateOperationsInput | number | null
    nopotential?: NullableIntFieldUpdateOperationsInput | number | null
    bossreward?: NullableIntFieldUpdateOperationsInput | number | null
    superioreqp?: NullableIntFieldUpdateOperationsInput | number | null
    flameid?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    android?: NullableIntFieldUpdateOperationsInput | number | null
    androidgrade?: NullableIntFieldUpdateOperationsInput | number | null
    arcane_stat?: NullableIntFieldUpdateOperationsInput | number | null
    arcane_exp?: NullableIntFieldUpdateOperationsInput | number | null
    arcane_level?: NullableIntFieldUpdateOperationsInput | number | null
    flame_str?: NullableIntFieldUpdateOperationsInput | number | null
    flame_dex?: NullableIntFieldUpdateOperationsInput | number | null
    flame_int?: NullableIntFieldUpdateOperationsInput | number | null
    flame_luk?: NullableIntFieldUpdateOperationsInput | number | null
    flame_pad?: NullableIntFieldUpdateOperationsInput | number | null
    flame_mad?: NullableIntFieldUpdateOperationsInput | number | null
    flame_pdd?: NullableIntFieldUpdateOperationsInput | number | null
    flame_hp?: NullableIntFieldUpdateOperationsInput | number | null
    flame_mp?: NullableIntFieldUpdateOperationsInput | number | null
    flame_speed?: NullableIntFieldUpdateOperationsInput | number | null
    flame_jump?: NullableIntFieldUpdateOperationsInput | number | null
    flame_allStatR?: NullableIntFieldUpdateOperationsInput | number | null
    flame_bossDamageR?: NullableIntFieldUpdateOperationsInput | number | null
    flame_damageR?: NullableIntFieldUpdateOperationsInput | number | null
    flame_reduceReqLevel?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type equipsUncheckedUpdateInput = {
    serialnumber?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    itemid?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    equippeddate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prevbonusexprate?: NullableIntFieldUpdateOperationsInput | number | null
    options?: NullableStringFieldUpdateOperationsInput | string | null
    sockets?: NullableStringFieldUpdateOperationsInput | string | null
    tuc?: NullableIntFieldUpdateOperationsInput | number | null
    cuc?: NullableIntFieldUpdateOperationsInput | number | null
    istr?: NullableIntFieldUpdateOperationsInput | number | null
    idex?: NullableIntFieldUpdateOperationsInput | number | null
    iint?: NullableIntFieldUpdateOperationsInput | number | null
    iluk?: NullableIntFieldUpdateOperationsInput | number | null
    imaxhp?: NullableIntFieldUpdateOperationsInput | number | null
    imaxhpr?: IntFieldUpdateOperationsInput | number
    imaxmp?: NullableIntFieldUpdateOperationsInput | number | null
    imaxmpr?: IntFieldUpdateOperationsInput | number
    ipad?: NullableIntFieldUpdateOperationsInput | number | null
    imad?: NullableIntFieldUpdateOperationsInput | number | null
    ipdd?: NullableIntFieldUpdateOperationsInput | number | null
    imdd?: NullableIntFieldUpdateOperationsInput | number | null
    iacc?: NullableIntFieldUpdateOperationsInput | number | null
    ieva?: NullableIntFieldUpdateOperationsInput | number | null
    icraft?: NullableIntFieldUpdateOperationsInput | number | null
    ispeed?: NullableIntFieldUpdateOperationsInput | number | null
    ijump?: NullableIntFieldUpdateOperationsInput | number | null
    arcaneid?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    attribute?: NullableIntFieldUpdateOperationsInput | number | null
    leveluptype?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    exp?: NullableIntFieldUpdateOperationsInput | number | null
    durability?: NullableIntFieldUpdateOperationsInput | number | null
    iuc?: NullableIntFieldUpdateOperationsInput | number | null
    ipvpdamage?: NullableIntFieldUpdateOperationsInput | number | null
    ireducereq?: NullableIntFieldUpdateOperationsInput | number | null
    specialattribute?: NullableIntFieldUpdateOperationsInput | number | null
    durabilitymax?: NullableIntFieldUpdateOperationsInput | number | null
    iincreq?: NullableIntFieldUpdateOperationsInput | number | null
    growthenchant?: NullableIntFieldUpdateOperationsInput | number | null
    psenchant?: NullableIntFieldUpdateOperationsInput | number | null
    hyperupgrade?: NullableIntFieldUpdateOperationsInput | number | null
    bdr?: NullableIntFieldUpdateOperationsInput | number | null
    imdr?: NullableIntFieldUpdateOperationsInput | number | null
    damr?: NullableIntFieldUpdateOperationsInput | number | null
    statr?: NullableIntFieldUpdateOperationsInput | number | null
    cuttable?: NullableIntFieldUpdateOperationsInput | number | null
    exgradeoption?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    itemstate?: NullableIntFieldUpdateOperationsInput | number | null
    grade?: NullableIntFieldUpdateOperationsInput | number | null
    chuc?: NullableIntFieldUpdateOperationsInput | number | null
    souloptionid?: NullableIntFieldUpdateOperationsInput | number | null
    soulsocketid?: NullableIntFieldUpdateOperationsInput | number | null
    souloption?: NullableIntFieldUpdateOperationsInput | number | null
    soulitemid?: NullableIntFieldUpdateOperationsInput | number | null
    rstr?: NullableIntFieldUpdateOperationsInput | number | null
    rdex?: NullableIntFieldUpdateOperationsInput | number | null
    rint?: NullableIntFieldUpdateOperationsInput | number | null
    rluk?: NullableIntFieldUpdateOperationsInput | number | null
    rlevel?: NullableIntFieldUpdateOperationsInput | number | null
    rjob?: NullableIntFieldUpdateOperationsInput | number | null
    rpop?: NullableIntFieldUpdateOperationsInput | number | null
    specialgrade?: NullableIntFieldUpdateOperationsInput | number | null
    fixedpotential?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tradeblock?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isonly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    notsale?: NullableBoolFieldUpdateOperationsInput | boolean | null
    attackspeed?: NullableIntFieldUpdateOperationsInput | number | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    charmexp?: NullableIntFieldUpdateOperationsInput | number | null
    setitemid?: NullableIntFieldUpdateOperationsInput | number | null
    exitem?: NullableBoolFieldUpdateOperationsInput | boolean | null
    equiptradeblock?: NullableBoolFieldUpdateOperationsInput | boolean | null
    islot?: NullableStringFieldUpdateOperationsInput | string | null
    vslot?: NullableStringFieldUpdateOperationsInput | string | null
    fixedgrade?: NullableIntFieldUpdateOperationsInput | number | null
    nopotential?: NullableIntFieldUpdateOperationsInput | number | null
    bossreward?: NullableIntFieldUpdateOperationsInput | number | null
    superioreqp?: NullableIntFieldUpdateOperationsInput | number | null
    flameid?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    android?: NullableIntFieldUpdateOperationsInput | number | null
    androidgrade?: NullableIntFieldUpdateOperationsInput | number | null
    arcane_stat?: NullableIntFieldUpdateOperationsInput | number | null
    arcane_exp?: NullableIntFieldUpdateOperationsInput | number | null
    arcane_level?: NullableIntFieldUpdateOperationsInput | number | null
    flame_str?: NullableIntFieldUpdateOperationsInput | number | null
    flame_dex?: NullableIntFieldUpdateOperationsInput | number | null
    flame_int?: NullableIntFieldUpdateOperationsInput | number | null
    flame_luk?: NullableIntFieldUpdateOperationsInput | number | null
    flame_pad?: NullableIntFieldUpdateOperationsInput | number | null
    flame_mad?: NullableIntFieldUpdateOperationsInput | number | null
    flame_pdd?: NullableIntFieldUpdateOperationsInput | number | null
    flame_hp?: NullableIntFieldUpdateOperationsInput | number | null
    flame_mp?: NullableIntFieldUpdateOperationsInput | number | null
    flame_speed?: NullableIntFieldUpdateOperationsInput | number | null
    flame_jump?: NullableIntFieldUpdateOperationsInput | number | null
    flame_allStatR?: NullableIntFieldUpdateOperationsInput | number | null
    flame_bossDamageR?: NullableIntFieldUpdateOperationsInput | number | null
    flame_damageR?: NullableIntFieldUpdateOperationsInput | number | null
    flame_reduceReqLevel?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type equipsCreateManyInput = {
    serialnumber?: bigint | number | null
    itemid: bigint | number
    title?: string | null
    equippeddate?: Date | string | null
    prevbonusexprate?: number | null
    options?: string | null
    sockets?: string | null
    tuc?: number | null
    cuc?: number | null
    istr?: number | null
    idex?: number | null
    iint?: number | null
    iluk?: number | null
    imaxhp?: number | null
    imaxhpr: number
    imaxmp?: number | null
    imaxmpr: number
    ipad?: number | null
    imad?: number | null
    ipdd?: number | null
    imdd?: number | null
    iacc?: number | null
    ieva?: number | null
    icraft?: number | null
    ispeed?: number | null
    ijump?: number | null
    arcaneid?: bigint | number | null
    attribute?: number | null
    leveluptype?: number | null
    level?: number | null
    exp?: number | null
    durability?: number | null
    iuc?: number | null
    ipvpdamage?: number | null
    ireducereq?: number | null
    specialattribute?: number | null
    durabilitymax?: number | null
    iincreq?: number | null
    growthenchant?: number | null
    psenchant?: number | null
    hyperupgrade?: number | null
    bdr?: number | null
    imdr?: number | null
    damr?: number | null
    statr?: number | null
    cuttable?: number | null
    exgradeoption?: bigint | number | null
    itemstate?: number | null
    grade?: number | null
    chuc?: number | null
    souloptionid?: number | null
    soulsocketid?: number | null
    souloption?: number | null
    soulitemid?: number | null
    rstr?: number | null
    rdex?: number | null
    rint?: number | null
    rluk?: number | null
    rlevel?: number | null
    rjob?: number | null
    rpop?: number | null
    specialgrade?: number | null
    fixedpotential?: boolean | null
    tradeblock?: boolean | null
    isonly?: boolean | null
    notsale?: boolean | null
    attackspeed?: number | null
    price?: number | null
    charmexp?: number | null
    setitemid?: number | null
    exitem?: boolean | null
    equiptradeblock?: boolean | null
    islot?: string | null
    vslot?: string | null
    fixedgrade?: number | null
    nopotential?: number | null
    bossreward?: number | null
    superioreqp?: number | null
    flameid?: bigint | number | null
    android?: number | null
    androidgrade?: number | null
    arcane_stat?: number | null
    arcane_exp?: number | null
    arcane_level?: number | null
    flame_str?: number | null
    flame_dex?: number | null
    flame_int?: number | null
    flame_luk?: number | null
    flame_pad?: number | null
    flame_mad?: number | null
    flame_pdd?: number | null
    flame_hp?: number | null
    flame_mp?: number | null
    flame_speed?: number | null
    flame_jump?: number | null
    flame_allStatR?: number | null
    flame_bossDamageR?: number | null
    flame_damageR?: number | null
    flame_reduceReqLevel?: number | null
  }

  export type equipsUpdateManyMutationInput = {
    serialnumber?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    itemid?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    equippeddate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prevbonusexprate?: NullableIntFieldUpdateOperationsInput | number | null
    options?: NullableStringFieldUpdateOperationsInput | string | null
    sockets?: NullableStringFieldUpdateOperationsInput | string | null
    tuc?: NullableIntFieldUpdateOperationsInput | number | null
    cuc?: NullableIntFieldUpdateOperationsInput | number | null
    istr?: NullableIntFieldUpdateOperationsInput | number | null
    idex?: NullableIntFieldUpdateOperationsInput | number | null
    iint?: NullableIntFieldUpdateOperationsInput | number | null
    iluk?: NullableIntFieldUpdateOperationsInput | number | null
    imaxhp?: NullableIntFieldUpdateOperationsInput | number | null
    imaxhpr?: IntFieldUpdateOperationsInput | number
    imaxmp?: NullableIntFieldUpdateOperationsInput | number | null
    imaxmpr?: IntFieldUpdateOperationsInput | number
    ipad?: NullableIntFieldUpdateOperationsInput | number | null
    imad?: NullableIntFieldUpdateOperationsInput | number | null
    ipdd?: NullableIntFieldUpdateOperationsInput | number | null
    imdd?: NullableIntFieldUpdateOperationsInput | number | null
    iacc?: NullableIntFieldUpdateOperationsInput | number | null
    ieva?: NullableIntFieldUpdateOperationsInput | number | null
    icraft?: NullableIntFieldUpdateOperationsInput | number | null
    ispeed?: NullableIntFieldUpdateOperationsInput | number | null
    ijump?: NullableIntFieldUpdateOperationsInput | number | null
    arcaneid?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    attribute?: NullableIntFieldUpdateOperationsInput | number | null
    leveluptype?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    exp?: NullableIntFieldUpdateOperationsInput | number | null
    durability?: NullableIntFieldUpdateOperationsInput | number | null
    iuc?: NullableIntFieldUpdateOperationsInput | number | null
    ipvpdamage?: NullableIntFieldUpdateOperationsInput | number | null
    ireducereq?: NullableIntFieldUpdateOperationsInput | number | null
    specialattribute?: NullableIntFieldUpdateOperationsInput | number | null
    durabilitymax?: NullableIntFieldUpdateOperationsInput | number | null
    iincreq?: NullableIntFieldUpdateOperationsInput | number | null
    growthenchant?: NullableIntFieldUpdateOperationsInput | number | null
    psenchant?: NullableIntFieldUpdateOperationsInput | number | null
    hyperupgrade?: NullableIntFieldUpdateOperationsInput | number | null
    bdr?: NullableIntFieldUpdateOperationsInput | number | null
    imdr?: NullableIntFieldUpdateOperationsInput | number | null
    damr?: NullableIntFieldUpdateOperationsInput | number | null
    statr?: NullableIntFieldUpdateOperationsInput | number | null
    cuttable?: NullableIntFieldUpdateOperationsInput | number | null
    exgradeoption?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    itemstate?: NullableIntFieldUpdateOperationsInput | number | null
    grade?: NullableIntFieldUpdateOperationsInput | number | null
    chuc?: NullableIntFieldUpdateOperationsInput | number | null
    souloptionid?: NullableIntFieldUpdateOperationsInput | number | null
    soulsocketid?: NullableIntFieldUpdateOperationsInput | number | null
    souloption?: NullableIntFieldUpdateOperationsInput | number | null
    soulitemid?: NullableIntFieldUpdateOperationsInput | number | null
    rstr?: NullableIntFieldUpdateOperationsInput | number | null
    rdex?: NullableIntFieldUpdateOperationsInput | number | null
    rint?: NullableIntFieldUpdateOperationsInput | number | null
    rluk?: NullableIntFieldUpdateOperationsInput | number | null
    rlevel?: NullableIntFieldUpdateOperationsInput | number | null
    rjob?: NullableIntFieldUpdateOperationsInput | number | null
    rpop?: NullableIntFieldUpdateOperationsInput | number | null
    specialgrade?: NullableIntFieldUpdateOperationsInput | number | null
    fixedpotential?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tradeblock?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isonly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    notsale?: NullableBoolFieldUpdateOperationsInput | boolean | null
    attackspeed?: NullableIntFieldUpdateOperationsInput | number | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    charmexp?: NullableIntFieldUpdateOperationsInput | number | null
    setitemid?: NullableIntFieldUpdateOperationsInput | number | null
    exitem?: NullableBoolFieldUpdateOperationsInput | boolean | null
    equiptradeblock?: NullableBoolFieldUpdateOperationsInput | boolean | null
    islot?: NullableStringFieldUpdateOperationsInput | string | null
    vslot?: NullableStringFieldUpdateOperationsInput | string | null
    fixedgrade?: NullableIntFieldUpdateOperationsInput | number | null
    nopotential?: NullableIntFieldUpdateOperationsInput | number | null
    bossreward?: NullableIntFieldUpdateOperationsInput | number | null
    superioreqp?: NullableIntFieldUpdateOperationsInput | number | null
    flameid?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    android?: NullableIntFieldUpdateOperationsInput | number | null
    androidgrade?: NullableIntFieldUpdateOperationsInput | number | null
    arcane_stat?: NullableIntFieldUpdateOperationsInput | number | null
    arcane_exp?: NullableIntFieldUpdateOperationsInput | number | null
    arcane_level?: NullableIntFieldUpdateOperationsInput | number | null
    flame_str?: NullableIntFieldUpdateOperationsInput | number | null
    flame_dex?: NullableIntFieldUpdateOperationsInput | number | null
    flame_int?: NullableIntFieldUpdateOperationsInput | number | null
    flame_luk?: NullableIntFieldUpdateOperationsInput | number | null
    flame_pad?: NullableIntFieldUpdateOperationsInput | number | null
    flame_mad?: NullableIntFieldUpdateOperationsInput | number | null
    flame_pdd?: NullableIntFieldUpdateOperationsInput | number | null
    flame_hp?: NullableIntFieldUpdateOperationsInput | number | null
    flame_mp?: NullableIntFieldUpdateOperationsInput | number | null
    flame_speed?: NullableIntFieldUpdateOperationsInput | number | null
    flame_jump?: NullableIntFieldUpdateOperationsInput | number | null
    flame_allStatR?: NullableIntFieldUpdateOperationsInput | number | null
    flame_bossDamageR?: NullableIntFieldUpdateOperationsInput | number | null
    flame_damageR?: NullableIntFieldUpdateOperationsInput | number | null
    flame_reduceReqLevel?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type equipsUncheckedUpdateManyInput = {
    serialnumber?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    itemid?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    equippeddate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prevbonusexprate?: NullableIntFieldUpdateOperationsInput | number | null
    options?: NullableStringFieldUpdateOperationsInput | string | null
    sockets?: NullableStringFieldUpdateOperationsInput | string | null
    tuc?: NullableIntFieldUpdateOperationsInput | number | null
    cuc?: NullableIntFieldUpdateOperationsInput | number | null
    istr?: NullableIntFieldUpdateOperationsInput | number | null
    idex?: NullableIntFieldUpdateOperationsInput | number | null
    iint?: NullableIntFieldUpdateOperationsInput | number | null
    iluk?: NullableIntFieldUpdateOperationsInput | number | null
    imaxhp?: NullableIntFieldUpdateOperationsInput | number | null
    imaxhpr?: IntFieldUpdateOperationsInput | number
    imaxmp?: NullableIntFieldUpdateOperationsInput | number | null
    imaxmpr?: IntFieldUpdateOperationsInput | number
    ipad?: NullableIntFieldUpdateOperationsInput | number | null
    imad?: NullableIntFieldUpdateOperationsInput | number | null
    ipdd?: NullableIntFieldUpdateOperationsInput | number | null
    imdd?: NullableIntFieldUpdateOperationsInput | number | null
    iacc?: NullableIntFieldUpdateOperationsInput | number | null
    ieva?: NullableIntFieldUpdateOperationsInput | number | null
    icraft?: NullableIntFieldUpdateOperationsInput | number | null
    ispeed?: NullableIntFieldUpdateOperationsInput | number | null
    ijump?: NullableIntFieldUpdateOperationsInput | number | null
    arcaneid?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    attribute?: NullableIntFieldUpdateOperationsInput | number | null
    leveluptype?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    exp?: NullableIntFieldUpdateOperationsInput | number | null
    durability?: NullableIntFieldUpdateOperationsInput | number | null
    iuc?: NullableIntFieldUpdateOperationsInput | number | null
    ipvpdamage?: NullableIntFieldUpdateOperationsInput | number | null
    ireducereq?: NullableIntFieldUpdateOperationsInput | number | null
    specialattribute?: NullableIntFieldUpdateOperationsInput | number | null
    durabilitymax?: NullableIntFieldUpdateOperationsInput | number | null
    iincreq?: NullableIntFieldUpdateOperationsInput | number | null
    growthenchant?: NullableIntFieldUpdateOperationsInput | number | null
    psenchant?: NullableIntFieldUpdateOperationsInput | number | null
    hyperupgrade?: NullableIntFieldUpdateOperationsInput | number | null
    bdr?: NullableIntFieldUpdateOperationsInput | number | null
    imdr?: NullableIntFieldUpdateOperationsInput | number | null
    damr?: NullableIntFieldUpdateOperationsInput | number | null
    statr?: NullableIntFieldUpdateOperationsInput | number | null
    cuttable?: NullableIntFieldUpdateOperationsInput | number | null
    exgradeoption?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    itemstate?: NullableIntFieldUpdateOperationsInput | number | null
    grade?: NullableIntFieldUpdateOperationsInput | number | null
    chuc?: NullableIntFieldUpdateOperationsInput | number | null
    souloptionid?: NullableIntFieldUpdateOperationsInput | number | null
    soulsocketid?: NullableIntFieldUpdateOperationsInput | number | null
    souloption?: NullableIntFieldUpdateOperationsInput | number | null
    soulitemid?: NullableIntFieldUpdateOperationsInput | number | null
    rstr?: NullableIntFieldUpdateOperationsInput | number | null
    rdex?: NullableIntFieldUpdateOperationsInput | number | null
    rint?: NullableIntFieldUpdateOperationsInput | number | null
    rluk?: NullableIntFieldUpdateOperationsInput | number | null
    rlevel?: NullableIntFieldUpdateOperationsInput | number | null
    rjob?: NullableIntFieldUpdateOperationsInput | number | null
    rpop?: NullableIntFieldUpdateOperationsInput | number | null
    specialgrade?: NullableIntFieldUpdateOperationsInput | number | null
    fixedpotential?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tradeblock?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isonly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    notsale?: NullableBoolFieldUpdateOperationsInput | boolean | null
    attackspeed?: NullableIntFieldUpdateOperationsInput | number | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    charmexp?: NullableIntFieldUpdateOperationsInput | number | null
    setitemid?: NullableIntFieldUpdateOperationsInput | number | null
    exitem?: NullableBoolFieldUpdateOperationsInput | boolean | null
    equiptradeblock?: NullableBoolFieldUpdateOperationsInput | boolean | null
    islot?: NullableStringFieldUpdateOperationsInput | string | null
    vslot?: NullableStringFieldUpdateOperationsInput | string | null
    fixedgrade?: NullableIntFieldUpdateOperationsInput | number | null
    nopotential?: NullableIntFieldUpdateOperationsInput | number | null
    bossreward?: NullableIntFieldUpdateOperationsInput | number | null
    superioreqp?: NullableIntFieldUpdateOperationsInput | number | null
    flameid?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    android?: NullableIntFieldUpdateOperationsInput | number | null
    androidgrade?: NullableIntFieldUpdateOperationsInput | number | null
    arcane_stat?: NullableIntFieldUpdateOperationsInput | number | null
    arcane_exp?: NullableIntFieldUpdateOperationsInput | number | null
    arcane_level?: NullableIntFieldUpdateOperationsInput | number | null
    flame_str?: NullableIntFieldUpdateOperationsInput | number | null
    flame_dex?: NullableIntFieldUpdateOperationsInput | number | null
    flame_int?: NullableIntFieldUpdateOperationsInput | number | null
    flame_luk?: NullableIntFieldUpdateOperationsInput | number | null
    flame_pad?: NullableIntFieldUpdateOperationsInput | number | null
    flame_mad?: NullableIntFieldUpdateOperationsInput | number | null
    flame_pdd?: NullableIntFieldUpdateOperationsInput | number | null
    flame_hp?: NullableIntFieldUpdateOperationsInput | number | null
    flame_mp?: NullableIntFieldUpdateOperationsInput | number | null
    flame_speed?: NullableIntFieldUpdateOperationsInput | number | null
    flame_jump?: NullableIntFieldUpdateOperationsInput | number | null
    flame_allStatR?: NullableIntFieldUpdateOperationsInput | number | null
    flame_bossDamageR?: NullableIntFieldUpdateOperationsInput | number | null
    flame_damageR?: NullableIntFieldUpdateOperationsInput | number | null
    flame_reduceReqLevel?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type eventnametagCreateInput = {
    charid?: number
    activeRed?: number
    activeBlue?: number
    activeYellow?: number
    activeGreen?: number
    activePurple?: number
    sRed?: string
    sBlue?: string
    sYellow?: string
    sGreen?: string
    sPurple?: string
  }

  export type eventnametagUncheckedCreateInput = {
    id?: number
    charid?: number
    activeRed?: number
    activeBlue?: number
    activeYellow?: number
    activeGreen?: number
    activePurple?: number
    sRed?: string
    sBlue?: string
    sYellow?: string
    sGreen?: string
    sPurple?: string
  }

  export type eventnametagUpdateInput = {
    charid?: IntFieldUpdateOperationsInput | number
    activeRed?: IntFieldUpdateOperationsInput | number
    activeBlue?: IntFieldUpdateOperationsInput | number
    activeYellow?: IntFieldUpdateOperationsInput | number
    activeGreen?: IntFieldUpdateOperationsInput | number
    activePurple?: IntFieldUpdateOperationsInput | number
    sRed?: StringFieldUpdateOperationsInput | string
    sBlue?: StringFieldUpdateOperationsInput | string
    sYellow?: StringFieldUpdateOperationsInput | string
    sGreen?: StringFieldUpdateOperationsInput | string
    sPurple?: StringFieldUpdateOperationsInput | string
  }

  export type eventnametagUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    charid?: IntFieldUpdateOperationsInput | number
    activeRed?: IntFieldUpdateOperationsInput | number
    activeBlue?: IntFieldUpdateOperationsInput | number
    activeYellow?: IntFieldUpdateOperationsInput | number
    activeGreen?: IntFieldUpdateOperationsInput | number
    activePurple?: IntFieldUpdateOperationsInput | number
    sRed?: StringFieldUpdateOperationsInput | string
    sBlue?: StringFieldUpdateOperationsInput | string
    sYellow?: StringFieldUpdateOperationsInput | string
    sGreen?: StringFieldUpdateOperationsInput | string
    sPurple?: StringFieldUpdateOperationsInput | string
  }

  export type eventnametagCreateManyInput = {
    id?: number
    charid?: number
    activeRed?: number
    activeBlue?: number
    activeYellow?: number
    activeGreen?: number
    activePurple?: number
    sRed?: string
    sBlue?: string
    sYellow?: string
    sGreen?: string
    sPurple?: string
  }

  export type eventnametagUpdateManyMutationInput = {
    charid?: IntFieldUpdateOperationsInput | number
    activeRed?: IntFieldUpdateOperationsInput | number
    activeBlue?: IntFieldUpdateOperationsInput | number
    activeYellow?: IntFieldUpdateOperationsInput | number
    activeGreen?: IntFieldUpdateOperationsInput | number
    activePurple?: IntFieldUpdateOperationsInput | number
    sRed?: StringFieldUpdateOperationsInput | string
    sBlue?: StringFieldUpdateOperationsInput | string
    sYellow?: StringFieldUpdateOperationsInput | string
    sGreen?: StringFieldUpdateOperationsInput | string
    sPurple?: StringFieldUpdateOperationsInput | string
  }

  export type eventnametagUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    charid?: IntFieldUpdateOperationsInput | number
    activeRed?: IntFieldUpdateOperationsInput | number
    activeBlue?: IntFieldUpdateOperationsInput | number
    activeYellow?: IntFieldUpdateOperationsInput | number
    activeGreen?: IntFieldUpdateOperationsInput | number
    activePurple?: IntFieldUpdateOperationsInput | number
    sRed?: StringFieldUpdateOperationsInput | string
    sBlue?: StringFieldUpdateOperationsInput | string
    sYellow?: StringFieldUpdateOperationsInput | string
    sGreen?: StringFieldUpdateOperationsInput | string
    sPurple?: StringFieldUpdateOperationsInput | string
  }

  export type extendspCreateInput = {

  }

  export type extendspUncheckedCreateInput = {
    id?: number
  }

  export type extendspUpdateInput = {

  }

  export type extendspUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type extendspCreateManyInput = {
    id?: number
  }

  export type extendspUpdateManyMutationInput = {

  }

  export type extendspUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type familiarsCreateInput = {
    id?: bigint | number
    charid?: number | null
    idk1?: number | null
    familiarid?: number | null
    name?: string | null
    idk2?: boolean | null
    idk3?: number | null
    fatigue?: number | null
    idk4?: bigint | number | null
    idk5?: bigint | number | null
    expiration?: Date | string | null
    vitality?: number | null
  }

  export type familiarsUncheckedCreateInput = {
    id?: bigint | number
    charid?: number | null
    idk1?: number | null
    familiarid?: number | null
    name?: string | null
    idk2?: boolean | null
    idk3?: number | null
    fatigue?: number | null
    idk4?: bigint | number | null
    idk5?: bigint | number | null
    expiration?: Date | string | null
    vitality?: number | null
  }

  export type familiarsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    charid?: NullableIntFieldUpdateOperationsInput | number | null
    idk1?: NullableIntFieldUpdateOperationsInput | number | null
    familiarid?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    idk2?: NullableBoolFieldUpdateOperationsInput | boolean | null
    idk3?: NullableIntFieldUpdateOperationsInput | number | null
    fatigue?: NullableIntFieldUpdateOperationsInput | number | null
    idk4?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    idk5?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    expiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vitality?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type familiarsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    charid?: NullableIntFieldUpdateOperationsInput | number | null
    idk1?: NullableIntFieldUpdateOperationsInput | number | null
    familiarid?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    idk2?: NullableBoolFieldUpdateOperationsInput | boolean | null
    idk3?: NullableIntFieldUpdateOperationsInput | number | null
    fatigue?: NullableIntFieldUpdateOperationsInput | number | null
    idk4?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    idk5?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    expiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vitality?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type familiarsCreateManyInput = {
    id?: bigint | number
    charid?: number | null
    idk1?: number | null
    familiarid?: number | null
    name?: string | null
    idk2?: boolean | null
    idk3?: number | null
    fatigue?: number | null
    idk4?: bigint | number | null
    idk5?: bigint | number | null
    expiration?: Date | string | null
    vitality?: number | null
  }

  export type familiarsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    charid?: NullableIntFieldUpdateOperationsInput | number | null
    idk1?: NullableIntFieldUpdateOperationsInput | number | null
    familiarid?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    idk2?: NullableBoolFieldUpdateOperationsInput | boolean | null
    idk3?: NullableIntFieldUpdateOperationsInput | number | null
    fatigue?: NullableIntFieldUpdateOperationsInput | number | null
    idk4?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    idk5?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    expiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vitality?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type familiarsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    charid?: NullableIntFieldUpdateOperationsInput | number | null
    idk1?: NullableIntFieldUpdateOperationsInput | number | null
    familiarid?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    idk2?: NullableBoolFieldUpdateOperationsInput | boolean | null
    idk3?: NullableIntFieldUpdateOperationsInput | number | null
    fatigue?: NullableIntFieldUpdateOperationsInput | number | null
    idk4?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    idk5?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    expiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vitality?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type friendsCreateInput = {
    ownerid?: number | null
    owneraccid?: number | null
    friendid?: number | null
    friendaccountid?: number | null
    name?: string | null
    flag?: number | null
    groupname?: string | null
    mobile?: number | null
    nickname?: string | null
    memo?: string | null
  }

  export type friendsUncheckedCreateInput = {
    id?: number
    ownerid?: number | null
    owneraccid?: number | null
    friendid?: number | null
    friendaccountid?: number | null
    name?: string | null
    flag?: number | null
    groupname?: string | null
    mobile?: number | null
    nickname?: string | null
    memo?: string | null
  }

  export type friendsUpdateInput = {
    ownerid?: NullableIntFieldUpdateOperationsInput | number | null
    owneraccid?: NullableIntFieldUpdateOperationsInput | number | null
    friendid?: NullableIntFieldUpdateOperationsInput | number | null
    friendaccountid?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    flag?: NullableIntFieldUpdateOperationsInput | number | null
    groupname?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableIntFieldUpdateOperationsInput | number | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    memo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type friendsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ownerid?: NullableIntFieldUpdateOperationsInput | number | null
    owneraccid?: NullableIntFieldUpdateOperationsInput | number | null
    friendid?: NullableIntFieldUpdateOperationsInput | number | null
    friendaccountid?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    flag?: NullableIntFieldUpdateOperationsInput | number | null
    groupname?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableIntFieldUpdateOperationsInput | number | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    memo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type friendsCreateManyInput = {
    id?: number
    ownerid?: number | null
    owneraccid?: number | null
    friendid?: number | null
    friendaccountid?: number | null
    name?: string | null
    flag?: number | null
    groupname?: string | null
    mobile?: number | null
    nickname?: string | null
    memo?: string | null
  }

  export type friendsUpdateManyMutationInput = {
    ownerid?: NullableIntFieldUpdateOperationsInput | number | null
    owneraccid?: NullableIntFieldUpdateOperationsInput | number | null
    friendid?: NullableIntFieldUpdateOperationsInput | number | null
    friendaccountid?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    flag?: NullableIntFieldUpdateOperationsInput | number | null
    groupname?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableIntFieldUpdateOperationsInput | number | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    memo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type friendsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ownerid?: NullableIntFieldUpdateOperationsInput | number | null
    owneraccid?: NullableIntFieldUpdateOperationsInput | number | null
    friendid?: NullableIntFieldUpdateOperationsInput | number | null
    friendaccountid?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    flag?: NullableIntFieldUpdateOperationsInput | number | null
    groupname?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableIntFieldUpdateOperationsInput | number | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    memo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type funckeymapCreateInput = {
    charId?: number | null
    ord?: number | null
  }

  export type funckeymapUncheckedCreateInput = {
    id?: number
    charId?: number | null
    ord?: number | null
  }

  export type funckeymapUpdateInput = {
    charId?: NullableIntFieldUpdateOperationsInput | number | null
    ord?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type funckeymapUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    charId?: NullableIntFieldUpdateOperationsInput | number | null
    ord?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type funckeymapCreateManyInput = {
    id?: number
    charId?: number | null
    ord?: number | null
  }

  export type funckeymapUpdateManyMutationInput = {
    charId?: NullableIntFieldUpdateOperationsInput | number | null
    ord?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type funckeymapUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    charId?: NullableIntFieldUpdateOperationsInput | number | null
    ord?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type gradenamesCreateInput = {
    gradename?: string | null
    guildid?: number | null
  }

  export type gradenamesUncheckedCreateInput = {
    id?: number
    gradename?: string | null
    guildid?: number | null
  }

  export type gradenamesUpdateInput = {
    gradename?: NullableStringFieldUpdateOperationsInput | string | null
    guildid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type gradenamesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    gradename?: NullableStringFieldUpdateOperationsInput | string | null
    guildid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type gradenamesCreateManyInput = {
    id?: number
    gradename?: string | null
    guildid?: number | null
  }

  export type gradenamesUpdateManyMutationInput = {
    gradename?: NullableStringFieldUpdateOperationsInput | string | null
    guildid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type gradenamesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    gradename?: NullableStringFieldUpdateOperationsInput | string | null
    guildid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type guildmembersCreateInput = {
    charid?: number | null
    guildid?: number | null
    grade?: number | null
    alliancegrade?: number | null
    commitment?: number | null
    daycommitment?: number | null
    igp?: number | null
    commitmentinctime?: Date | string | null
    name?: string | null
    job?: number | null
    level?: number | null
    loggedin?: boolean | null
  }

  export type guildmembersUncheckedCreateInput = {
    id?: number
    charid?: number | null
    guildid?: number | null
    grade?: number | null
    alliancegrade?: number | null
    commitment?: number | null
    daycommitment?: number | null
    igp?: number | null
    commitmentinctime?: Date | string | null
    name?: string | null
    job?: number | null
    level?: number | null
    loggedin?: boolean | null
  }

  export type guildmembersUpdateInput = {
    charid?: NullableIntFieldUpdateOperationsInput | number | null
    guildid?: NullableIntFieldUpdateOperationsInput | number | null
    grade?: NullableIntFieldUpdateOperationsInput | number | null
    alliancegrade?: NullableIntFieldUpdateOperationsInput | number | null
    commitment?: NullableIntFieldUpdateOperationsInput | number | null
    daycommitment?: NullableIntFieldUpdateOperationsInput | number | null
    igp?: NullableIntFieldUpdateOperationsInput | number | null
    commitmentinctime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    job?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    loggedin?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type guildmembersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    charid?: NullableIntFieldUpdateOperationsInput | number | null
    guildid?: NullableIntFieldUpdateOperationsInput | number | null
    grade?: NullableIntFieldUpdateOperationsInput | number | null
    alliancegrade?: NullableIntFieldUpdateOperationsInput | number | null
    commitment?: NullableIntFieldUpdateOperationsInput | number | null
    daycommitment?: NullableIntFieldUpdateOperationsInput | number | null
    igp?: NullableIntFieldUpdateOperationsInput | number | null
    commitmentinctime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    job?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    loggedin?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type guildmembersCreateManyInput = {
    id?: number
    charid?: number | null
    guildid?: number | null
    grade?: number | null
    alliancegrade?: number | null
    commitment?: number | null
    daycommitment?: number | null
    igp?: number | null
    commitmentinctime?: Date | string | null
    name?: string | null
    job?: number | null
    level?: number | null
    loggedin?: boolean | null
  }

  export type guildmembersUpdateManyMutationInput = {
    charid?: NullableIntFieldUpdateOperationsInput | number | null
    guildid?: NullableIntFieldUpdateOperationsInput | number | null
    grade?: NullableIntFieldUpdateOperationsInput | number | null
    alliancegrade?: NullableIntFieldUpdateOperationsInput | number | null
    commitment?: NullableIntFieldUpdateOperationsInput | number | null
    daycommitment?: NullableIntFieldUpdateOperationsInput | number | null
    igp?: NullableIntFieldUpdateOperationsInput | number | null
    commitmentinctime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    job?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    loggedin?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type guildmembersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    charid?: NullableIntFieldUpdateOperationsInput | number | null
    guildid?: NullableIntFieldUpdateOperationsInput | number | null
    grade?: NullableIntFieldUpdateOperationsInput | number | null
    alliancegrade?: NullableIntFieldUpdateOperationsInput | number | null
    commitment?: NullableIntFieldUpdateOperationsInput | number | null
    daycommitment?: NullableIntFieldUpdateOperationsInput | number | null
    igp?: NullableIntFieldUpdateOperationsInput | number | null
    commitmentinctime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    job?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    loggedin?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type guildrequestorsCreateInput = {
    requestors_id?: number | null
    charid?: number | null
    guildid?: number | null
    name?: string | null
    job?: number | null
    level?: number | null
    loggedin?: boolean | null
  }

  export type guildrequestorsUncheckedCreateInput = {
    id?: number
    requestors_id?: number | null
    charid?: number | null
    guildid?: number | null
    name?: string | null
    job?: number | null
    level?: number | null
    loggedin?: boolean | null
  }

  export type guildrequestorsUpdateInput = {
    requestors_id?: NullableIntFieldUpdateOperationsInput | number | null
    charid?: NullableIntFieldUpdateOperationsInput | number | null
    guildid?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    job?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    loggedin?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type guildrequestorsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestors_id?: NullableIntFieldUpdateOperationsInput | number | null
    charid?: NullableIntFieldUpdateOperationsInput | number | null
    guildid?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    job?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    loggedin?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type guildrequestorsCreateManyInput = {
    id?: number
    requestors_id?: number | null
    charid?: number | null
    guildid?: number | null
    name?: string | null
    job?: number | null
    level?: number | null
    loggedin?: boolean | null
  }

  export type guildrequestorsUpdateManyMutationInput = {
    requestors_id?: NullableIntFieldUpdateOperationsInput | number | null
    charid?: NullableIntFieldUpdateOperationsInput | number | null
    guildid?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    job?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    loggedin?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type guildrequestorsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestors_id?: NullableIntFieldUpdateOperationsInput | number | null
    charid?: NullableIntFieldUpdateOperationsInput | number | null
    guildid?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    job?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    loggedin?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type guildsCreateInput = {
    name?: string | null
    leaderid?: number | null
    worldid?: number | null
    markbg?: number | null
    markbgcolor?: number | null
    mark?: number | null
    markcolor?: number | null
    maxmembers?: number | null
    notice?: string | null
    points?: number | null
    seasonpoints?: number | null
    allianceid?: number | null
    level?: number | null
    guildrank?: number | null
    ggp?: number | null
    appliable?: boolean | null
    joinsetting?: number | null
    reqlevel?: number | null
    bbsNotice?: number | null
    battleSp?: number | null
    fk_allianceid?: number | null
  }

  export type guildsUncheckedCreateInput = {
    id?: number
    name?: string | null
    leaderid?: number | null
    worldid?: number | null
    markbg?: number | null
    markbgcolor?: number | null
    mark?: number | null
    markcolor?: number | null
    maxmembers?: number | null
    notice?: string | null
    points?: number | null
    seasonpoints?: number | null
    allianceid?: number | null
    level?: number | null
    guildrank?: number | null
    ggp?: number | null
    appliable?: boolean | null
    joinsetting?: number | null
    reqlevel?: number | null
    bbsNotice?: number | null
    battleSp?: number | null
    fk_allianceid?: number | null
  }

  export type guildsUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    leaderid?: NullableIntFieldUpdateOperationsInput | number | null
    worldid?: NullableIntFieldUpdateOperationsInput | number | null
    markbg?: NullableIntFieldUpdateOperationsInput | number | null
    markbgcolor?: NullableIntFieldUpdateOperationsInput | number | null
    mark?: NullableIntFieldUpdateOperationsInput | number | null
    markcolor?: NullableIntFieldUpdateOperationsInput | number | null
    maxmembers?: NullableIntFieldUpdateOperationsInput | number | null
    notice?: NullableStringFieldUpdateOperationsInput | string | null
    points?: NullableIntFieldUpdateOperationsInput | number | null
    seasonpoints?: NullableIntFieldUpdateOperationsInput | number | null
    allianceid?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    guildrank?: NullableIntFieldUpdateOperationsInput | number | null
    ggp?: NullableIntFieldUpdateOperationsInput | number | null
    appliable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    joinsetting?: NullableIntFieldUpdateOperationsInput | number | null
    reqlevel?: NullableIntFieldUpdateOperationsInput | number | null
    bbsNotice?: NullableIntFieldUpdateOperationsInput | number | null
    battleSp?: NullableIntFieldUpdateOperationsInput | number | null
    fk_allianceid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type guildsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    leaderid?: NullableIntFieldUpdateOperationsInput | number | null
    worldid?: NullableIntFieldUpdateOperationsInput | number | null
    markbg?: NullableIntFieldUpdateOperationsInput | number | null
    markbgcolor?: NullableIntFieldUpdateOperationsInput | number | null
    mark?: NullableIntFieldUpdateOperationsInput | number | null
    markcolor?: NullableIntFieldUpdateOperationsInput | number | null
    maxmembers?: NullableIntFieldUpdateOperationsInput | number | null
    notice?: NullableStringFieldUpdateOperationsInput | string | null
    points?: NullableIntFieldUpdateOperationsInput | number | null
    seasonpoints?: NullableIntFieldUpdateOperationsInput | number | null
    allianceid?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    guildrank?: NullableIntFieldUpdateOperationsInput | number | null
    ggp?: NullableIntFieldUpdateOperationsInput | number | null
    appliable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    joinsetting?: NullableIntFieldUpdateOperationsInput | number | null
    reqlevel?: NullableIntFieldUpdateOperationsInput | number | null
    bbsNotice?: NullableIntFieldUpdateOperationsInput | number | null
    battleSp?: NullableIntFieldUpdateOperationsInput | number | null
    fk_allianceid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type guildsCreateManyInput = {
    id?: number
    name?: string | null
    leaderid?: number | null
    worldid?: number | null
    markbg?: number | null
    markbgcolor?: number | null
    mark?: number | null
    markcolor?: number | null
    maxmembers?: number | null
    notice?: string | null
    points?: number | null
    seasonpoints?: number | null
    allianceid?: number | null
    level?: number | null
    guildrank?: number | null
    ggp?: number | null
    appliable?: boolean | null
    joinsetting?: number | null
    reqlevel?: number | null
    bbsNotice?: number | null
    battleSp?: number | null
    fk_allianceid?: number | null
  }

  export type guildsUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    leaderid?: NullableIntFieldUpdateOperationsInput | number | null
    worldid?: NullableIntFieldUpdateOperationsInput | number | null
    markbg?: NullableIntFieldUpdateOperationsInput | number | null
    markbgcolor?: NullableIntFieldUpdateOperationsInput | number | null
    mark?: NullableIntFieldUpdateOperationsInput | number | null
    markcolor?: NullableIntFieldUpdateOperationsInput | number | null
    maxmembers?: NullableIntFieldUpdateOperationsInput | number | null
    notice?: NullableStringFieldUpdateOperationsInput | string | null
    points?: NullableIntFieldUpdateOperationsInput | number | null
    seasonpoints?: NullableIntFieldUpdateOperationsInput | number | null
    allianceid?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    guildrank?: NullableIntFieldUpdateOperationsInput | number | null
    ggp?: NullableIntFieldUpdateOperationsInput | number | null
    appliable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    joinsetting?: NullableIntFieldUpdateOperationsInput | number | null
    reqlevel?: NullableIntFieldUpdateOperationsInput | number | null
    bbsNotice?: NullableIntFieldUpdateOperationsInput | number | null
    battleSp?: NullableIntFieldUpdateOperationsInput | number | null
    fk_allianceid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type guildsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    leaderid?: NullableIntFieldUpdateOperationsInput | number | null
    worldid?: NullableIntFieldUpdateOperationsInput | number | null
    markbg?: NullableIntFieldUpdateOperationsInput | number | null
    markbgcolor?: NullableIntFieldUpdateOperationsInput | number | null
    mark?: NullableIntFieldUpdateOperationsInput | number | null
    markcolor?: NullableIntFieldUpdateOperationsInput | number | null
    maxmembers?: NullableIntFieldUpdateOperationsInput | number | null
    notice?: NullableStringFieldUpdateOperationsInput | string | null
    points?: NullableIntFieldUpdateOperationsInput | number | null
    seasonpoints?: NullableIntFieldUpdateOperationsInput | number | null
    allianceid?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    guildrank?: NullableIntFieldUpdateOperationsInput | number | null
    ggp?: NullableIntFieldUpdateOperationsInput | number | null
    appliable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    joinsetting?: NullableIntFieldUpdateOperationsInput | number | null
    reqlevel?: NullableIntFieldUpdateOperationsInput | number | null
    bbsNotice?: NullableIntFieldUpdateOperationsInput | number | null
    battleSp?: NullableIntFieldUpdateOperationsInput | number | null
    fk_allianceid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type guildskillCreateInput = {
    skillid?: number | null
    level?: number | null
    expiredate?: Date | string | null
    buycharactername?: string | null
    extendcharactername?: string | null
  }

  export type guildskillUncheckedCreateInput = {
    id?: number
    skillid?: number | null
    level?: number | null
    expiredate?: Date | string | null
    buycharactername?: string | null
    extendcharactername?: string | null
  }

  export type guildskillUpdateInput = {
    skillid?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    expiredate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    buycharactername?: NullableStringFieldUpdateOperationsInput | string | null
    extendcharactername?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type guildskillUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    skillid?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    expiredate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    buycharactername?: NullableStringFieldUpdateOperationsInput | string | null
    extendcharactername?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type guildskillCreateManyInput = {
    id?: number
    skillid?: number | null
    level?: number | null
    expiredate?: Date | string | null
    buycharactername?: string | null
    extendcharactername?: string | null
  }

  export type guildskillUpdateManyMutationInput = {
    skillid?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    expiredate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    buycharactername?: NullableStringFieldUpdateOperationsInput | string | null
    extendcharactername?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type guildskillUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    skillid?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    expiredate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    buycharactername?: NullableStringFieldUpdateOperationsInput | string | null
    extendcharactername?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type guildskillsCreateInput = {
    skills_id?: number | null
    guild_id?: number | null
    skillid?: number | null
    fk_guildskillid?: number | null
  }

  export type guildskillsUncheckedCreateInput = {
    guildskill_id?: number
    skills_id?: number | null
    guild_id?: number | null
    skillid?: number | null
    fk_guildskillid?: number | null
  }

  export type guildskillsUpdateInput = {
    skills_id?: NullableIntFieldUpdateOperationsInput | number | null
    guild_id?: NullableIntFieldUpdateOperationsInput | number | null
    skillid?: NullableIntFieldUpdateOperationsInput | number | null
    fk_guildskillid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type guildskillsUncheckedUpdateInput = {
    guildskill_id?: IntFieldUpdateOperationsInput | number
    skills_id?: NullableIntFieldUpdateOperationsInput | number | null
    guild_id?: NullableIntFieldUpdateOperationsInput | number | null
    skillid?: NullableIntFieldUpdateOperationsInput | number | null
    fk_guildskillid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type guildskillsCreateManyInput = {
    guildskill_id?: number
    skills_id?: number | null
    guild_id?: number | null
    skillid?: number | null
    fk_guildskillid?: number | null
  }

  export type guildskillsUpdateManyMutationInput = {
    skills_id?: NullableIntFieldUpdateOperationsInput | number | null
    guild_id?: NullableIntFieldUpdateOperationsInput | number | null
    skillid?: NullableIntFieldUpdateOperationsInput | number | null
    fk_guildskillid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type guildskillsUncheckedUpdateManyInput = {
    guildskill_id?: IntFieldUpdateOperationsInput | number
    skills_id?: NullableIntFieldUpdateOperationsInput | number | null
    guild_id?: NullableIntFieldUpdateOperationsInput | number | null
    skillid?: NullableIntFieldUpdateOperationsInput | number | null
    fk_guildskillid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type hairequipsCreateInput = {
    alid?: number | null
    equipid?: number | null
  }

  export type hairequipsUncheckedCreateInput = {
    id?: number
    alid?: number | null
    equipid?: number | null
  }

  export type hairequipsUpdateInput = {
    alid?: NullableIntFieldUpdateOperationsInput | number | null
    equipid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type hairequipsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    alid?: NullableIntFieldUpdateOperationsInput | number | null
    equipid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type hairequipsCreateManyInput = {
    id?: number
    alid?: number | null
    equipid?: number | null
  }

  export type hairequipsUpdateManyMutationInput = {
    alid?: NullableIntFieldUpdateOperationsInput | number | null
    equipid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type hairequipsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    alid?: NullableIntFieldUpdateOperationsInput | number | null
    equipid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type hyperrockfieldsCreateInput = {
    id?: bigint | number
    charid?: number | null
    ord?: number | null
    fieldid?: number | null
  }

  export type hyperrockfieldsUncheckedCreateInput = {
    id?: bigint | number
    charid?: number | null
    ord?: number | null
    fieldid?: number | null
  }

  export type hyperrockfieldsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    charid?: NullableIntFieldUpdateOperationsInput | number | null
    ord?: NullableIntFieldUpdateOperationsInput | number | null
    fieldid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type hyperrockfieldsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    charid?: NullableIntFieldUpdateOperationsInput | number | null
    ord?: NullableIntFieldUpdateOperationsInput | number | null
    fieldid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type hyperrockfieldsCreateManyInput = {
    id?: bigint | number
    charid?: number | null
    ord?: number | null
    fieldid?: number | null
  }

  export type hyperrockfieldsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    charid?: NullableIntFieldUpdateOperationsInput | number | null
    ord?: NullableIntFieldUpdateOperationsInput | number | null
    fieldid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type hyperrockfieldsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    charid?: NullableIntFieldUpdateOperationsInput | number | null
    ord?: NullableIntFieldUpdateOperationsInput | number | null
    fieldid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type inventoriesCreateInput = {
    type?: number | null
    slots?: number | null
  }

  export type inventoriesUncheckedCreateInput = {
    id?: number
    type?: number | null
    slots?: number | null
  }

  export type inventoriesUpdateInput = {
    type?: NullableIntFieldUpdateOperationsInput | number | null
    slots?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type inventoriesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableIntFieldUpdateOperationsInput | number | null
    slots?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type inventoriesCreateManyInput = {
    id?: number
    type?: number | null
    slots?: number | null
  }

  export type inventoriesUpdateManyMutationInput = {
    type?: NullableIntFieldUpdateOperationsInput | number | null
    slots?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type inventoriesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableIntFieldUpdateOperationsInput | number | null
    slots?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type itemsCreateInput = {
    id?: bigint | number
    inventoryid?: number | null
    trunkid?: number | null
    auctionHouseStatus?: boolean | null
    itemid?: number | null
    bagindex?: number | null
    cashitemserialnumber?: bigint | number | null
    dateexpire?: Date | string | null
    invtype?: number | null
    type?: number | null
    iscash?: boolean | null
    quantity?: number | null
    expireonlogout?: boolean | null
    owner?: string | null
    obtainedonce?: boolean | null
    zeroShareItemID?: bigint | number
    attribute?: number | null
  }

  export type itemsUncheckedCreateInput = {
    id?: bigint | number
    inventoryid?: number | null
    trunkid?: number | null
    auctionHouseStatus?: boolean | null
    itemid?: number | null
    bagindex?: number | null
    cashitemserialnumber?: bigint | number | null
    dateexpire?: Date | string | null
    invtype?: number | null
    type?: number | null
    iscash?: boolean | null
    quantity?: number | null
    expireonlogout?: boolean | null
    owner?: string | null
    obtainedonce?: boolean | null
    zeroShareItemID?: bigint | number
    attribute?: number | null
  }

  export type itemsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    inventoryid?: NullableIntFieldUpdateOperationsInput | number | null
    trunkid?: NullableIntFieldUpdateOperationsInput | number | null
    auctionHouseStatus?: NullableBoolFieldUpdateOperationsInput | boolean | null
    itemid?: NullableIntFieldUpdateOperationsInput | number | null
    bagindex?: NullableIntFieldUpdateOperationsInput | number | null
    cashitemserialnumber?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    dateexpire?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invtype?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    iscash?: NullableBoolFieldUpdateOperationsInput | boolean | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    expireonlogout?: NullableBoolFieldUpdateOperationsInput | boolean | null
    owner?: NullableStringFieldUpdateOperationsInput | string | null
    obtainedonce?: NullableBoolFieldUpdateOperationsInput | boolean | null
    zeroShareItemID?: BigIntFieldUpdateOperationsInput | bigint | number
    attribute?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type itemsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    inventoryid?: NullableIntFieldUpdateOperationsInput | number | null
    trunkid?: NullableIntFieldUpdateOperationsInput | number | null
    auctionHouseStatus?: NullableBoolFieldUpdateOperationsInput | boolean | null
    itemid?: NullableIntFieldUpdateOperationsInput | number | null
    bagindex?: NullableIntFieldUpdateOperationsInput | number | null
    cashitemserialnumber?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    dateexpire?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invtype?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    iscash?: NullableBoolFieldUpdateOperationsInput | boolean | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    expireonlogout?: NullableBoolFieldUpdateOperationsInput | boolean | null
    owner?: NullableStringFieldUpdateOperationsInput | string | null
    obtainedonce?: NullableBoolFieldUpdateOperationsInput | boolean | null
    zeroShareItemID?: BigIntFieldUpdateOperationsInput | bigint | number
    attribute?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type itemsCreateManyInput = {
    id?: bigint | number
    inventoryid?: number | null
    trunkid?: number | null
    auctionHouseStatus?: boolean | null
    itemid?: number | null
    bagindex?: number | null
    cashitemserialnumber?: bigint | number | null
    dateexpire?: Date | string | null
    invtype?: number | null
    type?: number | null
    iscash?: boolean | null
    quantity?: number | null
    expireonlogout?: boolean | null
    owner?: string | null
    obtainedonce?: boolean | null
    zeroShareItemID?: bigint | number
    attribute?: number | null
  }

  export type itemsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    inventoryid?: NullableIntFieldUpdateOperationsInput | number | null
    trunkid?: NullableIntFieldUpdateOperationsInput | number | null
    auctionHouseStatus?: NullableBoolFieldUpdateOperationsInput | boolean | null
    itemid?: NullableIntFieldUpdateOperationsInput | number | null
    bagindex?: NullableIntFieldUpdateOperationsInput | number | null
    cashitemserialnumber?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    dateexpire?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invtype?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    iscash?: NullableBoolFieldUpdateOperationsInput | boolean | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    expireonlogout?: NullableBoolFieldUpdateOperationsInput | boolean | null
    owner?: NullableStringFieldUpdateOperationsInput | string | null
    obtainedonce?: NullableBoolFieldUpdateOperationsInput | boolean | null
    zeroShareItemID?: BigIntFieldUpdateOperationsInput | bigint | number
    attribute?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type itemsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    inventoryid?: NullableIntFieldUpdateOperationsInput | number | null
    trunkid?: NullableIntFieldUpdateOperationsInput | number | null
    auctionHouseStatus?: NullableBoolFieldUpdateOperationsInput | boolean | null
    itemid?: NullableIntFieldUpdateOperationsInput | number | null
    bagindex?: NullableIntFieldUpdateOperationsInput | number | null
    cashitemserialnumber?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    dateexpire?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invtype?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    iscash?: NullableBoolFieldUpdateOperationsInput | boolean | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    expireonlogout?: NullableBoolFieldUpdateOperationsInput | boolean | null
    owner?: NullableStringFieldUpdateOperationsInput | string | null
    obtainedonce?: NullableBoolFieldUpdateOperationsInput | boolean | null
    zeroShareItemID?: BigIntFieldUpdateOperationsInput | bigint | number
    attribute?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type itemsbuylimitCreateInput = {
    shopitemid?: bigint | number | null
    charid?: number | null
    amountbought?: number | null
  }

  export type itemsbuylimitUncheckedCreateInput = {
    id?: number
    shopitemid?: bigint | number | null
    charid?: number | null
    amountbought?: number | null
  }

  export type itemsbuylimitUpdateInput = {
    shopitemid?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    charid?: NullableIntFieldUpdateOperationsInput | number | null
    amountbought?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type itemsbuylimitUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    shopitemid?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    charid?: NullableIntFieldUpdateOperationsInput | number | null
    amountbought?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type itemsbuylimitCreateManyInput = {
    id?: number
    shopitemid?: bigint | number | null
    charid?: number | null
    amountbought?: number | null
  }

  export type itemsbuylimitUpdateManyMutationInput = {
    shopitemid?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    charid?: NullableIntFieldUpdateOperationsInput | number | null
    amountbought?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type itemsbuylimitUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    shopitemid?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    charid?: NullableIntFieldUpdateOperationsInput | number | null
    amountbought?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type keymapsCreateInput = {
    fkmapid?: number | null
    idx?: number | null
    type?: number | null
    val?: number | null
  }

  export type keymapsUncheckedCreateInput = {
    id?: number
    fkmapid?: number | null
    idx?: number | null
    type?: number | null
    val?: number | null
  }

  export type keymapsUpdateInput = {
    fkmapid?: NullableIntFieldUpdateOperationsInput | number | null
    idx?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    val?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type keymapsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fkmapid?: NullableIntFieldUpdateOperationsInput | number | null
    idx?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    val?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type keymapsCreateManyInput = {
    id?: number
    fkmapid?: number | null
    idx?: number | null
    type?: number | null
    val?: number | null
  }

  export type keymapsUpdateManyMutationInput = {
    fkmapid?: NullableIntFieldUpdateOperationsInput | number | null
    idx?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    val?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type keymapsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fkmapid?: NullableIntFieldUpdateOperationsInput | number | null
    idx?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    val?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type linkskillsCreateInput = {
    accid?: number | null
    ownerid?: number | null
    linkedcharid?: number | null
    linkskillid?: number | null
    level?: number | null
    addeddate?: Date | string | null
  }

  export type linkskillsUncheckedCreateInput = {
    id?: number
    accid?: number | null
    ownerid?: number | null
    linkedcharid?: number | null
    linkskillid?: number | null
    level?: number | null
    addeddate?: Date | string | null
  }

  export type linkskillsUpdateInput = {
    accid?: NullableIntFieldUpdateOperationsInput | number | null
    ownerid?: NullableIntFieldUpdateOperationsInput | number | null
    linkedcharid?: NullableIntFieldUpdateOperationsInput | number | null
    linkskillid?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    addeddate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type linkskillsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    accid?: NullableIntFieldUpdateOperationsInput | number | null
    ownerid?: NullableIntFieldUpdateOperationsInput | number | null
    linkedcharid?: NullableIntFieldUpdateOperationsInput | number | null
    linkskillid?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    addeddate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type linkskillsCreateManyInput = {
    id?: number
    accid?: number | null
    ownerid?: number | null
    linkedcharid?: number | null
    linkskillid?: number | null
    level?: number | null
    addeddate?: Date | string | null
  }

  export type linkskillsUpdateManyMutationInput = {
    accid?: NullableIntFieldUpdateOperationsInput | number | null
    ownerid?: NullableIntFieldUpdateOperationsInput | number | null
    linkedcharid?: NullableIntFieldUpdateOperationsInput | number | null
    linkskillid?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    addeddate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type linkskillsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    accid?: NullableIntFieldUpdateOperationsInput | number | null
    ownerid?: NullableIntFieldUpdateOperationsInput | number | null
    linkedcharid?: NullableIntFieldUpdateOperationsInput | number | null
    linkskillid?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    addeddate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type macrosCreateInput = {
    id?: bigint | number
    charid?: number | null
    muted?: boolean | null
    name?: string | null
  }

  export type macrosUncheckedCreateInput = {
    id?: bigint | number
    charid?: number | null
    muted?: boolean | null
    name?: string | null
  }

  export type macrosUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    charid?: NullableIntFieldUpdateOperationsInput | number | null
    muted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type macrosUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    charid?: NullableIntFieldUpdateOperationsInput | number | null
    muted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type macrosCreateManyInput = {
    id?: bigint | number
    charid?: number | null
    muted?: boolean | null
    name?: string | null
  }

  export type macrosUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    charid?: NullableIntFieldUpdateOperationsInput | number | null
    muted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type macrosUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    charid?: NullableIntFieldUpdateOperationsInput | number | null
    muted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type macroskillsCreateInput = {
    id?: bigint | number
    ordercol?: number | null
    skillid?: number | null
    macroid?: bigint | number | null
  }

  export type macroskillsUncheckedCreateInput = {
    id?: bigint | number
    ordercol?: number | null
    skillid?: number | null
    macroid?: bigint | number | null
  }

  export type macroskillsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    ordercol?: NullableIntFieldUpdateOperationsInput | number | null
    skillid?: NullableIntFieldUpdateOperationsInput | number | null
    macroid?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type macroskillsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    ordercol?: NullableIntFieldUpdateOperationsInput | number | null
    skillid?: NullableIntFieldUpdateOperationsInput | number | null
    macroid?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type macroskillsCreateManyInput = {
    id?: bigint | number
    ordercol?: number | null
    skillid?: number | null
    macroid?: bigint | number | null
  }

  export type macroskillsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    ordercol?: NullableIntFieldUpdateOperationsInput | number | null
    skillid?: NullableIntFieldUpdateOperationsInput | number | null
    macroid?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type macroskillsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    ordercol?: NullableIntFieldUpdateOperationsInput | number | null
    skillid?: NullableIntFieldUpdateOperationsInput | number | null
    macroid?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type matrixskillCreateInput = {
    charid?: number
    state?: boolean
    coreID?: number
    skillID1?: number
    skillID2?: number
    skillID3?: number
    level?: number
    maxLevel?: number
    experience?: number
    crc?: bigint | number
    slot?: number
  }

  export type matrixskillUncheckedCreateInput = {
    id?: number
    charid?: number
    state?: boolean
    coreID?: number
    skillID1?: number
    skillID2?: number
    skillID3?: number
    level?: number
    maxLevel?: number
    experience?: number
    crc?: bigint | number
    slot?: number
  }

  export type matrixskillUpdateInput = {
    charid?: IntFieldUpdateOperationsInput | number
    state?: BoolFieldUpdateOperationsInput | boolean
    coreID?: IntFieldUpdateOperationsInput | number
    skillID1?: IntFieldUpdateOperationsInput | number
    skillID2?: IntFieldUpdateOperationsInput | number
    skillID3?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    maxLevel?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    crc?: BigIntFieldUpdateOperationsInput | bigint | number
    slot?: IntFieldUpdateOperationsInput | number
  }

  export type matrixskillUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    charid?: IntFieldUpdateOperationsInput | number
    state?: BoolFieldUpdateOperationsInput | boolean
    coreID?: IntFieldUpdateOperationsInput | number
    skillID1?: IntFieldUpdateOperationsInput | number
    skillID2?: IntFieldUpdateOperationsInput | number
    skillID3?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    maxLevel?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    crc?: BigIntFieldUpdateOperationsInput | bigint | number
    slot?: IntFieldUpdateOperationsInput | number
  }

  export type matrixskillCreateManyInput = {
    id?: number
    charid?: number
    state?: boolean
    coreID?: number
    skillID1?: number
    skillID2?: number
    skillID3?: number
    level?: number
    maxLevel?: number
    experience?: number
    crc?: bigint | number
    slot?: number
  }

  export type matrixskillUpdateManyMutationInput = {
    charid?: IntFieldUpdateOperationsInput | number
    state?: BoolFieldUpdateOperationsInput | boolean
    coreID?: IntFieldUpdateOperationsInput | number
    skillID1?: IntFieldUpdateOperationsInput | number
    skillID2?: IntFieldUpdateOperationsInput | number
    skillID3?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    maxLevel?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    crc?: BigIntFieldUpdateOperationsInput | bigint | number
    slot?: IntFieldUpdateOperationsInput | number
  }

  export type matrixskillUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    charid?: IntFieldUpdateOperationsInput | number
    state?: BoolFieldUpdateOperationsInput | boolean
    coreID?: IntFieldUpdateOperationsInput | number
    skillID1?: IntFieldUpdateOperationsInput | number
    skillID2?: IntFieldUpdateOperationsInput | number
    skillID3?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    maxLevel?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    crc?: BigIntFieldUpdateOperationsInput | bigint | number
    slot?: IntFieldUpdateOperationsInput | number
  }

  export type medalsCreateInput = {
    id?: bigint | number
    charid?: number | null
    questid?: number | null
    itemid?: number | null
    completedtime?: Date | string | null
  }

  export type medalsUncheckedCreateInput = {
    id?: bigint | number
    charid?: number | null
    questid?: number | null
    itemid?: number | null
    completedtime?: Date | string | null
  }

  export type medalsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    charid?: NullableIntFieldUpdateOperationsInput | number | null
    questid?: NullableIntFieldUpdateOperationsInput | number | null
    itemid?: NullableIntFieldUpdateOperationsInput | number | null
    completedtime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type medalsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    charid?: NullableIntFieldUpdateOperationsInput | number | null
    questid?: NullableIntFieldUpdateOperationsInput | number | null
    itemid?: NullableIntFieldUpdateOperationsInput | number | null
    completedtime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type medalsCreateManyInput = {
    id?: bigint | number
    charid?: number | null
    questid?: number | null
    itemid?: number | null
    completedtime?: Date | string | null
  }

  export type medalsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    charid?: NullableIntFieldUpdateOperationsInput | number | null
    questid?: NullableIntFieldUpdateOperationsInput | number | null
    itemid?: NullableIntFieldUpdateOperationsInput | number | null
    completedtime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type medalsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    charid?: NullableIntFieldUpdateOperationsInput | number | null
    questid?: NullableIntFieldUpdateOperationsInput | number | null
    itemid?: NullableIntFieldUpdateOperationsInput | number | null
    completedtime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type mob_dropsCreateInput = {
    id?: bigint | number
    mobid?: number | null
    itemid?: number | null
    chance?: number | null
    minquant?: number | null
    maxquant?: number | null
    reactordrop?: number | null
  }

  export type mob_dropsUncheckedCreateInput = {
    id?: bigint | number
    mobid?: number | null
    itemid?: number | null
    chance?: number | null
    minquant?: number | null
    maxquant?: number | null
    reactordrop?: number | null
  }

  export type mob_dropsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    mobid?: NullableIntFieldUpdateOperationsInput | number | null
    itemid?: NullableIntFieldUpdateOperationsInput | number | null
    chance?: NullableIntFieldUpdateOperationsInput | number | null
    minquant?: NullableIntFieldUpdateOperationsInput | number | null
    maxquant?: NullableIntFieldUpdateOperationsInput | number | null
    reactordrop?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mob_dropsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    mobid?: NullableIntFieldUpdateOperationsInput | number | null
    itemid?: NullableIntFieldUpdateOperationsInput | number | null
    chance?: NullableIntFieldUpdateOperationsInput | number | null
    minquant?: NullableIntFieldUpdateOperationsInput | number | null
    maxquant?: NullableIntFieldUpdateOperationsInput | number | null
    reactordrop?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mob_dropsCreateManyInput = {
    id?: bigint | number
    mobid?: number | null
    itemid?: number | null
    chance?: number | null
    minquant?: number | null
    maxquant?: number | null
    reactordrop?: number | null
  }

  export type mob_dropsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    mobid?: NullableIntFieldUpdateOperationsInput | number | null
    itemid?: NullableIntFieldUpdateOperationsInput | number | null
    chance?: NullableIntFieldUpdateOperationsInput | number | null
    minquant?: NullableIntFieldUpdateOperationsInput | number | null
    maxquant?: NullableIntFieldUpdateOperationsInput | number | null
    reactordrop?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mob_dropsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    mobid?: NullableIntFieldUpdateOperationsInput | number | null
    itemid?: NullableIntFieldUpdateOperationsInput | number | null
    chance?: NullableIntFieldUpdateOperationsInput | number | null
    minquant?: NullableIntFieldUpdateOperationsInput | number | null
    maxquant?: NullableIntFieldUpdateOperationsInput | number | null
    reactordrop?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type monster_collectionCreateInput = {
    mobid?: number | null
    region?: number | null
    session?: number | null
    position?: number | null
  }

  export type monster_collectionUncheckedCreateInput = {
    id?: number
    mobid?: number | null
    region?: number | null
    session?: number | null
    position?: number | null
  }

  export type monster_collectionUpdateInput = {
    mobid?: NullableIntFieldUpdateOperationsInput | number | null
    region?: NullableIntFieldUpdateOperationsInput | number | null
    session?: NullableIntFieldUpdateOperationsInput | number | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type monster_collectionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    mobid?: NullableIntFieldUpdateOperationsInput | number | null
    region?: NullableIntFieldUpdateOperationsInput | number | null
    session?: NullableIntFieldUpdateOperationsInput | number | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type monster_collectionCreateManyInput = {
    id?: number
    mobid?: number | null
    region?: number | null
    session?: number | null
    position?: number | null
  }

  export type monster_collectionUpdateManyMutationInput = {
    mobid?: NullableIntFieldUpdateOperationsInput | number | null
    region?: NullableIntFieldUpdateOperationsInput | number | null
    session?: NullableIntFieldUpdateOperationsInput | number | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type monster_collectionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    mobid?: NullableIntFieldUpdateOperationsInput | number | null
    region?: NullableIntFieldUpdateOperationsInput | number | null
    session?: NullableIntFieldUpdateOperationsInput | number | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type monster_collection_explorationsCreateInput = {
    id?: bigint | number
    collectionid?: number | null
    collectionkey?: number | null
    monsterkey?: string | null
    endDate?: Date | string | null
    position?: number | null
  }

  export type monster_collection_explorationsUncheckedCreateInput = {
    id?: bigint | number
    collectionid?: number | null
    collectionkey?: number | null
    monsterkey?: string | null
    endDate?: Date | string | null
    position?: number | null
  }

  export type monster_collection_explorationsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    collectionid?: NullableIntFieldUpdateOperationsInput | number | null
    collectionkey?: NullableIntFieldUpdateOperationsInput | number | null
    monsterkey?: NullableStringFieldUpdateOperationsInput | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type monster_collection_explorationsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    collectionid?: NullableIntFieldUpdateOperationsInput | number | null
    collectionkey?: NullableIntFieldUpdateOperationsInput | number | null
    monsterkey?: NullableStringFieldUpdateOperationsInput | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type monster_collection_explorationsCreateManyInput = {
    id?: bigint | number
    collectionid?: number | null
    collectionkey?: number | null
    monsterkey?: string | null
    endDate?: Date | string | null
    position?: number | null
  }

  export type monster_collection_explorationsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    collectionid?: NullableIntFieldUpdateOperationsInput | number | null
    collectionkey?: NullableIntFieldUpdateOperationsInput | number | null
    monsterkey?: NullableStringFieldUpdateOperationsInput | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type monster_collection_explorationsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    collectionid?: NullableIntFieldUpdateOperationsInput | number | null
    collectionkey?: NullableIntFieldUpdateOperationsInput | number | null
    monsterkey?: NullableStringFieldUpdateOperationsInput | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type monster_collection_group_rewardsCreateInput = {
    region: number
    session: number
    groupid: number
    rewardid?: number | null
    quantity?: number | null
  }

  export type monster_collection_group_rewardsUncheckedCreateInput = {
    region: number
    session: number
    groupid: number
    rewardid?: number | null
    quantity?: number | null
  }

  export type monster_collection_group_rewardsUpdateInput = {
    region?: IntFieldUpdateOperationsInput | number
    session?: IntFieldUpdateOperationsInput | number
    groupid?: IntFieldUpdateOperationsInput | number
    rewardid?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type monster_collection_group_rewardsUncheckedUpdateInput = {
    region?: IntFieldUpdateOperationsInput | number
    session?: IntFieldUpdateOperationsInput | number
    groupid?: IntFieldUpdateOperationsInput | number
    rewardid?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type monster_collection_group_rewardsCreateManyInput = {
    region: number
    session: number
    groupid: number
    rewardid?: number | null
    quantity?: number | null
  }

  export type monster_collection_group_rewardsUpdateManyMutationInput = {
    region?: IntFieldUpdateOperationsInput | number
    session?: IntFieldUpdateOperationsInput | number
    groupid?: IntFieldUpdateOperationsInput | number
    rewardid?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type monster_collection_group_rewardsUncheckedUpdateManyInput = {
    region?: IntFieldUpdateOperationsInput | number
    session?: IntFieldUpdateOperationsInput | number
    groupid?: IntFieldUpdateOperationsInput | number
    rewardid?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type monster_collection_mobsCreateInput = {
    collectionid?: number | null
    mobid?: number | null
  }

  export type monster_collection_mobsUncheckedCreateInput = {
    id?: number
    collectionid?: number | null
    mobid?: number | null
  }

  export type monster_collection_mobsUpdateInput = {
    collectionid?: NullableIntFieldUpdateOperationsInput | number | null
    mobid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type monster_collection_mobsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    collectionid?: NullableIntFieldUpdateOperationsInput | number | null
    mobid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type monster_collection_mobsCreateManyInput = {
    id?: number
    collectionid?: number | null
    mobid?: number | null
  }

  export type monster_collection_mobsUpdateManyMutationInput = {
    collectionid?: NullableIntFieldUpdateOperationsInput | number | null
    mobid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type monster_collection_mobsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    collectionid?: NullableIntFieldUpdateOperationsInput | number | null
    mobid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type monster_collection_rewardsCreateInput = {
    region: number
    session: number
    groupid: number
    collectionid?: number | null
  }

  export type monster_collection_rewardsUncheckedCreateInput = {
    region: number
    session: number
    groupid: number
    collectionid?: number | null
  }

  export type monster_collection_rewardsUpdateInput = {
    region?: IntFieldUpdateOperationsInput | number
    session?: IntFieldUpdateOperationsInput | number
    groupid?: IntFieldUpdateOperationsInput | number
    collectionid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type monster_collection_rewardsUncheckedUpdateInput = {
    region?: IntFieldUpdateOperationsInput | number
    session?: IntFieldUpdateOperationsInput | number
    groupid?: IntFieldUpdateOperationsInput | number
    collectionid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type monster_collection_rewardsCreateManyInput = {
    region: number
    session: number
    groupid: number
    collectionid?: number | null
  }

  export type monster_collection_rewardsUpdateManyMutationInput = {
    region?: IntFieldUpdateOperationsInput | number
    session?: IntFieldUpdateOperationsInput | number
    groupid?: IntFieldUpdateOperationsInput | number
    collectionid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type monster_collection_rewardsUncheckedUpdateManyInput = {
    region?: IntFieldUpdateOperationsInput | number
    session?: IntFieldUpdateOperationsInput | number
    groupid?: IntFieldUpdateOperationsInput | number
    collectionid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type monster_collection_session_rewardsCreateInput = {
    region: number
    session: number
    rewardid?: number | null
    quantity?: number | null
  }

  export type monster_collection_session_rewardsUncheckedCreateInput = {
    region: number
    session: number
    rewardid?: number | null
    quantity?: number | null
  }

  export type monster_collection_session_rewardsUpdateInput = {
    region?: IntFieldUpdateOperationsInput | number
    session?: IntFieldUpdateOperationsInput | number
    rewardid?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type monster_collection_session_rewardsUncheckedUpdateInput = {
    region?: IntFieldUpdateOperationsInput | number
    session?: IntFieldUpdateOperationsInput | number
    rewardid?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type monster_collection_session_rewardsCreateManyInput = {
    region: number
    session: number
    rewardid?: number | null
    quantity?: number | null
  }

  export type monster_collection_session_rewardsUpdateManyMutationInput = {
    region?: IntFieldUpdateOperationsInput | number
    session?: IntFieldUpdateOperationsInput | number
    rewardid?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type monster_collection_session_rewardsUncheckedUpdateManyInput = {
    region?: IntFieldUpdateOperationsInput | number
    session?: IntFieldUpdateOperationsInput | number
    rewardid?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type monster_collectionsCreateInput = {
    templateid?: number
    accid?: number
  }

  export type monster_collectionsUncheckedCreateInput = {
    id?: number
    templateid?: number
    accid?: number
  }

  export type monster_collectionsUpdateInput = {
    templateid?: IntFieldUpdateOperationsInput | number
    accid?: IntFieldUpdateOperationsInput | number
  }

  export type monster_collectionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    templateid?: IntFieldUpdateOperationsInput | number
    accid?: IntFieldUpdateOperationsInput | number
  }

  export type monster_collectionsCreateManyInput = {
    id?: number
    templateid?: number
    accid?: number
  }

  export type monster_collectionsUpdateManyMutationInput = {
    templateid?: IntFieldUpdateOperationsInput | number
    accid?: IntFieldUpdateOperationsInput | number
  }

  export type monster_collectionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    templateid?: IntFieldUpdateOperationsInput | number
    accid?: IntFieldUpdateOperationsInput | number
  }

  export type monsterbookcardsCreateInput = {
    id?: bigint | number
    bookid?: number | null
    cardid?: number | null
  }

  export type monsterbookcardsUncheckedCreateInput = {
    id?: bigint | number
    bookid?: number | null
    cardid?: number | null
  }

  export type monsterbookcardsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    bookid?: NullableIntFieldUpdateOperationsInput | number | null
    cardid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type monsterbookcardsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    bookid?: NullableIntFieldUpdateOperationsInput | number | null
    cardid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type monsterbookcardsCreateManyInput = {
    id?: bigint | number
    bookid?: number | null
    cardid?: number | null
  }

  export type monsterbookcardsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    bookid?: NullableIntFieldUpdateOperationsInput | number | null
    cardid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type monsterbookcardsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    bookid?: NullableIntFieldUpdateOperationsInput | number | null
    cardid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type monsterbookinfosCreateInput = {
    setid?: number | null
    coverid?: number | null
  }

  export type monsterbookinfosUncheckedCreateInput = {
    id?: number
    setid?: number | null
    coverid?: number | null
  }

  export type monsterbookinfosUpdateInput = {
    setid?: NullableIntFieldUpdateOperationsInput | number | null
    coverid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type monsterbookinfosUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    setid?: NullableIntFieldUpdateOperationsInput | number | null
    coverid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type monsterbookinfosCreateManyInput = {
    id?: number
    setid?: number | null
    coverid?: number | null
  }

  export type monsterbookinfosUpdateManyMutationInput = {
    setid?: NullableIntFieldUpdateOperationsInput | number | null
    coverid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type monsterbookinfosUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    setid?: NullableIntFieldUpdateOperationsInput | number | null
    coverid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type noncombatstatdaylimitCreateInput = {
    charisma?: number | null
    charm?: number | null
    insight?: number | null
    will?: number | null
    craft?: number | null
    sense?: number | null
    lastupdatecharmbycashpr?: Date | string | null
    charmbycashpr?: number | null
  }

  export type noncombatstatdaylimitUncheckedCreateInput = {
    id?: number
    charisma?: number | null
    charm?: number | null
    insight?: number | null
    will?: number | null
    craft?: number | null
    sense?: number | null
    lastupdatecharmbycashpr?: Date | string | null
    charmbycashpr?: number | null
  }

  export type noncombatstatdaylimitUpdateInput = {
    charisma?: NullableIntFieldUpdateOperationsInput | number | null
    charm?: NullableIntFieldUpdateOperationsInput | number | null
    insight?: NullableIntFieldUpdateOperationsInput | number | null
    will?: NullableIntFieldUpdateOperationsInput | number | null
    craft?: NullableIntFieldUpdateOperationsInput | number | null
    sense?: NullableIntFieldUpdateOperationsInput | number | null
    lastupdatecharmbycashpr?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    charmbycashpr?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type noncombatstatdaylimitUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    charisma?: NullableIntFieldUpdateOperationsInput | number | null
    charm?: NullableIntFieldUpdateOperationsInput | number | null
    insight?: NullableIntFieldUpdateOperationsInput | number | null
    will?: NullableIntFieldUpdateOperationsInput | number | null
    craft?: NullableIntFieldUpdateOperationsInput | number | null
    sense?: NullableIntFieldUpdateOperationsInput | number | null
    lastupdatecharmbycashpr?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    charmbycashpr?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type noncombatstatdaylimitCreateManyInput = {
    id?: number
    charisma?: number | null
    charm?: number | null
    insight?: number | null
    will?: number | null
    craft?: number | null
    sense?: number | null
    lastupdatecharmbycashpr?: Date | string | null
    charmbycashpr?: number | null
  }

  export type noncombatstatdaylimitUpdateManyMutationInput = {
    charisma?: NullableIntFieldUpdateOperationsInput | number | null
    charm?: NullableIntFieldUpdateOperationsInput | number | null
    insight?: NullableIntFieldUpdateOperationsInput | number | null
    will?: NullableIntFieldUpdateOperationsInput | number | null
    craft?: NullableIntFieldUpdateOperationsInput | number | null
    sense?: NullableIntFieldUpdateOperationsInput | number | null
    lastupdatecharmbycashpr?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    charmbycashpr?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type noncombatstatdaylimitUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    charisma?: NullableIntFieldUpdateOperationsInput | number | null
    charm?: NullableIntFieldUpdateOperationsInput | number | null
    insight?: NullableIntFieldUpdateOperationsInput | number | null
    will?: NullableIntFieldUpdateOperationsInput | number | null
    craft?: NullableIntFieldUpdateOperationsInput | number | null
    sense?: NullableIntFieldUpdateOperationsInput | number | null
    lastupdatecharmbycashpr?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    charmbycashpr?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type npcCreateInput = {
    npcid?: number | null
    mapid?: number | null
    x?: number | null
    y?: number | null
    cy?: number | null
    rx0?: number | null
    rx1?: number | null
    fh?: number | null
  }

  export type npcUncheckedCreateInput = {
    id?: number
    npcid?: number | null
    mapid?: number | null
    x?: number | null
    y?: number | null
    cy?: number | null
    rx0?: number | null
    rx1?: number | null
    fh?: number | null
  }

  export type npcUpdateInput = {
    npcid?: NullableIntFieldUpdateOperationsInput | number | null
    mapid?: NullableIntFieldUpdateOperationsInput | number | null
    x?: NullableIntFieldUpdateOperationsInput | number | null
    y?: NullableIntFieldUpdateOperationsInput | number | null
    cy?: NullableIntFieldUpdateOperationsInput | number | null
    rx0?: NullableIntFieldUpdateOperationsInput | number | null
    rx1?: NullableIntFieldUpdateOperationsInput | number | null
    fh?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type npcUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    npcid?: NullableIntFieldUpdateOperationsInput | number | null
    mapid?: NullableIntFieldUpdateOperationsInput | number | null
    x?: NullableIntFieldUpdateOperationsInput | number | null
    y?: NullableIntFieldUpdateOperationsInput | number | null
    cy?: NullableIntFieldUpdateOperationsInput | number | null
    rx0?: NullableIntFieldUpdateOperationsInput | number | null
    rx1?: NullableIntFieldUpdateOperationsInput | number | null
    fh?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type npcCreateManyInput = {
    id?: number
    npcid?: number | null
    mapid?: number | null
    x?: number | null
    y?: number | null
    cy?: number | null
    rx0?: number | null
    rx1?: number | null
    fh?: number | null
  }

  export type npcUpdateManyMutationInput = {
    npcid?: NullableIntFieldUpdateOperationsInput | number | null
    mapid?: NullableIntFieldUpdateOperationsInput | number | null
    x?: NullableIntFieldUpdateOperationsInput | number | null
    y?: NullableIntFieldUpdateOperationsInput | number | null
    cy?: NullableIntFieldUpdateOperationsInput | number | null
    rx0?: NullableIntFieldUpdateOperationsInput | number | null
    rx1?: NullableIntFieldUpdateOperationsInput | number | null
    fh?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type npcUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    npcid?: NullableIntFieldUpdateOperationsInput | number | null
    mapid?: NullableIntFieldUpdateOperationsInput | number | null
    x?: NullableIntFieldUpdateOperationsInput | number | null
    y?: NullableIntFieldUpdateOperationsInput | number | null
    cy?: NullableIntFieldUpdateOperationsInput | number | null
    rx0?: NullableIntFieldUpdateOperationsInput | number | null
    rx1?: NullableIntFieldUpdateOperationsInput | number | null
    fh?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type offense_managersCreateInput = {
    points?: number | null
  }

  export type offense_managersUncheckedCreateInput = {
    id?: number
    points?: number | null
  }

  export type offense_managersUpdateInput = {
    points?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type offense_managersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    points?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type offense_managersCreateManyInput = {
    id?: number
    points?: number | null
  }

  export type offense_managersUpdateManyMutationInput = {
    points?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type offense_managersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    points?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type offensesCreateInput = {
    id?: bigint | number
    manager_id?: number | null
    charid?: number | null
    accountid?: number | null
    msg?: string | null
    type?: string | null
    issuedate?: Date | string | null
    issuer_char_id?: number | null
  }

  export type offensesUncheckedCreateInput = {
    id?: bigint | number
    manager_id?: number | null
    charid?: number | null
    accountid?: number | null
    msg?: string | null
    type?: string | null
    issuedate?: Date | string | null
    issuer_char_id?: number | null
  }

  export type offensesUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    manager_id?: NullableIntFieldUpdateOperationsInput | number | null
    charid?: NullableIntFieldUpdateOperationsInput | number | null
    accountid?: NullableIntFieldUpdateOperationsInput | number | null
    msg?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    issuedate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issuer_char_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type offensesUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    manager_id?: NullableIntFieldUpdateOperationsInput | number | null
    charid?: NullableIntFieldUpdateOperationsInput | number | null
    accountid?: NullableIntFieldUpdateOperationsInput | number | null
    msg?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    issuedate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issuer_char_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type offensesCreateManyInput = {
    id?: bigint | number
    manager_id?: number | null
    charid?: number | null
    accountid?: number | null
    msg?: string | null
    type?: string | null
    issuedate?: Date | string | null
    issuer_char_id?: number | null
  }

  export type offensesUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    manager_id?: NullableIntFieldUpdateOperationsInput | number | null
    charid?: NullableIntFieldUpdateOperationsInput | number | null
    accountid?: NullableIntFieldUpdateOperationsInput | number | null
    msg?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    issuedate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issuer_char_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type offensesUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    manager_id?: NullableIntFieldUpdateOperationsInput | number | null
    charid?: NullableIntFieldUpdateOperationsInput | number | null
    accountid?: NullableIntFieldUpdateOperationsInput | number | null
    msg?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    issuedate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issuer_char_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type partyCreateInput = {
    name?: string | null
    partyleaderid?: number | null
    appliable?: boolean | null
    isprivateparty?: boolean | null
  }

  export type partyUncheckedCreateInput = {
    id?: number
    name?: string | null
    partyleaderid?: number | null
    appliable?: boolean | null
    isprivateparty?: boolean | null
  }

  export type partyUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    partyleaderid?: NullableIntFieldUpdateOperationsInput | number | null
    appliable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isprivateparty?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type partyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    partyleaderid?: NullableIntFieldUpdateOperationsInput | number | null
    appliable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isprivateparty?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type partyCreateManyInput = {
    id?: number
    name?: string | null
    partyleaderid?: number | null
    appliable?: boolean | null
    isprivateparty?: boolean | null
  }

  export type partyUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    partyleaderid?: NullableIntFieldUpdateOperationsInput | number | null
    appliable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isprivateparty?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type partyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    partyleaderid?: NullableIntFieldUpdateOperationsInput | number | null
    appliable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isprivateparty?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type partybossCreateInput = {
    charid?: number | null
    orderid?: number | null
    bossname?: string | null
    difficulty?: number | null
    attempt?: number | null
    lastattempttime?: Date | string | null
  }

  export type partybossUncheckedCreateInput = {
    id?: number
    charid?: number | null
    orderid?: number | null
    bossname?: string | null
    difficulty?: number | null
    attempt?: number | null
    lastattempttime?: Date | string | null
  }

  export type partybossUpdateInput = {
    charid?: NullableIntFieldUpdateOperationsInput | number | null
    orderid?: NullableIntFieldUpdateOperationsInput | number | null
    bossname?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    attempt?: NullableIntFieldUpdateOperationsInput | number | null
    lastattempttime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type partybossUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    charid?: NullableIntFieldUpdateOperationsInput | number | null
    orderid?: NullableIntFieldUpdateOperationsInput | number | null
    bossname?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    attempt?: NullableIntFieldUpdateOperationsInput | number | null
    lastattempttime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type partybossCreateManyInput = {
    id?: number
    charid?: number | null
    orderid?: number | null
    bossname?: string | null
    difficulty?: number | null
    attempt?: number | null
    lastattempttime?: Date | string | null
  }

  export type partybossUpdateManyMutationInput = {
    charid?: NullableIntFieldUpdateOperationsInput | number | null
    orderid?: NullableIntFieldUpdateOperationsInput | number | null
    bossname?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    attempt?: NullableIntFieldUpdateOperationsInput | number | null
    lastattempttime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type partybossUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    charid?: NullableIntFieldUpdateOperationsInput | number | null
    orderid?: NullableIntFieldUpdateOperationsInput | number | null
    bossname?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    attempt?: NullableIntFieldUpdateOperationsInput | number | null
    lastattempttime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type partymembersCreateInput = {
    partyid?: number | null
    charid?: number | null
    name?: string | null
    job?: number | null
    subJob?: number | null
    level?: number | null
    channel?: number | null
    fieldid?: number | null
    loggedin?: boolean | null
  }

  export type partymembersUncheckedCreateInput = {
    id?: number
    partyid?: number | null
    charid?: number | null
    name?: string | null
    job?: number | null
    subJob?: number | null
    level?: number | null
    channel?: number | null
    fieldid?: number | null
    loggedin?: boolean | null
  }

  export type partymembersUpdateInput = {
    partyid?: NullableIntFieldUpdateOperationsInput | number | null
    charid?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    job?: NullableIntFieldUpdateOperationsInput | number | null
    subJob?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    channel?: NullableIntFieldUpdateOperationsInput | number | null
    fieldid?: NullableIntFieldUpdateOperationsInput | number | null
    loggedin?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type partymembersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    partyid?: NullableIntFieldUpdateOperationsInput | number | null
    charid?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    job?: NullableIntFieldUpdateOperationsInput | number | null
    subJob?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    channel?: NullableIntFieldUpdateOperationsInput | number | null
    fieldid?: NullableIntFieldUpdateOperationsInput | number | null
    loggedin?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type partymembersCreateManyInput = {
    id?: number
    partyid?: number | null
    charid?: number | null
    name?: string | null
    job?: number | null
    subJob?: number | null
    level?: number | null
    channel?: number | null
    fieldid?: number | null
    loggedin?: boolean | null
  }

  export type partymembersUpdateManyMutationInput = {
    partyid?: NullableIntFieldUpdateOperationsInput | number | null
    charid?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    job?: NullableIntFieldUpdateOperationsInput | number | null
    subJob?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    channel?: NullableIntFieldUpdateOperationsInput | number | null
    fieldid?: NullableIntFieldUpdateOperationsInput | number | null
    loggedin?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type partymembersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    partyid?: NullableIntFieldUpdateOperationsInput | number | null
    charid?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    job?: NullableIntFieldUpdateOperationsInput | number | null
    subJob?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    channel?: NullableIntFieldUpdateOperationsInput | number | null
    fieldid?: NullableIntFieldUpdateOperationsInput | number | null
    loggedin?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type petidsCreateInput = {
    alid?: number | null
    petid?: number | null
  }

  export type petidsUncheckedCreateInput = {
    id?: number
    alid?: number | null
    petid?: number | null
  }

  export type petidsUpdateInput = {
    alid?: NullableIntFieldUpdateOperationsInput | number | null
    petid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type petidsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    alid?: NullableIntFieldUpdateOperationsInput | number | null
    petid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type petidsCreateManyInput = {
    id?: number
    alid?: number | null
    petid?: number | null
  }

  export type petidsUpdateManyMutationInput = {
    alid?: NullableIntFieldUpdateOperationsInput | number | null
    petid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type petidsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    alid?: NullableIntFieldUpdateOperationsInput | number | null
    petid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type petitemsCreateInput = {
    itemid: bigint | number
    name?: string | null
    level?: number | null
    tameness?: number | null
    repleteness?: number | null
    petattribute?: number | null
    petskill?: number | null
    datedead?: Date | string | null
    remainlife?: number | null
    attribute?: number | null
    activestate?: number | null
    autobuffskill?: number | null
    pethue?: number | null
    giantrate?: number | null
    exceptionList?: string | null
  }

  export type petitemsUncheckedCreateInput = {
    itemid: bigint | number
    name?: string | null
    level?: number | null
    tameness?: number | null
    repleteness?: number | null
    petattribute?: number | null
    petskill?: number | null
    datedead?: Date | string | null
    remainlife?: number | null
    attribute?: number | null
    activestate?: number | null
    autobuffskill?: number | null
    pethue?: number | null
    giantrate?: number | null
    exceptionList?: string | null
  }

  export type petitemsUpdateInput = {
    itemid?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    tameness?: NullableIntFieldUpdateOperationsInput | number | null
    repleteness?: NullableIntFieldUpdateOperationsInput | number | null
    petattribute?: NullableIntFieldUpdateOperationsInput | number | null
    petskill?: NullableIntFieldUpdateOperationsInput | number | null
    datedead?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remainlife?: NullableIntFieldUpdateOperationsInput | number | null
    attribute?: NullableIntFieldUpdateOperationsInput | number | null
    activestate?: NullableIntFieldUpdateOperationsInput | number | null
    autobuffskill?: NullableIntFieldUpdateOperationsInput | number | null
    pethue?: NullableIntFieldUpdateOperationsInput | number | null
    giantrate?: NullableIntFieldUpdateOperationsInput | number | null
    exceptionList?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type petitemsUncheckedUpdateInput = {
    itemid?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    tameness?: NullableIntFieldUpdateOperationsInput | number | null
    repleteness?: NullableIntFieldUpdateOperationsInput | number | null
    petattribute?: NullableIntFieldUpdateOperationsInput | number | null
    petskill?: NullableIntFieldUpdateOperationsInput | number | null
    datedead?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remainlife?: NullableIntFieldUpdateOperationsInput | number | null
    attribute?: NullableIntFieldUpdateOperationsInput | number | null
    activestate?: NullableIntFieldUpdateOperationsInput | number | null
    autobuffskill?: NullableIntFieldUpdateOperationsInput | number | null
    pethue?: NullableIntFieldUpdateOperationsInput | number | null
    giantrate?: NullableIntFieldUpdateOperationsInput | number | null
    exceptionList?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type petitemsCreateManyInput = {
    itemid: bigint | number
    name?: string | null
    level?: number | null
    tameness?: number | null
    repleteness?: number | null
    petattribute?: number | null
    petskill?: number | null
    datedead?: Date | string | null
    remainlife?: number | null
    attribute?: number | null
    activestate?: number | null
    autobuffskill?: number | null
    pethue?: number | null
    giantrate?: number | null
    exceptionList?: string | null
  }

  export type petitemsUpdateManyMutationInput = {
    itemid?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    tameness?: NullableIntFieldUpdateOperationsInput | number | null
    repleteness?: NullableIntFieldUpdateOperationsInput | number | null
    petattribute?: NullableIntFieldUpdateOperationsInput | number | null
    petskill?: NullableIntFieldUpdateOperationsInput | number | null
    datedead?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remainlife?: NullableIntFieldUpdateOperationsInput | number | null
    attribute?: NullableIntFieldUpdateOperationsInput | number | null
    activestate?: NullableIntFieldUpdateOperationsInput | number | null
    autobuffskill?: NullableIntFieldUpdateOperationsInput | number | null
    pethue?: NullableIntFieldUpdateOperationsInput | number | null
    giantrate?: NullableIntFieldUpdateOperationsInput | number | null
    exceptionList?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type petitemsUncheckedUpdateManyInput = {
    itemid?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    tameness?: NullableIntFieldUpdateOperationsInput | number | null
    repleteness?: NullableIntFieldUpdateOperationsInput | number | null
    petattribute?: NullableIntFieldUpdateOperationsInput | number | null
    petskill?: NullableIntFieldUpdateOperationsInput | number | null
    datedead?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remainlife?: NullableIntFieldUpdateOperationsInput | number | null
    attribute?: NullableIntFieldUpdateOperationsInput | number | null
    activestate?: NullableIntFieldUpdateOperationsInput | number | null
    autobuffskill?: NullableIntFieldUpdateOperationsInput | number | null
    pethue?: NullableIntFieldUpdateOperationsInput | number | null
    giantrate?: NullableIntFieldUpdateOperationsInput | number | null
    exceptionList?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type questlistsCreateInput = {
    questlist_id?: bigint | number
    questmanager_id?: bigint | number | null
    questid?: number | null
    fk_questid?: bigint | number | null
  }

  export type questlistsUncheckedCreateInput = {
    questlist_id?: bigint | number
    questmanager_id?: bigint | number | null
    questid?: number | null
    fk_questid?: bigint | number | null
  }

  export type questlistsUpdateInput = {
    questlist_id?: BigIntFieldUpdateOperationsInput | bigint | number
    questmanager_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    questid?: NullableIntFieldUpdateOperationsInput | number | null
    fk_questid?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type questlistsUncheckedUpdateInput = {
    questlist_id?: BigIntFieldUpdateOperationsInput | bigint | number
    questmanager_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    questid?: NullableIntFieldUpdateOperationsInput | number | null
    fk_questid?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type questlistsCreateManyInput = {
    questlist_id?: bigint | number
    questmanager_id?: bigint | number | null
    questid?: number | null
    fk_questid?: bigint | number | null
  }

  export type questlistsUpdateManyMutationInput = {
    questlist_id?: BigIntFieldUpdateOperationsInput | bigint | number
    questmanager_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    questid?: NullableIntFieldUpdateOperationsInput | number | null
    fk_questid?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type questlistsUncheckedUpdateManyInput = {
    questlist_id?: BigIntFieldUpdateOperationsInput | bigint | number
    questmanager_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    questid?: NullableIntFieldUpdateOperationsInput | number | null
    fk_questid?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type questmanagersCreateInput = {
    id?: bigint | number
  }

  export type questmanagersUncheckedCreateInput = {
    id?: bigint | number
  }

  export type questmanagersUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type questmanagersUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type questmanagersCreateManyInput = {
    id?: bigint | number
  }

  export type questmanagersUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type questmanagersUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type questprogressrequirementsCreateInput = {
    id?: bigint | number
    orderNum?: number | null
    progresstype?: string | null
    questid?: bigint | number | null
    unitid?: number | null
    requiredcount?: number | null
    currentcount?: number | null
  }

  export type questprogressrequirementsUncheckedCreateInput = {
    id?: bigint | number
    orderNum?: number | null
    progresstype?: string | null
    questid?: bigint | number | null
    unitid?: number | null
    requiredcount?: number | null
    currentcount?: number | null
  }

  export type questprogressrequirementsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    orderNum?: NullableIntFieldUpdateOperationsInput | number | null
    progresstype?: NullableStringFieldUpdateOperationsInput | string | null
    questid?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    unitid?: NullableIntFieldUpdateOperationsInput | number | null
    requiredcount?: NullableIntFieldUpdateOperationsInput | number | null
    currentcount?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type questprogressrequirementsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    orderNum?: NullableIntFieldUpdateOperationsInput | number | null
    progresstype?: NullableStringFieldUpdateOperationsInput | string | null
    questid?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    unitid?: NullableIntFieldUpdateOperationsInput | number | null
    requiredcount?: NullableIntFieldUpdateOperationsInput | number | null
    currentcount?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type questprogressrequirementsCreateManyInput = {
    id?: bigint | number
    orderNum?: number | null
    progresstype?: string | null
    questid?: bigint | number | null
    unitid?: number | null
    requiredcount?: number | null
    currentcount?: number | null
  }

  export type questprogressrequirementsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    orderNum?: NullableIntFieldUpdateOperationsInput | number | null
    progresstype?: NullableStringFieldUpdateOperationsInput | string | null
    questid?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    unitid?: NullableIntFieldUpdateOperationsInput | number | null
    requiredcount?: NullableIntFieldUpdateOperationsInput | number | null
    currentcount?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type questprogressrequirementsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    orderNum?: NullableIntFieldUpdateOperationsInput | number | null
    progresstype?: NullableStringFieldUpdateOperationsInput | string | null
    questid?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    unitid?: NullableIntFieldUpdateOperationsInput | number | null
    requiredcount?: NullableIntFieldUpdateOperationsInput | number | null
    currentcount?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type questsCreateInput = {
    id?: bigint | number
    qrkey?: number | null
    qrvalue?: string | null
    status?: number | null
    completedtime?: Date | string | null
    expireterm?: Date | string | null
  }

  export type questsUncheckedCreateInput = {
    id?: bigint | number
    qrkey?: number | null
    qrvalue?: string | null
    status?: number | null
    completedtime?: Date | string | null
    expireterm?: Date | string | null
  }

  export type questsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    qrkey?: NullableIntFieldUpdateOperationsInput | number | null
    qrvalue?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    completedtime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expireterm?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type questsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    qrkey?: NullableIntFieldUpdateOperationsInput | number | null
    qrvalue?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    completedtime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expireterm?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type questsCreateManyInput = {
    id?: bigint | number
    qrkey?: number | null
    qrvalue?: string | null
    status?: number | null
    completedtime?: Date | string | null
    expireterm?: Date | string | null
  }

  export type questsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    qrkey?: NullableIntFieldUpdateOperationsInput | number | null
    qrvalue?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    completedtime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expireterm?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type questsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    qrkey?: NullableIntFieldUpdateOperationsInput | number | null
    qrvalue?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    completedtime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expireterm?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type rewardinfoCreateInput = {
    charid?: number
    charname: string
    rewardItemType: boolean
    itemID?: number
    quantity?: number
    maplePoint?: number
    meso?: number
    level?: number
    exp?: number
    description: string
    starttime?: Date | string | null
    endtime?: Date | string | null
  }

  export type rewardinfoUncheckedCreateInput = {
    id?: number
    charid?: number
    charname: string
    rewardItemType: boolean
    itemID?: number
    quantity?: number
    maplePoint?: number
    meso?: number
    level?: number
    exp?: number
    description: string
    starttime?: Date | string | null
    endtime?: Date | string | null
  }

  export type rewardinfoUpdateInput = {
    charid?: IntFieldUpdateOperationsInput | number
    charname?: StringFieldUpdateOperationsInput | string
    rewardItemType?: BoolFieldUpdateOperationsInput | boolean
    itemID?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    maplePoint?: IntFieldUpdateOperationsInput | number
    meso?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    exp?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    starttime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endtime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type rewardinfoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    charid?: IntFieldUpdateOperationsInput | number
    charname?: StringFieldUpdateOperationsInput | string
    rewardItemType?: BoolFieldUpdateOperationsInput | boolean
    itemID?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    maplePoint?: IntFieldUpdateOperationsInput | number
    meso?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    exp?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    starttime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endtime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type rewardinfoCreateManyInput = {
    id?: number
    charid?: number
    charname: string
    rewardItemType: boolean
    itemID?: number
    quantity?: number
    maplePoint?: number
    meso?: number
    level?: number
    exp?: number
    description: string
    starttime?: Date | string | null
    endtime?: Date | string | null
  }

  export type rewardinfoUpdateManyMutationInput = {
    charid?: IntFieldUpdateOperationsInput | number
    charname?: StringFieldUpdateOperationsInput | string
    rewardItemType?: BoolFieldUpdateOperationsInput | boolean
    itemID?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    maplePoint?: IntFieldUpdateOperationsInput | number
    meso?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    exp?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    starttime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endtime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type rewardinfoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    charid?: IntFieldUpdateOperationsInput | number
    charname?: StringFieldUpdateOperationsInput | string
    rewardItemType?: BoolFieldUpdateOperationsInput | boolean
    itemID?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    maplePoint?: IntFieldUpdateOperationsInput | number
    meso?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    exp?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    starttime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endtime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type shopitemsCreateInput = {
    id?: bigint | number
    shopid?: number | null
    itemid?: number | null
    price?: number | null
    tokenitemid?: number | null
    tokenprice?: number | null
    pointquestid?: number | null
    pointprice?: number | null
    starcoin?: number | null
    questexid?: number | null
    questexkey?: string | null
    questexvalue?: number | null
    itemperiod?: number | null
    levellimited?: number | null
    showlevmin?: number | null
    showlevmax?: number | null
    questid?: number | null
    sellstart?: Date | string | null
    sellend?: Date | string | null
    tabindex?: number | null
    worldblock?: boolean | null
    potentialgrade?: number | null
    buylimit?: number | null
    quantity?: number | null
    unitprice?: bigint | number | null
    maxperslot?: number | null
    discountperc?: number | null
  }

  export type shopitemsUncheckedCreateInput = {
    id?: bigint | number
    shopid?: number | null
    itemid?: number | null
    price?: number | null
    tokenitemid?: number | null
    tokenprice?: number | null
    pointquestid?: number | null
    pointprice?: number | null
    starcoin?: number | null
    questexid?: number | null
    questexkey?: string | null
    questexvalue?: number | null
    itemperiod?: number | null
    levellimited?: number | null
    showlevmin?: number | null
    showlevmax?: number | null
    questid?: number | null
    sellstart?: Date | string | null
    sellend?: Date | string | null
    tabindex?: number | null
    worldblock?: boolean | null
    potentialgrade?: number | null
    buylimit?: number | null
    quantity?: number | null
    unitprice?: bigint | number | null
    maxperslot?: number | null
    discountperc?: number | null
  }

  export type shopitemsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    shopid?: NullableIntFieldUpdateOperationsInput | number | null
    itemid?: NullableIntFieldUpdateOperationsInput | number | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    tokenitemid?: NullableIntFieldUpdateOperationsInput | number | null
    tokenprice?: NullableIntFieldUpdateOperationsInput | number | null
    pointquestid?: NullableIntFieldUpdateOperationsInput | number | null
    pointprice?: NullableIntFieldUpdateOperationsInput | number | null
    starcoin?: NullableIntFieldUpdateOperationsInput | number | null
    questexid?: NullableIntFieldUpdateOperationsInput | number | null
    questexkey?: NullableStringFieldUpdateOperationsInput | string | null
    questexvalue?: NullableIntFieldUpdateOperationsInput | number | null
    itemperiod?: NullableIntFieldUpdateOperationsInput | number | null
    levellimited?: NullableIntFieldUpdateOperationsInput | number | null
    showlevmin?: NullableIntFieldUpdateOperationsInput | number | null
    showlevmax?: NullableIntFieldUpdateOperationsInput | number | null
    questid?: NullableIntFieldUpdateOperationsInput | number | null
    sellstart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sellend?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tabindex?: NullableIntFieldUpdateOperationsInput | number | null
    worldblock?: NullableBoolFieldUpdateOperationsInput | boolean | null
    potentialgrade?: NullableIntFieldUpdateOperationsInput | number | null
    buylimit?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    unitprice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    maxperslot?: NullableIntFieldUpdateOperationsInput | number | null
    discountperc?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type shopitemsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    shopid?: NullableIntFieldUpdateOperationsInput | number | null
    itemid?: NullableIntFieldUpdateOperationsInput | number | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    tokenitemid?: NullableIntFieldUpdateOperationsInput | number | null
    tokenprice?: NullableIntFieldUpdateOperationsInput | number | null
    pointquestid?: NullableIntFieldUpdateOperationsInput | number | null
    pointprice?: NullableIntFieldUpdateOperationsInput | number | null
    starcoin?: NullableIntFieldUpdateOperationsInput | number | null
    questexid?: NullableIntFieldUpdateOperationsInput | number | null
    questexkey?: NullableStringFieldUpdateOperationsInput | string | null
    questexvalue?: NullableIntFieldUpdateOperationsInput | number | null
    itemperiod?: NullableIntFieldUpdateOperationsInput | number | null
    levellimited?: NullableIntFieldUpdateOperationsInput | number | null
    showlevmin?: NullableIntFieldUpdateOperationsInput | number | null
    showlevmax?: NullableIntFieldUpdateOperationsInput | number | null
    questid?: NullableIntFieldUpdateOperationsInput | number | null
    sellstart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sellend?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tabindex?: NullableIntFieldUpdateOperationsInput | number | null
    worldblock?: NullableBoolFieldUpdateOperationsInput | boolean | null
    potentialgrade?: NullableIntFieldUpdateOperationsInput | number | null
    buylimit?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    unitprice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    maxperslot?: NullableIntFieldUpdateOperationsInput | number | null
    discountperc?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type shopitemsCreateManyInput = {
    id?: bigint | number
    shopid?: number | null
    itemid?: number | null
    price?: number | null
    tokenitemid?: number | null
    tokenprice?: number | null
    pointquestid?: number | null
    pointprice?: number | null
    starcoin?: number | null
    questexid?: number | null
    questexkey?: string | null
    questexvalue?: number | null
    itemperiod?: number | null
    levellimited?: number | null
    showlevmin?: number | null
    showlevmax?: number | null
    questid?: number | null
    sellstart?: Date | string | null
    sellend?: Date | string | null
    tabindex?: number | null
    worldblock?: boolean | null
    potentialgrade?: number | null
    buylimit?: number | null
    quantity?: number | null
    unitprice?: bigint | number | null
    maxperslot?: number | null
    discountperc?: number | null
  }

  export type shopitemsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    shopid?: NullableIntFieldUpdateOperationsInput | number | null
    itemid?: NullableIntFieldUpdateOperationsInput | number | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    tokenitemid?: NullableIntFieldUpdateOperationsInput | number | null
    tokenprice?: NullableIntFieldUpdateOperationsInput | number | null
    pointquestid?: NullableIntFieldUpdateOperationsInput | number | null
    pointprice?: NullableIntFieldUpdateOperationsInput | number | null
    starcoin?: NullableIntFieldUpdateOperationsInput | number | null
    questexid?: NullableIntFieldUpdateOperationsInput | number | null
    questexkey?: NullableStringFieldUpdateOperationsInput | string | null
    questexvalue?: NullableIntFieldUpdateOperationsInput | number | null
    itemperiod?: NullableIntFieldUpdateOperationsInput | number | null
    levellimited?: NullableIntFieldUpdateOperationsInput | number | null
    showlevmin?: NullableIntFieldUpdateOperationsInput | number | null
    showlevmax?: NullableIntFieldUpdateOperationsInput | number | null
    questid?: NullableIntFieldUpdateOperationsInput | number | null
    sellstart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sellend?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tabindex?: NullableIntFieldUpdateOperationsInput | number | null
    worldblock?: NullableBoolFieldUpdateOperationsInput | boolean | null
    potentialgrade?: NullableIntFieldUpdateOperationsInput | number | null
    buylimit?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    unitprice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    maxperslot?: NullableIntFieldUpdateOperationsInput | number | null
    discountperc?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type shopitemsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    shopid?: NullableIntFieldUpdateOperationsInput | number | null
    itemid?: NullableIntFieldUpdateOperationsInput | number | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    tokenitemid?: NullableIntFieldUpdateOperationsInput | number | null
    tokenprice?: NullableIntFieldUpdateOperationsInput | number | null
    pointquestid?: NullableIntFieldUpdateOperationsInput | number | null
    pointprice?: NullableIntFieldUpdateOperationsInput | number | null
    starcoin?: NullableIntFieldUpdateOperationsInput | number | null
    questexid?: NullableIntFieldUpdateOperationsInput | number | null
    questexkey?: NullableStringFieldUpdateOperationsInput | string | null
    questexvalue?: NullableIntFieldUpdateOperationsInput | number | null
    itemperiod?: NullableIntFieldUpdateOperationsInput | number | null
    levellimited?: NullableIntFieldUpdateOperationsInput | number | null
    showlevmin?: NullableIntFieldUpdateOperationsInput | number | null
    showlevmax?: NullableIntFieldUpdateOperationsInput | number | null
    questid?: NullableIntFieldUpdateOperationsInput | number | null
    sellstart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sellend?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tabindex?: NullableIntFieldUpdateOperationsInput | number | null
    worldblock?: NullableBoolFieldUpdateOperationsInput | boolean | null
    potentialgrade?: NullableIntFieldUpdateOperationsInput | number | null
    buylimit?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    unitprice?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    maxperslot?: NullableIntFieldUpdateOperationsInput | number | null
    discountperc?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type skillcooltimesCreateInput = {
    charid?: number | null
    skillid?: number | null
    nextusabletime?: bigint | number | null
  }

  export type skillcooltimesUncheckedCreateInput = {
    id?: number
    charid?: number | null
    skillid?: number | null
    nextusabletime?: bigint | number | null
  }

  export type skillcooltimesUpdateInput = {
    charid?: NullableIntFieldUpdateOperationsInput | number | null
    skillid?: NullableIntFieldUpdateOperationsInput | number | null
    nextusabletime?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type skillcooltimesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    charid?: NullableIntFieldUpdateOperationsInput | number | null
    skillid?: NullableIntFieldUpdateOperationsInput | number | null
    nextusabletime?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type skillcooltimesCreateManyInput = {
    id?: number
    charid?: number | null
    skillid?: number | null
    nextusabletime?: bigint | number | null
  }

  export type skillcooltimesUpdateManyMutationInput = {
    charid?: NullableIntFieldUpdateOperationsInput | number | null
    skillid?: NullableIntFieldUpdateOperationsInput | number | null
    nextusabletime?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type skillcooltimesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    charid?: NullableIntFieldUpdateOperationsInput | number | null
    skillid?: NullableIntFieldUpdateOperationsInput | number | null
    nextusabletime?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type skillsCreateInput = {
    charid?: number | null
    skillid?: number | null
    rootid?: number | null
    maxlevel?: number | null
    currentlevel?: number | null
    masterlevel?: number | null
  }

  export type skillsUncheckedCreateInput = {
    id?: number
    charid?: number | null
    skillid?: number | null
    rootid?: number | null
    maxlevel?: number | null
    currentlevel?: number | null
    masterlevel?: number | null
  }

  export type skillsUpdateInput = {
    charid?: NullableIntFieldUpdateOperationsInput | number | null
    skillid?: NullableIntFieldUpdateOperationsInput | number | null
    rootid?: NullableIntFieldUpdateOperationsInput | number | null
    maxlevel?: NullableIntFieldUpdateOperationsInput | number | null
    currentlevel?: NullableIntFieldUpdateOperationsInput | number | null
    masterlevel?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type skillsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    charid?: NullableIntFieldUpdateOperationsInput | number | null
    skillid?: NullableIntFieldUpdateOperationsInput | number | null
    rootid?: NullableIntFieldUpdateOperationsInput | number | null
    maxlevel?: NullableIntFieldUpdateOperationsInput | number | null
    currentlevel?: NullableIntFieldUpdateOperationsInput | number | null
    masterlevel?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type skillsCreateManyInput = {
    id?: number
    charid?: number | null
    skillid?: number | null
    rootid?: number | null
    maxlevel?: number | null
    currentlevel?: number | null
    masterlevel?: number | null
  }

  export type skillsUpdateManyMutationInput = {
    charid?: NullableIntFieldUpdateOperationsInput | number | null
    skillid?: NullableIntFieldUpdateOperationsInput | number | null
    rootid?: NullableIntFieldUpdateOperationsInput | number | null
    maxlevel?: NullableIntFieldUpdateOperationsInput | number | null
    currentlevel?: NullableIntFieldUpdateOperationsInput | number | null
    masterlevel?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type skillsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    charid?: NullableIntFieldUpdateOperationsInput | number | null
    skillid?: NullableIntFieldUpdateOperationsInput | number | null
    rootid?: NullableIntFieldUpdateOperationsInput | number | null
    maxlevel?: NullableIntFieldUpdateOperationsInput | number | null
    currentlevel?: NullableIntFieldUpdateOperationsInput | number | null
    masterlevel?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type spsetCreateInput = {
    extendsp_id?: number | null
    joblevel?: number | null
    sp?: number | null
  }

  export type spsetUncheckedCreateInput = {
    id?: number
    extendsp_id?: number | null
    joblevel?: number | null
    sp?: number | null
  }

  export type spsetUpdateInput = {
    extendsp_id?: NullableIntFieldUpdateOperationsInput | number | null
    joblevel?: NullableIntFieldUpdateOperationsInput | number | null
    sp?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type spsetUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    extendsp_id?: NullableIntFieldUpdateOperationsInput | number | null
    joblevel?: NullableIntFieldUpdateOperationsInput | number | null
    sp?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type spsetCreateManyInput = {
    id?: number
    extendsp_id?: number | null
    joblevel?: number | null
    sp?: number | null
  }

  export type spsetUpdateManyMutationInput = {
    extendsp_id?: NullableIntFieldUpdateOperationsInput | number | null
    joblevel?: NullableIntFieldUpdateOperationsInput | number | null
    sp?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type spsetUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    extendsp_id?: NullableIntFieldUpdateOperationsInput | number | null
    joblevel?: NullableIntFieldUpdateOperationsInput | number | null
    sp?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type stolenskillsCreateInput = {
    charid?: number | null
    skillid?: number | null
    position?: number | null
    currentlv?: number | null
  }

  export type stolenskillsUncheckedCreateInput = {
    id?: number
    charid?: number | null
    skillid?: number | null
    position?: number | null
    currentlv?: number | null
  }

  export type stolenskillsUpdateInput = {
    charid?: NullableIntFieldUpdateOperationsInput | number | null
    skillid?: NullableIntFieldUpdateOperationsInput | number | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
    currentlv?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type stolenskillsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    charid?: NullableIntFieldUpdateOperationsInput | number | null
    skillid?: NullableIntFieldUpdateOperationsInput | number | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
    currentlv?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type stolenskillsCreateManyInput = {
    id?: number
    charid?: number | null
    skillid?: number | null
    position?: number | null
    currentlv?: number | null
  }

  export type stolenskillsUpdateManyMutationInput = {
    charid?: NullableIntFieldUpdateOperationsInput | number | null
    skillid?: NullableIntFieldUpdateOperationsInput | number | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
    currentlv?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type stolenskillsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    charid?: NullableIntFieldUpdateOperationsInput | number | null
    skillid?: NullableIntFieldUpdateOperationsInput | number | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
    currentlv?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type systemtimesCreateInput = {
    yr?: number | null
    mnth?: number | null
  }

  export type systemtimesUncheckedCreateInput = {
    id?: number
    yr?: number | null
    mnth?: number | null
  }

  export type systemtimesUpdateInput = {
    yr?: NullableIntFieldUpdateOperationsInput | number | null
    mnth?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type systemtimesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    yr?: NullableIntFieldUpdateOperationsInput | number | null
    mnth?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type systemtimesCreateManyInput = {
    id?: number
    yr?: number | null
    mnth?: number | null
  }

  export type systemtimesUpdateManyMutationInput = {
    yr?: NullableIntFieldUpdateOperationsInput | number | null
    mnth?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type systemtimesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    yr?: NullableIntFieldUpdateOperationsInput | number | null
    mnth?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type totemsCreateInput = {
    alid?: number | null
    totemid?: number | null
  }

  export type totemsUncheckedCreateInput = {
    id?: number
    alid?: number | null
    totemid?: number | null
  }

  export type totemsUpdateInput = {
    alid?: NullableIntFieldUpdateOperationsInput | number | null
    totemid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type totemsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    alid?: NullableIntFieldUpdateOperationsInput | number | null
    totemid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type totemsCreateManyInput = {
    id?: number
    alid?: number | null
    totemid?: number | null
  }

  export type totemsUpdateManyMutationInput = {
    alid?: NullableIntFieldUpdateOperationsInput | number | null
    totemid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type totemsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    alid?: NullableIntFieldUpdateOperationsInput | number | null
    totemid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type trunksCreateInput = {
    slotcount?: number | null
    money?: bigint | number | null
  }

  export type trunksUncheckedCreateInput = {
    id?: number
    slotcount?: number | null
    money?: bigint | number | null
  }

  export type trunksUpdateInput = {
    slotcount?: NullableIntFieldUpdateOperationsInput | number | null
    money?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type trunksUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    slotcount?: NullableIntFieldUpdateOperationsInput | number | null
    money?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type trunksCreateManyInput = {
    id?: number
    slotcount?: number | null
    money?: bigint | number | null
  }

  export type trunksUpdateManyMutationInput = {
    slotcount?: NullableIntFieldUpdateOperationsInput | number | null
    money?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type trunksUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    slotcount?: NullableIntFieldUpdateOperationsInput | number | null
    money?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type unseenequipsCreateInput = {
    alid?: number | null
    equipid?: number | null
  }

  export type unseenequipsUncheckedCreateInput = {
    id?: number
    alid?: number | null
    equipid?: number | null
  }

  export type unseenequipsUpdateInput = {
    alid?: NullableIntFieldUpdateOperationsInput | number | null
    equipid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type unseenequipsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    alid?: NullableIntFieldUpdateOperationsInput | number | null
    equipid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type unseenequipsCreateManyInput = {
    id?: number
    alid?: number | null
    equipid?: number | null
  }

  export type unseenequipsUpdateManyMutationInput = {
    alid?: NullableIntFieldUpdateOperationsInput | number | null
    equipid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type unseenequipsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    alid?: NullableIntFieldUpdateOperationsInput | number | null
    equipid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type usersCreateInput = {
    name?: string | null
    password?: string | null
    pic?: string | null
    email?: string | null
    age?: number | null
    accounttype?: number | null
    votepoints?: number | null
    donationpoints?: number | null
    maplePoints?: number | null
    nxPrepaid?: number | null
    clientstate?: number | null
    vipgrade?: number | null
    vippoints?: number | null
    freevippointdate?: Date | string | null
    vipexpireddate?: Date | string | null
    nblockreason?: number | null
    banExpireDate?: Date | string | null
    banReason?: string | null
    offensemanager?: number | null
    gender?: number | null
    msg2?: number | null
    purchaseexp?: number | null
    pblockreason?: number | null
    chatunblockdate?: bigint | number | null
    hascensorednxloginid?: boolean | null
    gradecode?: number | null
    censorednxloginid?: string | null
    characterslots?: number
    creationdate?: Date | string | null
    bosspoints?: number
    lastvote1?: number
    lastvote2?: number
    claimvote1?: number
    claimvote2?: number
    dojop?: number
    lastvotetime?: Date | string | null
    lastvoteip?: string | null
    discordid?: string | null
  }

  export type usersUncheckedCreateInput = {
    id?: number
    name?: string | null
    password?: string | null
    pic?: string | null
    email?: string | null
    age?: number | null
    accounttype?: number | null
    votepoints?: number | null
    donationpoints?: number | null
    maplePoints?: number | null
    nxPrepaid?: number | null
    clientstate?: number | null
    vipgrade?: number | null
    vippoints?: number | null
    freevippointdate?: Date | string | null
    vipexpireddate?: Date | string | null
    nblockreason?: number | null
    banExpireDate?: Date | string | null
    banReason?: string | null
    offensemanager?: number | null
    gender?: number | null
    msg2?: number | null
    purchaseexp?: number | null
    pblockreason?: number | null
    chatunblockdate?: bigint | number | null
    hascensorednxloginid?: boolean | null
    gradecode?: number | null
    censorednxloginid?: string | null
    characterslots?: number
    creationdate?: Date | string | null
    bosspoints?: number
    lastvote1?: number
    lastvote2?: number
    claimvote1?: number
    claimvote2?: number
    dojop?: number
    lastvotetime?: Date | string | null
    lastvoteip?: string | null
    discordid?: string | null
  }

  export type usersUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    pic?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    accounttype?: NullableIntFieldUpdateOperationsInput | number | null
    votepoints?: NullableIntFieldUpdateOperationsInput | number | null
    donationpoints?: NullableIntFieldUpdateOperationsInput | number | null
    maplePoints?: NullableIntFieldUpdateOperationsInput | number | null
    nxPrepaid?: NullableIntFieldUpdateOperationsInput | number | null
    clientstate?: NullableIntFieldUpdateOperationsInput | number | null
    vipgrade?: NullableIntFieldUpdateOperationsInput | number | null
    vippoints?: NullableIntFieldUpdateOperationsInput | number | null
    freevippointdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vipexpireddate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nblockreason?: NullableIntFieldUpdateOperationsInput | number | null
    banExpireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    offensemanager?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    msg2?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseexp?: NullableIntFieldUpdateOperationsInput | number | null
    pblockreason?: NullableIntFieldUpdateOperationsInput | number | null
    chatunblockdate?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    hascensorednxloginid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gradecode?: NullableIntFieldUpdateOperationsInput | number | null
    censorednxloginid?: NullableStringFieldUpdateOperationsInput | string | null
    characterslots?: IntFieldUpdateOperationsInput | number
    creationdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bosspoints?: IntFieldUpdateOperationsInput | number
    lastvote1?: IntFieldUpdateOperationsInput | number
    lastvote2?: IntFieldUpdateOperationsInput | number
    claimvote1?: IntFieldUpdateOperationsInput | number
    claimvote2?: IntFieldUpdateOperationsInput | number
    dojop?: IntFieldUpdateOperationsInput | number
    lastvotetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastvoteip?: NullableStringFieldUpdateOperationsInput | string | null
    discordid?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type usersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    pic?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    accounttype?: NullableIntFieldUpdateOperationsInput | number | null
    votepoints?: NullableIntFieldUpdateOperationsInput | number | null
    donationpoints?: NullableIntFieldUpdateOperationsInput | number | null
    maplePoints?: NullableIntFieldUpdateOperationsInput | number | null
    nxPrepaid?: NullableIntFieldUpdateOperationsInput | number | null
    clientstate?: NullableIntFieldUpdateOperationsInput | number | null
    vipgrade?: NullableIntFieldUpdateOperationsInput | number | null
    vippoints?: NullableIntFieldUpdateOperationsInput | number | null
    freevippointdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vipexpireddate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nblockreason?: NullableIntFieldUpdateOperationsInput | number | null
    banExpireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    offensemanager?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    msg2?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseexp?: NullableIntFieldUpdateOperationsInput | number | null
    pblockreason?: NullableIntFieldUpdateOperationsInput | number | null
    chatunblockdate?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    hascensorednxloginid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gradecode?: NullableIntFieldUpdateOperationsInput | number | null
    censorednxloginid?: NullableStringFieldUpdateOperationsInput | string | null
    characterslots?: IntFieldUpdateOperationsInput | number
    creationdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bosspoints?: IntFieldUpdateOperationsInput | number
    lastvote1?: IntFieldUpdateOperationsInput | number
    lastvote2?: IntFieldUpdateOperationsInput | number
    claimvote1?: IntFieldUpdateOperationsInput | number
    claimvote2?: IntFieldUpdateOperationsInput | number
    dojop?: IntFieldUpdateOperationsInput | number
    lastvotetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastvoteip?: NullableStringFieldUpdateOperationsInput | string | null
    discordid?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type usersCreateManyInput = {
    id?: number
    name?: string | null
    password?: string | null
    pic?: string | null
    email?: string | null
    age?: number | null
    accounttype?: number | null
    votepoints?: number | null
    donationpoints?: number | null
    maplePoints?: number | null
    nxPrepaid?: number | null
    clientstate?: number | null
    vipgrade?: number | null
    vippoints?: number | null
    freevippointdate?: Date | string | null
    vipexpireddate?: Date | string | null
    nblockreason?: number | null
    banExpireDate?: Date | string | null
    banReason?: string | null
    offensemanager?: number | null
    gender?: number | null
    msg2?: number | null
    purchaseexp?: number | null
    pblockreason?: number | null
    chatunblockdate?: bigint | number | null
    hascensorednxloginid?: boolean | null
    gradecode?: number | null
    censorednxloginid?: string | null
    characterslots?: number
    creationdate?: Date | string | null
    bosspoints?: number
    lastvote1?: number
    lastvote2?: number
    claimvote1?: number
    claimvote2?: number
    dojop?: number
    lastvotetime?: Date | string | null
    lastvoteip?: string | null
    discordid?: string | null
  }

  export type usersUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    pic?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    accounttype?: NullableIntFieldUpdateOperationsInput | number | null
    votepoints?: NullableIntFieldUpdateOperationsInput | number | null
    donationpoints?: NullableIntFieldUpdateOperationsInput | number | null
    maplePoints?: NullableIntFieldUpdateOperationsInput | number | null
    nxPrepaid?: NullableIntFieldUpdateOperationsInput | number | null
    clientstate?: NullableIntFieldUpdateOperationsInput | number | null
    vipgrade?: NullableIntFieldUpdateOperationsInput | number | null
    vippoints?: NullableIntFieldUpdateOperationsInput | number | null
    freevippointdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vipexpireddate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nblockreason?: NullableIntFieldUpdateOperationsInput | number | null
    banExpireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    offensemanager?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    msg2?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseexp?: NullableIntFieldUpdateOperationsInput | number | null
    pblockreason?: NullableIntFieldUpdateOperationsInput | number | null
    chatunblockdate?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    hascensorednxloginid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gradecode?: NullableIntFieldUpdateOperationsInput | number | null
    censorednxloginid?: NullableStringFieldUpdateOperationsInput | string | null
    characterslots?: IntFieldUpdateOperationsInput | number
    creationdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bosspoints?: IntFieldUpdateOperationsInput | number
    lastvote1?: IntFieldUpdateOperationsInput | number
    lastvote2?: IntFieldUpdateOperationsInput | number
    claimvote1?: IntFieldUpdateOperationsInput | number
    claimvote2?: IntFieldUpdateOperationsInput | number
    dojop?: IntFieldUpdateOperationsInput | number
    lastvotetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastvoteip?: NullableStringFieldUpdateOperationsInput | string | null
    discordid?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type usersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    pic?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    accounttype?: NullableIntFieldUpdateOperationsInput | number | null
    votepoints?: NullableIntFieldUpdateOperationsInput | number | null
    donationpoints?: NullableIntFieldUpdateOperationsInput | number | null
    maplePoints?: NullableIntFieldUpdateOperationsInput | number | null
    nxPrepaid?: NullableIntFieldUpdateOperationsInput | number | null
    clientstate?: NullableIntFieldUpdateOperationsInput | number | null
    vipgrade?: NullableIntFieldUpdateOperationsInput | number | null
    vippoints?: NullableIntFieldUpdateOperationsInput | number | null
    freevippointdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vipexpireddate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nblockreason?: NullableIntFieldUpdateOperationsInput | number | null
    banExpireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    offensemanager?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    msg2?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseexp?: NullableIntFieldUpdateOperationsInput | number | null
    pblockreason?: NullableIntFieldUpdateOperationsInput | number | null
    chatunblockdate?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    hascensorednxloginid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gradecode?: NullableIntFieldUpdateOperationsInput | number | null
    censorednxloginid?: NullableStringFieldUpdateOperationsInput | string | null
    characterslots?: IntFieldUpdateOperationsInput | number
    creationdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bosspoints?: IntFieldUpdateOperationsInput | number
    lastvote1?: IntFieldUpdateOperationsInput | number
    lastvote2?: IntFieldUpdateOperationsInput | number
    claimvote1?: IntFieldUpdateOperationsInput | number
    claimvote2?: IntFieldUpdateOperationsInput | number
    dojop?: IntFieldUpdateOperationsInput | number
    lastvotetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastvoteip?: NullableStringFieldUpdateOperationsInput | string | null
    discordid?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type accountsCountOrderByAggregateInput = {
    id?: SortOrder
    worldid?: SortOrder
    userid?: SortOrder
    trunkid?: SortOrder
    nxCredit?: SortOrder
    monstercollectionid?: SortOrder
    employeetrunkid?: SortOrder
  }

  export type accountsAvgOrderByAggregateInput = {
    id?: SortOrder
    worldid?: SortOrder
    userid?: SortOrder
    trunkid?: SortOrder
    nxCredit?: SortOrder
    monstercollectionid?: SortOrder
    employeetrunkid?: SortOrder
  }

  export type accountsMaxOrderByAggregateInput = {
    id?: SortOrder
    worldid?: SortOrder
    userid?: SortOrder
    trunkid?: SortOrder
    nxCredit?: SortOrder
    monstercollectionid?: SortOrder
    employeetrunkid?: SortOrder
  }

  export type accountsMinOrderByAggregateInput = {
    id?: SortOrder
    worldid?: SortOrder
    userid?: SortOrder
    trunkid?: SortOrder
    nxCredit?: SortOrder
    monstercollectionid?: SortOrder
    employeetrunkid?: SortOrder
  }

  export type accountsSumOrderByAggregateInput = {
    id?: SortOrder
    worldid?: SortOrder
    userid?: SortOrder
    trunkid?: SortOrder
    nxCredit?: SortOrder
    monstercollectionid?: SortOrder
    employeetrunkid?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type alliance_gradenamesCountOrderByAggregateInput = {
    id?: SortOrder
    gradename?: SortOrder
    allianceid?: SortOrder
  }

  export type alliance_gradenamesAvgOrderByAggregateInput = {
    id?: SortOrder
    allianceid?: SortOrder
  }

  export type alliance_gradenamesMaxOrderByAggregateInput = {
    id?: SortOrder
    gradename?: SortOrder
    allianceid?: SortOrder
  }

  export type alliance_gradenamesMinOrderByAggregateInput = {
    id?: SortOrder
    gradename?: SortOrder
    allianceid?: SortOrder
  }

  export type alliance_gradenamesSumOrderByAggregateInput = {
    id?: SortOrder
    allianceid?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type alliancesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    maxmembernum?: SortOrder
    notice?: SortOrder
  }

  export type alliancesAvgOrderByAggregateInput = {
    id?: SortOrder
    maxmembernum?: SortOrder
  }

  export type alliancesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    maxmembernum?: SortOrder
    notice?: SortOrder
  }

  export type alliancesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    maxmembernum?: SortOrder
    notice?: SortOrder
  }

  export type alliancesSumOrderByAggregateInput = {
    id?: SortOrder
    maxmembernum?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type auction_historiesCountOrderByAggregateInput = {
    id?: SortOrder
    itemid?: SortOrder
    bargain?: SortOrder
    refund?: SortOrder
    ownerid?: SortOrder
    ownername?: SortOrder
    historytype?: SortOrder
    mesos?: SortOrder
    buyer?: SortOrder
    bid?: SortOrder
    expiredtime?: SortOrder
    buytime?: SortOrder
    starttime?: SortOrder
  }

  export type auction_historiesAvgOrderByAggregateInput = {
    id?: SortOrder
    itemid?: SortOrder
    ownerid?: SortOrder
    historytype?: SortOrder
    mesos?: SortOrder
    buyer?: SortOrder
    bid?: SortOrder
  }

  export type auction_historiesMaxOrderByAggregateInput = {
    id?: SortOrder
    itemid?: SortOrder
    bargain?: SortOrder
    refund?: SortOrder
    ownerid?: SortOrder
    ownername?: SortOrder
    historytype?: SortOrder
    mesos?: SortOrder
    buyer?: SortOrder
    bid?: SortOrder
    expiredtime?: SortOrder
    buytime?: SortOrder
    starttime?: SortOrder
  }

  export type auction_historiesMinOrderByAggregateInput = {
    id?: SortOrder
    itemid?: SortOrder
    bargain?: SortOrder
    refund?: SortOrder
    ownerid?: SortOrder
    ownername?: SortOrder
    historytype?: SortOrder
    mesos?: SortOrder
    buyer?: SortOrder
    bid?: SortOrder
    expiredtime?: SortOrder
    buytime?: SortOrder
    starttime?: SortOrder
  }

  export type auction_historiesSumOrderByAggregateInput = {
    id?: SortOrder
    itemid?: SortOrder
    ownerid?: SortOrder
    historytype?: SortOrder
    mesos?: SortOrder
    buyer?: SortOrder
    bid?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type auction_itemsCountOrderByAggregateInput = {
    id?: SortOrder
    itemid?: SortOrder
    bargain?: SortOrder
    ownerid?: SortOrder
    ownername?: SortOrder
    mesos?: SortOrder
    buyer?: SortOrder
    bid?: SortOrder
    expiredtime?: SortOrder
    starttime?: SortOrder
  }

  export type auction_itemsAvgOrderByAggregateInput = {
    id?: SortOrder
    itemid?: SortOrder
    ownerid?: SortOrder
    mesos?: SortOrder
    buyer?: SortOrder
    bid?: SortOrder
  }

  export type auction_itemsMaxOrderByAggregateInput = {
    id?: SortOrder
    itemid?: SortOrder
    bargain?: SortOrder
    ownerid?: SortOrder
    ownername?: SortOrder
    mesos?: SortOrder
    buyer?: SortOrder
    bid?: SortOrder
    expiredtime?: SortOrder
    starttime?: SortOrder
  }

  export type auction_itemsMinOrderByAggregateInput = {
    id?: SortOrder
    itemid?: SortOrder
    bargain?: SortOrder
    ownerid?: SortOrder
    ownername?: SortOrder
    mesos?: SortOrder
    buyer?: SortOrder
    bid?: SortOrder
    expiredtime?: SortOrder
    starttime?: SortOrder
  }

  export type auction_itemsSumOrderByAggregateInput = {
    id?: SortOrder
    itemid?: SortOrder
    ownerid?: SortOrder
    mesos?: SortOrder
    buyer?: SortOrder
    bid?: SortOrder
  }

  export type avatardataCountOrderByAggregateInput = {
    id?: SortOrder
    characterstat?: SortOrder
    avatarlook?: SortOrder
    zeroavatarlook?: SortOrder
  }

  export type avatardataAvgOrderByAggregateInput = {
    id?: SortOrder
    characterstat?: SortOrder
    avatarlook?: SortOrder
    zeroavatarlook?: SortOrder
  }

  export type avatardataMaxOrderByAggregateInput = {
    id?: SortOrder
    characterstat?: SortOrder
    avatarlook?: SortOrder
    zeroavatarlook?: SortOrder
  }

  export type avatardataMinOrderByAggregateInput = {
    id?: SortOrder
    characterstat?: SortOrder
    avatarlook?: SortOrder
    zeroavatarlook?: SortOrder
  }

  export type avatardataSumOrderByAggregateInput = {
    id?: SortOrder
    characterstat?: SortOrder
    avatarlook?: SortOrder
    zeroavatarlook?: SortOrder
  }

  export type avatarlookCountOrderByAggregateInput = {
    id?: SortOrder
    gender?: SortOrder
    skin?: SortOrder
    face?: SortOrder
    hair?: SortOrder
    weaponstickerid?: SortOrder
    weaponid?: SortOrder
    subweaponid?: SortOrder
    job?: SortOrder
    drawelfear?: SortOrder
    demonslayerdeffaceacc?: SortOrder
    xenondeffaceacc?: SortOrder
    beasttamerdeffaceacc?: SortOrder
    iszerobetalook?: SortOrder
    mixedhaircolor?: SortOrder
    mixhairpercent?: SortOrder
    ears?: SortOrder
    tail?: SortOrder
  }

  export type avatarlookAvgOrderByAggregateInput = {
    id?: SortOrder
    gender?: SortOrder
    skin?: SortOrder
    face?: SortOrder
    hair?: SortOrder
    weaponstickerid?: SortOrder
    weaponid?: SortOrder
    subweaponid?: SortOrder
    job?: SortOrder
    demonslayerdeffaceacc?: SortOrder
    xenondeffaceacc?: SortOrder
    beasttamerdeffaceacc?: SortOrder
    mixedhaircolor?: SortOrder
    mixhairpercent?: SortOrder
    ears?: SortOrder
    tail?: SortOrder
  }

  export type avatarlookMaxOrderByAggregateInput = {
    id?: SortOrder
    gender?: SortOrder
    skin?: SortOrder
    face?: SortOrder
    hair?: SortOrder
    weaponstickerid?: SortOrder
    weaponid?: SortOrder
    subweaponid?: SortOrder
    job?: SortOrder
    drawelfear?: SortOrder
    demonslayerdeffaceacc?: SortOrder
    xenondeffaceacc?: SortOrder
    beasttamerdeffaceacc?: SortOrder
    iszerobetalook?: SortOrder
    mixedhaircolor?: SortOrder
    mixhairpercent?: SortOrder
    ears?: SortOrder
    tail?: SortOrder
  }

  export type avatarlookMinOrderByAggregateInput = {
    id?: SortOrder
    gender?: SortOrder
    skin?: SortOrder
    face?: SortOrder
    hair?: SortOrder
    weaponstickerid?: SortOrder
    weaponid?: SortOrder
    subweaponid?: SortOrder
    job?: SortOrder
    drawelfear?: SortOrder
    demonslayerdeffaceacc?: SortOrder
    xenondeffaceacc?: SortOrder
    beasttamerdeffaceacc?: SortOrder
    iszerobetalook?: SortOrder
    mixedhaircolor?: SortOrder
    mixhairpercent?: SortOrder
    ears?: SortOrder
    tail?: SortOrder
  }

  export type avatarlookSumOrderByAggregateInput = {
    id?: SortOrder
    gender?: SortOrder
    skin?: SortOrder
    face?: SortOrder
    hair?: SortOrder
    weaponstickerid?: SortOrder
    weaponid?: SortOrder
    subweaponid?: SortOrder
    job?: SortOrder
    demonslayerdeffaceacc?: SortOrder
    xenondeffaceacc?: SortOrder
    beasttamerdeffaceacc?: SortOrder
    mixedhaircolor?: SortOrder
    mixhairpercent?: SortOrder
    ears?: SortOrder
    tail?: SortOrder
  }

  export type bbs_recordsCountOrderByAggregateInput = {
    id?: SortOrder
    idforbbs?: SortOrder
    creatorid?: SortOrder
    subject?: SortOrder
    msg?: SortOrder
    creationdate?: SortOrder
    icon?: SortOrder
    guildid?: SortOrder
  }

  export type bbs_recordsAvgOrderByAggregateInput = {
    id?: SortOrder
    idforbbs?: SortOrder
    creatorid?: SortOrder
    icon?: SortOrder
    guildid?: SortOrder
  }

  export type bbs_recordsMaxOrderByAggregateInput = {
    id?: SortOrder
    idforbbs?: SortOrder
    creatorid?: SortOrder
    subject?: SortOrder
    msg?: SortOrder
    creationdate?: SortOrder
    icon?: SortOrder
    guildid?: SortOrder
  }

  export type bbs_recordsMinOrderByAggregateInput = {
    id?: SortOrder
    idforbbs?: SortOrder
    creatorid?: SortOrder
    subject?: SortOrder
    msg?: SortOrder
    creationdate?: SortOrder
    icon?: SortOrder
    guildid?: SortOrder
  }

  export type bbs_recordsSumOrderByAggregateInput = {
    id?: SortOrder
    idforbbs?: SortOrder
    creatorid?: SortOrder
    icon?: SortOrder
    guildid?: SortOrder
  }

  export type bbs_repliesCountOrderByAggregateInput = {
    id?: SortOrder
    idforreply?: SortOrder
    creatorid?: SortOrder
    creationdate?: SortOrder
    msg?: SortOrder
    recordid?: SortOrder
  }

  export type bbs_repliesAvgOrderByAggregateInput = {
    id?: SortOrder
    idforreply?: SortOrder
    creatorid?: SortOrder
    recordid?: SortOrder
  }

  export type bbs_repliesMaxOrderByAggregateInput = {
    id?: SortOrder
    idforreply?: SortOrder
    creatorid?: SortOrder
    creationdate?: SortOrder
    msg?: SortOrder
    recordid?: SortOrder
  }

  export type bbs_repliesMinOrderByAggregateInput = {
    id?: SortOrder
    idforreply?: SortOrder
    creatorid?: SortOrder
    creationdate?: SortOrder
    msg?: SortOrder
    recordid?: SortOrder
  }

  export type bbs_repliesSumOrderByAggregateInput = {
    id?: SortOrder
    idforreply?: SortOrder
    creatorid?: SortOrder
    recordid?: SortOrder
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type beautydataCountOrderByAggregateInput = {
    id?: SortOrder
    charID?: SortOrder
    hairSize?: SortOrder
    faceSize?: SortOrder
    hairString?: SortOrder
    faceString?: SortOrder
  }

  export type beautydataAvgOrderByAggregateInput = {
    id?: SortOrder
    charID?: SortOrder
    hairSize?: SortOrder
    faceSize?: SortOrder
  }

  export type beautydataMaxOrderByAggregateInput = {
    id?: SortOrder
    charID?: SortOrder
    hairSize?: SortOrder
    faceSize?: SortOrder
    hairString?: SortOrder
    faceString?: SortOrder
  }

  export type beautydataMinOrderByAggregateInput = {
    id?: SortOrder
    charID?: SortOrder
    hairSize?: SortOrder
    faceSize?: SortOrder
    hairString?: SortOrder
    faceString?: SortOrder
  }

  export type beautydataSumOrderByAggregateInput = {
    id?: SortOrder
    charID?: SortOrder
    hairSize?: SortOrder
    faceSize?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type bosslogCountOrderByAggregateInput = {
    id?: SortOrder
    accountid?: SortOrder
    bossid?: SortOrder
    lastattempt?: SortOrder
    pqentry?: SortOrder
  }

  export type bosslogAvgOrderByAggregateInput = {
    id?: SortOrder
    accountid?: SortOrder
    pqentry?: SortOrder
  }

  export type bosslogMaxOrderByAggregateInput = {
    id?: SortOrder
    accountid?: SortOrder
    bossid?: SortOrder
    lastattempt?: SortOrder
    pqentry?: SortOrder
  }

  export type bosslogMinOrderByAggregateInput = {
    id?: SortOrder
    accountid?: SortOrder
    bossid?: SortOrder
    lastattempt?: SortOrder
    pqentry?: SortOrder
  }

  export type bosslogSumOrderByAggregateInput = {
    id?: SortOrder
    accountid?: SortOrder
    pqentry?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type cashiteminfosCountOrderByAggregateInput = {
    id?: SortOrder
    accountid?: SortOrder
    characterid?: SortOrder
    commodityid?: SortOrder
    buycharacterid?: SortOrder
    paybackrate?: SortOrder
    discount?: SortOrder
    orderno?: SortOrder
    productno?: SortOrder
    refundable?: SortOrder
    sourceflag?: SortOrder
    storebank?: SortOrder
    itemid?: SortOrder
    trunkid?: SortOrder
    position?: SortOrder
  }

  export type cashiteminfosAvgOrderByAggregateInput = {
    id?: SortOrder
    accountid?: SortOrder
    characterid?: SortOrder
    commodityid?: SortOrder
    paybackrate?: SortOrder
    discount?: SortOrder
    orderno?: SortOrder
    productno?: SortOrder
    sourceflag?: SortOrder
    itemid?: SortOrder
    trunkid?: SortOrder
    position?: SortOrder
  }

  export type cashiteminfosMaxOrderByAggregateInput = {
    id?: SortOrder
    accountid?: SortOrder
    characterid?: SortOrder
    commodityid?: SortOrder
    buycharacterid?: SortOrder
    paybackrate?: SortOrder
    discount?: SortOrder
    orderno?: SortOrder
    productno?: SortOrder
    refundable?: SortOrder
    sourceflag?: SortOrder
    storebank?: SortOrder
    itemid?: SortOrder
    trunkid?: SortOrder
    position?: SortOrder
  }

  export type cashiteminfosMinOrderByAggregateInput = {
    id?: SortOrder
    accountid?: SortOrder
    characterid?: SortOrder
    commodityid?: SortOrder
    buycharacterid?: SortOrder
    paybackrate?: SortOrder
    discount?: SortOrder
    orderno?: SortOrder
    productno?: SortOrder
    refundable?: SortOrder
    sourceflag?: SortOrder
    storebank?: SortOrder
    itemid?: SortOrder
    trunkid?: SortOrder
    position?: SortOrder
  }

  export type cashiteminfosSumOrderByAggregateInput = {
    id?: SortOrder
    accountid?: SortOrder
    characterid?: SortOrder
    commodityid?: SortOrder
    paybackrate?: SortOrder
    discount?: SortOrder
    orderno?: SortOrder
    productno?: SortOrder
    sourceflag?: SortOrder
    itemid?: SortOrder
    trunkid?: SortOrder
    position?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type characterpotentialsCountOrderByAggregateInput = {
    id?: SortOrder
    potkey?: SortOrder
    skillid?: SortOrder
    slv?: SortOrder
    grade?: SortOrder
    charid?: SortOrder
  }

  export type characterpotentialsAvgOrderByAggregateInput = {
    id?: SortOrder
    potkey?: SortOrder
    skillid?: SortOrder
    slv?: SortOrder
    grade?: SortOrder
    charid?: SortOrder
  }

  export type characterpotentialsMaxOrderByAggregateInput = {
    id?: SortOrder
    potkey?: SortOrder
    skillid?: SortOrder
    slv?: SortOrder
    grade?: SortOrder
    charid?: SortOrder
  }

  export type characterpotentialsMinOrderByAggregateInput = {
    id?: SortOrder
    potkey?: SortOrder
    skillid?: SortOrder
    slv?: SortOrder
    grade?: SortOrder
    charid?: SortOrder
  }

  export type characterpotentialsSumOrderByAggregateInput = {
    id?: SortOrder
    potkey?: SortOrder
    skillid?: SortOrder
    slv?: SortOrder
    grade?: SortOrder
    charid?: SortOrder
  }

  export type charactersCountOrderByAggregateInput = {
    id?: SortOrder
    accid?: SortOrder
    orderid?: SortOrder
    avatardata?: SortOrder
    equippedinventory?: SortOrder
    equipinventory?: SortOrder
    consumeinventory?: SortOrder
    etcinventory?: SortOrder
    installinventory?: SortOrder
    cashinventory?: SortOrder
    funckeymap_id?: SortOrder
    fieldid?: SortOrder
    questmanager?: SortOrder
    guild?: SortOrder
    rewardPoints?: SortOrder
    monsterbook?: SortOrder
    party?: SortOrder
    medalid?: SortOrder
    monsterparkcount?: SortOrder
    previousFieldID?: SortOrder
    onlineDay?: SortOrder
    onlineTime?: SortOrder
    quickslotKeys?: SortOrder
  }

  export type charactersAvgOrderByAggregateInput = {
    id?: SortOrder
    accid?: SortOrder
    orderid?: SortOrder
    avatardata?: SortOrder
    equippedinventory?: SortOrder
    equipinventory?: SortOrder
    consumeinventory?: SortOrder
    etcinventory?: SortOrder
    installinventory?: SortOrder
    cashinventory?: SortOrder
    funckeymap_id?: SortOrder
    fieldid?: SortOrder
    questmanager?: SortOrder
    guild?: SortOrder
    rewardPoints?: SortOrder
    monsterbook?: SortOrder
    party?: SortOrder
    medalid?: SortOrder
    monsterparkcount?: SortOrder
    previousFieldID?: SortOrder
    onlineDay?: SortOrder
    onlineTime?: SortOrder
  }

  export type charactersMaxOrderByAggregateInput = {
    id?: SortOrder
    accid?: SortOrder
    orderid?: SortOrder
    avatardata?: SortOrder
    equippedinventory?: SortOrder
    equipinventory?: SortOrder
    consumeinventory?: SortOrder
    etcinventory?: SortOrder
    installinventory?: SortOrder
    cashinventory?: SortOrder
    funckeymap_id?: SortOrder
    fieldid?: SortOrder
    questmanager?: SortOrder
    guild?: SortOrder
    rewardPoints?: SortOrder
    monsterbook?: SortOrder
    party?: SortOrder
    medalid?: SortOrder
    monsterparkcount?: SortOrder
    previousFieldID?: SortOrder
    onlineDay?: SortOrder
    onlineTime?: SortOrder
    quickslotKeys?: SortOrder
  }

  export type charactersMinOrderByAggregateInput = {
    id?: SortOrder
    accid?: SortOrder
    orderid?: SortOrder
    avatardata?: SortOrder
    equippedinventory?: SortOrder
    equipinventory?: SortOrder
    consumeinventory?: SortOrder
    etcinventory?: SortOrder
    installinventory?: SortOrder
    cashinventory?: SortOrder
    funckeymap_id?: SortOrder
    fieldid?: SortOrder
    questmanager?: SortOrder
    guild?: SortOrder
    rewardPoints?: SortOrder
    monsterbook?: SortOrder
    party?: SortOrder
    medalid?: SortOrder
    monsterparkcount?: SortOrder
    previousFieldID?: SortOrder
    onlineDay?: SortOrder
    onlineTime?: SortOrder
    quickslotKeys?: SortOrder
  }

  export type charactersSumOrderByAggregateInput = {
    id?: SortOrder
    accid?: SortOrder
    orderid?: SortOrder
    avatardata?: SortOrder
    equippedinventory?: SortOrder
    equipinventory?: SortOrder
    consumeinventory?: SortOrder
    etcinventory?: SortOrder
    installinventory?: SortOrder
    cashinventory?: SortOrder
    funckeymap_id?: SortOrder
    fieldid?: SortOrder
    questmanager?: SortOrder
    guild?: SortOrder
    rewardPoints?: SortOrder
    monsterbook?: SortOrder
    party?: SortOrder
    medalid?: SortOrder
    monsterparkcount?: SortOrder
    previousFieldID?: SortOrder
    onlineDay?: SortOrder
    onlineTime?: SortOrder
  }

  export type characterstatsCountOrderByAggregateInput = {
    id?: SortOrder
    characterid?: SortOrder
    characteridforlog?: SortOrder
    worldidforlog?: SortOrder
    name?: SortOrder
    gender?: SortOrder
    skin?: SortOrder
    face?: SortOrder
    hair?: SortOrder
    mixbasehaircolor?: SortOrder
    mixaddhaircolor?: SortOrder
    mixhairbaseprob?: SortOrder
    level?: SortOrder
    job?: SortOrder
    str?: SortOrder
    dex?: SortOrder
    inte?: SortOrder
    luk?: SortOrder
    hp?: SortOrder
    maxhp?: SortOrder
    mp?: SortOrder
    maxmp?: SortOrder
    ap?: SortOrder
    sp?: SortOrder
    exp?: SortOrder
    pop?: SortOrder
    money?: SortOrder
    wp?: SortOrder
    extendsp?: SortOrder
    posmap?: SortOrder
    portal?: SortOrder
    subjob?: SortOrder
    deffaceacc?: SortOrder
    fatigue?: SortOrder
    lastfatigueupdatetime?: SortOrder
    charismaexp?: SortOrder
    insightexp?: SortOrder
    willexp?: SortOrder
    craftexp?: SortOrder
    senseexp?: SortOrder
    charmexp?: SortOrder
    noncombatstatdaylimit?: SortOrder
    mcpoint?: SortOrder
    pvpexp?: SortOrder
    pvpgrade?: SortOrder
    pvppoint?: SortOrder
    pvpmodelevel?: SortOrder
    pvpmodetype?: SortOrder
    eventpoint?: SortOrder
    albaactivityid?: SortOrder
    albastarttime?: SortOrder
    albaduration?: SortOrder
    albaspecialreward?: SortOrder
    burning?: SortOrder
    charactercard?: SortOrder
    accountlastlogout?: SortOrder
    lastlogout?: SortOrder
    gachexp?: SortOrder
    honorexp?: SortOrder
    nextavailablefametime?: SortOrder
    node_shards?: SortOrder
    maxfriends?: SortOrder
  }

  export type characterstatsAvgOrderByAggregateInput = {
    id?: SortOrder
    characterid?: SortOrder
    characteridforlog?: SortOrder
    worldidforlog?: SortOrder
    gender?: SortOrder
    skin?: SortOrder
    face?: SortOrder
    hair?: SortOrder
    mixbasehaircolor?: SortOrder
    mixaddhaircolor?: SortOrder
    mixhairbaseprob?: SortOrder
    level?: SortOrder
    job?: SortOrder
    str?: SortOrder
    dex?: SortOrder
    inte?: SortOrder
    luk?: SortOrder
    hp?: SortOrder
    maxhp?: SortOrder
    mp?: SortOrder
    maxmp?: SortOrder
    ap?: SortOrder
    sp?: SortOrder
    pop?: SortOrder
    wp?: SortOrder
    extendsp?: SortOrder
    portal?: SortOrder
    subjob?: SortOrder
    deffaceacc?: SortOrder
    fatigue?: SortOrder
    lastfatigueupdatetime?: SortOrder
    charismaexp?: SortOrder
    insightexp?: SortOrder
    willexp?: SortOrder
    craftexp?: SortOrder
    senseexp?: SortOrder
    charmexp?: SortOrder
    noncombatstatdaylimit?: SortOrder
    mcpoint?: SortOrder
    pvpexp?: SortOrder
    pvpgrade?: SortOrder
    pvppoint?: SortOrder
    pvpmodelevel?: SortOrder
    pvpmodetype?: SortOrder
    eventpoint?: SortOrder
    albaactivityid?: SortOrder
    albaduration?: SortOrder
    albaspecialreward?: SortOrder
    charactercard?: SortOrder
    accountlastlogout?: SortOrder
    gachexp?: SortOrder
    honorexp?: SortOrder
    node_shards?: SortOrder
    maxfriends?: SortOrder
  }

  export type characterstatsMaxOrderByAggregateInput = {
    id?: SortOrder
    characterid?: SortOrder
    characteridforlog?: SortOrder
    worldidforlog?: SortOrder
    name?: SortOrder
    gender?: SortOrder
    skin?: SortOrder
    face?: SortOrder
    hair?: SortOrder
    mixbasehaircolor?: SortOrder
    mixaddhaircolor?: SortOrder
    mixhairbaseprob?: SortOrder
    level?: SortOrder
    job?: SortOrder
    str?: SortOrder
    dex?: SortOrder
    inte?: SortOrder
    luk?: SortOrder
    hp?: SortOrder
    maxhp?: SortOrder
    mp?: SortOrder
    maxmp?: SortOrder
    ap?: SortOrder
    sp?: SortOrder
    exp?: SortOrder
    pop?: SortOrder
    money?: SortOrder
    wp?: SortOrder
    extendsp?: SortOrder
    posmap?: SortOrder
    portal?: SortOrder
    subjob?: SortOrder
    deffaceacc?: SortOrder
    fatigue?: SortOrder
    lastfatigueupdatetime?: SortOrder
    charismaexp?: SortOrder
    insightexp?: SortOrder
    willexp?: SortOrder
    craftexp?: SortOrder
    senseexp?: SortOrder
    charmexp?: SortOrder
    noncombatstatdaylimit?: SortOrder
    mcpoint?: SortOrder
    pvpexp?: SortOrder
    pvpgrade?: SortOrder
    pvppoint?: SortOrder
    pvpmodelevel?: SortOrder
    pvpmodetype?: SortOrder
    eventpoint?: SortOrder
    albaactivityid?: SortOrder
    albastarttime?: SortOrder
    albaduration?: SortOrder
    albaspecialreward?: SortOrder
    burning?: SortOrder
    charactercard?: SortOrder
    accountlastlogout?: SortOrder
    lastlogout?: SortOrder
    gachexp?: SortOrder
    honorexp?: SortOrder
    nextavailablefametime?: SortOrder
    node_shards?: SortOrder
    maxfriends?: SortOrder
  }

  export type characterstatsMinOrderByAggregateInput = {
    id?: SortOrder
    characterid?: SortOrder
    characteridforlog?: SortOrder
    worldidforlog?: SortOrder
    name?: SortOrder
    gender?: SortOrder
    skin?: SortOrder
    face?: SortOrder
    hair?: SortOrder
    mixbasehaircolor?: SortOrder
    mixaddhaircolor?: SortOrder
    mixhairbaseprob?: SortOrder
    level?: SortOrder
    job?: SortOrder
    str?: SortOrder
    dex?: SortOrder
    inte?: SortOrder
    luk?: SortOrder
    hp?: SortOrder
    maxhp?: SortOrder
    mp?: SortOrder
    maxmp?: SortOrder
    ap?: SortOrder
    sp?: SortOrder
    exp?: SortOrder
    pop?: SortOrder
    money?: SortOrder
    wp?: SortOrder
    extendsp?: SortOrder
    posmap?: SortOrder
    portal?: SortOrder
    subjob?: SortOrder
    deffaceacc?: SortOrder
    fatigue?: SortOrder
    lastfatigueupdatetime?: SortOrder
    charismaexp?: SortOrder
    insightexp?: SortOrder
    willexp?: SortOrder
    craftexp?: SortOrder
    senseexp?: SortOrder
    charmexp?: SortOrder
    noncombatstatdaylimit?: SortOrder
    mcpoint?: SortOrder
    pvpexp?: SortOrder
    pvpgrade?: SortOrder
    pvppoint?: SortOrder
    pvpmodelevel?: SortOrder
    pvpmodetype?: SortOrder
    eventpoint?: SortOrder
    albaactivityid?: SortOrder
    albastarttime?: SortOrder
    albaduration?: SortOrder
    albaspecialreward?: SortOrder
    burning?: SortOrder
    charactercard?: SortOrder
    accountlastlogout?: SortOrder
    lastlogout?: SortOrder
    gachexp?: SortOrder
    honorexp?: SortOrder
    nextavailablefametime?: SortOrder
    node_shards?: SortOrder
    maxfriends?: SortOrder
  }

  export type characterstatsSumOrderByAggregateInput = {
    id?: SortOrder
    characterid?: SortOrder
    characteridforlog?: SortOrder
    worldidforlog?: SortOrder
    gender?: SortOrder
    skin?: SortOrder
    face?: SortOrder
    hair?: SortOrder
    mixbasehaircolor?: SortOrder
    mixaddhaircolor?: SortOrder
    mixhairbaseprob?: SortOrder
    level?: SortOrder
    job?: SortOrder
    str?: SortOrder
    dex?: SortOrder
    inte?: SortOrder
    luk?: SortOrder
    hp?: SortOrder
    maxhp?: SortOrder
    mp?: SortOrder
    maxmp?: SortOrder
    ap?: SortOrder
    sp?: SortOrder
    pop?: SortOrder
    wp?: SortOrder
    extendsp?: SortOrder
    portal?: SortOrder
    subjob?: SortOrder
    deffaceacc?: SortOrder
    fatigue?: SortOrder
    lastfatigueupdatetime?: SortOrder
    charismaexp?: SortOrder
    insightexp?: SortOrder
    willexp?: SortOrder
    craftexp?: SortOrder
    senseexp?: SortOrder
    charmexp?: SortOrder
    noncombatstatdaylimit?: SortOrder
    mcpoint?: SortOrder
    pvpexp?: SortOrder
    pvpgrade?: SortOrder
    pvppoint?: SortOrder
    pvpmodelevel?: SortOrder
    pvpmodetype?: SortOrder
    eventpoint?: SortOrder
    albaactivityid?: SortOrder
    albaduration?: SortOrder
    albaspecialreward?: SortOrder
    charactercard?: SortOrder
    accountlastlogout?: SortOrder
    gachexp?: SortOrder
    honorexp?: SortOrder
    node_shards?: SortOrder
    maxfriends?: SortOrder
  }

  export type chosenskillsCountOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
    skillid?: SortOrder
    position?: SortOrder
  }

  export type chosenskillsAvgOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
    skillid?: SortOrder
    position?: SortOrder
  }

  export type chosenskillsMaxOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
    skillid?: SortOrder
    position?: SortOrder
  }

  export type chosenskillsMinOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
    skillid?: SortOrder
    position?: SortOrder
  }

  export type chosenskillsSumOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
    skillid?: SortOrder
    position?: SortOrder
  }

  export type cms_votesCountOrderByAggregateInput = {
    id?: SortOrder
    accountid?: SortOrder
    ip?: SortOrder
    time?: SortOrder
    vp?: SortOrder
    collected?: SortOrder
  }

  export type cms_votesAvgOrderByAggregateInput = {
    id?: SortOrder
    accountid?: SortOrder
    vp?: SortOrder
    collected?: SortOrder
  }

  export type cms_votesMaxOrderByAggregateInput = {
    id?: SortOrder
    accountid?: SortOrder
    ip?: SortOrder
    time?: SortOrder
    vp?: SortOrder
    collected?: SortOrder
  }

  export type cms_votesMinOrderByAggregateInput = {
    id?: SortOrder
    accountid?: SortOrder
    ip?: SortOrder
    time?: SortOrder
    vp?: SortOrder
    collected?: SortOrder
  }

  export type cms_votesSumOrderByAggregateInput = {
    id?: SortOrder
    accountid?: SortOrder
    vp?: SortOrder
    collected?: SortOrder
  }

  export type cooldownsCountOrderByAggregateInput = {
    id?: SortOrder
    player_name?: SortOrder
    cooldown_type?: SortOrder
    expiry_time?: SortOrder
  }

  export type cooldownsAvgOrderByAggregateInput = {
    id?: SortOrder
    cooldown_type?: SortOrder
  }

  export type cooldownsMaxOrderByAggregateInput = {
    id?: SortOrder
    player_name?: SortOrder
    cooldown_type?: SortOrder
    expiry_time?: SortOrder
  }

  export type cooldownsMinOrderByAggregateInput = {
    id?: SortOrder
    player_name?: SortOrder
    cooldown_type?: SortOrder
    expiry_time?: SortOrder
  }

  export type cooldownsSumOrderByAggregateInput = {
    id?: SortOrder
    cooldown_type?: SortOrder
  }

  export type coresCountOrderByAggregateInput = {
    id?: SortOrder
    pos?: SortOrder
    charid?: SortOrder
    slottype?: SortOrder
    coreid?: SortOrder
    leftCount?: SortOrder
  }

  export type coresAvgOrderByAggregateInput = {
    id?: SortOrder
    pos?: SortOrder
    charid?: SortOrder
    slottype?: SortOrder
    coreid?: SortOrder
    leftCount?: SortOrder
  }

  export type coresMaxOrderByAggregateInput = {
    id?: SortOrder
    pos?: SortOrder
    charid?: SortOrder
    slottype?: SortOrder
    coreid?: SortOrder
    leftCount?: SortOrder
  }

  export type coresMinOrderByAggregateInput = {
    id?: SortOrder
    pos?: SortOrder
    charid?: SortOrder
    slottype?: SortOrder
    coreid?: SortOrder
    leftCount?: SortOrder
  }

  export type coresSumOrderByAggregateInput = {
    id?: SortOrder
    pos?: SortOrder
    charid?: SortOrder
    slottype?: SortOrder
    coreid?: SortOrder
    leftCount?: SortOrder
  }

  export type cs_categoriesCountOrderByAggregateInput = {
    id?: SortOrder
    idx?: SortOrder
    name?: SortOrder
    flag?: SortOrder
    parentIdx?: SortOrder
    stock?: SortOrder
  }

  export type cs_categoriesAvgOrderByAggregateInput = {
    id?: SortOrder
    idx?: SortOrder
    flag?: SortOrder
    parentIdx?: SortOrder
    stock?: SortOrder
  }

  export type cs_categoriesMaxOrderByAggregateInput = {
    id?: SortOrder
    idx?: SortOrder
    name?: SortOrder
    flag?: SortOrder
    parentIdx?: SortOrder
    stock?: SortOrder
  }

  export type cs_categoriesMinOrderByAggregateInput = {
    id?: SortOrder
    idx?: SortOrder
    name?: SortOrder
    flag?: SortOrder
    parentIdx?: SortOrder
    stock?: SortOrder
  }

  export type cs_categoriesSumOrderByAggregateInput = {
    id?: SortOrder
    idx?: SortOrder
    flag?: SortOrder
    parentIdx?: SortOrder
    stock?: SortOrder
  }

  export type cs_itemsCountOrderByAggregateInput = {
    id?: SortOrder
    itemID?: SortOrder
    stock?: SortOrder
    shopItemFlag?: SortOrder
    idk1?: SortOrder
    idk2?: SortOrder
    oldPrice?: SortOrder
    newPrice?: SortOrder
    idkTime1?: SortOrder
    saleFromFT?: SortOrder
    idkTime3?: SortOrder
    saleToFT?: SortOrder
    idk3?: SortOrder
    bundleQuantity?: SortOrder
    availableDays?: SortOrder
    buyableWithMaplePoints?: SortOrder
    buyableWithCredit?: SortOrder
    buyableWithPrepaid?: SortOrder
    likable?: SortOrder
    meso?: SortOrder
    favoritable?: SortOrder
    gender?: SortOrder
    likes?: SortOrder
    requiredLevel?: SortOrder
    idk10?: SortOrder
    idk11?: SortOrder
    idk13?: SortOrder
    idk14?: SortOrder
    category?: SortOrder
  }

  export type cs_itemsAvgOrderByAggregateInput = {
    id?: SortOrder
    itemID?: SortOrder
    stock?: SortOrder
    shopItemFlag?: SortOrder
    idk1?: SortOrder
    idk2?: SortOrder
    oldPrice?: SortOrder
    newPrice?: SortOrder
    idk3?: SortOrder
    bundleQuantity?: SortOrder
    availableDays?: SortOrder
    buyableWithMaplePoints?: SortOrder
    buyableWithCredit?: SortOrder
    buyableWithPrepaid?: SortOrder
    likable?: SortOrder
    meso?: SortOrder
    favoritable?: SortOrder
    gender?: SortOrder
    likes?: SortOrder
    requiredLevel?: SortOrder
    idk11?: SortOrder
    idk13?: SortOrder
    idk14?: SortOrder
  }

  export type cs_itemsMaxOrderByAggregateInput = {
    id?: SortOrder
    itemID?: SortOrder
    stock?: SortOrder
    shopItemFlag?: SortOrder
    idk1?: SortOrder
    idk2?: SortOrder
    oldPrice?: SortOrder
    newPrice?: SortOrder
    idkTime1?: SortOrder
    saleFromFT?: SortOrder
    idkTime3?: SortOrder
    saleToFT?: SortOrder
    idk3?: SortOrder
    bundleQuantity?: SortOrder
    availableDays?: SortOrder
    buyableWithMaplePoints?: SortOrder
    buyableWithCredit?: SortOrder
    buyableWithPrepaid?: SortOrder
    likable?: SortOrder
    meso?: SortOrder
    favoritable?: SortOrder
    gender?: SortOrder
    likes?: SortOrder
    requiredLevel?: SortOrder
    idk10?: SortOrder
    idk11?: SortOrder
    idk13?: SortOrder
    idk14?: SortOrder
    category?: SortOrder
  }

  export type cs_itemsMinOrderByAggregateInput = {
    id?: SortOrder
    itemID?: SortOrder
    stock?: SortOrder
    shopItemFlag?: SortOrder
    idk1?: SortOrder
    idk2?: SortOrder
    oldPrice?: SortOrder
    newPrice?: SortOrder
    idkTime1?: SortOrder
    saleFromFT?: SortOrder
    idkTime3?: SortOrder
    saleToFT?: SortOrder
    idk3?: SortOrder
    bundleQuantity?: SortOrder
    availableDays?: SortOrder
    buyableWithMaplePoints?: SortOrder
    buyableWithCredit?: SortOrder
    buyableWithPrepaid?: SortOrder
    likable?: SortOrder
    meso?: SortOrder
    favoritable?: SortOrder
    gender?: SortOrder
    likes?: SortOrder
    requiredLevel?: SortOrder
    idk10?: SortOrder
    idk11?: SortOrder
    idk13?: SortOrder
    idk14?: SortOrder
    category?: SortOrder
  }

  export type cs_itemsSumOrderByAggregateInput = {
    id?: SortOrder
    itemID?: SortOrder
    stock?: SortOrder
    shopItemFlag?: SortOrder
    idk1?: SortOrder
    idk2?: SortOrder
    oldPrice?: SortOrder
    newPrice?: SortOrder
    idk3?: SortOrder
    bundleQuantity?: SortOrder
    availableDays?: SortOrder
    buyableWithMaplePoints?: SortOrder
    buyableWithCredit?: SortOrder
    buyableWithPrepaid?: SortOrder
    likable?: SortOrder
    meso?: SortOrder
    favoritable?: SortOrder
    gender?: SortOrder
    likes?: SortOrder
    requiredLevel?: SortOrder
    idk11?: SortOrder
    idk13?: SortOrder
    idk14?: SortOrder
  }

  export type damageskinsCountOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
    damageskinid?: SortOrder
    itemid?: SortOrder
    notsave?: SortOrder
    description?: SortOrder
  }

  export type damageskinsAvgOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
    damageskinid?: SortOrder
    itemid?: SortOrder
  }

  export type damageskinsMaxOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
    damageskinid?: SortOrder
    itemid?: SortOrder
    notsave?: SortOrder
    description?: SortOrder
  }

  export type damageskinsMinOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
    damageskinid?: SortOrder
    itemid?: SortOrder
    notsave?: SortOrder
    description?: SortOrder
  }

  export type damageskinsSumOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
    damageskinid?: SortOrder
    itemid?: SortOrder
  }

  export type employeetrunkCountOrderByAggregateInput = {
    id?: SortOrder
    money?: SortOrder
  }

  export type employeetrunkAvgOrderByAggregateInput = {
    id?: SortOrder
    money?: SortOrder
  }

  export type employeetrunkMaxOrderByAggregateInput = {
    id?: SortOrder
    money?: SortOrder
  }

  export type employeetrunkMinOrderByAggregateInput = {
    id?: SortOrder
    money?: SortOrder
  }

  export type employeetrunkSumOrderByAggregateInput = {
    id?: SortOrder
    money?: SortOrder
  }

  export type equipsCountOrderByAggregateInput = {
    serialnumber?: SortOrder
    itemid?: SortOrder
    title?: SortOrder
    equippeddate?: SortOrder
    prevbonusexprate?: SortOrder
    options?: SortOrder
    sockets?: SortOrder
    tuc?: SortOrder
    cuc?: SortOrder
    istr?: SortOrder
    idex?: SortOrder
    iint?: SortOrder
    iluk?: SortOrder
    imaxhp?: SortOrder
    imaxhpr?: SortOrder
    imaxmp?: SortOrder
    imaxmpr?: SortOrder
    ipad?: SortOrder
    imad?: SortOrder
    ipdd?: SortOrder
    imdd?: SortOrder
    iacc?: SortOrder
    ieva?: SortOrder
    icraft?: SortOrder
    ispeed?: SortOrder
    ijump?: SortOrder
    arcaneid?: SortOrder
    attribute?: SortOrder
    leveluptype?: SortOrder
    level?: SortOrder
    exp?: SortOrder
    durability?: SortOrder
    iuc?: SortOrder
    ipvpdamage?: SortOrder
    ireducereq?: SortOrder
    specialattribute?: SortOrder
    durabilitymax?: SortOrder
    iincreq?: SortOrder
    growthenchant?: SortOrder
    psenchant?: SortOrder
    hyperupgrade?: SortOrder
    bdr?: SortOrder
    imdr?: SortOrder
    damr?: SortOrder
    statr?: SortOrder
    cuttable?: SortOrder
    exgradeoption?: SortOrder
    itemstate?: SortOrder
    grade?: SortOrder
    chuc?: SortOrder
    souloptionid?: SortOrder
    soulsocketid?: SortOrder
    souloption?: SortOrder
    soulitemid?: SortOrder
    rstr?: SortOrder
    rdex?: SortOrder
    rint?: SortOrder
    rluk?: SortOrder
    rlevel?: SortOrder
    rjob?: SortOrder
    rpop?: SortOrder
    specialgrade?: SortOrder
    fixedpotential?: SortOrder
    tradeblock?: SortOrder
    isonly?: SortOrder
    notsale?: SortOrder
    attackspeed?: SortOrder
    price?: SortOrder
    charmexp?: SortOrder
    setitemid?: SortOrder
    exitem?: SortOrder
    equiptradeblock?: SortOrder
    islot?: SortOrder
    vslot?: SortOrder
    fixedgrade?: SortOrder
    nopotential?: SortOrder
    bossreward?: SortOrder
    superioreqp?: SortOrder
    flameid?: SortOrder
    android?: SortOrder
    androidgrade?: SortOrder
    arcane_stat?: SortOrder
    arcane_exp?: SortOrder
    arcane_level?: SortOrder
    flame_str?: SortOrder
    flame_dex?: SortOrder
    flame_int?: SortOrder
    flame_luk?: SortOrder
    flame_pad?: SortOrder
    flame_mad?: SortOrder
    flame_pdd?: SortOrder
    flame_hp?: SortOrder
    flame_mp?: SortOrder
    flame_speed?: SortOrder
    flame_jump?: SortOrder
    flame_allStatR?: SortOrder
    flame_bossDamageR?: SortOrder
    flame_damageR?: SortOrder
    flame_reduceReqLevel?: SortOrder
  }

  export type equipsAvgOrderByAggregateInput = {
    serialnumber?: SortOrder
    itemid?: SortOrder
    prevbonusexprate?: SortOrder
    tuc?: SortOrder
    cuc?: SortOrder
    istr?: SortOrder
    idex?: SortOrder
    iint?: SortOrder
    iluk?: SortOrder
    imaxhp?: SortOrder
    imaxhpr?: SortOrder
    imaxmp?: SortOrder
    imaxmpr?: SortOrder
    ipad?: SortOrder
    imad?: SortOrder
    ipdd?: SortOrder
    imdd?: SortOrder
    iacc?: SortOrder
    ieva?: SortOrder
    icraft?: SortOrder
    ispeed?: SortOrder
    ijump?: SortOrder
    arcaneid?: SortOrder
    attribute?: SortOrder
    leveluptype?: SortOrder
    level?: SortOrder
    exp?: SortOrder
    durability?: SortOrder
    iuc?: SortOrder
    ipvpdamage?: SortOrder
    ireducereq?: SortOrder
    specialattribute?: SortOrder
    durabilitymax?: SortOrder
    iincreq?: SortOrder
    growthenchant?: SortOrder
    psenchant?: SortOrder
    hyperupgrade?: SortOrder
    bdr?: SortOrder
    imdr?: SortOrder
    damr?: SortOrder
    statr?: SortOrder
    cuttable?: SortOrder
    exgradeoption?: SortOrder
    itemstate?: SortOrder
    grade?: SortOrder
    chuc?: SortOrder
    souloptionid?: SortOrder
    soulsocketid?: SortOrder
    souloption?: SortOrder
    soulitemid?: SortOrder
    rstr?: SortOrder
    rdex?: SortOrder
    rint?: SortOrder
    rluk?: SortOrder
    rlevel?: SortOrder
    rjob?: SortOrder
    rpop?: SortOrder
    specialgrade?: SortOrder
    attackspeed?: SortOrder
    price?: SortOrder
    charmexp?: SortOrder
    setitemid?: SortOrder
    fixedgrade?: SortOrder
    nopotential?: SortOrder
    bossreward?: SortOrder
    superioreqp?: SortOrder
    flameid?: SortOrder
    android?: SortOrder
    androidgrade?: SortOrder
    arcane_stat?: SortOrder
    arcane_exp?: SortOrder
    arcane_level?: SortOrder
    flame_str?: SortOrder
    flame_dex?: SortOrder
    flame_int?: SortOrder
    flame_luk?: SortOrder
    flame_pad?: SortOrder
    flame_mad?: SortOrder
    flame_pdd?: SortOrder
    flame_hp?: SortOrder
    flame_mp?: SortOrder
    flame_speed?: SortOrder
    flame_jump?: SortOrder
    flame_allStatR?: SortOrder
    flame_bossDamageR?: SortOrder
    flame_damageR?: SortOrder
    flame_reduceReqLevel?: SortOrder
  }

  export type equipsMaxOrderByAggregateInput = {
    serialnumber?: SortOrder
    itemid?: SortOrder
    title?: SortOrder
    equippeddate?: SortOrder
    prevbonusexprate?: SortOrder
    options?: SortOrder
    sockets?: SortOrder
    tuc?: SortOrder
    cuc?: SortOrder
    istr?: SortOrder
    idex?: SortOrder
    iint?: SortOrder
    iluk?: SortOrder
    imaxhp?: SortOrder
    imaxhpr?: SortOrder
    imaxmp?: SortOrder
    imaxmpr?: SortOrder
    ipad?: SortOrder
    imad?: SortOrder
    ipdd?: SortOrder
    imdd?: SortOrder
    iacc?: SortOrder
    ieva?: SortOrder
    icraft?: SortOrder
    ispeed?: SortOrder
    ijump?: SortOrder
    arcaneid?: SortOrder
    attribute?: SortOrder
    leveluptype?: SortOrder
    level?: SortOrder
    exp?: SortOrder
    durability?: SortOrder
    iuc?: SortOrder
    ipvpdamage?: SortOrder
    ireducereq?: SortOrder
    specialattribute?: SortOrder
    durabilitymax?: SortOrder
    iincreq?: SortOrder
    growthenchant?: SortOrder
    psenchant?: SortOrder
    hyperupgrade?: SortOrder
    bdr?: SortOrder
    imdr?: SortOrder
    damr?: SortOrder
    statr?: SortOrder
    cuttable?: SortOrder
    exgradeoption?: SortOrder
    itemstate?: SortOrder
    grade?: SortOrder
    chuc?: SortOrder
    souloptionid?: SortOrder
    soulsocketid?: SortOrder
    souloption?: SortOrder
    soulitemid?: SortOrder
    rstr?: SortOrder
    rdex?: SortOrder
    rint?: SortOrder
    rluk?: SortOrder
    rlevel?: SortOrder
    rjob?: SortOrder
    rpop?: SortOrder
    specialgrade?: SortOrder
    fixedpotential?: SortOrder
    tradeblock?: SortOrder
    isonly?: SortOrder
    notsale?: SortOrder
    attackspeed?: SortOrder
    price?: SortOrder
    charmexp?: SortOrder
    setitemid?: SortOrder
    exitem?: SortOrder
    equiptradeblock?: SortOrder
    islot?: SortOrder
    vslot?: SortOrder
    fixedgrade?: SortOrder
    nopotential?: SortOrder
    bossreward?: SortOrder
    superioreqp?: SortOrder
    flameid?: SortOrder
    android?: SortOrder
    androidgrade?: SortOrder
    arcane_stat?: SortOrder
    arcane_exp?: SortOrder
    arcane_level?: SortOrder
    flame_str?: SortOrder
    flame_dex?: SortOrder
    flame_int?: SortOrder
    flame_luk?: SortOrder
    flame_pad?: SortOrder
    flame_mad?: SortOrder
    flame_pdd?: SortOrder
    flame_hp?: SortOrder
    flame_mp?: SortOrder
    flame_speed?: SortOrder
    flame_jump?: SortOrder
    flame_allStatR?: SortOrder
    flame_bossDamageR?: SortOrder
    flame_damageR?: SortOrder
    flame_reduceReqLevel?: SortOrder
  }

  export type equipsMinOrderByAggregateInput = {
    serialnumber?: SortOrder
    itemid?: SortOrder
    title?: SortOrder
    equippeddate?: SortOrder
    prevbonusexprate?: SortOrder
    options?: SortOrder
    sockets?: SortOrder
    tuc?: SortOrder
    cuc?: SortOrder
    istr?: SortOrder
    idex?: SortOrder
    iint?: SortOrder
    iluk?: SortOrder
    imaxhp?: SortOrder
    imaxhpr?: SortOrder
    imaxmp?: SortOrder
    imaxmpr?: SortOrder
    ipad?: SortOrder
    imad?: SortOrder
    ipdd?: SortOrder
    imdd?: SortOrder
    iacc?: SortOrder
    ieva?: SortOrder
    icraft?: SortOrder
    ispeed?: SortOrder
    ijump?: SortOrder
    arcaneid?: SortOrder
    attribute?: SortOrder
    leveluptype?: SortOrder
    level?: SortOrder
    exp?: SortOrder
    durability?: SortOrder
    iuc?: SortOrder
    ipvpdamage?: SortOrder
    ireducereq?: SortOrder
    specialattribute?: SortOrder
    durabilitymax?: SortOrder
    iincreq?: SortOrder
    growthenchant?: SortOrder
    psenchant?: SortOrder
    hyperupgrade?: SortOrder
    bdr?: SortOrder
    imdr?: SortOrder
    damr?: SortOrder
    statr?: SortOrder
    cuttable?: SortOrder
    exgradeoption?: SortOrder
    itemstate?: SortOrder
    grade?: SortOrder
    chuc?: SortOrder
    souloptionid?: SortOrder
    soulsocketid?: SortOrder
    souloption?: SortOrder
    soulitemid?: SortOrder
    rstr?: SortOrder
    rdex?: SortOrder
    rint?: SortOrder
    rluk?: SortOrder
    rlevel?: SortOrder
    rjob?: SortOrder
    rpop?: SortOrder
    specialgrade?: SortOrder
    fixedpotential?: SortOrder
    tradeblock?: SortOrder
    isonly?: SortOrder
    notsale?: SortOrder
    attackspeed?: SortOrder
    price?: SortOrder
    charmexp?: SortOrder
    setitemid?: SortOrder
    exitem?: SortOrder
    equiptradeblock?: SortOrder
    islot?: SortOrder
    vslot?: SortOrder
    fixedgrade?: SortOrder
    nopotential?: SortOrder
    bossreward?: SortOrder
    superioreqp?: SortOrder
    flameid?: SortOrder
    android?: SortOrder
    androidgrade?: SortOrder
    arcane_stat?: SortOrder
    arcane_exp?: SortOrder
    arcane_level?: SortOrder
    flame_str?: SortOrder
    flame_dex?: SortOrder
    flame_int?: SortOrder
    flame_luk?: SortOrder
    flame_pad?: SortOrder
    flame_mad?: SortOrder
    flame_pdd?: SortOrder
    flame_hp?: SortOrder
    flame_mp?: SortOrder
    flame_speed?: SortOrder
    flame_jump?: SortOrder
    flame_allStatR?: SortOrder
    flame_bossDamageR?: SortOrder
    flame_damageR?: SortOrder
    flame_reduceReqLevel?: SortOrder
  }

  export type equipsSumOrderByAggregateInput = {
    serialnumber?: SortOrder
    itemid?: SortOrder
    prevbonusexprate?: SortOrder
    tuc?: SortOrder
    cuc?: SortOrder
    istr?: SortOrder
    idex?: SortOrder
    iint?: SortOrder
    iluk?: SortOrder
    imaxhp?: SortOrder
    imaxhpr?: SortOrder
    imaxmp?: SortOrder
    imaxmpr?: SortOrder
    ipad?: SortOrder
    imad?: SortOrder
    ipdd?: SortOrder
    imdd?: SortOrder
    iacc?: SortOrder
    ieva?: SortOrder
    icraft?: SortOrder
    ispeed?: SortOrder
    ijump?: SortOrder
    arcaneid?: SortOrder
    attribute?: SortOrder
    leveluptype?: SortOrder
    level?: SortOrder
    exp?: SortOrder
    durability?: SortOrder
    iuc?: SortOrder
    ipvpdamage?: SortOrder
    ireducereq?: SortOrder
    specialattribute?: SortOrder
    durabilitymax?: SortOrder
    iincreq?: SortOrder
    growthenchant?: SortOrder
    psenchant?: SortOrder
    hyperupgrade?: SortOrder
    bdr?: SortOrder
    imdr?: SortOrder
    damr?: SortOrder
    statr?: SortOrder
    cuttable?: SortOrder
    exgradeoption?: SortOrder
    itemstate?: SortOrder
    grade?: SortOrder
    chuc?: SortOrder
    souloptionid?: SortOrder
    soulsocketid?: SortOrder
    souloption?: SortOrder
    soulitemid?: SortOrder
    rstr?: SortOrder
    rdex?: SortOrder
    rint?: SortOrder
    rluk?: SortOrder
    rlevel?: SortOrder
    rjob?: SortOrder
    rpop?: SortOrder
    specialgrade?: SortOrder
    attackspeed?: SortOrder
    price?: SortOrder
    charmexp?: SortOrder
    setitemid?: SortOrder
    fixedgrade?: SortOrder
    nopotential?: SortOrder
    bossreward?: SortOrder
    superioreqp?: SortOrder
    flameid?: SortOrder
    android?: SortOrder
    androidgrade?: SortOrder
    arcane_stat?: SortOrder
    arcane_exp?: SortOrder
    arcane_level?: SortOrder
    flame_str?: SortOrder
    flame_dex?: SortOrder
    flame_int?: SortOrder
    flame_luk?: SortOrder
    flame_pad?: SortOrder
    flame_mad?: SortOrder
    flame_pdd?: SortOrder
    flame_hp?: SortOrder
    flame_mp?: SortOrder
    flame_speed?: SortOrder
    flame_jump?: SortOrder
    flame_allStatR?: SortOrder
    flame_bossDamageR?: SortOrder
    flame_damageR?: SortOrder
    flame_reduceReqLevel?: SortOrder
  }

  export type eventnametagCountOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
    activeRed?: SortOrder
    activeBlue?: SortOrder
    activeYellow?: SortOrder
    activeGreen?: SortOrder
    activePurple?: SortOrder
    sRed?: SortOrder
    sBlue?: SortOrder
    sYellow?: SortOrder
    sGreen?: SortOrder
    sPurple?: SortOrder
  }

  export type eventnametagAvgOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
    activeRed?: SortOrder
    activeBlue?: SortOrder
    activeYellow?: SortOrder
    activeGreen?: SortOrder
    activePurple?: SortOrder
  }

  export type eventnametagMaxOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
    activeRed?: SortOrder
    activeBlue?: SortOrder
    activeYellow?: SortOrder
    activeGreen?: SortOrder
    activePurple?: SortOrder
    sRed?: SortOrder
    sBlue?: SortOrder
    sYellow?: SortOrder
    sGreen?: SortOrder
    sPurple?: SortOrder
  }

  export type eventnametagMinOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
    activeRed?: SortOrder
    activeBlue?: SortOrder
    activeYellow?: SortOrder
    activeGreen?: SortOrder
    activePurple?: SortOrder
    sRed?: SortOrder
    sBlue?: SortOrder
    sYellow?: SortOrder
    sGreen?: SortOrder
    sPurple?: SortOrder
  }

  export type eventnametagSumOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
    activeRed?: SortOrder
    activeBlue?: SortOrder
    activeYellow?: SortOrder
    activeGreen?: SortOrder
    activePurple?: SortOrder
  }

  export type extendspCountOrderByAggregateInput = {
    id?: SortOrder
  }

  export type extendspAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type extendspMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type extendspMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type extendspSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type familiarsCountOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
    idk1?: SortOrder
    familiarid?: SortOrder
    name?: SortOrder
    idk2?: SortOrder
    idk3?: SortOrder
    fatigue?: SortOrder
    idk4?: SortOrder
    idk5?: SortOrder
    expiration?: SortOrder
    vitality?: SortOrder
  }

  export type familiarsAvgOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
    idk1?: SortOrder
    familiarid?: SortOrder
    idk3?: SortOrder
    fatigue?: SortOrder
    idk4?: SortOrder
    idk5?: SortOrder
    vitality?: SortOrder
  }

  export type familiarsMaxOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
    idk1?: SortOrder
    familiarid?: SortOrder
    name?: SortOrder
    idk2?: SortOrder
    idk3?: SortOrder
    fatigue?: SortOrder
    idk4?: SortOrder
    idk5?: SortOrder
    expiration?: SortOrder
    vitality?: SortOrder
  }

  export type familiarsMinOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
    idk1?: SortOrder
    familiarid?: SortOrder
    name?: SortOrder
    idk2?: SortOrder
    idk3?: SortOrder
    fatigue?: SortOrder
    idk4?: SortOrder
    idk5?: SortOrder
    expiration?: SortOrder
    vitality?: SortOrder
  }

  export type familiarsSumOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
    idk1?: SortOrder
    familiarid?: SortOrder
    idk3?: SortOrder
    fatigue?: SortOrder
    idk4?: SortOrder
    idk5?: SortOrder
    vitality?: SortOrder
  }

  export type friendsCountOrderByAggregateInput = {
    id?: SortOrder
    ownerid?: SortOrder
    owneraccid?: SortOrder
    friendid?: SortOrder
    friendaccountid?: SortOrder
    name?: SortOrder
    flag?: SortOrder
    groupname?: SortOrder
    mobile?: SortOrder
    nickname?: SortOrder
    memo?: SortOrder
  }

  export type friendsAvgOrderByAggregateInput = {
    id?: SortOrder
    ownerid?: SortOrder
    owneraccid?: SortOrder
    friendid?: SortOrder
    friendaccountid?: SortOrder
    flag?: SortOrder
    mobile?: SortOrder
  }

  export type friendsMaxOrderByAggregateInput = {
    id?: SortOrder
    ownerid?: SortOrder
    owneraccid?: SortOrder
    friendid?: SortOrder
    friendaccountid?: SortOrder
    name?: SortOrder
    flag?: SortOrder
    groupname?: SortOrder
    mobile?: SortOrder
    nickname?: SortOrder
    memo?: SortOrder
  }

  export type friendsMinOrderByAggregateInput = {
    id?: SortOrder
    ownerid?: SortOrder
    owneraccid?: SortOrder
    friendid?: SortOrder
    friendaccountid?: SortOrder
    name?: SortOrder
    flag?: SortOrder
    groupname?: SortOrder
    mobile?: SortOrder
    nickname?: SortOrder
    memo?: SortOrder
  }

  export type friendsSumOrderByAggregateInput = {
    id?: SortOrder
    ownerid?: SortOrder
    owneraccid?: SortOrder
    friendid?: SortOrder
    friendaccountid?: SortOrder
    flag?: SortOrder
    mobile?: SortOrder
  }

  export type funckeymapCountOrderByAggregateInput = {
    id?: SortOrder
    charId?: SortOrder
    ord?: SortOrder
  }

  export type funckeymapAvgOrderByAggregateInput = {
    id?: SortOrder
    charId?: SortOrder
    ord?: SortOrder
  }

  export type funckeymapMaxOrderByAggregateInput = {
    id?: SortOrder
    charId?: SortOrder
    ord?: SortOrder
  }

  export type funckeymapMinOrderByAggregateInput = {
    id?: SortOrder
    charId?: SortOrder
    ord?: SortOrder
  }

  export type funckeymapSumOrderByAggregateInput = {
    id?: SortOrder
    charId?: SortOrder
    ord?: SortOrder
  }

  export type gradenamesCountOrderByAggregateInput = {
    id?: SortOrder
    gradename?: SortOrder
    guildid?: SortOrder
  }

  export type gradenamesAvgOrderByAggregateInput = {
    id?: SortOrder
    guildid?: SortOrder
  }

  export type gradenamesMaxOrderByAggregateInput = {
    id?: SortOrder
    gradename?: SortOrder
    guildid?: SortOrder
  }

  export type gradenamesMinOrderByAggregateInput = {
    id?: SortOrder
    gradename?: SortOrder
    guildid?: SortOrder
  }

  export type gradenamesSumOrderByAggregateInput = {
    id?: SortOrder
    guildid?: SortOrder
  }

  export type guildmembersCountOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
    guildid?: SortOrder
    grade?: SortOrder
    alliancegrade?: SortOrder
    commitment?: SortOrder
    daycommitment?: SortOrder
    igp?: SortOrder
    commitmentinctime?: SortOrder
    name?: SortOrder
    job?: SortOrder
    level?: SortOrder
    loggedin?: SortOrder
  }

  export type guildmembersAvgOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
    guildid?: SortOrder
    grade?: SortOrder
    alliancegrade?: SortOrder
    commitment?: SortOrder
    daycommitment?: SortOrder
    igp?: SortOrder
    job?: SortOrder
    level?: SortOrder
  }

  export type guildmembersMaxOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
    guildid?: SortOrder
    grade?: SortOrder
    alliancegrade?: SortOrder
    commitment?: SortOrder
    daycommitment?: SortOrder
    igp?: SortOrder
    commitmentinctime?: SortOrder
    name?: SortOrder
    job?: SortOrder
    level?: SortOrder
    loggedin?: SortOrder
  }

  export type guildmembersMinOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
    guildid?: SortOrder
    grade?: SortOrder
    alliancegrade?: SortOrder
    commitment?: SortOrder
    daycommitment?: SortOrder
    igp?: SortOrder
    commitmentinctime?: SortOrder
    name?: SortOrder
    job?: SortOrder
    level?: SortOrder
    loggedin?: SortOrder
  }

  export type guildmembersSumOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
    guildid?: SortOrder
    grade?: SortOrder
    alliancegrade?: SortOrder
    commitment?: SortOrder
    daycommitment?: SortOrder
    igp?: SortOrder
    job?: SortOrder
    level?: SortOrder
  }

  export type guildrequestorsCountOrderByAggregateInput = {
    id?: SortOrder
    requestors_id?: SortOrder
    charid?: SortOrder
    guildid?: SortOrder
    name?: SortOrder
    job?: SortOrder
    level?: SortOrder
    loggedin?: SortOrder
  }

  export type guildrequestorsAvgOrderByAggregateInput = {
    id?: SortOrder
    requestors_id?: SortOrder
    charid?: SortOrder
    guildid?: SortOrder
    job?: SortOrder
    level?: SortOrder
  }

  export type guildrequestorsMaxOrderByAggregateInput = {
    id?: SortOrder
    requestors_id?: SortOrder
    charid?: SortOrder
    guildid?: SortOrder
    name?: SortOrder
    job?: SortOrder
    level?: SortOrder
    loggedin?: SortOrder
  }

  export type guildrequestorsMinOrderByAggregateInput = {
    id?: SortOrder
    requestors_id?: SortOrder
    charid?: SortOrder
    guildid?: SortOrder
    name?: SortOrder
    job?: SortOrder
    level?: SortOrder
    loggedin?: SortOrder
  }

  export type guildrequestorsSumOrderByAggregateInput = {
    id?: SortOrder
    requestors_id?: SortOrder
    charid?: SortOrder
    guildid?: SortOrder
    job?: SortOrder
    level?: SortOrder
  }

  export type guildsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    leaderid?: SortOrder
    worldid?: SortOrder
    markbg?: SortOrder
    markbgcolor?: SortOrder
    mark?: SortOrder
    markcolor?: SortOrder
    maxmembers?: SortOrder
    notice?: SortOrder
    points?: SortOrder
    seasonpoints?: SortOrder
    allianceid?: SortOrder
    level?: SortOrder
    guildrank?: SortOrder
    ggp?: SortOrder
    appliable?: SortOrder
    joinsetting?: SortOrder
    reqlevel?: SortOrder
    bbsNotice?: SortOrder
    battleSp?: SortOrder
    fk_allianceid?: SortOrder
  }

  export type guildsAvgOrderByAggregateInput = {
    id?: SortOrder
    leaderid?: SortOrder
    worldid?: SortOrder
    markbg?: SortOrder
    markbgcolor?: SortOrder
    mark?: SortOrder
    markcolor?: SortOrder
    maxmembers?: SortOrder
    points?: SortOrder
    seasonpoints?: SortOrder
    allianceid?: SortOrder
    level?: SortOrder
    guildrank?: SortOrder
    ggp?: SortOrder
    joinsetting?: SortOrder
    reqlevel?: SortOrder
    bbsNotice?: SortOrder
    battleSp?: SortOrder
    fk_allianceid?: SortOrder
  }

  export type guildsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    leaderid?: SortOrder
    worldid?: SortOrder
    markbg?: SortOrder
    markbgcolor?: SortOrder
    mark?: SortOrder
    markcolor?: SortOrder
    maxmembers?: SortOrder
    notice?: SortOrder
    points?: SortOrder
    seasonpoints?: SortOrder
    allianceid?: SortOrder
    level?: SortOrder
    guildrank?: SortOrder
    ggp?: SortOrder
    appliable?: SortOrder
    joinsetting?: SortOrder
    reqlevel?: SortOrder
    bbsNotice?: SortOrder
    battleSp?: SortOrder
    fk_allianceid?: SortOrder
  }

  export type guildsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    leaderid?: SortOrder
    worldid?: SortOrder
    markbg?: SortOrder
    markbgcolor?: SortOrder
    mark?: SortOrder
    markcolor?: SortOrder
    maxmembers?: SortOrder
    notice?: SortOrder
    points?: SortOrder
    seasonpoints?: SortOrder
    allianceid?: SortOrder
    level?: SortOrder
    guildrank?: SortOrder
    ggp?: SortOrder
    appliable?: SortOrder
    joinsetting?: SortOrder
    reqlevel?: SortOrder
    bbsNotice?: SortOrder
    battleSp?: SortOrder
    fk_allianceid?: SortOrder
  }

  export type guildsSumOrderByAggregateInput = {
    id?: SortOrder
    leaderid?: SortOrder
    worldid?: SortOrder
    markbg?: SortOrder
    markbgcolor?: SortOrder
    mark?: SortOrder
    markcolor?: SortOrder
    maxmembers?: SortOrder
    points?: SortOrder
    seasonpoints?: SortOrder
    allianceid?: SortOrder
    level?: SortOrder
    guildrank?: SortOrder
    ggp?: SortOrder
    joinsetting?: SortOrder
    reqlevel?: SortOrder
    bbsNotice?: SortOrder
    battleSp?: SortOrder
    fk_allianceid?: SortOrder
  }

  export type guildskillCountOrderByAggregateInput = {
    id?: SortOrder
    skillid?: SortOrder
    level?: SortOrder
    expiredate?: SortOrder
    buycharactername?: SortOrder
    extendcharactername?: SortOrder
  }

  export type guildskillAvgOrderByAggregateInput = {
    id?: SortOrder
    skillid?: SortOrder
    level?: SortOrder
  }

  export type guildskillMaxOrderByAggregateInput = {
    id?: SortOrder
    skillid?: SortOrder
    level?: SortOrder
    expiredate?: SortOrder
    buycharactername?: SortOrder
    extendcharactername?: SortOrder
  }

  export type guildskillMinOrderByAggregateInput = {
    id?: SortOrder
    skillid?: SortOrder
    level?: SortOrder
    expiredate?: SortOrder
    buycharactername?: SortOrder
    extendcharactername?: SortOrder
  }

  export type guildskillSumOrderByAggregateInput = {
    id?: SortOrder
    skillid?: SortOrder
    level?: SortOrder
  }

  export type guildskillsCountOrderByAggregateInput = {
    guildskill_id?: SortOrder
    skills_id?: SortOrder
    guild_id?: SortOrder
    skillid?: SortOrder
    fk_guildskillid?: SortOrder
  }

  export type guildskillsAvgOrderByAggregateInput = {
    guildskill_id?: SortOrder
    skills_id?: SortOrder
    guild_id?: SortOrder
    skillid?: SortOrder
    fk_guildskillid?: SortOrder
  }

  export type guildskillsMaxOrderByAggregateInput = {
    guildskill_id?: SortOrder
    skills_id?: SortOrder
    guild_id?: SortOrder
    skillid?: SortOrder
    fk_guildskillid?: SortOrder
  }

  export type guildskillsMinOrderByAggregateInput = {
    guildskill_id?: SortOrder
    skills_id?: SortOrder
    guild_id?: SortOrder
    skillid?: SortOrder
    fk_guildskillid?: SortOrder
  }

  export type guildskillsSumOrderByAggregateInput = {
    guildskill_id?: SortOrder
    skills_id?: SortOrder
    guild_id?: SortOrder
    skillid?: SortOrder
    fk_guildskillid?: SortOrder
  }

  export type hairequipsCountOrderByAggregateInput = {
    id?: SortOrder
    alid?: SortOrder
    equipid?: SortOrder
  }

  export type hairequipsAvgOrderByAggregateInput = {
    id?: SortOrder
    alid?: SortOrder
    equipid?: SortOrder
  }

  export type hairequipsMaxOrderByAggregateInput = {
    id?: SortOrder
    alid?: SortOrder
    equipid?: SortOrder
  }

  export type hairequipsMinOrderByAggregateInput = {
    id?: SortOrder
    alid?: SortOrder
    equipid?: SortOrder
  }

  export type hairequipsSumOrderByAggregateInput = {
    id?: SortOrder
    alid?: SortOrder
    equipid?: SortOrder
  }

  export type hyperrockfieldsCountOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
    ord?: SortOrder
    fieldid?: SortOrder
  }

  export type hyperrockfieldsAvgOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
    ord?: SortOrder
    fieldid?: SortOrder
  }

  export type hyperrockfieldsMaxOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
    ord?: SortOrder
    fieldid?: SortOrder
  }

  export type hyperrockfieldsMinOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
    ord?: SortOrder
    fieldid?: SortOrder
  }

  export type hyperrockfieldsSumOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
    ord?: SortOrder
    fieldid?: SortOrder
  }

  export type inventoriesCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    slots?: SortOrder
  }

  export type inventoriesAvgOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    slots?: SortOrder
  }

  export type inventoriesMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    slots?: SortOrder
  }

  export type inventoriesMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    slots?: SortOrder
  }

  export type inventoriesSumOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    slots?: SortOrder
  }

  export type itemsCountOrderByAggregateInput = {
    id?: SortOrder
    inventoryid?: SortOrder
    trunkid?: SortOrder
    auctionHouseStatus?: SortOrder
    itemid?: SortOrder
    bagindex?: SortOrder
    cashitemserialnumber?: SortOrder
    dateexpire?: SortOrder
    invtype?: SortOrder
    type?: SortOrder
    iscash?: SortOrder
    quantity?: SortOrder
    expireonlogout?: SortOrder
    owner?: SortOrder
    obtainedonce?: SortOrder
    zeroShareItemID?: SortOrder
    attribute?: SortOrder
  }

  export type itemsAvgOrderByAggregateInput = {
    id?: SortOrder
    inventoryid?: SortOrder
    trunkid?: SortOrder
    itemid?: SortOrder
    bagindex?: SortOrder
    cashitemserialnumber?: SortOrder
    invtype?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    zeroShareItemID?: SortOrder
    attribute?: SortOrder
  }

  export type itemsMaxOrderByAggregateInput = {
    id?: SortOrder
    inventoryid?: SortOrder
    trunkid?: SortOrder
    auctionHouseStatus?: SortOrder
    itemid?: SortOrder
    bagindex?: SortOrder
    cashitemserialnumber?: SortOrder
    dateexpire?: SortOrder
    invtype?: SortOrder
    type?: SortOrder
    iscash?: SortOrder
    quantity?: SortOrder
    expireonlogout?: SortOrder
    owner?: SortOrder
    obtainedonce?: SortOrder
    zeroShareItemID?: SortOrder
    attribute?: SortOrder
  }

  export type itemsMinOrderByAggregateInput = {
    id?: SortOrder
    inventoryid?: SortOrder
    trunkid?: SortOrder
    auctionHouseStatus?: SortOrder
    itemid?: SortOrder
    bagindex?: SortOrder
    cashitemserialnumber?: SortOrder
    dateexpire?: SortOrder
    invtype?: SortOrder
    type?: SortOrder
    iscash?: SortOrder
    quantity?: SortOrder
    expireonlogout?: SortOrder
    owner?: SortOrder
    obtainedonce?: SortOrder
    zeroShareItemID?: SortOrder
    attribute?: SortOrder
  }

  export type itemsSumOrderByAggregateInput = {
    id?: SortOrder
    inventoryid?: SortOrder
    trunkid?: SortOrder
    itemid?: SortOrder
    bagindex?: SortOrder
    cashitemserialnumber?: SortOrder
    invtype?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    zeroShareItemID?: SortOrder
    attribute?: SortOrder
  }

  export type itemsbuylimitCountOrderByAggregateInput = {
    id?: SortOrder
    shopitemid?: SortOrder
    charid?: SortOrder
    amountbought?: SortOrder
  }

  export type itemsbuylimitAvgOrderByAggregateInput = {
    id?: SortOrder
    shopitemid?: SortOrder
    charid?: SortOrder
    amountbought?: SortOrder
  }

  export type itemsbuylimitMaxOrderByAggregateInput = {
    id?: SortOrder
    shopitemid?: SortOrder
    charid?: SortOrder
    amountbought?: SortOrder
  }

  export type itemsbuylimitMinOrderByAggregateInput = {
    id?: SortOrder
    shopitemid?: SortOrder
    charid?: SortOrder
    amountbought?: SortOrder
  }

  export type itemsbuylimitSumOrderByAggregateInput = {
    id?: SortOrder
    shopitemid?: SortOrder
    charid?: SortOrder
    amountbought?: SortOrder
  }

  export type keymapsCountOrderByAggregateInput = {
    id?: SortOrder
    fkmapid?: SortOrder
    idx?: SortOrder
    type?: SortOrder
    val?: SortOrder
  }

  export type keymapsAvgOrderByAggregateInput = {
    id?: SortOrder
    fkmapid?: SortOrder
    idx?: SortOrder
    type?: SortOrder
    val?: SortOrder
  }

  export type keymapsMaxOrderByAggregateInput = {
    id?: SortOrder
    fkmapid?: SortOrder
    idx?: SortOrder
    type?: SortOrder
    val?: SortOrder
  }

  export type keymapsMinOrderByAggregateInput = {
    id?: SortOrder
    fkmapid?: SortOrder
    idx?: SortOrder
    type?: SortOrder
    val?: SortOrder
  }

  export type keymapsSumOrderByAggregateInput = {
    id?: SortOrder
    fkmapid?: SortOrder
    idx?: SortOrder
    type?: SortOrder
    val?: SortOrder
  }

  export type linkskillsCountOrderByAggregateInput = {
    id?: SortOrder
    accid?: SortOrder
    ownerid?: SortOrder
    linkedcharid?: SortOrder
    linkskillid?: SortOrder
    level?: SortOrder
    addeddate?: SortOrder
  }

  export type linkskillsAvgOrderByAggregateInput = {
    id?: SortOrder
    accid?: SortOrder
    ownerid?: SortOrder
    linkedcharid?: SortOrder
    linkskillid?: SortOrder
    level?: SortOrder
  }

  export type linkskillsMaxOrderByAggregateInput = {
    id?: SortOrder
    accid?: SortOrder
    ownerid?: SortOrder
    linkedcharid?: SortOrder
    linkskillid?: SortOrder
    level?: SortOrder
    addeddate?: SortOrder
  }

  export type linkskillsMinOrderByAggregateInput = {
    id?: SortOrder
    accid?: SortOrder
    ownerid?: SortOrder
    linkedcharid?: SortOrder
    linkskillid?: SortOrder
    level?: SortOrder
    addeddate?: SortOrder
  }

  export type linkskillsSumOrderByAggregateInput = {
    id?: SortOrder
    accid?: SortOrder
    ownerid?: SortOrder
    linkedcharid?: SortOrder
    linkskillid?: SortOrder
    level?: SortOrder
  }

  export type macrosCountOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
    muted?: SortOrder
    name?: SortOrder
  }

  export type macrosAvgOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
  }

  export type macrosMaxOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
    muted?: SortOrder
    name?: SortOrder
  }

  export type macrosMinOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
    muted?: SortOrder
    name?: SortOrder
  }

  export type macrosSumOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
  }

  export type macroskillsCountOrderByAggregateInput = {
    id?: SortOrder
    ordercol?: SortOrder
    skillid?: SortOrder
    macroid?: SortOrder
  }

  export type macroskillsAvgOrderByAggregateInput = {
    id?: SortOrder
    ordercol?: SortOrder
    skillid?: SortOrder
    macroid?: SortOrder
  }

  export type macroskillsMaxOrderByAggregateInput = {
    id?: SortOrder
    ordercol?: SortOrder
    skillid?: SortOrder
    macroid?: SortOrder
  }

  export type macroskillsMinOrderByAggregateInput = {
    id?: SortOrder
    ordercol?: SortOrder
    skillid?: SortOrder
    macroid?: SortOrder
  }

  export type macroskillsSumOrderByAggregateInput = {
    id?: SortOrder
    ordercol?: SortOrder
    skillid?: SortOrder
    macroid?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type matrixskillCountOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
    state?: SortOrder
    coreID?: SortOrder
    skillID1?: SortOrder
    skillID2?: SortOrder
    skillID3?: SortOrder
    level?: SortOrder
    maxLevel?: SortOrder
    experience?: SortOrder
    crc?: SortOrder
    slot?: SortOrder
  }

  export type matrixskillAvgOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
    coreID?: SortOrder
    skillID1?: SortOrder
    skillID2?: SortOrder
    skillID3?: SortOrder
    level?: SortOrder
    maxLevel?: SortOrder
    experience?: SortOrder
    crc?: SortOrder
    slot?: SortOrder
  }

  export type matrixskillMaxOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
    state?: SortOrder
    coreID?: SortOrder
    skillID1?: SortOrder
    skillID2?: SortOrder
    skillID3?: SortOrder
    level?: SortOrder
    maxLevel?: SortOrder
    experience?: SortOrder
    crc?: SortOrder
    slot?: SortOrder
  }

  export type matrixskillMinOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
    state?: SortOrder
    coreID?: SortOrder
    skillID1?: SortOrder
    skillID2?: SortOrder
    skillID3?: SortOrder
    level?: SortOrder
    maxLevel?: SortOrder
    experience?: SortOrder
    crc?: SortOrder
    slot?: SortOrder
  }

  export type matrixskillSumOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
    coreID?: SortOrder
    skillID1?: SortOrder
    skillID2?: SortOrder
    skillID3?: SortOrder
    level?: SortOrder
    maxLevel?: SortOrder
    experience?: SortOrder
    crc?: SortOrder
    slot?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type medalsCountOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
    questid?: SortOrder
    itemid?: SortOrder
    completedtime?: SortOrder
  }

  export type medalsAvgOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
    questid?: SortOrder
    itemid?: SortOrder
  }

  export type medalsMaxOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
    questid?: SortOrder
    itemid?: SortOrder
    completedtime?: SortOrder
  }

  export type medalsMinOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
    questid?: SortOrder
    itemid?: SortOrder
    completedtime?: SortOrder
  }

  export type medalsSumOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
    questid?: SortOrder
    itemid?: SortOrder
  }

  export type mob_dropsCountOrderByAggregateInput = {
    id?: SortOrder
    mobid?: SortOrder
    itemid?: SortOrder
    chance?: SortOrder
    minquant?: SortOrder
    maxquant?: SortOrder
    reactordrop?: SortOrder
  }

  export type mob_dropsAvgOrderByAggregateInput = {
    id?: SortOrder
    mobid?: SortOrder
    itemid?: SortOrder
    chance?: SortOrder
    minquant?: SortOrder
    maxquant?: SortOrder
    reactordrop?: SortOrder
  }

  export type mob_dropsMaxOrderByAggregateInput = {
    id?: SortOrder
    mobid?: SortOrder
    itemid?: SortOrder
    chance?: SortOrder
    minquant?: SortOrder
    maxquant?: SortOrder
    reactordrop?: SortOrder
  }

  export type mob_dropsMinOrderByAggregateInput = {
    id?: SortOrder
    mobid?: SortOrder
    itemid?: SortOrder
    chance?: SortOrder
    minquant?: SortOrder
    maxquant?: SortOrder
    reactordrop?: SortOrder
  }

  export type mob_dropsSumOrderByAggregateInput = {
    id?: SortOrder
    mobid?: SortOrder
    itemid?: SortOrder
    chance?: SortOrder
    minquant?: SortOrder
    maxquant?: SortOrder
    reactordrop?: SortOrder
  }

  export type monster_collectionCountOrderByAggregateInput = {
    id?: SortOrder
    mobid?: SortOrder
    region?: SortOrder
    session?: SortOrder
    position?: SortOrder
  }

  export type monster_collectionAvgOrderByAggregateInput = {
    id?: SortOrder
    mobid?: SortOrder
    region?: SortOrder
    session?: SortOrder
    position?: SortOrder
  }

  export type monster_collectionMaxOrderByAggregateInput = {
    id?: SortOrder
    mobid?: SortOrder
    region?: SortOrder
    session?: SortOrder
    position?: SortOrder
  }

  export type monster_collectionMinOrderByAggregateInput = {
    id?: SortOrder
    mobid?: SortOrder
    region?: SortOrder
    session?: SortOrder
    position?: SortOrder
  }

  export type monster_collectionSumOrderByAggregateInput = {
    id?: SortOrder
    mobid?: SortOrder
    region?: SortOrder
    session?: SortOrder
    position?: SortOrder
  }

  export type monster_collection_explorationsCountOrderByAggregateInput = {
    id?: SortOrder
    collectionid?: SortOrder
    collectionkey?: SortOrder
    monsterkey?: SortOrder
    endDate?: SortOrder
    position?: SortOrder
  }

  export type monster_collection_explorationsAvgOrderByAggregateInput = {
    id?: SortOrder
    collectionid?: SortOrder
    collectionkey?: SortOrder
    position?: SortOrder
  }

  export type monster_collection_explorationsMaxOrderByAggregateInput = {
    id?: SortOrder
    collectionid?: SortOrder
    collectionkey?: SortOrder
    monsterkey?: SortOrder
    endDate?: SortOrder
    position?: SortOrder
  }

  export type monster_collection_explorationsMinOrderByAggregateInput = {
    id?: SortOrder
    collectionid?: SortOrder
    collectionkey?: SortOrder
    monsterkey?: SortOrder
    endDate?: SortOrder
    position?: SortOrder
  }

  export type monster_collection_explorationsSumOrderByAggregateInput = {
    id?: SortOrder
    collectionid?: SortOrder
    collectionkey?: SortOrder
    position?: SortOrder
  }

  export type monster_collection_group_rewardsRegionSessionGroupidCompoundUniqueInput = {
    region: number
    session: number
    groupid: number
  }

  export type monster_collection_group_rewardsCountOrderByAggregateInput = {
    region?: SortOrder
    session?: SortOrder
    groupid?: SortOrder
    rewardid?: SortOrder
    quantity?: SortOrder
  }

  export type monster_collection_group_rewardsAvgOrderByAggregateInput = {
    region?: SortOrder
    session?: SortOrder
    groupid?: SortOrder
    rewardid?: SortOrder
    quantity?: SortOrder
  }

  export type monster_collection_group_rewardsMaxOrderByAggregateInput = {
    region?: SortOrder
    session?: SortOrder
    groupid?: SortOrder
    rewardid?: SortOrder
    quantity?: SortOrder
  }

  export type monster_collection_group_rewardsMinOrderByAggregateInput = {
    region?: SortOrder
    session?: SortOrder
    groupid?: SortOrder
    rewardid?: SortOrder
    quantity?: SortOrder
  }

  export type monster_collection_group_rewardsSumOrderByAggregateInput = {
    region?: SortOrder
    session?: SortOrder
    groupid?: SortOrder
    rewardid?: SortOrder
    quantity?: SortOrder
  }

  export type monster_collection_mobsCountOrderByAggregateInput = {
    id?: SortOrder
    collectionid?: SortOrder
    mobid?: SortOrder
  }

  export type monster_collection_mobsAvgOrderByAggregateInput = {
    id?: SortOrder
    collectionid?: SortOrder
    mobid?: SortOrder
  }

  export type monster_collection_mobsMaxOrderByAggregateInput = {
    id?: SortOrder
    collectionid?: SortOrder
    mobid?: SortOrder
  }

  export type monster_collection_mobsMinOrderByAggregateInput = {
    id?: SortOrder
    collectionid?: SortOrder
    mobid?: SortOrder
  }

  export type monster_collection_mobsSumOrderByAggregateInput = {
    id?: SortOrder
    collectionid?: SortOrder
    mobid?: SortOrder
  }

  export type monster_collection_rewardsRegionSessionGroupidCompoundUniqueInput = {
    region: number
    session: number
    groupid: number
  }

  export type monster_collection_rewardsCountOrderByAggregateInput = {
    region?: SortOrder
    session?: SortOrder
    groupid?: SortOrder
    collectionid?: SortOrder
  }

  export type monster_collection_rewardsAvgOrderByAggregateInput = {
    region?: SortOrder
    session?: SortOrder
    groupid?: SortOrder
    collectionid?: SortOrder
  }

  export type monster_collection_rewardsMaxOrderByAggregateInput = {
    region?: SortOrder
    session?: SortOrder
    groupid?: SortOrder
    collectionid?: SortOrder
  }

  export type monster_collection_rewardsMinOrderByAggregateInput = {
    region?: SortOrder
    session?: SortOrder
    groupid?: SortOrder
    collectionid?: SortOrder
  }

  export type monster_collection_rewardsSumOrderByAggregateInput = {
    region?: SortOrder
    session?: SortOrder
    groupid?: SortOrder
    collectionid?: SortOrder
  }

  export type monster_collection_session_rewardsRegionSessionCompoundUniqueInput = {
    region: number
    session: number
  }

  export type monster_collection_session_rewardsCountOrderByAggregateInput = {
    region?: SortOrder
    session?: SortOrder
    rewardid?: SortOrder
    quantity?: SortOrder
  }

  export type monster_collection_session_rewardsAvgOrderByAggregateInput = {
    region?: SortOrder
    session?: SortOrder
    rewardid?: SortOrder
    quantity?: SortOrder
  }

  export type monster_collection_session_rewardsMaxOrderByAggregateInput = {
    region?: SortOrder
    session?: SortOrder
    rewardid?: SortOrder
    quantity?: SortOrder
  }

  export type monster_collection_session_rewardsMinOrderByAggregateInput = {
    region?: SortOrder
    session?: SortOrder
    rewardid?: SortOrder
    quantity?: SortOrder
  }

  export type monster_collection_session_rewardsSumOrderByAggregateInput = {
    region?: SortOrder
    session?: SortOrder
    rewardid?: SortOrder
    quantity?: SortOrder
  }

  export type monster_collectionsCountOrderByAggregateInput = {
    id?: SortOrder
    templateid?: SortOrder
    accid?: SortOrder
  }

  export type monster_collectionsAvgOrderByAggregateInput = {
    id?: SortOrder
    templateid?: SortOrder
    accid?: SortOrder
  }

  export type monster_collectionsMaxOrderByAggregateInput = {
    id?: SortOrder
    templateid?: SortOrder
    accid?: SortOrder
  }

  export type monster_collectionsMinOrderByAggregateInput = {
    id?: SortOrder
    templateid?: SortOrder
    accid?: SortOrder
  }

  export type monster_collectionsSumOrderByAggregateInput = {
    id?: SortOrder
    templateid?: SortOrder
    accid?: SortOrder
  }

  export type monsterbookcardsCountOrderByAggregateInput = {
    id?: SortOrder
    bookid?: SortOrder
    cardid?: SortOrder
  }

  export type monsterbookcardsAvgOrderByAggregateInput = {
    id?: SortOrder
    bookid?: SortOrder
    cardid?: SortOrder
  }

  export type monsterbookcardsMaxOrderByAggregateInput = {
    id?: SortOrder
    bookid?: SortOrder
    cardid?: SortOrder
  }

  export type monsterbookcardsMinOrderByAggregateInput = {
    id?: SortOrder
    bookid?: SortOrder
    cardid?: SortOrder
  }

  export type monsterbookcardsSumOrderByAggregateInput = {
    id?: SortOrder
    bookid?: SortOrder
    cardid?: SortOrder
  }

  export type monsterbookinfosCountOrderByAggregateInput = {
    id?: SortOrder
    setid?: SortOrder
    coverid?: SortOrder
  }

  export type monsterbookinfosAvgOrderByAggregateInput = {
    id?: SortOrder
    setid?: SortOrder
    coverid?: SortOrder
  }

  export type monsterbookinfosMaxOrderByAggregateInput = {
    id?: SortOrder
    setid?: SortOrder
    coverid?: SortOrder
  }

  export type monsterbookinfosMinOrderByAggregateInput = {
    id?: SortOrder
    setid?: SortOrder
    coverid?: SortOrder
  }

  export type monsterbookinfosSumOrderByAggregateInput = {
    id?: SortOrder
    setid?: SortOrder
    coverid?: SortOrder
  }

  export type noncombatstatdaylimitCountOrderByAggregateInput = {
    id?: SortOrder
    charisma?: SortOrder
    charm?: SortOrder
    insight?: SortOrder
    will?: SortOrder
    craft?: SortOrder
    sense?: SortOrder
    lastupdatecharmbycashpr?: SortOrder
    charmbycashpr?: SortOrder
  }

  export type noncombatstatdaylimitAvgOrderByAggregateInput = {
    id?: SortOrder
    charisma?: SortOrder
    charm?: SortOrder
    insight?: SortOrder
    will?: SortOrder
    craft?: SortOrder
    sense?: SortOrder
    charmbycashpr?: SortOrder
  }

  export type noncombatstatdaylimitMaxOrderByAggregateInput = {
    id?: SortOrder
    charisma?: SortOrder
    charm?: SortOrder
    insight?: SortOrder
    will?: SortOrder
    craft?: SortOrder
    sense?: SortOrder
    lastupdatecharmbycashpr?: SortOrder
    charmbycashpr?: SortOrder
  }

  export type noncombatstatdaylimitMinOrderByAggregateInput = {
    id?: SortOrder
    charisma?: SortOrder
    charm?: SortOrder
    insight?: SortOrder
    will?: SortOrder
    craft?: SortOrder
    sense?: SortOrder
    lastupdatecharmbycashpr?: SortOrder
    charmbycashpr?: SortOrder
  }

  export type noncombatstatdaylimitSumOrderByAggregateInput = {
    id?: SortOrder
    charisma?: SortOrder
    charm?: SortOrder
    insight?: SortOrder
    will?: SortOrder
    craft?: SortOrder
    sense?: SortOrder
    charmbycashpr?: SortOrder
  }

  export type npcCountOrderByAggregateInput = {
    id?: SortOrder
    npcid?: SortOrder
    mapid?: SortOrder
    x?: SortOrder
    y?: SortOrder
    cy?: SortOrder
    rx0?: SortOrder
    rx1?: SortOrder
    fh?: SortOrder
  }

  export type npcAvgOrderByAggregateInput = {
    id?: SortOrder
    npcid?: SortOrder
    mapid?: SortOrder
    x?: SortOrder
    y?: SortOrder
    cy?: SortOrder
    rx0?: SortOrder
    rx1?: SortOrder
    fh?: SortOrder
  }

  export type npcMaxOrderByAggregateInput = {
    id?: SortOrder
    npcid?: SortOrder
    mapid?: SortOrder
    x?: SortOrder
    y?: SortOrder
    cy?: SortOrder
    rx0?: SortOrder
    rx1?: SortOrder
    fh?: SortOrder
  }

  export type npcMinOrderByAggregateInput = {
    id?: SortOrder
    npcid?: SortOrder
    mapid?: SortOrder
    x?: SortOrder
    y?: SortOrder
    cy?: SortOrder
    rx0?: SortOrder
    rx1?: SortOrder
    fh?: SortOrder
  }

  export type npcSumOrderByAggregateInput = {
    id?: SortOrder
    npcid?: SortOrder
    mapid?: SortOrder
    x?: SortOrder
    y?: SortOrder
    cy?: SortOrder
    rx0?: SortOrder
    rx1?: SortOrder
    fh?: SortOrder
  }

  export type offense_managersCountOrderByAggregateInput = {
    id?: SortOrder
    points?: SortOrder
  }

  export type offense_managersAvgOrderByAggregateInput = {
    id?: SortOrder
    points?: SortOrder
  }

  export type offense_managersMaxOrderByAggregateInput = {
    id?: SortOrder
    points?: SortOrder
  }

  export type offense_managersMinOrderByAggregateInput = {
    id?: SortOrder
    points?: SortOrder
  }

  export type offense_managersSumOrderByAggregateInput = {
    id?: SortOrder
    points?: SortOrder
  }

  export type offensesCountOrderByAggregateInput = {
    id?: SortOrder
    manager_id?: SortOrder
    charid?: SortOrder
    accountid?: SortOrder
    msg?: SortOrder
    type?: SortOrder
    issuedate?: SortOrder
    issuer_char_id?: SortOrder
  }

  export type offensesAvgOrderByAggregateInput = {
    id?: SortOrder
    manager_id?: SortOrder
    charid?: SortOrder
    accountid?: SortOrder
    issuer_char_id?: SortOrder
  }

  export type offensesMaxOrderByAggregateInput = {
    id?: SortOrder
    manager_id?: SortOrder
    charid?: SortOrder
    accountid?: SortOrder
    msg?: SortOrder
    type?: SortOrder
    issuedate?: SortOrder
    issuer_char_id?: SortOrder
  }

  export type offensesMinOrderByAggregateInput = {
    id?: SortOrder
    manager_id?: SortOrder
    charid?: SortOrder
    accountid?: SortOrder
    msg?: SortOrder
    type?: SortOrder
    issuedate?: SortOrder
    issuer_char_id?: SortOrder
  }

  export type offensesSumOrderByAggregateInput = {
    id?: SortOrder
    manager_id?: SortOrder
    charid?: SortOrder
    accountid?: SortOrder
    issuer_char_id?: SortOrder
  }

  export type partyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    partyleaderid?: SortOrder
    appliable?: SortOrder
    isprivateparty?: SortOrder
  }

  export type partyAvgOrderByAggregateInput = {
    id?: SortOrder
    partyleaderid?: SortOrder
  }

  export type partyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    partyleaderid?: SortOrder
    appliable?: SortOrder
    isprivateparty?: SortOrder
  }

  export type partyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    partyleaderid?: SortOrder
    appliable?: SortOrder
    isprivateparty?: SortOrder
  }

  export type partySumOrderByAggregateInput = {
    id?: SortOrder
    partyleaderid?: SortOrder
  }

  export type partybossCountOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
    orderid?: SortOrder
    bossname?: SortOrder
    difficulty?: SortOrder
    attempt?: SortOrder
    lastattempttime?: SortOrder
  }

  export type partybossAvgOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
    orderid?: SortOrder
    difficulty?: SortOrder
    attempt?: SortOrder
  }

  export type partybossMaxOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
    orderid?: SortOrder
    bossname?: SortOrder
    difficulty?: SortOrder
    attempt?: SortOrder
    lastattempttime?: SortOrder
  }

  export type partybossMinOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
    orderid?: SortOrder
    bossname?: SortOrder
    difficulty?: SortOrder
    attempt?: SortOrder
    lastattempttime?: SortOrder
  }

  export type partybossSumOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
    orderid?: SortOrder
    difficulty?: SortOrder
    attempt?: SortOrder
  }

  export type partymembersCountOrderByAggregateInput = {
    id?: SortOrder
    partyid?: SortOrder
    charid?: SortOrder
    name?: SortOrder
    job?: SortOrder
    subJob?: SortOrder
    level?: SortOrder
    channel?: SortOrder
    fieldid?: SortOrder
    loggedin?: SortOrder
  }

  export type partymembersAvgOrderByAggregateInput = {
    id?: SortOrder
    partyid?: SortOrder
    charid?: SortOrder
    job?: SortOrder
    subJob?: SortOrder
    level?: SortOrder
    channel?: SortOrder
    fieldid?: SortOrder
  }

  export type partymembersMaxOrderByAggregateInput = {
    id?: SortOrder
    partyid?: SortOrder
    charid?: SortOrder
    name?: SortOrder
    job?: SortOrder
    subJob?: SortOrder
    level?: SortOrder
    channel?: SortOrder
    fieldid?: SortOrder
    loggedin?: SortOrder
  }

  export type partymembersMinOrderByAggregateInput = {
    id?: SortOrder
    partyid?: SortOrder
    charid?: SortOrder
    name?: SortOrder
    job?: SortOrder
    subJob?: SortOrder
    level?: SortOrder
    channel?: SortOrder
    fieldid?: SortOrder
    loggedin?: SortOrder
  }

  export type partymembersSumOrderByAggregateInput = {
    id?: SortOrder
    partyid?: SortOrder
    charid?: SortOrder
    job?: SortOrder
    subJob?: SortOrder
    level?: SortOrder
    channel?: SortOrder
    fieldid?: SortOrder
  }

  export type petidsCountOrderByAggregateInput = {
    id?: SortOrder
    alid?: SortOrder
    petid?: SortOrder
  }

  export type petidsAvgOrderByAggregateInput = {
    id?: SortOrder
    alid?: SortOrder
    petid?: SortOrder
  }

  export type petidsMaxOrderByAggregateInput = {
    id?: SortOrder
    alid?: SortOrder
    petid?: SortOrder
  }

  export type petidsMinOrderByAggregateInput = {
    id?: SortOrder
    alid?: SortOrder
    petid?: SortOrder
  }

  export type petidsSumOrderByAggregateInput = {
    id?: SortOrder
    alid?: SortOrder
    petid?: SortOrder
  }

  export type petitemsCountOrderByAggregateInput = {
    itemid?: SortOrder
    name?: SortOrder
    level?: SortOrder
    tameness?: SortOrder
    repleteness?: SortOrder
    petattribute?: SortOrder
    petskill?: SortOrder
    datedead?: SortOrder
    remainlife?: SortOrder
    attribute?: SortOrder
    activestate?: SortOrder
    autobuffskill?: SortOrder
    pethue?: SortOrder
    giantrate?: SortOrder
    exceptionList?: SortOrder
  }

  export type petitemsAvgOrderByAggregateInput = {
    itemid?: SortOrder
    level?: SortOrder
    tameness?: SortOrder
    repleteness?: SortOrder
    petattribute?: SortOrder
    petskill?: SortOrder
    remainlife?: SortOrder
    attribute?: SortOrder
    activestate?: SortOrder
    autobuffskill?: SortOrder
    pethue?: SortOrder
    giantrate?: SortOrder
  }

  export type petitemsMaxOrderByAggregateInput = {
    itemid?: SortOrder
    name?: SortOrder
    level?: SortOrder
    tameness?: SortOrder
    repleteness?: SortOrder
    petattribute?: SortOrder
    petskill?: SortOrder
    datedead?: SortOrder
    remainlife?: SortOrder
    attribute?: SortOrder
    activestate?: SortOrder
    autobuffskill?: SortOrder
    pethue?: SortOrder
    giantrate?: SortOrder
    exceptionList?: SortOrder
  }

  export type petitemsMinOrderByAggregateInput = {
    itemid?: SortOrder
    name?: SortOrder
    level?: SortOrder
    tameness?: SortOrder
    repleteness?: SortOrder
    petattribute?: SortOrder
    petskill?: SortOrder
    datedead?: SortOrder
    remainlife?: SortOrder
    attribute?: SortOrder
    activestate?: SortOrder
    autobuffskill?: SortOrder
    pethue?: SortOrder
    giantrate?: SortOrder
    exceptionList?: SortOrder
  }

  export type petitemsSumOrderByAggregateInput = {
    itemid?: SortOrder
    level?: SortOrder
    tameness?: SortOrder
    repleteness?: SortOrder
    petattribute?: SortOrder
    petskill?: SortOrder
    remainlife?: SortOrder
    attribute?: SortOrder
    activestate?: SortOrder
    autobuffskill?: SortOrder
    pethue?: SortOrder
    giantrate?: SortOrder
  }

  export type questlistsCountOrderByAggregateInput = {
    questlist_id?: SortOrder
    questmanager_id?: SortOrder
    questid?: SortOrder
    fk_questid?: SortOrder
  }

  export type questlistsAvgOrderByAggregateInput = {
    questlist_id?: SortOrder
    questmanager_id?: SortOrder
    questid?: SortOrder
    fk_questid?: SortOrder
  }

  export type questlistsMaxOrderByAggregateInput = {
    questlist_id?: SortOrder
    questmanager_id?: SortOrder
    questid?: SortOrder
    fk_questid?: SortOrder
  }

  export type questlistsMinOrderByAggregateInput = {
    questlist_id?: SortOrder
    questmanager_id?: SortOrder
    questid?: SortOrder
    fk_questid?: SortOrder
  }

  export type questlistsSumOrderByAggregateInput = {
    questlist_id?: SortOrder
    questmanager_id?: SortOrder
    questid?: SortOrder
    fk_questid?: SortOrder
  }

  export type questmanagersCountOrderByAggregateInput = {
    id?: SortOrder
  }

  export type questmanagersAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type questmanagersMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type questmanagersMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type questmanagersSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type questprogressrequirementsCountOrderByAggregateInput = {
    id?: SortOrder
    orderNum?: SortOrder
    progresstype?: SortOrder
    questid?: SortOrder
    unitid?: SortOrder
    requiredcount?: SortOrder
    currentcount?: SortOrder
  }

  export type questprogressrequirementsAvgOrderByAggregateInput = {
    id?: SortOrder
    orderNum?: SortOrder
    questid?: SortOrder
    unitid?: SortOrder
    requiredcount?: SortOrder
    currentcount?: SortOrder
  }

  export type questprogressrequirementsMaxOrderByAggregateInput = {
    id?: SortOrder
    orderNum?: SortOrder
    progresstype?: SortOrder
    questid?: SortOrder
    unitid?: SortOrder
    requiredcount?: SortOrder
    currentcount?: SortOrder
  }

  export type questprogressrequirementsMinOrderByAggregateInput = {
    id?: SortOrder
    orderNum?: SortOrder
    progresstype?: SortOrder
    questid?: SortOrder
    unitid?: SortOrder
    requiredcount?: SortOrder
    currentcount?: SortOrder
  }

  export type questprogressrequirementsSumOrderByAggregateInput = {
    id?: SortOrder
    orderNum?: SortOrder
    questid?: SortOrder
    unitid?: SortOrder
    requiredcount?: SortOrder
    currentcount?: SortOrder
  }

  export type questsCountOrderByAggregateInput = {
    id?: SortOrder
    qrkey?: SortOrder
    qrvalue?: SortOrder
    status?: SortOrder
    completedtime?: SortOrder
    expireterm?: SortOrder
  }

  export type questsAvgOrderByAggregateInput = {
    id?: SortOrder
    qrkey?: SortOrder
    status?: SortOrder
  }

  export type questsMaxOrderByAggregateInput = {
    id?: SortOrder
    qrkey?: SortOrder
    qrvalue?: SortOrder
    status?: SortOrder
    completedtime?: SortOrder
    expireterm?: SortOrder
  }

  export type questsMinOrderByAggregateInput = {
    id?: SortOrder
    qrkey?: SortOrder
    qrvalue?: SortOrder
    status?: SortOrder
    completedtime?: SortOrder
    expireterm?: SortOrder
  }

  export type questsSumOrderByAggregateInput = {
    id?: SortOrder
    qrkey?: SortOrder
    status?: SortOrder
  }

  export type rewardinfoCountOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
    charname?: SortOrder
    rewardItemType?: SortOrder
    itemID?: SortOrder
    quantity?: SortOrder
    maplePoint?: SortOrder
    meso?: SortOrder
    level?: SortOrder
    exp?: SortOrder
    description?: SortOrder
    starttime?: SortOrder
    endtime?: SortOrder
  }

  export type rewardinfoAvgOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
    itemID?: SortOrder
    quantity?: SortOrder
    maplePoint?: SortOrder
    meso?: SortOrder
    level?: SortOrder
    exp?: SortOrder
  }

  export type rewardinfoMaxOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
    charname?: SortOrder
    rewardItemType?: SortOrder
    itemID?: SortOrder
    quantity?: SortOrder
    maplePoint?: SortOrder
    meso?: SortOrder
    level?: SortOrder
    exp?: SortOrder
    description?: SortOrder
    starttime?: SortOrder
    endtime?: SortOrder
  }

  export type rewardinfoMinOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
    charname?: SortOrder
    rewardItemType?: SortOrder
    itemID?: SortOrder
    quantity?: SortOrder
    maplePoint?: SortOrder
    meso?: SortOrder
    level?: SortOrder
    exp?: SortOrder
    description?: SortOrder
    starttime?: SortOrder
    endtime?: SortOrder
  }

  export type rewardinfoSumOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
    itemID?: SortOrder
    quantity?: SortOrder
    maplePoint?: SortOrder
    meso?: SortOrder
    level?: SortOrder
    exp?: SortOrder
  }

  export type shopitemsCountOrderByAggregateInput = {
    id?: SortOrder
    shopid?: SortOrder
    itemid?: SortOrder
    price?: SortOrder
    tokenitemid?: SortOrder
    tokenprice?: SortOrder
    pointquestid?: SortOrder
    pointprice?: SortOrder
    starcoin?: SortOrder
    questexid?: SortOrder
    questexkey?: SortOrder
    questexvalue?: SortOrder
    itemperiod?: SortOrder
    levellimited?: SortOrder
    showlevmin?: SortOrder
    showlevmax?: SortOrder
    questid?: SortOrder
    sellstart?: SortOrder
    sellend?: SortOrder
    tabindex?: SortOrder
    worldblock?: SortOrder
    potentialgrade?: SortOrder
    buylimit?: SortOrder
    quantity?: SortOrder
    unitprice?: SortOrder
    maxperslot?: SortOrder
    discountperc?: SortOrder
  }

  export type shopitemsAvgOrderByAggregateInput = {
    id?: SortOrder
    shopid?: SortOrder
    itemid?: SortOrder
    price?: SortOrder
    tokenitemid?: SortOrder
    tokenprice?: SortOrder
    pointquestid?: SortOrder
    pointprice?: SortOrder
    starcoin?: SortOrder
    questexid?: SortOrder
    questexvalue?: SortOrder
    itemperiod?: SortOrder
    levellimited?: SortOrder
    showlevmin?: SortOrder
    showlevmax?: SortOrder
    questid?: SortOrder
    tabindex?: SortOrder
    potentialgrade?: SortOrder
    buylimit?: SortOrder
    quantity?: SortOrder
    unitprice?: SortOrder
    maxperslot?: SortOrder
    discountperc?: SortOrder
  }

  export type shopitemsMaxOrderByAggregateInput = {
    id?: SortOrder
    shopid?: SortOrder
    itemid?: SortOrder
    price?: SortOrder
    tokenitemid?: SortOrder
    tokenprice?: SortOrder
    pointquestid?: SortOrder
    pointprice?: SortOrder
    starcoin?: SortOrder
    questexid?: SortOrder
    questexkey?: SortOrder
    questexvalue?: SortOrder
    itemperiod?: SortOrder
    levellimited?: SortOrder
    showlevmin?: SortOrder
    showlevmax?: SortOrder
    questid?: SortOrder
    sellstart?: SortOrder
    sellend?: SortOrder
    tabindex?: SortOrder
    worldblock?: SortOrder
    potentialgrade?: SortOrder
    buylimit?: SortOrder
    quantity?: SortOrder
    unitprice?: SortOrder
    maxperslot?: SortOrder
    discountperc?: SortOrder
  }

  export type shopitemsMinOrderByAggregateInput = {
    id?: SortOrder
    shopid?: SortOrder
    itemid?: SortOrder
    price?: SortOrder
    tokenitemid?: SortOrder
    tokenprice?: SortOrder
    pointquestid?: SortOrder
    pointprice?: SortOrder
    starcoin?: SortOrder
    questexid?: SortOrder
    questexkey?: SortOrder
    questexvalue?: SortOrder
    itemperiod?: SortOrder
    levellimited?: SortOrder
    showlevmin?: SortOrder
    showlevmax?: SortOrder
    questid?: SortOrder
    sellstart?: SortOrder
    sellend?: SortOrder
    tabindex?: SortOrder
    worldblock?: SortOrder
    potentialgrade?: SortOrder
    buylimit?: SortOrder
    quantity?: SortOrder
    unitprice?: SortOrder
    maxperslot?: SortOrder
    discountperc?: SortOrder
  }

  export type shopitemsSumOrderByAggregateInput = {
    id?: SortOrder
    shopid?: SortOrder
    itemid?: SortOrder
    price?: SortOrder
    tokenitemid?: SortOrder
    tokenprice?: SortOrder
    pointquestid?: SortOrder
    pointprice?: SortOrder
    starcoin?: SortOrder
    questexid?: SortOrder
    questexvalue?: SortOrder
    itemperiod?: SortOrder
    levellimited?: SortOrder
    showlevmin?: SortOrder
    showlevmax?: SortOrder
    questid?: SortOrder
    tabindex?: SortOrder
    potentialgrade?: SortOrder
    buylimit?: SortOrder
    quantity?: SortOrder
    unitprice?: SortOrder
    maxperslot?: SortOrder
    discountperc?: SortOrder
  }

  export type skillcooltimesCountOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
    skillid?: SortOrder
    nextusabletime?: SortOrder
  }

  export type skillcooltimesAvgOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
    skillid?: SortOrder
    nextusabletime?: SortOrder
  }

  export type skillcooltimesMaxOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
    skillid?: SortOrder
    nextusabletime?: SortOrder
  }

  export type skillcooltimesMinOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
    skillid?: SortOrder
    nextusabletime?: SortOrder
  }

  export type skillcooltimesSumOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
    skillid?: SortOrder
    nextusabletime?: SortOrder
  }

  export type skillsCountOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
    skillid?: SortOrder
    rootid?: SortOrder
    maxlevel?: SortOrder
    currentlevel?: SortOrder
    masterlevel?: SortOrder
  }

  export type skillsAvgOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
    skillid?: SortOrder
    rootid?: SortOrder
    maxlevel?: SortOrder
    currentlevel?: SortOrder
    masterlevel?: SortOrder
  }

  export type skillsMaxOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
    skillid?: SortOrder
    rootid?: SortOrder
    maxlevel?: SortOrder
    currentlevel?: SortOrder
    masterlevel?: SortOrder
  }

  export type skillsMinOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
    skillid?: SortOrder
    rootid?: SortOrder
    maxlevel?: SortOrder
    currentlevel?: SortOrder
    masterlevel?: SortOrder
  }

  export type skillsSumOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
    skillid?: SortOrder
    rootid?: SortOrder
    maxlevel?: SortOrder
    currentlevel?: SortOrder
    masterlevel?: SortOrder
  }

  export type spsetCountOrderByAggregateInput = {
    id?: SortOrder
    extendsp_id?: SortOrder
    joblevel?: SortOrder
    sp?: SortOrder
  }

  export type spsetAvgOrderByAggregateInput = {
    id?: SortOrder
    extendsp_id?: SortOrder
    joblevel?: SortOrder
    sp?: SortOrder
  }

  export type spsetMaxOrderByAggregateInput = {
    id?: SortOrder
    extendsp_id?: SortOrder
    joblevel?: SortOrder
    sp?: SortOrder
  }

  export type spsetMinOrderByAggregateInput = {
    id?: SortOrder
    extendsp_id?: SortOrder
    joblevel?: SortOrder
    sp?: SortOrder
  }

  export type spsetSumOrderByAggregateInput = {
    id?: SortOrder
    extendsp_id?: SortOrder
    joblevel?: SortOrder
    sp?: SortOrder
  }

  export type stolenskillsCountOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
    skillid?: SortOrder
    position?: SortOrder
    currentlv?: SortOrder
  }

  export type stolenskillsAvgOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
    skillid?: SortOrder
    position?: SortOrder
    currentlv?: SortOrder
  }

  export type stolenskillsMaxOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
    skillid?: SortOrder
    position?: SortOrder
    currentlv?: SortOrder
  }

  export type stolenskillsMinOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
    skillid?: SortOrder
    position?: SortOrder
    currentlv?: SortOrder
  }

  export type stolenskillsSumOrderByAggregateInput = {
    id?: SortOrder
    charid?: SortOrder
    skillid?: SortOrder
    position?: SortOrder
    currentlv?: SortOrder
  }

  export type systemtimesCountOrderByAggregateInput = {
    id?: SortOrder
    yr?: SortOrder
    mnth?: SortOrder
  }

  export type systemtimesAvgOrderByAggregateInput = {
    id?: SortOrder
    yr?: SortOrder
    mnth?: SortOrder
  }

  export type systemtimesMaxOrderByAggregateInput = {
    id?: SortOrder
    yr?: SortOrder
    mnth?: SortOrder
  }

  export type systemtimesMinOrderByAggregateInput = {
    id?: SortOrder
    yr?: SortOrder
    mnth?: SortOrder
  }

  export type systemtimesSumOrderByAggregateInput = {
    id?: SortOrder
    yr?: SortOrder
    mnth?: SortOrder
  }

  export type totemsCountOrderByAggregateInput = {
    id?: SortOrder
    alid?: SortOrder
    totemid?: SortOrder
  }

  export type totemsAvgOrderByAggregateInput = {
    id?: SortOrder
    alid?: SortOrder
    totemid?: SortOrder
  }

  export type totemsMaxOrderByAggregateInput = {
    id?: SortOrder
    alid?: SortOrder
    totemid?: SortOrder
  }

  export type totemsMinOrderByAggregateInput = {
    id?: SortOrder
    alid?: SortOrder
    totemid?: SortOrder
  }

  export type totemsSumOrderByAggregateInput = {
    id?: SortOrder
    alid?: SortOrder
    totemid?: SortOrder
  }

  export type trunksCountOrderByAggregateInput = {
    id?: SortOrder
    slotcount?: SortOrder
    money?: SortOrder
  }

  export type trunksAvgOrderByAggregateInput = {
    id?: SortOrder
    slotcount?: SortOrder
    money?: SortOrder
  }

  export type trunksMaxOrderByAggregateInput = {
    id?: SortOrder
    slotcount?: SortOrder
    money?: SortOrder
  }

  export type trunksMinOrderByAggregateInput = {
    id?: SortOrder
    slotcount?: SortOrder
    money?: SortOrder
  }

  export type trunksSumOrderByAggregateInput = {
    id?: SortOrder
    slotcount?: SortOrder
    money?: SortOrder
  }

  export type unseenequipsCountOrderByAggregateInput = {
    id?: SortOrder
    alid?: SortOrder
    equipid?: SortOrder
  }

  export type unseenequipsAvgOrderByAggregateInput = {
    id?: SortOrder
    alid?: SortOrder
    equipid?: SortOrder
  }

  export type unseenequipsMaxOrderByAggregateInput = {
    id?: SortOrder
    alid?: SortOrder
    equipid?: SortOrder
  }

  export type unseenequipsMinOrderByAggregateInput = {
    id?: SortOrder
    alid?: SortOrder
    equipid?: SortOrder
  }

  export type unseenequipsSumOrderByAggregateInput = {
    id?: SortOrder
    alid?: SortOrder
    equipid?: SortOrder
  }

  export type usersCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    password?: SortOrder
    pic?: SortOrder
    email?: SortOrder
    age?: SortOrder
    accounttype?: SortOrder
    votepoints?: SortOrder
    donationpoints?: SortOrder
    maplePoints?: SortOrder
    nxPrepaid?: SortOrder
    clientstate?: SortOrder
    vipgrade?: SortOrder
    vippoints?: SortOrder
    freevippointdate?: SortOrder
    vipexpireddate?: SortOrder
    nblockreason?: SortOrder
    banExpireDate?: SortOrder
    banReason?: SortOrder
    offensemanager?: SortOrder
    gender?: SortOrder
    msg2?: SortOrder
    purchaseexp?: SortOrder
    pblockreason?: SortOrder
    chatunblockdate?: SortOrder
    hascensorednxloginid?: SortOrder
    gradecode?: SortOrder
    censorednxloginid?: SortOrder
    characterslots?: SortOrder
    creationdate?: SortOrder
    bosspoints?: SortOrder
    lastvote1?: SortOrder
    lastvote2?: SortOrder
    claimvote1?: SortOrder
    claimvote2?: SortOrder
    dojop?: SortOrder
    lastvotetime?: SortOrder
    lastvoteip?: SortOrder
    discordid?: SortOrder
  }

  export type usersAvgOrderByAggregateInput = {
    id?: SortOrder
    age?: SortOrder
    accounttype?: SortOrder
    votepoints?: SortOrder
    donationpoints?: SortOrder
    maplePoints?: SortOrder
    nxPrepaid?: SortOrder
    clientstate?: SortOrder
    vipgrade?: SortOrder
    vippoints?: SortOrder
    nblockreason?: SortOrder
    offensemanager?: SortOrder
    gender?: SortOrder
    msg2?: SortOrder
    purchaseexp?: SortOrder
    pblockreason?: SortOrder
    chatunblockdate?: SortOrder
    gradecode?: SortOrder
    characterslots?: SortOrder
    bosspoints?: SortOrder
    lastvote1?: SortOrder
    lastvote2?: SortOrder
    claimvote1?: SortOrder
    claimvote2?: SortOrder
    dojop?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    password?: SortOrder
    pic?: SortOrder
    email?: SortOrder
    age?: SortOrder
    accounttype?: SortOrder
    votepoints?: SortOrder
    donationpoints?: SortOrder
    maplePoints?: SortOrder
    nxPrepaid?: SortOrder
    clientstate?: SortOrder
    vipgrade?: SortOrder
    vippoints?: SortOrder
    freevippointdate?: SortOrder
    vipexpireddate?: SortOrder
    nblockreason?: SortOrder
    banExpireDate?: SortOrder
    banReason?: SortOrder
    offensemanager?: SortOrder
    gender?: SortOrder
    msg2?: SortOrder
    purchaseexp?: SortOrder
    pblockreason?: SortOrder
    chatunblockdate?: SortOrder
    hascensorednxloginid?: SortOrder
    gradecode?: SortOrder
    censorednxloginid?: SortOrder
    characterslots?: SortOrder
    creationdate?: SortOrder
    bosspoints?: SortOrder
    lastvote1?: SortOrder
    lastvote2?: SortOrder
    claimvote1?: SortOrder
    claimvote2?: SortOrder
    dojop?: SortOrder
    lastvotetime?: SortOrder
    lastvoteip?: SortOrder
    discordid?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    password?: SortOrder
    pic?: SortOrder
    email?: SortOrder
    age?: SortOrder
    accounttype?: SortOrder
    votepoints?: SortOrder
    donationpoints?: SortOrder
    maplePoints?: SortOrder
    nxPrepaid?: SortOrder
    clientstate?: SortOrder
    vipgrade?: SortOrder
    vippoints?: SortOrder
    freevippointdate?: SortOrder
    vipexpireddate?: SortOrder
    nblockreason?: SortOrder
    banExpireDate?: SortOrder
    banReason?: SortOrder
    offensemanager?: SortOrder
    gender?: SortOrder
    msg2?: SortOrder
    purchaseexp?: SortOrder
    pblockreason?: SortOrder
    chatunblockdate?: SortOrder
    hascensorednxloginid?: SortOrder
    gradecode?: SortOrder
    censorednxloginid?: SortOrder
    characterslots?: SortOrder
    creationdate?: SortOrder
    bosspoints?: SortOrder
    lastvote1?: SortOrder
    lastvote2?: SortOrder
    claimvote1?: SortOrder
    claimvote2?: SortOrder
    dojop?: SortOrder
    lastvotetime?: SortOrder
    lastvoteip?: SortOrder
    discordid?: SortOrder
  }

  export type usersSumOrderByAggregateInput = {
    id?: SortOrder
    age?: SortOrder
    accounttype?: SortOrder
    votepoints?: SortOrder
    donationpoints?: SortOrder
    maplePoints?: SortOrder
    nxPrepaid?: SortOrder
    clientstate?: SortOrder
    vipgrade?: SortOrder
    vippoints?: SortOrder
    nblockreason?: SortOrder
    offensemanager?: SortOrder
    gender?: SortOrder
    msg2?: SortOrder
    purchaseexp?: SortOrder
    pblockreason?: SortOrder
    chatunblockdate?: SortOrder
    gradecode?: SortOrder
    characterslots?: SortOrder
    bosspoints?: SortOrder
    lastvote1?: SortOrder
    lastvote2?: SortOrder
    claimvote1?: SortOrder
    claimvote2?: SortOrder
    dojop?: SortOrder
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use accountsDefaultArgs instead
     */
    export type accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = accountsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use alliance_gradenamesDefaultArgs instead
     */
    export type alliance_gradenamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = alliance_gradenamesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use alliancesDefaultArgs instead
     */
    export type alliancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = alliancesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use auction_historiesDefaultArgs instead
     */
    export type auction_historiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = auction_historiesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use auction_itemsDefaultArgs instead
     */
    export type auction_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = auction_itemsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use avatardataDefaultArgs instead
     */
    export type avatardataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = avatardataDefaultArgs<ExtArgs>
    /**
     * @deprecated Use avatarlookDefaultArgs instead
     */
    export type avatarlookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = avatarlookDefaultArgs<ExtArgs>
    /**
     * @deprecated Use bbs_recordsDefaultArgs instead
     */
    export type bbs_recordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = bbs_recordsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use bbs_repliesDefaultArgs instead
     */
    export type bbs_repliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = bbs_repliesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use beautydataDefaultArgs instead
     */
    export type beautydataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = beautydataDefaultArgs<ExtArgs>
    /**
     * @deprecated Use bosslogDefaultArgs instead
     */
    export type bosslogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = bosslogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use cashiteminfosDefaultArgs instead
     */
    export type cashiteminfosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = cashiteminfosDefaultArgs<ExtArgs>
    /**
     * @deprecated Use characterpotentialsDefaultArgs instead
     */
    export type characterpotentialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = characterpotentialsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use charactersDefaultArgs instead
     */
    export type charactersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = charactersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use characterstatsDefaultArgs instead
     */
    export type characterstatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = characterstatsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use chosenskillsDefaultArgs instead
     */
    export type chosenskillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = chosenskillsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use cms_votesDefaultArgs instead
     */
    export type cms_votesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = cms_votesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use cooldownsDefaultArgs instead
     */
    export type cooldownsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = cooldownsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use coresDefaultArgs instead
     */
    export type coresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = coresDefaultArgs<ExtArgs>
    /**
     * @deprecated Use cs_categoriesDefaultArgs instead
     */
    export type cs_categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = cs_categoriesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use cs_itemsDefaultArgs instead
     */
    export type cs_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = cs_itemsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use damageskinsDefaultArgs instead
     */
    export type damageskinsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = damageskinsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use employeetrunkDefaultArgs instead
     */
    export type employeetrunkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = employeetrunkDefaultArgs<ExtArgs>
    /**
     * @deprecated Use equipsDefaultArgs instead
     */
    export type equipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = equipsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use eventnametagDefaultArgs instead
     */
    export type eventnametagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = eventnametagDefaultArgs<ExtArgs>
    /**
     * @deprecated Use extendspDefaultArgs instead
     */
    export type extendspArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = extendspDefaultArgs<ExtArgs>
    /**
     * @deprecated Use familiarsDefaultArgs instead
     */
    export type familiarsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = familiarsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use friendsDefaultArgs instead
     */
    export type friendsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = friendsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use funckeymapDefaultArgs instead
     */
    export type funckeymapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = funckeymapDefaultArgs<ExtArgs>
    /**
     * @deprecated Use gradenamesDefaultArgs instead
     */
    export type gradenamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = gradenamesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use guildmembersDefaultArgs instead
     */
    export type guildmembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = guildmembersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use guildrequestorsDefaultArgs instead
     */
    export type guildrequestorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = guildrequestorsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use guildsDefaultArgs instead
     */
    export type guildsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = guildsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use guildskillDefaultArgs instead
     */
    export type guildskillArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = guildskillDefaultArgs<ExtArgs>
    /**
     * @deprecated Use guildskillsDefaultArgs instead
     */
    export type guildskillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = guildskillsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use hairequipsDefaultArgs instead
     */
    export type hairequipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = hairequipsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use hyperrockfieldsDefaultArgs instead
     */
    export type hyperrockfieldsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = hyperrockfieldsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inventoriesDefaultArgs instead
     */
    export type inventoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = inventoriesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use itemsDefaultArgs instead
     */
    export type itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = itemsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use itemsbuylimitDefaultArgs instead
     */
    export type itemsbuylimitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = itemsbuylimitDefaultArgs<ExtArgs>
    /**
     * @deprecated Use keymapsDefaultArgs instead
     */
    export type keymapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = keymapsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use linkskillsDefaultArgs instead
     */
    export type linkskillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = linkskillsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use macrosDefaultArgs instead
     */
    export type macrosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = macrosDefaultArgs<ExtArgs>
    /**
     * @deprecated Use macroskillsDefaultArgs instead
     */
    export type macroskillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = macroskillsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use matrixskillDefaultArgs instead
     */
    export type matrixskillArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = matrixskillDefaultArgs<ExtArgs>
    /**
     * @deprecated Use medalsDefaultArgs instead
     */
    export type medalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = medalsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use mob_dropsDefaultArgs instead
     */
    export type mob_dropsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = mob_dropsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use monster_collectionDefaultArgs instead
     */
    export type monster_collectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = monster_collectionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use monster_collection_explorationsDefaultArgs instead
     */
    export type monster_collection_explorationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = monster_collection_explorationsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use monster_collection_group_rewardsDefaultArgs instead
     */
    export type monster_collection_group_rewardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = monster_collection_group_rewardsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use monster_collection_mobsDefaultArgs instead
     */
    export type monster_collection_mobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = monster_collection_mobsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use monster_collection_rewardsDefaultArgs instead
     */
    export type monster_collection_rewardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = monster_collection_rewardsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use monster_collection_session_rewardsDefaultArgs instead
     */
    export type monster_collection_session_rewardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = monster_collection_session_rewardsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use monster_collectionsDefaultArgs instead
     */
    export type monster_collectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = monster_collectionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use monsterbookcardsDefaultArgs instead
     */
    export type monsterbookcardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = monsterbookcardsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use monsterbookinfosDefaultArgs instead
     */
    export type monsterbookinfosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = monsterbookinfosDefaultArgs<ExtArgs>
    /**
     * @deprecated Use noncombatstatdaylimitDefaultArgs instead
     */
    export type noncombatstatdaylimitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = noncombatstatdaylimitDefaultArgs<ExtArgs>
    /**
     * @deprecated Use npcDefaultArgs instead
     */
    export type npcArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = npcDefaultArgs<ExtArgs>
    /**
     * @deprecated Use offense_managersDefaultArgs instead
     */
    export type offense_managersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = offense_managersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use offensesDefaultArgs instead
     */
    export type offensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = offensesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use partyDefaultArgs instead
     */
    export type partyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = partyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use partybossDefaultArgs instead
     */
    export type partybossArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = partybossDefaultArgs<ExtArgs>
    /**
     * @deprecated Use partymembersDefaultArgs instead
     */
    export type partymembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = partymembersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use petidsDefaultArgs instead
     */
    export type petidsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = petidsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use petitemsDefaultArgs instead
     */
    export type petitemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = petitemsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use questlistsDefaultArgs instead
     */
    export type questlistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = questlistsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use questmanagersDefaultArgs instead
     */
    export type questmanagersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = questmanagersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use questprogressrequirementsDefaultArgs instead
     */
    export type questprogressrequirementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = questprogressrequirementsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use questsDefaultArgs instead
     */
    export type questsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = questsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use rewardinfoDefaultArgs instead
     */
    export type rewardinfoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = rewardinfoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use shopitemsDefaultArgs instead
     */
    export type shopitemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = shopitemsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use skillcooltimesDefaultArgs instead
     */
    export type skillcooltimesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = skillcooltimesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use skillsDefaultArgs instead
     */
    export type skillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = skillsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use spsetDefaultArgs instead
     */
    export type spsetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = spsetDefaultArgs<ExtArgs>
    /**
     * @deprecated Use stolenskillsDefaultArgs instead
     */
    export type stolenskillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = stolenskillsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use systemtimesDefaultArgs instead
     */
    export type systemtimesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = systemtimesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use totemsDefaultArgs instead
     */
    export type totemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = totemsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use trunksDefaultArgs instead
     */
    export type trunksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = trunksDefaultArgs<ExtArgs>
    /**
     * @deprecated Use unseenequipsDefaultArgs instead
     */
    export type unseenequipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = unseenequipsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use usersDefaultArgs instead
     */
    export type usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = usersDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}